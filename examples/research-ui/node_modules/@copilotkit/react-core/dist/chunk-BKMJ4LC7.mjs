import {
  useStateRenderRegistry
} from "./chunk-77IVITG3.mjs";
import {
  useCoAgentStateRenders
} from "./chunk-QD7EID4N.mjs";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-SKC7AJIV.mjs";

// src/hooks/use-coagent-state-render-bridge.tsx
import { useAgent } from "@copilotkitnext/react";
import { useCallback, useEffect, useMemo, useState } from "react";
import { parseJson } from "@copilotkit/shared";
function useCoagentStateRenderBridge(agentId, props) {
  var _a;
  const { stateSnapshot, message } = props;
  const { coAgentStateRenders, claimsRef } = useCoAgentStateRenders();
  const { agent } = useAgent({ agentId });
  const [nodeName, setNodeName] = useState(void 0);
  const [, forceUpdate] = useState(0);
  useEffect(() => {
    if (!agent)
      return;
    const subscriber = {
      onStateChanged: () => {
        forceUpdate((value) => value + 1);
      },
      onStepStartedEvent: ({ event }) => {
        if (event.stepName !== nodeName) {
          setNodeName(event.stepName);
        }
      },
      onStepFinishedEvent: ({ event }) => {
        if (event.stepName === nodeName) {
          setNodeName(void 0);
        }
      }
    };
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agentId, nodeName]);
  const getStateRender = useCallback(
    (messageId) => {
      return Object.entries(coAgentStateRenders).find(([stateRenderId2, stateRender2]) => {
        if (claimsRef.current[messageId]) {
          return stateRenderId2 === claimsRef.current[messageId].stateRenderId;
        }
        const matchingAgentName = stateRender2.name === agentId;
        const matchesNodeContext = stateRender2.nodeName ? stateRender2.nodeName === nodeName : true;
        return matchingAgentName && matchesNodeContext;
      });
    },
    [coAgentStateRenders, nodeName, agentId]
  );
  const stateRenderEntry = useMemo(() => getStateRender(message.id), [getStateRender, message.id]);
  const stateRenderId = stateRenderEntry == null ? void 0 : stateRenderEntry[0];
  const stateRender = stateRenderEntry == null ? void 0 : stateRenderEntry[1];
  const registryMessage = __spreadProps(__spreadValues({}, message), {
    runId: (_a = props.runId) != null ? _a : message.runId
  });
  const { canRender } = useStateRenderRegistry({
    agentId,
    stateRenderId,
    message: registryMessage,
    messageIndex: props.messageIndex,
    stateSnapshot,
    agentState: agent == null ? void 0 : agent.state,
    agentMessages: agent == null ? void 0 : agent.messages,
    claimsRef
  });
  return useMemo(() => {
    var _a2, _b;
    if (!stateRender || !stateRenderId) {
      return null;
    }
    if (!canRender) {
      return null;
    }
    if (stateRender.handler) {
      stateRender.handler({
        state: stateSnapshot ? parseJson(stateSnapshot, stateSnapshot) : (_a2 = agent == null ? void 0 : agent.state) != null ? _a2 : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
    if (stateRender.render) {
      const status = (agent == null ? void 0 : agent.isRunning) ? "inProgress" /* InProgress */ : "complete" /* Complete */;
      if (typeof stateRender.render === "string")
        return stateRender.render;
      return stateRender.render({
        status,
        // Always use state from claim, to make sure the state does not seem "wiped" for a fraction of a second
        state: (_b = claimsRef.current[message.id].stateSnapshot) != null ? _b : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
  }, [
    stateRender,
    stateRenderId,
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.isRunning,
    nodeName,
    message.id,
    stateSnapshot,
    canRender
  ]);
}
function CoAgentStateRenderBridge(props) {
  return useCoagentStateRenderBridge(props.agentId, props);
}

export {
  useCoagentStateRenderBridge,
  CoAgentStateRenderBridge
};
//# sourceMappingURL=chunk-BKMJ4LC7.mjs.map