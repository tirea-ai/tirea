import {
  useLazyToolRenderer
} from "./chunk-ZVF5Q6IH.mjs";
import {
  useLangGraphInterruptRender
} from "./chunk-VV56AVPB.mjs";
import {
  useAsyncCallback
} from "./chunk-6PUNP7CD.mjs";
import {
  CoAgentStateRenderBridge
} from "./chunk-BKMJ4LC7.mjs";
import {
  useCopilotContext
} from "./chunk-AFNWX62Q.mjs";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-SKC7AJIV.mjs";

// src/hooks/use-copilot-chat_internal.ts
import { useRef, useEffect, useCallback, useMemo, useState, createElement } from "react";
import { gqlToAGUI, Message as DeprecatedGqlMessage } from "@copilotkit/runtime-client-gql";
import {
  useAgent,
  useCopilotChatConfiguration,
  useCopilotKit,
  useRenderCustomMessages,
  useSuggestions
} from "@copilotkitnext/react";
import { AGUIConnectNotImplementedError } from "@ag-ui/client";
function useCopilotChatInternal({
  suggestions,
  onInProgress,
  onSubmitMessage,
  onStopGeneration,
  onReloadMessages
} = {}) {
  var _a, _b, _c;
  const { copilotkit } = useCopilotKit();
  const { threadId, agentSession } = useCopilotContext();
  const existingConfig = useCopilotChatConfiguration();
  const [agentAvailable, setAgentAvailable] = useState(false);
  const resolvedAgentId = (_a = existingConfig == null ? void 0 : existingConfig.agentId) != null ? _a : "default";
  const { agent } = useAgent({ agentId: resolvedAgentId });
  useEffect(() => {
    const connect = (agent2) => __async(this, null, function* () {
      setAgentAvailable(false);
      try {
        yield copilotkit.connectAgent({ agent: agent2 });
        setAgentAvailable(true);
      } catch (error) {
        if (error instanceof AGUIConnectNotImplementedError) {
        } else {
          console.error("CopilotChat: connectAgent failed", error);
        }
      }
    });
    if (agent && (existingConfig == null ? void 0 : existingConfig.threadId) && agent.threadId !== existingConfig.threadId) {
      agent.threadId = existingConfig.threadId;
      connect(agent);
    }
    return () => {
    };
  }, [existingConfig == null ? void 0 : existingConfig.threadId, agent, copilotkit, resolvedAgentId]);
  useEffect(() => {
    onInProgress == null ? void 0 : onInProgress(Boolean(agent == null ? void 0 : agent.isRunning));
  }, [agent == null ? void 0 : agent.isRunning, onInProgress]);
  const interrupt = useLangGraphInterruptRender(agent);
  const reset = () => {
    agent == null ? void 0 : agent.setMessages([]);
    agent == null ? void 0 : agent.setState(null);
  };
  const deleteMessage = useCallback(
    (messageId) => {
      var _a2;
      const filteredMessages = ((_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : []).filter(
        (message) => message.id !== messageId
      );
      agent == null ? void 0 : agent.setMessages(filteredMessages);
    },
    [agent == null ? void 0 : agent.setMessages, agent == null ? void 0 : agent.messages]
  );
  const latestDelete = useUpdatedRef(deleteMessage);
  const latestDeleteFunc = useCallback(
    (messageId) => {
      return latestDelete.current(messageId);
    },
    [latestDelete]
  );
  const currentSuggestions = useSuggestions({ agentId: resolvedAgentId });
  const reload = useAsyncCallback(
    (reloadMessageId) => __async(this, null, function* () {
      var _a2;
      const messages = (_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : [];
      const isLoading = false;
      if (isLoading || messages.length === 0) {
        return;
      }
      const reloadMessageIndex = messages.findIndex((msg) => msg.id === reloadMessageId);
      if (reloadMessageIndex === -1) {
        console.warn(`Message with id ${reloadMessageId} not found`);
        return;
      }
      const reloadMessageRole = messages[reloadMessageIndex].role;
      if (reloadMessageRole !== "assistant") {
        console.warn(`Regenerate cannot be performed on ${reloadMessageRole} role`);
        return;
      }
      let historyCutoff = [messages[0]];
      if (messages.length > 2 && reloadMessageIndex !== 0) {
        const lastUserMessageBeforeRegenerate = messages.slice(0, reloadMessageIndex).reverse().find((msg) => msg.role === "user");
        if (!lastUserMessageBeforeRegenerate) {
          historyCutoff = [messages[0]];
        } else {
          const indexOfLastUserMessageBeforeRegenerate = messages.findIndex(
            (msg) => msg.id === lastUserMessageBeforeRegenerate.id
          );
          historyCutoff = messages.slice(0, indexOfLastUserMessageBeforeRegenerate + 1);
        }
      } else if (messages.length > 2 && reloadMessageIndex === 0) {
        historyCutoff = [messages[0], messages[1]];
      }
      agent == null ? void 0 : agent.setMessages(historyCutoff);
      if (agent) {
        try {
          yield copilotkit.runAgent({ agent });
        } catch (error) {
          console.error("CopilotChat: runAgent failed during reload", error);
        }
      }
      return;
    }),
    [agent == null ? void 0 : agent.setMessages, copilotkit == null ? void 0 : copilotkit.runAgent]
  );
  const latestSendMessageFunc = useAsyncCallback(
    (message, options) => __async(this, null, function* () {
      var _a2;
      if (!agent)
        return;
      const followUp = (_a2 = options == null ? void 0 : options.followUp) != null ? _a2 : true;
      if (options == null ? void 0 : options.clearSuggestions) {
        copilotkit.clearSuggestions(resolvedAgentId);
      }
      if (onSubmitMessage) {
        const content = typeof message.content === "string" ? message.content : message.content && "text" in message.content ? message.content.text : message.content && "filename" in message.content ? message.content.filename : "";
        try {
          yield onSubmitMessage(content);
        } catch (error) {
          console.error("Error in onSubmitMessage:", error);
        }
      }
      agent == null ? void 0 : agent.addMessage(message);
      if (followUp) {
        try {
          yield copilotkit.runAgent({ agent });
        } catch (error) {
          console.error("CopilotChat: runAgent failed", error);
        }
      }
    }),
    [agent, copilotkit, resolvedAgentId, onSubmitMessage]
  );
  const latestAppendFunc = useAsyncCallback(
    (message, options) => __async(this, null, function* () {
      return latestSendMessageFunc(gqlToAGUI([message])[0], options);
    }),
    [latestSendMessageFunc]
  );
  const latestSetMessagesFunc = useCallback(
    (messages) => {
      var _a2, _b2;
      if (messages.every((message) => message instanceof DeprecatedGqlMessage)) {
        return (_a2 = agent == null ? void 0 : agent.setMessages) == null ? void 0 : _a2.call(agent, gqlToAGUI(messages));
      }
      return (_b2 = agent == null ? void 0 : agent.setMessages) == null ? void 0 : _b2.call(agent, messages);
    },
    [agent == null ? void 0 : agent.setMessages, agent]
  );
  const latestReload = useUpdatedRef(reload);
  const latestReloadFunc = useAsyncCallback(
    (messageId) => __async(this, null, function* () {
      var _a2;
      onReloadMessages == null ? void 0 : onReloadMessages({
        messageId,
        currentAgentName: agent == null ? void 0 : agent.agentId,
        messages: (_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : []
      });
      return yield latestReload.current(messageId);
    }),
    [latestReload, agent, onReloadMessages]
  );
  const latestStopFunc = useCallback(() => {
    var _a2, _b2;
    onStopGeneration == null ? void 0 : onStopGeneration({
      currentAgentName: agent == null ? void 0 : agent.agentId,
      messages: (_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : []
    });
    return (_b2 = agent == null ? void 0 : agent.abortRun) == null ? void 0 : _b2.call(agent);
  }, [onStopGeneration, agent]);
  const latestReset = useUpdatedRef(reset);
  const latestResetFunc = useCallback(() => {
    return latestReset.current();
  }, [latestReset]);
  const lazyToolRendered = useLazyToolRenderer();
  const renderCustomMessage = useRenderCustomMessages();
  const legacyCustomMessageRenderer = useLegacyCoagentRenderer({
    copilotkit,
    agent,
    agentId: resolvedAgentId,
    threadId: (_b = existingConfig == null ? void 0 : existingConfig.threadId) != null ? _b : threadId
  });
  const allMessages = (_c = agent == null ? void 0 : agent.messages) != null ? _c : [];
  const resolvedMessages = useMemo(() => {
    var _a2, _b2;
    let processedMessages = allMessages.map((message) => {
      if (message.role !== "assistant") {
        return message;
      }
      const lazyRendered = lazyToolRendered(message, allMessages);
      if (lazyRendered) {
        const renderedGenUi = lazyRendered();
        if (renderedGenUi) {
          return __spreadProps(__spreadValues({}, message), { generativeUI: () => renderedGenUi });
        }
      }
      const bridgeRenderer = legacyCustomMessageRenderer || renderCustomMessage ? () => {
        var _a3;
        if (legacyCustomMessageRenderer) {
          return legacyCustomMessageRenderer({ message, position: "before" });
        }
        try {
          return (_a3 = renderCustomMessage == null ? void 0 : renderCustomMessage({ message, position: "before" })) != null ? _a3 : null;
        } catch (error) {
          console.warn(
            "[CopilotKit] renderCustomMessages failed, falling back to legacy renderer",
            error
          );
          return null;
        }
      } : null;
      if (bridgeRenderer) {
        return __spreadProps(__spreadValues({}, message), {
          generativeUI: bridgeRenderer,
          generativeUIPosition: "before"
        });
      }
      return message;
    });
    const hasAssistantMessages = processedMessages.some((msg) => msg.role === "assistant");
    const canUseCustomRenderer = Boolean(
      renderCustomMessage && ((_a2 = copilotkit == null ? void 0 : copilotkit.getAgent) == null ? void 0 : _a2.call(copilotkit, resolvedAgentId))
    );
    const placeholderRenderer = legacyCustomMessageRenderer ? legacyCustomMessageRenderer : canUseCustomRenderer ? renderCustomMessage : null;
    const shouldRenderPlaceholder = Boolean(agent == null ? void 0 : agent.isRunning) || Boolean((agent == null ? void 0 : agent.state) && Object.keys(agent.state).length);
    const effectiveThreadId = (_b2 = threadId != null ? threadId : agent == null ? void 0 : agent.threadId) != null ? _b2 : "default";
    let latestUserIndex = -1;
    for (let i = processedMessages.length - 1; i >= 0; i -= 1) {
      if (processedMessages[i].role === "user") {
        latestUserIndex = i;
        break;
      }
    }
    const latestUserMessageId = latestUserIndex >= 0 ? processedMessages[latestUserIndex].id : void 0;
    const currentRunId = latestUserMessageId ? copilotkit.getRunIdForMessage(resolvedAgentId, effectiveThreadId, latestUserMessageId) || `pending:${latestUserMessageId}` : void 0;
    const hasAssistantForCurrentRun = latestUserIndex >= 0 ? processedMessages.slice(latestUserIndex + 1).some((msg) => msg.role === "assistant") : hasAssistantMessages;
    if (placeholderRenderer && shouldRenderPlaceholder && !hasAssistantForCurrentRun) {
      const placeholderId = currentRunId ? `coagent-state-render-${resolvedAgentId}-${currentRunId}` : `coagent-state-render-${resolvedAgentId}`;
      const placeholderMessage = {
        id: placeholderId,
        role: "assistant",
        content: "",
        name: "coagent-state-render",
        runId: currentRunId
      };
      processedMessages = [
        ...processedMessages,
        __spreadProps(__spreadValues({}, placeholderMessage), {
          generativeUIPosition: "before",
          generativeUI: () => placeholderRenderer({
            message: placeholderMessage,
            position: "before"
          })
        })
      ];
    }
    return processedMessages;
  }, [
    agent == null ? void 0 : agent.messages,
    lazyToolRendered,
    allMessages,
    renderCustomMessage,
    legacyCustomMessageRenderer,
    resolvedAgentId,
    copilotkit,
    agent == null ? void 0 : agent.isRunning,
    agent == null ? void 0 : agent.state
  ]);
  const renderedSuggestions = useMemo(() => {
    if (Array.isArray(suggestions)) {
      return {
        suggestions: suggestions.map((s) => __spreadProps(__spreadValues({}, s), { isLoading: false })),
        isLoading: false
      };
    }
    return currentSuggestions;
  }, [suggestions, currentSuggestions]);
  return {
    messages: resolvedMessages,
    sendMessage: latestSendMessageFunc,
    appendMessage: latestAppendFunc,
    setMessages: latestSetMessagesFunc,
    reloadMessages: latestReloadFunc,
    stopGeneration: latestStopFunc,
    reset: latestResetFunc,
    deleteMessage: latestDeleteFunc,
    isAvailable: agentAvailable,
    isLoading: Boolean(agent == null ? void 0 : agent.isRunning),
    // mcpServers,
    // setMcpServers,
    suggestions: renderedSuggestions.suggestions,
    setSuggestions: (suggestions2) => copilotkit.addSuggestionsConfig({ suggestions: suggestions2 }),
    generateSuggestions: () => __async(this, null, function* () {
      return copilotkit.reloadSuggestions(resolvedAgentId);
    }),
    resetSuggestions: () => copilotkit.clearSuggestions(resolvedAgentId),
    isLoadingSuggestions: renderedSuggestions.isLoading,
    interrupt,
    agent,
    threadId
  };
}
function useUpdatedRef(value) {
  const ref = useRef(value);
  useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref;
}
function useLegacyCoagentRenderer({
  copilotkit,
  agent,
  agentId,
  threadId
}) {
  return useMemo(() => {
    if (!copilotkit || !agent) {
      return null;
    }
    return ({ message, position }) => {
      var _a;
      const effectiveThreadId = (_a = threadId != null ? threadId : agent.threadId) != null ? _a : "default";
      const providedRunId = message.runId;
      const existingRunId = providedRunId ? providedRunId : copilotkit.getRunIdForMessage(agentId, effectiveThreadId, message.id);
      const runId = existingRunId || `pending:${message.id}`;
      const messageIndex = Math.max(
        agent.messages.findIndex((msg) => msg.id === message.id),
        0
      );
      const bridgeProps = {
        message,
        position,
        runId,
        messageIndex,
        messageIndexInRun: 0,
        numberOfMessagesInRun: 1,
        agentId,
        stateSnapshot: message.state
      };
      return createElement(CoAgentStateRenderBridge, bridgeProps);
    };
  }, [agent, agentId, copilotkit, threadId]);
}
function defaultSystemMessage(contextString, additionalInstructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.

Please assist them as best you can.

You can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.

If you would like to call a function, call it without saying anything else.
In case of a function error:
- If this error stems from incorrect function parameters or syntax, you may retry with corrected arguments.
- If the error's source is unclear or seems unrelated to your input, do not attempt further retries.
` + (additionalInstructions ? `

${additionalInstructions}` : "");
}

export {
  useCopilotChatInternal,
  defaultSystemMessage
};
//# sourceMappingURL=chunk-LO4RRITI.mjs.map