{"version":3,"sources":["../../src/hooks/use-coagent-state-render-registry.ts","../../src/hooks/use-coagent-state-render-bridge.helpers.ts"],"sourcesContent":["import { useEffect } from \"react\";\nimport {\n  areStatesEquals,\n  ClaimAction,\n  getEffectiveRunId,\n  isPlaceholderMessageId,\n  isPlaceholderMessageName,\n  readCachedMessageEntry,\n  resolveClaim,\n  selectSnapshot,\n  type Claim,\n  type ClaimsByMessageId,\n  type SnapshotCaches,\n  type StateRenderContext,\n} from \"./use-coagent-state-render-bridge.helpers\";\n\nexport interface StateRenderRegistryInput {\n  agentId: string;\n  stateRenderId?: string;\n  message: { id: string; runId?: string; name?: string };\n  messageIndex?: number;\n  stateSnapshot?: any;\n  agentState?: any;\n  agentMessages?: Array<{ id: string; role?: string }>;\n  claimsRef: React.MutableRefObject<Record<string, Claim>>;\n}\n\nexport interface StateRenderRegistryResult {\n  canRender: boolean;\n}\n\nconst LAST_SNAPSHOTS_BY_RENDER_AND_RUN = \"__lastSnapshotsByStateRenderIdAndRun\";\nconst LAST_SNAPSHOTS_BY_MESSAGE = \"__lastSnapshotsByMessageId\";\n\ntype SnapshotByMessageEntry = { snapshot: any; runId?: string } | any;\ntype ClaimsStore = Record<string, Claim> & {\n  [LAST_SNAPSHOTS_BY_RENDER_AND_RUN]?: Record<string, any>;\n  [LAST_SNAPSHOTS_BY_MESSAGE]?: Record<string, SnapshotByMessageEntry>;\n};\n\nfunction getClaimsStore(\n  claimsRef: React.MutableRefObject<Record<string, Claim>>,\n): ClaimsStore {\n  return claimsRef.current as ClaimsStore;\n}\n\nfunction getSnapshotCaches(claimsRef: React.MutableRefObject<Record<string, Claim>>): SnapshotCaches {\n  const store = getClaimsStore(claimsRef);\n  return {\n    byStateRenderAndRun: store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {},\n    byMessageId: store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {},\n  };\n}\n\nexport function useStateRenderRegistry({\n  agentId,\n  stateRenderId,\n  message,\n  messageIndex,\n  stateSnapshot,\n  agentState,\n  agentMessages,\n  claimsRef,\n}: StateRenderRegistryInput): StateRenderRegistryResult {\n  const store = getClaimsStore(claimsRef);\n  const runId = message.runId;\n  const cachedMessageEntry = store[LAST_SNAPSHOTS_BY_MESSAGE]?.[message.id];\n  const { runId: cachedMessageRunId } = readCachedMessageEntry(cachedMessageEntry);\n  const existingClaimRunId = claimsRef.current[message.id]?.runId;\n  const effectiveRunId = getEffectiveRunId({\n    existingClaimRunId,\n    cachedMessageRunId,\n    runId,\n  });\n\n  useEffect(() => {\n    return () => {\n      const existingClaim = claimsRef.current[message.id];\n      if (\n        existingClaim?.stateSnapshot &&\n        Object.keys(existingClaim.stateSnapshot).length > 0\n      ) {\n        const snapshotCache = {\n          ...(store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {}),\n        };\n        const cacheKey = `${existingClaim.stateRenderId}::${existingClaim.runId ?? \"pending\"}`;\n        snapshotCache[cacheKey] = existingClaim.stateSnapshot;\n        snapshotCache[`${existingClaim.stateRenderId}::latest`] = existingClaim.stateSnapshot;\n        store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;\n\n        const messageCache = {\n          ...(store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {}),\n        };\n        messageCache[message.id] = {\n          snapshot: existingClaim.stateSnapshot,\n          runId: existingClaim.runId ?? effectiveRunId,\n        };\n        store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;\n      }\n      delete claimsRef.current[message.id];\n    };\n  }, [claimsRef, effectiveRunId, message.id]);\n\n  if (!stateRenderId) {\n    return { canRender: false };\n  }\n\n  const caches = getSnapshotCaches(claimsRef);\n  const existingClaim = claimsRef.current[message.id] as Claim | undefined;\n\n  const { snapshot, hasSnapshotKeys, allowEmptySnapshot, snapshotForClaim } = selectSnapshot({\n    messageId: message.id,\n    messageName: message.name,\n    allowLiveState:\n      isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),\n    skipLatestCache:\n      isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),\n    stateRenderId,\n    effectiveRunId,\n    stateSnapshotProp: stateSnapshot,\n    agentState,\n    agentMessages,\n    existingClaim,\n    caches,\n  });\n\n  const resolution = resolveClaim({\n    claims: claimsRef.current as ClaimsByMessageId,\n    context: {\n      agentId,\n      messageId: message.id,\n      stateRenderId,\n      runId: effectiveRunId,\n      messageIndex,\n    } satisfies StateRenderContext,\n    stateSnapshot: snapshotForClaim,\n  });\n\n  if (resolution.action === ClaimAction.Block) {\n    return { canRender: false };\n  }\n\n  if (resolution.updateRunId && claimsRef.current[message.id]) {\n    claimsRef.current[message.id].runId = resolution.updateRunId;\n  }\n\n  if (resolution.nextClaim) {\n    claimsRef.current[message.id] = resolution.nextClaim;\n  }\n\n  if (resolution.lockOthers) {\n    Object.entries(claimsRef.current).forEach(([id, claim]) => {\n      if (id !== message.id && claim.stateRenderId === stateRenderId) {\n        claim.locked = true;\n      }\n    });\n  }\n\n  if (existingClaim && !existingClaim.locked && agentMessages?.length) {\n    const indexInAgentMessages = agentMessages.findIndex((msg: any) => msg.id === message.id);\n    if (indexInAgentMessages >= 0 && indexInAgentMessages < agentMessages.length - 1) {\n      existingClaim.locked = true;\n    }\n  }\n\n  const existingSnapshot = claimsRef.current[message.id].stateSnapshot;\n  const snapshotChanged =\n    stateSnapshot &&\n    existingSnapshot !== undefined &&\n    !areStatesEquals(existingSnapshot, snapshot);\n\n  if (\n    snapshot &&\n    (stateSnapshot || hasSnapshotKeys || allowEmptySnapshot) &&\n    (!claimsRef.current[message.id].locked || snapshotChanged)\n  ) {\n    if (!claimsRef.current[message.id].locked || snapshotChanged) {\n      claimsRef.current[message.id].stateSnapshot = snapshot;\n      const snapshotCache = {\n        ...(store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {}),\n      };\n      const cacheKey = `${stateRenderId}::${effectiveRunId}`;\n      snapshotCache[cacheKey] = snapshot;\n      snapshotCache[`${stateRenderId}::latest`] = snapshot;\n      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;\n      const messageCache = {\n        ...(store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {}),\n      };\n      messageCache[message.id] = { snapshot, runId: effectiveRunId };\n      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;\n      if (stateSnapshot) {\n        claimsRef.current[message.id].locked = true;\n      }\n    }\n  } else if (snapshotForClaim) {\n    const existingSnapshot = claimsRef.current[message.id].stateSnapshot;\n    if (!existingSnapshot) {\n      claimsRef.current[message.id].stateSnapshot = snapshotForClaim;\n      const snapshotCache = {\n        ...(store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {}),\n      };\n      const cacheKey = `${stateRenderId}::${effectiveRunId}`;\n      snapshotCache[cacheKey] = snapshotForClaim;\n      snapshotCache[`${stateRenderId}::latest`] = snapshotForClaim;\n      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;\n      const messageCache = {\n        ...(store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {}),\n      };\n      messageCache[message.id] = { snapshot: snapshotForClaim, runId: effectiveRunId };\n      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;\n    }\n  }\n\n  return { canRender: true };\n}\n","import { dataToUUID, parseJson } from \"@copilotkit/shared\";\n\nexport enum RenderStatus {\n  InProgress = \"inProgress\",\n  Complete = \"complete\",\n}\n\nexport enum ClaimAction {\n  Create = \"create\",\n  Override = \"override\",\n  Existing = \"existing\",\n  Block = \"block\",\n}\n\nexport interface StateRenderContext {\n  agentId: string;\n  stateRenderId: string;\n  messageId: string;\n  runId: string;\n  messageIndex?: number;\n}\n\nexport interface Claim {\n  stateRenderId: string;\n  runId?: string;\n  stateSnapshot?: any;\n  locked?: boolean;\n  messageIndex?: number;\n}\n\nexport type ClaimsByMessageId = Record<string, Claim>;\n\nexport interface ClaimResolution {\n  canRender: boolean;\n  action: ClaimAction;\n  nextClaim?: Claim;\n  lockOthers?: boolean;\n  updateRunId?: string;\n}\n\nexport interface SnapshotCaches {\n  byStateRenderAndRun: Record<string, any>;\n  byMessageId: Record<string, any>;\n}\n\nexport interface SnapshotSelectionInput {\n  messageId: string;\n  messageName?: string;\n  allowLiveState?: boolean;\n  skipLatestCache?: boolean;\n  stateRenderId?: string;\n  effectiveRunId: string;\n  stateSnapshotProp?: any;\n  agentState?: any;\n  agentMessages?: Array<{ id: string; role?: string }>;\n  existingClaim?: Claim;\n  caches: SnapshotCaches;\n}\n\nexport interface SnapshotSelectionResult {\n  snapshot?: any;\n  hasSnapshotKeys: boolean;\n  cachedSnapshot?: any;\n  allowEmptySnapshot?: boolean;\n  snapshotForClaim?: any;\n}\n\nfunction getStateWithoutConstantKeys(state: any) {\n  if (!state) return {};\n  const { messages, tools, copilotkit, ...stateWithoutConstantKeys } = state;\n  return stateWithoutConstantKeys;\n}\n\n// Function that compares states, without the constant keys\nexport function areStatesEquals(a: any, b: any) {\n  if ((a && !b) || (!a && b)) return false;\n  const { messages, tools, copilotkit, ...aWithoutConstantKeys } = a;\n  const {\n    messages: bMessages,\n    tools: bTools,\n    copilotkit: bCopilotkit,\n    ...bWithoutConstantKeys\n  } = b;\n\n  return JSON.stringify(aWithoutConstantKeys) === JSON.stringify(bWithoutConstantKeys);\n}\n\nexport function isPlaceholderMessageId(messageId: string | undefined) {\n  return !!messageId && messageId.startsWith(\"coagent-state-render-\");\n}\n\nexport function isPlaceholderMessageName(messageName: string | undefined) {\n  return messageName === \"coagent-state-render\";\n}\n\nexport function readCachedMessageEntry(entry: any): { snapshot?: any; runId?: string } {\n  if (!entry || typeof entry !== \"object\") {\n    return { snapshot: entry, runId: undefined };\n  }\n  const snapshot = \"snapshot\" in entry ? entry.snapshot : entry;\n  const runId = \"runId\" in entry ? entry.runId : undefined;\n  return { snapshot, runId };\n}\n\nexport function getEffectiveRunId({\n  existingClaimRunId,\n  cachedMessageRunId,\n  runId,\n}: {\n  existingClaimRunId?: string;\n  cachedMessageRunId?: string;\n  runId?: string;\n}) {\n  return existingClaimRunId || cachedMessageRunId || runId || \"pending\";\n}\n\n/**\n * Resolve whether a message can claim a render slot.\n * This is a pure decision function; the caller applies claim mutations.\n */\nexport function resolveClaim({\n  claims,\n  context,\n  stateSnapshot,\n}: {\n  claims: ClaimsByMessageId;\n  context: StateRenderContext;\n  stateSnapshot?: any;\n}): ClaimResolution {\n  const { messageId, stateRenderId, runId, messageIndex } = context;\n  const existing = claims[messageId];\n\n  if (existing) {\n    const canRender = existing.stateRenderId === stateRenderId;\n    const shouldUpdateRunId =\n      canRender && runId && (!existing.runId || existing.runId === \"pending\");\n    return {\n      canRender,\n      action: canRender ? ClaimAction.Existing : ClaimAction.Block,\n      updateRunId: shouldUpdateRunId ? runId : undefined,\n    };\n  }\n\n  const normalizedRunId = runId ?? \"pending\";\n  const renderClaimedByOtherMessageEntry = Object.entries(claims).find(\n    ([, claim]) =>\n      claim.stateRenderId === stateRenderId &&\n      (claim.runId ?? \"pending\") === normalizedRunId &&\n      dataToUUID(getStateWithoutConstantKeys(claim.stateSnapshot)) ===\n        dataToUUID(getStateWithoutConstantKeys(stateSnapshot)),\n  );\n\n  const renderClaimedByOtherMessage = renderClaimedByOtherMessageEntry?.[1];\n  const claimedMessageId = renderClaimedByOtherMessageEntry?.[0];\n\n  if (renderClaimedByOtherMessage) {\n    if (\n      messageIndex !== undefined &&\n      renderClaimedByOtherMessage.messageIndex !== undefined &&\n      messageIndex > renderClaimedByOtherMessage.messageIndex\n    ) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers:\n          runId === renderClaimedByOtherMessage.runId || isPlaceholderMessageId(claimedMessageId),\n      };\n    }\n\n    if (runId && renderClaimedByOtherMessage.runId && runId !== renderClaimedByOtherMessage.runId) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers: isPlaceholderMessageId(claimedMessageId),\n      };\n    }\n\n    if (isPlaceholderMessageId(claimedMessageId)) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers: true,\n      };\n    }\n\n    if (\n      stateSnapshot &&\n      renderClaimedByOtherMessage.stateSnapshot &&\n      !areStatesEquals(renderClaimedByOtherMessage.stateSnapshot, stateSnapshot)\n    ) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId },\n      };\n    }\n\n    return { canRender: false, action: ClaimAction.Block };\n  }\n\n  if (!runId) {\n    return { canRender: false, action: ClaimAction.Block };\n  }\n\n  return {\n    canRender: true,\n    action: ClaimAction.Create,\n    nextClaim: { stateRenderId, runId, messageIndex },\n  };\n}\n\n/**\n * Select the best snapshot to render for this message.\n * Priority order is:\n * 1) explicit message snapshot\n * 2) live agent state (latest assistant only)\n * 3) cached snapshot for message\n * 4) cached snapshot for stateRenderId+runId\n * 5) last cached snapshot for stateRenderId\n */\nexport function selectSnapshot({\n  messageId,\n  messageName,\n  allowLiveState,\n  skipLatestCache,\n  stateRenderId,\n  effectiveRunId,\n  stateSnapshotProp,\n  agentState,\n  agentMessages,\n  existingClaim,\n  caches,\n}: SnapshotSelectionInput): SnapshotSelectionResult {\n  const lastAssistantId = agentMessages\n    ? [...agentMessages].reverse().find((msg) => msg.role === \"assistant\")?.id\n    : undefined;\n  const latestSnapshot =\n    stateRenderId !== undefined ? caches.byStateRenderAndRun[`${stateRenderId}::latest`] : undefined;\n  const messageIndex = agentMessages\n    ? agentMessages.findIndex((msg) => msg.id === messageId)\n    : -1;\n  const messageRole =\n    messageIndex >= 0 && agentMessages ? agentMessages[messageIndex]?.role : undefined;\n  let previousUserMessageId: string | undefined;\n  if (messageIndex > 0 && agentMessages) {\n    for (let i = messageIndex - 1; i >= 0; i -= 1) {\n      if (agentMessages[i]?.role === \"user\") {\n        previousUserMessageId = agentMessages[i]?.id;\n        break;\n      }\n    }\n  }\n  const liveStateIsStale =\n    stateSnapshotProp === undefined &&\n    latestSnapshot !== undefined &&\n    agentState !== undefined &&\n    areStatesEquals(latestSnapshot, agentState);\n  const shouldUseLiveState =\n    (Boolean(allowLiveState) || !lastAssistantId || messageId === lastAssistantId) &&\n    !liveStateIsStale;\n  const snapshot = stateSnapshotProp\n    ? parseJson(stateSnapshotProp, stateSnapshotProp)\n    : shouldUseLiveState\n      ? agentState\n      : undefined;\n  const hasSnapshotKeys = !!(snapshot && Object.keys(snapshot).length > 0);\n  const allowEmptySnapshot =\n    snapshot !== undefined &&\n    !hasSnapshotKeys &&\n    (stateSnapshotProp !== undefined || shouldUseLiveState);\n\n  const messageCacheEntry = caches.byMessageId[messageId];\n  const cachedMessageSnapshot = readCachedMessageEntry(messageCacheEntry).snapshot;\n  const cacheKey =\n    stateRenderId !== undefined ? `${stateRenderId}::${effectiveRunId}` : undefined;\n  let cachedSnapshot = cachedMessageSnapshot ?? caches.byMessageId[messageId];\n  if (cachedSnapshot === undefined && cacheKey && caches.byStateRenderAndRun[cacheKey] !== undefined) {\n    cachedSnapshot = caches.byStateRenderAndRun[cacheKey];\n  }\n  if (\n    cachedSnapshot === undefined &&\n    stateRenderId &&\n    previousUserMessageId &&\n    caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`] !==\n      undefined\n  ) {\n    cachedSnapshot =\n      caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`];\n  }\n  if (\n    cachedSnapshot === undefined &&\n    !skipLatestCache &&\n    stateRenderId &&\n    messageRole !== \"assistant\" &&\n    (stateSnapshotProp !== undefined ||\n      (agentState && Object.keys(agentState).length > 0))\n  ) {\n    cachedSnapshot = caches.byStateRenderAndRun[`${stateRenderId}::latest`];\n  }\n\n  const snapshotForClaim = existingClaim?.locked\n    ? existingClaim.stateSnapshot ?? cachedSnapshot\n    : hasSnapshotKeys\n      ? snapshot\n      : existingClaim?.stateSnapshot ?? cachedSnapshot;\n\n  return { snapshot, hasSnapshotKeys, cachedSnapshot, allowEmptySnapshot, snapshotForClaim };\n}\n"],"mappings":"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","names":["_a","_b","_c","_d","existingClaim","existingSnapshot"]}