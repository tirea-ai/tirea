{"version":3,"sources":["../../src/hooks/use-langgraph-interrupt-render.ts","../../src/context/copilot-context.tsx","../../src/hooks/use-agent-nodename.ts"],"sourcesContent":["import { useCopilotContext } from \"../context\";\nimport React, { useCallback, useEffect, useMemo } from \"react\";\nimport type { AbstractAgent, AgentSubscriber } from \"@ag-ui/client\";\nimport { MetaEventName } from \"@copilotkit/runtime-client-gql\";\nimport { dataToUUID, parseJson } from \"@copilotkit/shared\";\nimport { useAgentNodeName } from \"./use-agent-nodename\";\nimport { useCopilotChatConfiguration } from \"@copilotkitnext/react\";\n\ntype InterruptProps = {\n  event: any;\n  result: any;\n  render: (props: {\n    event: any;\n    result: any;\n    resolve: (response: string) => void;\n  }) => string | React.ReactElement;\n  resolve: (response: string) => void;\n};\n\nconst InterruptRenderer: React.FC<InterruptProps> = ({ event, result, render, resolve }) => {\n  return render({ event, result, resolve });\n};\n\nexport function useLangGraphInterruptRender(\n  agent: AbstractAgent,\n): string | React.ReactElement | null {\n  const {\n    interruptActions,\n    agentSession,\n    threadId,\n    interruptEventQueue,\n    addInterruptEvent,\n    resolveInterruptEvent,\n  } = useCopilotContext();\n  const existingConfig = useCopilotChatConfiguration();\n  const resolvedAgentId = existingConfig?.agentId ?? \"default\";\n  const nodeName = useAgentNodeName(resolvedAgentId);\n\n  useEffect(() => {\n    if (!agent) return;\n    let localInterrupt: any = null;\n    const subscriber: AgentSubscriber = {\n      onCustomEvent: ({ event }) => {\n        if (event.name === \"on_interrupt\") {\n          const eventData = {\n            name: MetaEventName.LangGraphInterruptEvent,\n            type: event.type,\n            value: parseJson(event.value, event.value),\n          };\n          const eventId = dataToUUID(eventData, \"interruptEvents\");\n          localInterrupt = {\n            eventId,\n            threadId,\n            event: eventData,\n          };\n        }\n      },\n      onRunStartedEvent: () => {\n        localInterrupt = null;\n      },\n      onRunFinalized: () => {\n        if (localInterrupt) {\n          addInterruptEvent(localInterrupt);\n          localInterrupt = null;\n        }\n      },\n    };\n\n    const { unsubscribe } = agent.subscribe(subscriber);\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [agent, threadId]);\n\n  const handleResolve = useCallback(\n    (eventId: string, response?: string) => {\n      agent?.runAgent({\n        forwardedProps: {\n          command: {\n            resume: response,\n          },\n        },\n      });\n      resolveInterruptEvent(threadId, eventId, response ?? \"\");\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [agent, threadId],\n  );\n\n  return useMemo(() => {\n    // Get the queue for this thread and find the first unresponded event\n    const eventQueue = interruptEventQueue[threadId] || [];\n    const currentQueuedEvent = eventQueue.find((qe) => !qe.event.response);\n\n    if (!currentQueuedEvent || !agentSession) return null;\n\n    // Find the first matching action from all registered actions\n    const allActions = Object.values(interruptActions);\n    const matchingAction = allActions.find((action) => {\n      if (!action.enabled) return true; // No filter = match all\n      return action.enabled({\n        eventValue: currentQueuedEvent.event.value,\n        agentMetadata: {\n          ...agentSession,\n          nodeName,\n        },\n      });\n    });\n\n    if (!matchingAction) return null;\n\n    const { render, handler } = matchingAction;\n\n    const resolveInterrupt = (response: string) => {\n      handleResolve(currentQueuedEvent.eventId, response);\n    };\n\n    let result = null;\n    if (handler) {\n      result = handler({\n        event: currentQueuedEvent.event,\n        resolve: resolveInterrupt,\n      });\n    }\n\n    if (!render) return null;\n\n    return React.createElement(InterruptRenderer, {\n      event: currentQueuedEvent.event,\n      result,\n      render,\n      resolve: resolveInterrupt,\n    });\n  }, [interruptActions, interruptEventQueue, threadId, agentSession, handleResolve]);\n}\n","import {\n  CopilotCloudConfig,\n  FunctionCallHandler,\n  CopilotErrorHandler,\n  CopilotKitError,\n} from \"@copilotkit/shared\";\nimport {\n  ActionRenderProps,\n  CatchAllActionRenderProps,\n  FrontendAction,\n} from \"../types/frontend-action\";\nimport React from \"react\";\nimport { TreeNodeId, Tree } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\nimport { CopilotChatSuggestionConfiguration } from \"../types/chat-suggestion-configuration\";\nimport { CoAgentStateRender, CoAgentStateRenderProps } from \"../types/coagent-action\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport {\n  CopilotRuntimeClient,\n  ExtensionsInput,\n  ForwardedParametersInput,\n} from \"@copilotkit/runtime-client-gql\";\nimport { Agent } from \"@copilotkit/runtime-client-gql\";\nimport {\n  LangGraphInterruptRender,\n  LangGraphInterruptActionSetter,\n  QueuedInterruptEvent,\n} from \"../types/interrupt-action\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The public API key for Copilot Cloud.\n   */\n  publicApiKey?: string;\n\n  /**\n   * The configuration for Copilot Cloud.\n   */\n  cloud?: CopilotCloudConfig;\n\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the Copilot transcribe audio service.\n   */\n  transcribeAudioUrl?: string;\n\n  /**\n   * The endpoint for the Copilot text to speech service.\n   */\n  textToSpeechUrl?: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Custom properties to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  properties?: Record<string, any>;\n\n  /**\n   * Indicates whether the user agent should send or receive cookies from the other domain\n   * in the case of cross-origin requests.\n   */\n  credentials?: RequestCredentials;\n\n  /**\n   * Optional configuration for connecting to Model Context Protocol (MCP) servers.\n   * This is typically derived from the CopilotKitProps and used internally.\n   * @experimental\n   */\n  mcpServers?: Array<{ endpoint: string; apiKey?: string }>;\n}\n\nexport type InChatRenderFunction<TProps = ActionRenderProps<any> | CatchAllActionRenderProps<any>> =\n  (props: TProps) => string | React.JSX.Element;\nexport type CoagentInChatRenderFunction = (\n  props: CoAgentStateRenderProps<any>,\n) => string | React.JSX.Element | undefined | null;\n\nexport interface ChatComponentsCache {\n  actions: Record<string, InChatRenderFunction | string>;\n  coAgentStateRenders: Record<string, CoagentInChatRenderFunction | string>;\n}\n\nexport interface AgentSession {\n  agentName: string;\n  threadId?: string;\n  nodeName?: string;\n}\n\nexport interface AuthState {\n  status: \"authenticated\" | \"unauthenticated\";\n  authHeaders: Record<string, string>;\n  userId?: string;\n  metadata?: Record<string, any>;\n}\n\nexport type ActionName = string;\nexport type ContextTree = Tree;\n\nexport interface CopilotContextParams {\n  // function-calling\n  actions: Record<string, FrontendAction<any>>;\n  setAction: (id: string, action: FrontendAction<any>) => void;\n  removeAction: (id: string) => void;\n\n  // registered actions for component-based rendering\n  setRegisteredActions: (actionConfig: any) => string;\n  removeRegisteredAction: (actionKey: string) => void;\n\n  chatComponentsCache: React.RefObject<ChatComponentsCache>;\n\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, FrontendAction<any>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getAllContext: () => Tree;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  isLoading: boolean;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration };\n  addChatSuggestionConfiguration: (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => void;\n  removeChatSuggestionConfiguration: (id: string) => void;\n\n  chatInstructions: string;\n  setChatInstructions: React.Dispatch<React.SetStateAction<string>>;\n\n  additionalInstructions?: string[];\n  setAdditionalInstructions: React.Dispatch<React.SetStateAction<string[]>>;\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n\n  showDevConsole: boolean;\n\n  // agents\n  coagentStates: Record<string, CoagentState>;\n  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;\n  coagentStatesRef: React.RefObject<Record<string, CoagentState>>;\n  setCoagentStatesWithRef: (\n    value:\n      | Record<string, CoagentState>\n      | ((prev: Record<string, CoagentState>) => Record<string, CoagentState>),\n  ) => void;\n\n  agentSession: AgentSession | null;\n  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;\n\n  agentLock: string | null;\n\n  threadId: string;\n  setThreadId: React.Dispatch<React.SetStateAction<string>>;\n\n  runId: string | null;\n  setRunId: React.Dispatch<React.SetStateAction<string | null>>;\n\n  // The chat abort controller can be used to stop generation globally,\n  // i.e. when using `stop()` from `useChat`\n  chatAbortControllerRef: React.MutableRefObject<AbortController | null>;\n\n  /**\n   * The forwarded parameters to use for the task.\n   */\n  forwardedParameters?: Partial<Pick<ForwardedParametersInput, \"temperature\">>;\n  availableAgents: Agent[];\n\n  /**\n   * The auth states for the CopilotKit.\n   */\n  authStates_c?: Record<ActionName, AuthState>;\n  setAuthStates_c?: React.Dispatch<React.SetStateAction<Record<ActionName, AuthState>>>;\n\n  /**\n   * The auth config for the CopilotKit.\n   */\n  authConfig_c?: {\n    SignInComponent: React.ComponentType<{\n      onSignInComplete: (authState: AuthState) => void;\n    }>;\n  };\n\n  extensions: ExtensionsInput;\n  setExtensions: React.Dispatch<React.SetStateAction<ExtensionsInput>>;\n  interruptActions: Record<string, LangGraphInterruptRender>;\n  setInterruptAction: LangGraphInterruptActionSetter;\n  removeInterruptAction: (actionId: string) => void;\n  interruptEventQueue: Record<string, QueuedInterruptEvent[]>;\n  addInterruptEvent: (queuedEvent: QueuedInterruptEvent) => void;\n  resolveInterruptEvent: (threadId: string, eventId: string, response: string) => void;\n\n  /**\n   * Optional trace handler for comprehensive debugging and observability.\n   */\n  onError: CopilotErrorHandler;\n\n  // banner error state\n  bannerError: CopilotKitError | null;\n  setBannerError: React.Dispatch<React.SetStateAction<CopilotKitError | null>>;\n  // Internal error handlers\n  // These are used to handle errors that occur during the execution of the chat.\n  // They are not intended for use by the developer. A component can register itself an error listener to be activated somewhere else as needed\n  internalErrorHandlers: Record<string, CopilotErrorHandler>;\n  setInternalErrorHandler: (handler: Record<string, CopilotErrorHandler>) => void;\n  removeInternalErrorHandler: (id: string) => void;\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  actions: {},\n  setAction: () => {},\n  removeAction: () => {},\n\n  setRegisteredActions: () => \"\",\n  removeRegisteredAction: () => {},\n\n  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n  getAllContext: () => [],\n\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  isLoading: false,\n  setIsLoading: () => returnAndThrowInDebug(false),\n\n  chatInstructions: \"\",\n  setChatInstructions: () => returnAndThrowInDebug(\"\"),\n\n  additionalInstructions: [],\n  setAdditionalInstructions: () => returnAndThrowInDebug([]),\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n\n  chatSuggestionConfiguration: {},\n  addChatSuggestionConfiguration: () => {},\n  removeChatSuggestionConfiguration: () => {},\n  showDevConsole: false,\n  coagentStates: {},\n  setCoagentStates: () => {},\n  coagentStatesRef: { current: {} },\n  setCoagentStatesWithRef: () => {},\n  agentSession: null,\n  setAgentSession: () => {},\n  forwardedParameters: {},\n  agentLock: null,\n  threadId: \"\",\n  setThreadId: () => {},\n  runId: null,\n  setRunId: () => {},\n  chatAbortControllerRef: { current: null },\n  availableAgents: [],\n  extensions: {},\n  setExtensions: () => {},\n  interruptActions: {},\n  setInterruptAction: () => {},\n  removeInterruptAction: () => {},\n  interruptEventQueue: {},\n  addInterruptEvent: () => {},\n  resolveInterruptEvent: () => {},\n  onError: () => {},\n  bannerError: null,\n  setBannerError: () => {},\n  internalErrorHandlers: {},\n  setInternalErrorHandler: () => {},\n  removeInternalErrorHandler: () => {},\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  const context = React.useContext(CopilotContext);\n  if (context === emptyCopilotContext) {\n    throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  }\n  return context;\n}\n\nfunction returnAndThrowInDebug<T>(_value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n}\n","import { useEffect, useRef } from \"react\";\nimport type { AgentSubscriber } from \"@ag-ui/client\";\nimport { useAgent } from \"@copilotkitnext/react\";\n\nexport function useAgentNodeName(agentName?: string) {\n  const { agent } = useAgent({ agentId: agentName });\n  const nodeNameRef = useRef<string>(\"start\");\n\n  useEffect(() => {\n    if (!agent) return;\n    const subscriber: AgentSubscriber = {\n      onStepStartedEvent: ({ event }) => {\n        nodeNameRef.current = event.stepName;\n      },\n      onRunStartedEvent: () => {\n        nodeNameRef.current = \"start\";\n      },\n      onRunFinishedEvent: () => {\n        nodeNameRef.current = \"end\";\n      },\n    };\n\n    const subscription = agent.subscribe(subscriber);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [agent]);\n\n  return nodeNameRef.current;\n}\n"],"mappings":"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","names":["React","import_react","import_react","import_react","React"]}