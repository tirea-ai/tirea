"use strict";
"use client";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  CoAgentStateRendersContext: () => CoAgentStateRendersContext,
  CoAgentStateRendersProvider: () => CoAgentStateRendersProvider,
  CopilotContext: () => CopilotContext,
  CopilotKit: () => CopilotKit,
  CopilotMessagesContext: () => CopilotMessagesContext,
  CopilotTask: () => CopilotTask,
  SUGGESTION_RETRY_CONFIG: () => SUGGESTION_RETRY_CONFIG,
  ThreadsContext: () => ThreadsContext,
  ThreadsProvider: () => ThreadsProvider,
  defaultCopilotContextCategories: () => defaultCopilotContextCategories,
  shouldShowDevConsole: () => shouldShowDevConsole,
  useCoAgent: () => useCoAgent,
  useCoAgentStateRender: () => useCoAgentStateRender,
  useCoAgentStateRenders: () => useCoAgentStateRenders,
  useCopilotAction: () => useCopilotAction,
  useCopilotAdditionalInstructions: () => useCopilotAdditionalInstructions,
  useCopilotAuthenticatedAction_c: () => useCopilotAuthenticatedAction_c,
  useCopilotChat: () => useCopilotChat,
  useCopilotChatHeadless_c: () => useCopilotChatHeadless_c,
  useCopilotChatInternal: () => useCopilotChatInternal,
  useCopilotChatSuggestions: () => useCopilotChatSuggestions,
  useCopilotContext: () => useCopilotContext,
  useCopilotMessagesContext: () => useCopilotMessagesContext,
  useCopilotReadable: () => useCopilotReadable,
  useCopilotRuntimeClient: () => useCopilotRuntimeClient,
  useDefaultTool: () => useDefaultTool,
  useFrontendTool: () => useFrontendTool,
  useHumanInTheLoop: () => useHumanInTheLoop,
  useLangGraphInterrupt: () => useLangGraphInterrupt,
  useLangGraphInterruptRender: () => useLangGraphInterruptRender,
  useLazyToolRenderer: () => useLazyToolRenderer,
  useMakeCopilotDocumentReadable: () => useMakeCopilotDocumentReadable,
  useRenderToolCall: () => useRenderToolCall2,
  useThreads: () => useThreads
});
module.exports = __toCommonJS(src_exports);

// src/components/copilot-provider/copilotkit.tsx
var import_react16 = require("react");
var import_react17 = require("@copilotkitnext/react");

// src/context/copilot-context.tsx
var import_react = __toESM(require("react"));
var emptyCopilotContext = {
  actions: {},
  setAction: () => {
  },
  removeAction: () => {
  },
  setRegisteredActions: () => "",
  removeRegisteredAction: () => {
  },
  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },
  getContextString: (documents, categories) => returnAndThrowInDebug(""),
  addContext: () => "",
  removeContext: () => {
  },
  getAllContext: () => [],
  getFunctionCallHandler: () => returnAndThrowInDebug(() => __async(void 0, null, function* () {
  })),
  isLoading: false,
  setIsLoading: () => returnAndThrowInDebug(false),
  chatInstructions: "",
  setChatInstructions: () => returnAndThrowInDebug(""),
  additionalInstructions: [],
  setAdditionalInstructions: () => returnAndThrowInDebug([]),
  getDocumentsContext: (categories) => returnAndThrowInDebug([]),
  addDocumentContext: () => returnAndThrowInDebug(""),
  removeDocumentContext: () => {
  },
  copilotApiConfig: new class {
    get chatApiEndpoint() {
      throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
    }
    get headers() {
      return {};
    }
    get body() {
      return {};
    }
  }(),
  chatSuggestionConfiguration: {},
  addChatSuggestionConfiguration: () => {
  },
  removeChatSuggestionConfiguration: () => {
  },
  showDevConsole: false,
  coagentStates: {},
  setCoagentStates: () => {
  },
  coagentStatesRef: { current: {} },
  setCoagentStatesWithRef: () => {
  },
  agentSession: null,
  setAgentSession: () => {
  },
  forwardedParameters: {},
  agentLock: null,
  threadId: "",
  setThreadId: () => {
  },
  runId: null,
  setRunId: () => {
  },
  chatAbortControllerRef: { current: null },
  availableAgents: [],
  extensions: {},
  setExtensions: () => {
  },
  interruptActions: {},
  setInterruptAction: () => {
  },
  removeInterruptAction: () => {
  },
  interruptEventQueue: {},
  addInterruptEvent: () => {
  },
  resolveInterruptEvent: () => {
  },
  onError: () => {
  },
  bannerError: null,
  setBannerError: () => {
  },
  internalErrorHandlers: {},
  setInternalErrorHandler: () => {
  },
  removeInternalErrorHandler: () => {
  }
};
var CopilotContext = import_react.default.createContext(emptyCopilotContext);
function useCopilotContext() {
  const context = import_react.default.useContext(CopilotContext);
  if (context === emptyCopilotContext) {
    throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
  }
  return context;
}
function returnAndThrowInDebug(_value) {
  throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
}

// src/hooks/use-tree.ts
var import_shared = require("@copilotkit/shared");
var import_react2 = require("react");
var removeNode = (nodes, id) => {
  return nodes.reduce((result, node) => {
    if (node.id !== id) {
      const newNode = __spreadProps(__spreadValues({}, node), { children: removeNode(node.children, id) });
      result.push(newNode);
    }
    return result;
  }, []);
};
var addNode = (nodes, newNode, parentId) => {
  if (!parentId) {
    return [...nodes, newNode];
  }
  return nodes.map((node) => {
    if (node.id === parentId) {
      return __spreadProps(__spreadValues({}, node), { children: [...node.children, newNode] });
    } else if (node.children.length) {
      return __spreadProps(__spreadValues({}, node), { children: addNode(node.children, newNode, parentId) });
    }
    return node;
  });
};
var treeIndentationRepresentation = (index, indentLevel) => {
  if (indentLevel === 0) {
    return (index + 1).toString();
  } else if (indentLevel === 1) {
    return String.fromCharCode(65 + index);
  } else if (indentLevel === 2) {
    return String.fromCharCode(97 + index);
  } else {
    return "-";
  }
};
var printNode = (node, prefix = "", indentLevel = 0) => {
  const indent = " ".repeat(3).repeat(indentLevel);
  const prefixPlusIndentLength = prefix.length + indent.length;
  const subsequentLinesPrefix = " ".repeat(prefixPlusIndentLength);
  const valueLines = node.value.split("\n");
  const outputFirstLine = `${indent}${prefix}${valueLines[0]}`;
  const outputSubsequentLines = valueLines.slice(1).map((line) => `${subsequentLinesPrefix}${line}`).join("\n");
  let output = `${outputFirstLine}
`;
  if (outputSubsequentLines) {
    output += `${outputSubsequentLines}
`;
  }
  const childPrePrefix = " ".repeat(prefix.length);
  node.children.forEach(
    (child, index) => output += printNode(
      child,
      `${childPrePrefix}${treeIndentationRepresentation(index, indentLevel + 1)}. `,
      indentLevel + 1
    )
  );
  return output;
};
function treeReducer(state, action) {
  switch (action.type) {
    case "ADD_NODE": {
      const { value, parentId, id: newNodeId } = action;
      const newNode = {
        id: newNodeId,
        value,
        children: [],
        categories: new Set(action.categories)
      };
      try {
        return addNode(state, newNode, parentId);
      } catch (error) {
        console.error(`Error while adding node with id ${newNodeId}: ${error}`);
        return state;
      }
    }
    case "REMOVE_NODE":
      return removeNode(state, action.id);
    default:
      return state;
  }
}
var useTree = () => {
  const [tree, dispatch] = (0, import_react2.useReducer)(treeReducer, []);
  const addElement = (0, import_react2.useCallback)(
    (value, categories, parentId) => {
      const newNodeId = (0, import_shared.randomId)();
      dispatch({
        type: "ADD_NODE",
        value,
        parentId,
        id: newNodeId,
        categories
      });
      return newNodeId;
    },
    []
  );
  const removeElement = (0, import_react2.useCallback)((id) => {
    dispatch({ type: "REMOVE_NODE", id });
  }, []);
  const getAllElements = (0, import_react2.useCallback)(() => {
    return tree;
  }, [tree]);
  const printTree = (0, import_react2.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      let output = "";
      tree.forEach((node, index) => {
        if (!setsHaveIntersection(categoriesSet, node.categories)) {
          return;
        }
        if (index !== 0) {
          output += "\n";
        }
        output += printNode(node, `${treeIndentationRepresentation(index, 0)}. `);
      });
      return output;
    },
    [tree]
  );
  return { tree, addElement, printTree, removeElement, getAllElements };
};
var use_tree_default = useTree;
function setsHaveIntersection(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// src/components/copilot-provider/copilotkit.tsx
var import_react_dom = require("react-dom");
var import_shared13 = require("@copilotkit/shared");

// src/hooks/use-flat-category-store.ts
var import_react3 = require("react");
var import_shared2 = require("@copilotkit/shared");
var useFlatCategoryStore = () => {
  const [elements, dispatch] = (0, import_react3.useReducer)(
    flatCategoryStoreReducer,
    /* @__PURE__ */ new Map()
  );
  const addElement = (0, import_react3.useCallback)((value, categories) => {
    const newId = (0, import_shared2.randomId)();
    dispatch({
      type: "ADD_ELEMENT",
      value,
      id: newId,
      categories
    });
    return newId;
  }, []);
  const removeElement = (0, import_react3.useCallback)((id) => {
    dispatch({ type: "REMOVE_ELEMENT", id });
  }, []);
  const allElements = (0, import_react3.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      const result = [];
      elements.forEach((element) => {
        if (setsHaveIntersection2(categoriesSet, element.categories)) {
          result.push(element.value);
        }
      });
      return result;
    },
    [elements]
  );
  return { addElement, removeElement, allElements };
};
var use_flat_category_store_default = useFlatCategoryStore;
function flatCategoryStoreReducer(state, action) {
  switch (action.type) {
    case "ADD_ELEMENT": {
      const { value, id, categories } = action;
      const newElement = {
        id,
        value,
        categories: new Set(categories)
      };
      const newState = new Map(state);
      newState.set(id, newElement);
      return newState;
    }
    case "REMOVE_ELEMENT": {
      const newState = new Map(state);
      newState.delete(action.id);
      return newState;
    }
    default:
      return state;
  }
}
function setsHaveIntersection2(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// src/components/copilot-provider/copilot-messages.tsx
var import_react6 = require("react");

// src/context/copilot-messages-context.tsx
var import_react4 = __toESM(require("react"));
var emptyCopilotContext2 = {
  messages: [],
  setMessages: () => [],
  // suggestions state
  suggestions: [],
  setSuggestions: () => []
};
var CopilotMessagesContext = import_react4.default.createContext(emptyCopilotContext2);
function useCopilotMessagesContext() {
  const context = import_react4.default.useContext(CopilotMessagesContext);
  if (context === emptyCopilotContext2) {
    throw new Error(
      "A messages consuming component was not wrapped with `<CopilotMessages> {...} </CopilotMessages>`"
    );
  }
  return context;
}

// src/components/toast/toast-provider.tsx
var import_react5 = require("react");
var import_shared3 = require("@copilotkit/shared");
var import_jsx_runtime = require("react/jsx-runtime");
var ToastContext = (0, import_react5.createContext)(void 0);
function getErrorSeverity(error) {
  if (error.severity) {
    switch (error.severity) {
      case import_shared3.Severity.CRITICAL:
        return "critical";
      case import_shared3.Severity.WARNING:
        return "warning";
      case import_shared3.Severity.INFO:
        return "info";
      default:
        return "info";
    }
  }
  const message = error.message.toLowerCase();
  if (message.includes("api key") || message.includes("401") || message.includes("unauthorized") || message.includes("authentication") || message.includes("incorrect api key")) {
    return "critical";
  }
  return "info";
}
function getErrorColors(severity) {
  switch (severity) {
    case "critical":
      return {
        background: "#fee2e2",
        border: "#dc2626",
        text: "#7f1d1d",
        icon: "#dc2626"
      };
    case "warning":
      return {
        background: "#fef3c7",
        border: "#d97706",
        text: "#78350f",
        icon: "#d97706"
      };
    case "info":
      return {
        background: "#dbeafe",
        border: "#2563eb",
        text: "#1e3a8a",
        icon: "#2563eb"
      };
  }
}
function useToast() {
  const context = (0, import_react5.useContext)(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
}
function ToastProvider({
  enabled,
  children
}) {
  const [toasts, setToasts] = (0, import_react5.useState)([]);
  const [bannerError, setBannerErrorState] = (0, import_react5.useState)(null);
  const removeToast = (0, import_react5.useCallback)((id) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);
  const addToast = (0, import_react5.useCallback)(
    (toast) => {
      var _a;
      if (!enabled) {
        return;
      }
      const id = (_a = toast.id) != null ? _a : Math.random().toString(36).substring(2, 9);
      setToasts((currentToasts) => {
        if (currentToasts.find((toast2) => toast2.id === id))
          return currentToasts;
        return [...currentToasts, __spreadProps(__spreadValues({}, toast), { id })];
      });
      if (toast.duration) {
        setTimeout(() => {
          removeToast(id);
        }, toast.duration);
      }
    },
    [enabled, removeToast]
  );
  const setBannerError = (0, import_react5.useCallback)(
    (error) => {
      if (!enabled && error !== null) {
        return;
      }
      setBannerErrorState(error);
    },
    [enabled]
  );
  const addGraphQLErrorsToast = (0, import_react5.useCallback)((errors) => {
    console.warn("addGraphQLErrorsToast is deprecated. All errors now show as banners.");
  }, []);
  const value = {
    toasts,
    addToast,
    addGraphQLErrorsToast,
    removeToast,
    enabled,
    bannerError,
    setBannerError
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ToastContext.Provider, { value, children: [
    bannerError && (() => {
      const severity = getErrorSeverity(bannerError);
      const colors = getErrorColors(severity);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "div",
        {
          style: {
            position: "fixed",
            bottom: "20px",
            left: "50%",
            transform: "translateX(-50%)",
            zIndex: 9999,
            backgroundColor: colors.background,
            border: `1px solid ${colors.border}`,
            borderLeft: `4px solid ${colors.border}`,
            borderRadius: "8px",
            padding: "12px 16px",
            fontSize: "13px",
            boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
            backdropFilter: "blur(8px)",
            maxWidth: "min(90vw, 700px)",
            width: "100%",
            boxSizing: "border-box",
            overflow: "hidden"
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                gap: "10px"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      flex: 1,
                      minWidth: 0
                    },
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                        "div",
                        {
                          style: {
                            width: "12px",
                            height: "12px",
                            borderRadius: "50%",
                            backgroundColor: colors.border,
                            flexShrink: 0
                          }
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            display: "flex",
                            alignItems: "center",
                            gap: "10px",
                            flex: 1,
                            minWidth: 0
                          },
                          children: [
                            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                              "div",
                              {
                                style: {
                                  color: colors.text,
                                  lineHeight: "1.4",
                                  fontWeight: "400",
                                  fontSize: "13px",
                                  flex: 1,
                                  wordBreak: "break-all",
                                  overflowWrap: "break-word",
                                  maxWidth: "550px",
                                  overflow: "hidden",
                                  display: "-webkit-box",
                                  WebkitLineClamp: 10,
                                  WebkitBoxOrient: "vertical"
                                },
                                children: (() => {
                                  let message = bannerError.message;
                                  const jsonMatch = message.match(/'message':\s*'([^']+)'/);
                                  if (jsonMatch) {
                                    return jsonMatch[1];
                                  }
                                  message = message.split(" - ")[0];
                                  message = message.split(": Error code")[0];
                                  message = message.replace(/:\s*\d{3}$/, "");
                                  message = message.replace(/See more:.*$/g, "");
                                  message = message.trim();
                                  return message || "Configuration error occurred.";
                                })()
                              }
                            ),
                            (() => {
                              const message = bannerError.message;
                              const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
                              const plainUrlRegex = /(https?:\/\/[^\s)]+)/g;
                              let url = null;
                              let buttonText = "See More";
                              const markdownMatch = markdownLinkRegex.exec(message);
                              if (markdownMatch) {
                                url = markdownMatch[2];
                                buttonText = "See More";
                              } else {
                                const urlMatch = plainUrlRegex.exec(message);
                                if (urlMatch) {
                                  url = urlMatch[0].replace(/[.,;:'"]*$/, "");
                                  buttonText = "See More";
                                }
                              }
                              if (!url)
                                return null;
                              return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                                "button",
                                {
                                  onClick: () => window.open(url, "_blank", "noopener,noreferrer"),
                                  style: {
                                    background: colors.border,
                                    color: "white",
                                    border: "none",
                                    borderRadius: "5px",
                                    padding: "4px 10px",
                                    fontSize: "11px",
                                    fontWeight: "500",
                                    cursor: "pointer",
                                    transition: "all 0.2s ease",
                                    flexShrink: 0
                                  },
                                  onMouseEnter: (e) => {
                                    e.currentTarget.style.opacity = "0.9";
                                    e.currentTarget.style.transform = "translateY(-1px)";
                                  },
                                  onMouseLeave: (e) => {
                                    e.currentTarget.style.opacity = "1";
                                    e.currentTarget.style.transform = "translateY(0)";
                                  },
                                  children: buttonText
                                }
                              );
                            })()
                          ]
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "button",
                  {
                    onClick: () => setBannerError(null),
                    style: {
                      background: "transparent",
                      border: "none",
                      color: colors.text,
                      cursor: "pointer",
                      padding: "2px",
                      borderRadius: "3px",
                      fontSize: "14px",
                      lineHeight: "1",
                      opacity: 0.6,
                      transition: "all 0.2s ease",
                      flexShrink: 0
                    },
                    title: "Dismiss",
                    onMouseEnter: (e) => {
                      e.currentTarget.style.opacity = "1";
                      e.currentTarget.style.background = "rgba(0, 0, 0, 0.05)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.opacity = "0.6";
                      e.currentTarget.style.background = "transparent";
                    },
                    children: "\xD7"
                  }
                )
              ]
            }
          )
        }
      );
    })(),
    children
  ] });
}

// src/utils/dev-console.ts
function isLocalhost() {
  if (typeof window === "undefined")
    return false;
  return window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname === "0.0.0.0";
}
function shouldShowDevConsole(showDevConsole) {
  if (showDevConsole !== void 0) {
    return showDevConsole;
  }
  return isLocalhost();
}

// src/components/copilot-provider/copilot-messages.tsx
var import_shared4 = require("@copilotkit/shared");
var import_jsx_runtime2 = require("react/jsx-runtime");
var MessagesTapContext = (0, import_react6.createContext)(null);
function useMessagesTap() {
  const tap = (0, import_react6.useContext)(MessagesTapContext);
  if (!tap)
    throw new Error("useMessagesTap must be used inside <MessagesTapProvider>");
  return tap;
}
function MessagesTapProvider({ children }) {
  const messagesRef = (0, import_react6.useRef)([]);
  const tapRef = (0, import_react6.useRef)({
    getMessagesFromTap: () => messagesRef.current,
    updateTapMessages: (messages) => {
      messagesRef.current = messages;
    }
  });
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MessagesTapContext.Provider, { value: tapRef.current, children });
}
function CopilotMessages({ children }) {
  const [messages, setMessages] = (0, import_react6.useState)([]);
  const lastLoadedThreadId = (0, import_react6.useRef)(void 0);
  const lastLoadedAgentName = (0, import_react6.useRef)(void 0);
  const lastLoadedMessages = (0, import_react6.useRef)(void 0);
  const { updateTapMessages } = useMessagesTap();
  const { threadId, agentSession, showDevConsole, onError, copilotApiConfig } = useCopilotContext();
  const { setBannerError } = useToast();
  const traceUIError = (0, import_react6.useCallback)(
    (error, originalError) => __async(this, null, function* () {
      if (!onError || !copilotApiConfig.publicApiKey)
        return;
      try {
        const traceEvent = {
          type: "error",
          timestamp: Date.now(),
          context: {
            source: "ui",
            request: {
              operation: "loadAgentState",
              url: copilotApiConfig.chatApiEndpoint,
              startTime: Date.now()
            },
            technical: {
              environment: "browser",
              userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
              stackTrace: originalError instanceof Error ? originalError.stack : void 0
            }
          },
          error
        };
        yield onError(traceEvent);
      } catch (traceError) {
        console.error("Error in CopilotMessages onError handler:", traceError);
      }
    }),
    [onError, copilotApiConfig.publicApiKey, copilotApiConfig.chatApiEndpoint]
  );
  const createStructuredError2 = (gqlError) => {
    const extensions = gqlError.extensions;
    const originalError = extensions == null ? void 0 : extensions.originalError;
    if (originalError == null ? void 0 : originalError.stack) {
      if (originalError.stack.includes("CopilotApiDiscoveryError")) {
        return new import_shared4.CopilotKitApiDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitRemoteEndpointDiscoveryError")) {
        return new import_shared4.CopilotKitRemoteEndpointDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitAgentDiscoveryError")) {
        return new import_shared4.CopilotKitAgentDiscoveryError({
          agentName: "",
          availableAgents: []
        });
      }
    }
    const message = (originalError == null ? void 0 : originalError.message) || gqlError.message;
    const code = extensions == null ? void 0 : extensions.code;
    if (code) {
      return new import_shared4.CopilotKitError({ message, code });
    }
    return null;
  };
  const handleGraphQLErrors = (0, import_react6.useCallback)(
    (error) => {
      var _a;
      if ((_a = error.graphQLErrors) == null ? void 0 : _a.length) {
        const graphQLErrors = error.graphQLErrors;
        const routeError = (gqlError) => {
          const extensions = gqlError.extensions;
          const visibility = extensions == null ? void 0 : extensions.visibility;
          const isDev = shouldShowDevConsole(showDevConsole);
          if (!isDev) {
            console.error("CopilotKit Error (hidden in production):", gqlError.message);
            return;
          }
          if (visibility === import_shared4.ErrorVisibility.SILENT) {
            console.error("CopilotKit Silent Error:", gqlError.message);
            return;
          }
          const ckError = createStructuredError2(gqlError);
          if (ckError) {
            setBannerError(ckError);
            traceUIError(ckError, gqlError);
          } else {
            const fallbackError = new import_shared4.CopilotKitError({
              message: gqlError.message,
              code: import_shared4.CopilotKitErrorCode.UNKNOWN
            });
            setBannerError(fallbackError);
            traceUIError(fallbackError, gqlError);
          }
        };
        graphQLErrors.forEach(routeError);
      } else {
        const isDev = shouldShowDevConsole(showDevConsole);
        if (!isDev) {
          console.error("CopilotKit Error (hidden in production):", error);
        } else {
          const fallbackError = new import_shared4.CopilotKitError({
            message: (error == null ? void 0 : error.message) || String(error),
            code: import_shared4.CopilotKitErrorCode.UNKNOWN
          });
          setBannerError(fallbackError);
          traceUIError(fallbackError, error);
        }
      }
    },
    [setBannerError, showDevConsole, traceUIError]
  );
  (0, import_react6.useEffect)(() => {
    updateTapMessages(messages);
  }, [messages, updateTapMessages]);
  const memoizedChildren = (0, import_react6.useMemo)(() => children, [children]);
  const [suggestions, setSuggestions] = (0, import_react6.useState)([]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    CopilotMessagesContext.Provider,
    {
      value: {
        messages,
        setMessages,
        suggestions,
        setSuggestions
      },
      children: memoizedChildren
    }
  );
}

// src/components/usage-banner.tsx
var import_shared5 = require("@copilotkit/shared");
var import_jsx_runtime3 = require("react/jsx-runtime");
function UsageBanner({
  severity = import_shared5.Severity.CRITICAL,
  message = "",
  onClose,
  actions
}) {
  if (!message || !severity) {
    return null;
  }
  const themes = {
    [import_shared5.Severity.INFO]: {
      bg: "#f8fafc",
      border: "#e2e8f0",
      text: "#475569",
      accent: "#3b82f6"
    },
    [import_shared5.Severity.WARNING]: {
      bg: "#fffbeb",
      border: "#fbbf24",
      text: "#92400e",
      accent: "#f59e0b"
    },
    [import_shared5.Severity.CRITICAL]: {
      bg: "#fef2f2",
      border: "#fecaca",
      text: "#dc2626",
      accent: "#ef4444"
    }
  };
  const theme = themes[severity];
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("style", { children: `
          @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(8px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
          }
          
          .usage-banner {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: min(600px, calc(100vw - 32px));
            z-index: 10000;
            animation: slideUp 0.2s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          .banner-content {
            background: linear-gradient(135deg, ${theme.bg} 0%, ${theme.bg}f5 100%);
            border: 1px solid ${theme.border};
            border-radius: 12px;
            padding: 18px 20px;
            box-shadow: 
              0 4px 24px rgba(0, 0, 0, 0.08),
              0 2px 8px rgba(0, 0, 0, 0.04),
              inset 0 1px 0 rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            gap: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            backdrop-filter: blur(12px);
            position: relative;
            overflow: hidden;
          }
          
          .banner-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, ${theme.accent}40, transparent);
          }
          
          .banner-message {
            color: ${theme.text};
            font-size: 14px;
            line-height: 1.5;
            font-weight: 500;
            flex: 1;
            letter-spacing: -0.01em;
          }
          
          .close-btn {
            background: rgba(0, 0, 0, 0.05);
            border: none;
            color: ${theme.text};
            cursor: pointer;
            padding: 0;
            border-radius: 6px;
            opacity: 0.6;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-size: 14px;
            line-height: 1;
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          
          .close-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.08);
            transform: scale(1.05);
          }
          
          .btn-primary {
            background: linear-gradient(135deg, ${theme.accent} 0%, ${theme.accent}e6 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-family: inherit;
            flex-shrink: 0;
            box-shadow: 
              0 2px 8px ${theme.accent}30,
              inset 0 1px 0 rgba(255, 255, 255, 0.2);
            letter-spacing: -0.01em;
          }
          
          .btn-primary:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 
              0 4px 12px ${theme.accent}40,
              inset 0 1px 0 rgba(255, 255, 255, 0.25);
          }
          
          .btn-primary:active {
            transform: translateY(0) scale(0.98);
            transition: all 0.08s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          @media (max-width: 640px) {
            .usage-banner {
              width: calc(100vw - 24px);
            }
            
            .banner-content {
              padding: 16px;
              gap: 12px;
            }
            
            .banner-message {
              font-size: 13px;
              line-height: 1.45;
            }
            
            .btn-primary {
              padding: 8px 14px;
              font-size: 12px;
            }
            
            .close-btn {
              width: 22px;
              height: 22px;
              font-size: 12px;
            }
          }
        ` }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "usage-banner", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "banner-content", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "banner-message", children: message }),
      (actions == null ? void 0 : actions.primary) && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("button", { className: "btn-primary", onClick: actions.primary.onClick, children: actions.primary.label }),
      onClose && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("button", { className: "close-btn", onClick: onClose, title: "Close", children: "\xD7" })
    ] }) })
  ] });
}
var getErrorActions = (error) => {
  switch (error.code) {
    case import_shared5.CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR:
      return {
        primary: {
          label: "Show me how",
          onClick: () => window.open(
            "https://docs.copilotkit.ai/premium#how-do-i-get-access-to-premium-features",
            "_blank",
            "noopener,noreferrer"
          )
        }
      };
    case import_shared5.CopilotKitErrorCode.UPGRADE_REQUIRED_ERROR:
      return {
        primary: {
          label: "Upgrade",
          onClick: () => window.open("https://cloud.copilotkit.ai", "_blank", "noopener,noreferrer")
        }
      };
    default:
      return void 0;
  }
};

// src/utils/suggestions-constants.ts
var SUGGESTION_RETRY_CONFIG = {
  MAX_RETRIES: 3,
  COOLDOWN_MS: 5e3
  // 5 seconds
};

// src/components/error-boundary/error-boundary.tsx
var import_react8 = __toESM(require("react"));
var import_shared7 = require("@copilotkit/shared");

// src/lib/status-checker.ts
var import_shared6 = require("@copilotkit/shared");
var STATUS_CHECK_INTERVAL = 1e3 * 60 * 5;
var StatusChecker = class {
  constructor() {
    this.activeKey = null;
    this.intervalId = null;
    this.instanceCount = 0;
    this.lastResponse = null;
  }
  start(publicApiKey, onUpdate) {
    return __async(this, null, function* () {
      this.instanceCount++;
      if (this.activeKey === publicApiKey)
        return;
      if (this.intervalId)
        clearInterval(this.intervalId);
      const checkStatus = () => __async(this, null, function* () {
        try {
          const response = yield fetch(`${import_shared6.COPILOT_CLOUD_API_URL}/ciu`, {
            method: "GET",
            headers: {
              [import_shared6.COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey
            }
          }).then((response2) => response2.json());
          this.lastResponse = response;
          onUpdate == null ? void 0 : onUpdate(response);
          return response;
        } catch (error) {
          return null;
        }
      });
      const initialResponse = yield checkStatus();
      this.intervalId = setInterval(checkStatus, STATUS_CHECK_INTERVAL);
      this.activeKey = publicApiKey;
      return initialResponse;
    });
  }
  getLastResponse() {
    return this.lastResponse;
  }
  stop() {
    this.instanceCount--;
    if (this.instanceCount === 0) {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
        this.activeKey = null;
        this.lastResponse = null;
      }
    }
  }
};

// src/components/error-boundary/error-utils.tsx
var import_react7 = require("react");

// src/components/toast/exclamation-mark-icon.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var ExclamationMarkIcon = ({
  className,
  style
}) => /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    className: `lucide lucide-circle-alert ${className ? className : ""}`,
    style,
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("circle", { cx: "12", cy: "12", r: "10" }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("line", { x1: "12", x2: "12", y1: "8", y2: "12" }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("line", { x1: "12", x2: "12.01", y1: "16", y2: "16" })
    ]
  }
);

// src/components/error-boundary/error-utils.tsx
var import_react_markdown = __toESM(require("react-markdown"));
var import_jsx_runtime5 = require("react/jsx-runtime");
function ErrorToast({ errors }) {
  const errorsToRender = errors.map((error, idx) => {
    var _a, _b, _c;
    const originalError = "extensions" in error ? (_a = error.extensions) == null ? void 0 : _a.originalError : {};
    const message = (_b = originalError == null ? void 0 : originalError.message) != null ? _b : error.message;
    const code = "extensions" in error ? (_c = error.extensions) == null ? void 0 : _c.code : null;
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
      "div",
      {
        style: {
          marginTop: idx === 0 ? 0 : 10,
          marginBottom: 14
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ExclamationMarkIcon, { style: { marginBottom: 4 } }),
          code && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
            "div",
            {
              style: {
                fontWeight: "600",
                marginBottom: 4
              },
              children: [
                "Copilot Runtime Error:",
                " ",
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { style: { fontFamily: "monospace", fontWeight: "normal" }, children: code })
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_markdown.default, { children: message })
        ]
      },
      idx
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
    "div",
    {
      style: {
        fontSize: "13px",
        maxWidth: "600px"
      },
      children: [
        errorsToRender,
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: { fontSize: "11px", opacity: 0.75 }, children: "NOTE: This error only displays during local development." })
      ]
    }
  );
}
function useErrorToast() {
  const { addToast } = useToast();
  return (0, import_react7.useCallback)(
    (errors) => {
      const errorId = errors.map((err) => {
        var _a, _b;
        const message = "extensions" in err ? ((_b = (_a = err.extensions) == null ? void 0 : _a.originalError) == null ? void 0 : _b.message) || err.message : err.message;
        const stack = err.stack || "";
        return btoa(message + stack).slice(0, 32);
      }).join("|");
      addToast({
        type: "error",
        id: errorId,
        // Toast libraries typically dedupe by id
        message: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ErrorToast, { errors })
      });
    },
    [addToast]
  );
}
function useAsyncCallback(callback, deps) {
  const addErrorToast = useErrorToast();
  return (0, import_react7.useCallback)((...args) => __async(this, null, function* () {
    try {
      return yield callback(...args);
    } catch (error) {
      console.error("Error in async callback:", error);
      addErrorToast([error]);
      throw error;
    }
  }), deps);
}

// src/components/error-boundary/error-boundary.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var statusChecker = new StatusChecker();
var CopilotErrorBoundary = class extends import_react8.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidMount() {
    if (this.props.publicApiKey) {
      statusChecker.start(this.props.publicApiKey, (newStatus) => {
        this.setState((prevState) => {
          var _a;
          if ((newStatus == null ? void 0 : newStatus.severity) !== ((_a = prevState.status) == null ? void 0 : _a.severity)) {
            return { status: newStatus != null ? newStatus : void 0 };
          }
          return null;
        });
      });
    }
  }
  componentWillUnmount() {
    statusChecker.stop();
  }
  componentDidCatch(error, errorInfo) {
    console.error("CopilotKit Error:", error, errorInfo);
  }
  render() {
    var _a, _b, _c, _d;
    if (this.state.hasError) {
      if (this.state.error instanceof import_shared7.CopilotKitError) {
        return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
          this.props.children,
          this.props.showUsageBanner && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
            UsageBanner,
            {
              severity: (_b = (_a = this.state.status) == null ? void 0 : _a.severity) != null ? _b : this.state.error.severity,
              message: (_d = (_c = this.state.status) == null ? void 0 : _c.message) != null ? _d : this.state.error.message,
              actions: getErrorActions(this.state.error)
            }
          )
        ] });
      }
      throw this.state.error;
    }
    return this.props.children;
  }
};

// src/context/coagent-state-renders-context.tsx
var import_react9 = require("react");
var import_jsx_runtime7 = require("react/jsx-runtime");
var CoAgentStateRendersContext = (0, import_react9.createContext)(
  void 0
);
function CoAgentStateRendersProvider({ children }) {
  const [coAgentStateRenders, setCoAgentStateRenders] = (0, import_react9.useState)({});
  const setCoAgentStateRender = (0, import_react9.useCallback)((id, stateRender) => {
    setCoAgentStateRenders((prevPoints) => __spreadProps(__spreadValues({}, prevPoints), {
      [id]: stateRender
    }));
  }, []);
  const removeCoAgentStateRender = (0, import_react9.useCallback)((id) => {
    setCoAgentStateRenders((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const claimsRef = (0, import_react9.useRef)({});
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    CoAgentStateRendersContext.Provider,
    {
      value: {
        coAgentStateRenders,
        setCoAgentStateRender,
        removeCoAgentStateRender,
        claimsRef
      },
      children
    }
  );
}
function useCoAgentStateRenders() {
  const context = (0, import_react9.useContext)(CoAgentStateRendersContext);
  if (!context) {
    throw new Error("useCoAgentStateRenders must be used within CoAgentStateRendersProvider");
  }
  return context;
}

// src/hooks/use-coagent-state-render-bridge.tsx
var import_react12 = require("@copilotkitnext/react");
var import_react13 = require("react");

// src/context/threads-context.tsx
var import_react10 = require("react");
var import_shared8 = require("@copilotkit/shared");
var import_jsx_runtime8 = require("react/jsx-runtime");
var ThreadsContext = (0, import_react10.createContext)(void 0);
function ThreadsProvider({ children, threadId: explicitThreadId }) {
  const [internalThreadId, setThreadId] = (0, import_react10.useState)(() => (0, import_shared8.randomUUID)());
  const threadId = explicitThreadId != null ? explicitThreadId : internalThreadId;
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    ThreadsContext.Provider,
    {
      value: {
        threadId,
        setThreadId
      },
      children
    }
  );
}
function useThreads() {
  const context = (0, import_react10.useContext)(ThreadsContext);
  if (!context) {
    throw new Error("useThreads must be used within ThreadsProvider");
  }
  return context;
}

// src/hooks/use-coagent-state-render-bridge.tsx
var import_shared10 = require("@copilotkit/shared");

// src/hooks/use-coagent-state-render-bridge.helpers.ts
var import_shared9 = require("@copilotkit/shared");
function getStateWithoutConstantKeys(state) {
  if (!state)
    return {};
  const _a = state, { messages, tools, copilotkit } = _a, stateWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  return stateWithoutConstantKeys;
}
function areStatesEquals(a, b) {
  if (a && !b || !a && b)
    return false;
  const _a = a, { messages, tools, copilotkit } = _a, aWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  const _b = b, {
    messages: bMessages,
    tools: bTools,
    copilotkit: bCopilotkit
  } = _b, bWithoutConstantKeys = __objRest(_b, [
    "messages",
    "tools",
    "copilotkit"
  ]);
  return JSON.stringify(aWithoutConstantKeys) === JSON.stringify(bWithoutConstantKeys);
}
function isPlaceholderMessageId(messageId) {
  return !!messageId && messageId.startsWith("coagent-state-render-");
}
function isPlaceholderMessageName(messageName) {
  return messageName === "coagent-state-render";
}
function readCachedMessageEntry(entry) {
  if (!entry || typeof entry !== "object") {
    return { snapshot: entry, runId: void 0 };
  }
  const snapshot = "snapshot" in entry ? entry.snapshot : entry;
  const runId = "runId" in entry ? entry.runId : void 0;
  return { snapshot, runId };
}
function getEffectiveRunId({
  existingClaimRunId,
  cachedMessageRunId,
  runId
}) {
  return existingClaimRunId || cachedMessageRunId || runId || "pending";
}
function resolveClaim({
  claims,
  context,
  stateSnapshot
}) {
  const { messageId, stateRenderId, runId, messageIndex } = context;
  const existing = claims[messageId];
  if (existing) {
    const canRender = existing.stateRenderId === stateRenderId;
    const shouldUpdateRunId = canRender && runId && (!existing.runId || existing.runId === "pending");
    return {
      canRender,
      action: canRender ? "existing" /* Existing */ : "block" /* Block */,
      updateRunId: shouldUpdateRunId ? runId : void 0
    };
  }
  const normalizedRunId = runId != null ? runId : "pending";
  const renderClaimedByOtherMessageEntry = Object.entries(claims).find(
    ([, claim]) => {
      var _a;
      return claim.stateRenderId === stateRenderId && ((_a = claim.runId) != null ? _a : "pending") === normalizedRunId && (0, import_shared9.dataToUUID)(getStateWithoutConstantKeys(claim.stateSnapshot)) === (0, import_shared9.dataToUUID)(getStateWithoutConstantKeys(stateSnapshot));
    }
  );
  const renderClaimedByOtherMessage = renderClaimedByOtherMessageEntry == null ? void 0 : renderClaimedByOtherMessageEntry[1];
  const claimedMessageId = renderClaimedByOtherMessageEntry == null ? void 0 : renderClaimedByOtherMessageEntry[0];
  if (renderClaimedByOtherMessage) {
    if (messageIndex !== void 0 && renderClaimedByOtherMessage.messageIndex !== void 0 && messageIndex > renderClaimedByOtherMessage.messageIndex) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId, messageIndex },
        lockOthers: runId === renderClaimedByOtherMessage.runId || isPlaceholderMessageId(claimedMessageId)
      };
    }
    if (runId && renderClaimedByOtherMessage.runId && runId !== renderClaimedByOtherMessage.runId) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId, messageIndex },
        lockOthers: isPlaceholderMessageId(claimedMessageId)
      };
    }
    if (isPlaceholderMessageId(claimedMessageId)) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId, messageIndex },
        lockOthers: true
      };
    }
    if (stateSnapshot && renderClaimedByOtherMessage.stateSnapshot && !areStatesEquals(renderClaimedByOtherMessage.stateSnapshot, stateSnapshot)) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId }
      };
    }
    return { canRender: false, action: "block" /* Block */ };
  }
  if (!runId) {
    return { canRender: false, action: "block" /* Block */ };
  }
  return {
    canRender: true,
    action: "create" /* Create */,
    nextClaim: { stateRenderId, runId, messageIndex }
  };
}
function selectSnapshot({
  messageId,
  messageName,
  allowLiveState,
  skipLatestCache,
  stateRenderId,
  effectiveRunId,
  stateSnapshotProp,
  agentState,
  agentMessages,
  existingClaim,
  caches
}) {
  var _a, _b, _c, _d, _e, _f;
  const lastAssistantId = agentMessages ? (_a = [...agentMessages].reverse().find((msg) => msg.role === "assistant")) == null ? void 0 : _a.id : void 0;
  const latestSnapshot = stateRenderId !== void 0 ? caches.byStateRenderAndRun[`${stateRenderId}::latest`] : void 0;
  const messageIndex = agentMessages ? agentMessages.findIndex((msg) => msg.id === messageId) : -1;
  const messageRole = messageIndex >= 0 && agentMessages ? (_b = agentMessages[messageIndex]) == null ? void 0 : _b.role : void 0;
  let previousUserMessageId;
  if (messageIndex > 0 && agentMessages) {
    for (let i = messageIndex - 1; i >= 0; i -= 1) {
      if (((_c = agentMessages[i]) == null ? void 0 : _c.role) === "user") {
        previousUserMessageId = (_d = agentMessages[i]) == null ? void 0 : _d.id;
        break;
      }
    }
  }
  const liveStateIsStale = stateSnapshotProp === void 0 && latestSnapshot !== void 0 && agentState !== void 0 && areStatesEquals(latestSnapshot, agentState);
  const shouldUseLiveState = (Boolean(allowLiveState) || !lastAssistantId || messageId === lastAssistantId) && !liveStateIsStale;
  const snapshot = stateSnapshotProp ? (0, import_shared9.parseJson)(stateSnapshotProp, stateSnapshotProp) : shouldUseLiveState ? agentState : void 0;
  const hasSnapshotKeys = !!(snapshot && Object.keys(snapshot).length > 0);
  const allowEmptySnapshot = snapshot !== void 0 && !hasSnapshotKeys && (stateSnapshotProp !== void 0 || shouldUseLiveState);
  const messageCacheEntry = caches.byMessageId[messageId];
  const cachedMessageSnapshot = readCachedMessageEntry(messageCacheEntry).snapshot;
  const cacheKey = stateRenderId !== void 0 ? `${stateRenderId}::${effectiveRunId}` : void 0;
  let cachedSnapshot = cachedMessageSnapshot != null ? cachedMessageSnapshot : caches.byMessageId[messageId];
  if (cachedSnapshot === void 0 && cacheKey && caches.byStateRenderAndRun[cacheKey] !== void 0) {
    cachedSnapshot = caches.byStateRenderAndRun[cacheKey];
  }
  if (cachedSnapshot === void 0 && stateRenderId && previousUserMessageId && caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`] !== void 0) {
    cachedSnapshot = caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`];
  }
  if (cachedSnapshot === void 0 && !skipLatestCache && stateRenderId && messageRole !== "assistant" && (stateSnapshotProp !== void 0 || agentState && Object.keys(agentState).length > 0)) {
    cachedSnapshot = caches.byStateRenderAndRun[`${stateRenderId}::latest`];
  }
  const snapshotForClaim = (existingClaim == null ? void 0 : existingClaim.locked) ? (_e = existingClaim.stateSnapshot) != null ? _e : cachedSnapshot : hasSnapshotKeys ? snapshot : (_f = existingClaim == null ? void 0 : existingClaim.stateSnapshot) != null ? _f : cachedSnapshot;
  return { snapshot, hasSnapshotKeys, cachedSnapshot, allowEmptySnapshot, snapshotForClaim };
}

// src/hooks/use-coagent-state-render-registry.ts
var import_react11 = require("react");
var LAST_SNAPSHOTS_BY_RENDER_AND_RUN = "__lastSnapshotsByStateRenderIdAndRun";
var LAST_SNAPSHOTS_BY_MESSAGE = "__lastSnapshotsByMessageId";
function getClaimsStore(claimsRef) {
  return claimsRef.current;
}
function getSnapshotCaches(claimsRef) {
  var _a, _b;
  const store = getClaimsStore(claimsRef);
  return {
    byStateRenderAndRun: (_a = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _a : {},
    byMessageId: (_b = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _b : {}
  };
}
function useStateRenderRegistry({
  agentId,
  stateRenderId,
  message,
  messageIndex,
  stateSnapshot,
  agentState,
  agentMessages,
  claimsRef
}) {
  var _a, _b, _c, _d, _e, _f;
  const store = getClaimsStore(claimsRef);
  const runId = message.runId;
  const cachedMessageEntry = (_a = store[LAST_SNAPSHOTS_BY_MESSAGE]) == null ? void 0 : _a[message.id];
  const { runId: cachedMessageRunId } = readCachedMessageEntry(cachedMessageEntry);
  const existingClaimRunId = (_b = claimsRef.current[message.id]) == null ? void 0 : _b.runId;
  const effectiveRunId = getEffectiveRunId({
    existingClaimRunId,
    cachedMessageRunId,
    runId
  });
  (0, import_react11.useEffect)(() => {
    return () => {
      var _a2, _b2, _c2, _d2;
      const existingClaim2 = claimsRef.current[message.id];
      if ((existingClaim2 == null ? void 0 : existingClaim2.stateSnapshot) && Object.keys(existingClaim2.stateSnapshot).length > 0) {
        const snapshotCache = __spreadValues({}, (_a2 = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _a2 : {});
        const cacheKey = `${existingClaim2.stateRenderId}::${(_b2 = existingClaim2.runId) != null ? _b2 : "pending"}`;
        snapshotCache[cacheKey] = existingClaim2.stateSnapshot;
        snapshotCache[`${existingClaim2.stateRenderId}::latest`] = existingClaim2.stateSnapshot;
        store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;
        const messageCache = __spreadValues({}, (_c2 = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _c2 : {});
        messageCache[message.id] = {
          snapshot: existingClaim2.stateSnapshot,
          runId: (_d2 = existingClaim2.runId) != null ? _d2 : effectiveRunId
        };
        store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;
      }
      delete claimsRef.current[message.id];
    };
  }, [claimsRef, effectiveRunId, message.id]);
  if (!stateRenderId) {
    return { canRender: false };
  }
  const caches = getSnapshotCaches(claimsRef);
  const existingClaim = claimsRef.current[message.id];
  const { snapshot, hasSnapshotKeys, allowEmptySnapshot, snapshotForClaim } = selectSnapshot({
    messageId: message.id,
    messageName: message.name,
    allowLiveState: isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),
    skipLatestCache: isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),
    stateRenderId,
    effectiveRunId,
    stateSnapshotProp: stateSnapshot,
    agentState,
    agentMessages,
    existingClaim,
    caches
  });
  const resolution = resolveClaim({
    claims: claimsRef.current,
    context: {
      agentId,
      messageId: message.id,
      stateRenderId,
      runId: effectiveRunId,
      messageIndex
    },
    stateSnapshot: snapshotForClaim
  });
  if (resolution.action === "block" /* Block */) {
    return { canRender: false };
  }
  if (resolution.updateRunId && claimsRef.current[message.id]) {
    claimsRef.current[message.id].runId = resolution.updateRunId;
  }
  if (resolution.nextClaim) {
    claimsRef.current[message.id] = resolution.nextClaim;
  }
  if (resolution.lockOthers) {
    Object.entries(claimsRef.current).forEach(([id, claim]) => {
      if (id !== message.id && claim.stateRenderId === stateRenderId) {
        claim.locked = true;
      }
    });
  }
  if (existingClaim && !existingClaim.locked && (agentMessages == null ? void 0 : agentMessages.length)) {
    const indexInAgentMessages = agentMessages.findIndex((msg) => msg.id === message.id);
    if (indexInAgentMessages >= 0 && indexInAgentMessages < agentMessages.length - 1) {
      existingClaim.locked = true;
    }
  }
  const existingSnapshot = claimsRef.current[message.id].stateSnapshot;
  const snapshotChanged = stateSnapshot && existingSnapshot !== void 0 && !areStatesEquals(existingSnapshot, snapshot);
  if (snapshot && (stateSnapshot || hasSnapshotKeys || allowEmptySnapshot) && (!claimsRef.current[message.id].locked || snapshotChanged)) {
    if (!claimsRef.current[message.id].locked || snapshotChanged) {
      claimsRef.current[message.id].stateSnapshot = snapshot;
      const snapshotCache = __spreadValues({}, (_c = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _c : {});
      const cacheKey = `${stateRenderId}::${effectiveRunId}`;
      snapshotCache[cacheKey] = snapshot;
      snapshotCache[`${stateRenderId}::latest`] = snapshot;
      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;
      const messageCache = __spreadValues({}, (_d = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _d : {});
      messageCache[message.id] = { snapshot, runId: effectiveRunId };
      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;
      if (stateSnapshot) {
        claimsRef.current[message.id].locked = true;
      }
    }
  } else if (snapshotForClaim) {
    const existingSnapshot2 = claimsRef.current[message.id].stateSnapshot;
    if (!existingSnapshot2) {
      claimsRef.current[message.id].stateSnapshot = snapshotForClaim;
      const snapshotCache = __spreadValues({}, (_e = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _e : {});
      const cacheKey = `${stateRenderId}::${effectiveRunId}`;
      snapshotCache[cacheKey] = snapshotForClaim;
      snapshotCache[`${stateRenderId}::latest`] = snapshotForClaim;
      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;
      const messageCache = __spreadValues({}, (_f = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _f : {});
      messageCache[message.id] = { snapshot: snapshotForClaim, runId: effectiveRunId };
      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;
    }
  }
  return { canRender: true };
}

// src/hooks/use-coagent-state-render-bridge.tsx
function useCoagentStateRenderBridge(agentId, props) {
  var _a;
  const { stateSnapshot, message } = props;
  const { coAgentStateRenders, claimsRef } = useCoAgentStateRenders();
  const { agent } = (0, import_react12.useAgent)({ agentId });
  const [nodeName, setNodeName] = (0, import_react13.useState)(void 0);
  const [, forceUpdate] = (0, import_react13.useState)(0);
  (0, import_react13.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = {
      onStateChanged: () => {
        forceUpdate((value) => value + 1);
      },
      onStepStartedEvent: ({ event }) => {
        if (event.stepName !== nodeName) {
          setNodeName(event.stepName);
        }
      },
      onStepFinishedEvent: ({ event }) => {
        if (event.stepName === nodeName) {
          setNodeName(void 0);
        }
      }
    };
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agentId, nodeName]);
  const getStateRender = (0, import_react13.useCallback)(
    (messageId) => {
      return Object.entries(coAgentStateRenders).find(([stateRenderId2, stateRender2]) => {
        if (claimsRef.current[messageId]) {
          return stateRenderId2 === claimsRef.current[messageId].stateRenderId;
        }
        const matchingAgentName = stateRender2.name === agentId;
        const matchesNodeContext = stateRender2.nodeName ? stateRender2.nodeName === nodeName : true;
        return matchingAgentName && matchesNodeContext;
      });
    },
    [coAgentStateRenders, nodeName, agentId]
  );
  const stateRenderEntry = (0, import_react13.useMemo)(() => getStateRender(message.id), [getStateRender, message.id]);
  const stateRenderId = stateRenderEntry == null ? void 0 : stateRenderEntry[0];
  const stateRender = stateRenderEntry == null ? void 0 : stateRenderEntry[1];
  const registryMessage = __spreadProps(__spreadValues({}, message), {
    runId: (_a = props.runId) != null ? _a : message.runId
  });
  const { canRender } = useStateRenderRegistry({
    agentId,
    stateRenderId,
    message: registryMessage,
    messageIndex: props.messageIndex,
    stateSnapshot,
    agentState: agent == null ? void 0 : agent.state,
    agentMessages: agent == null ? void 0 : agent.messages,
    claimsRef
  });
  return (0, import_react13.useMemo)(() => {
    var _a2, _b;
    if (!stateRender || !stateRenderId) {
      return null;
    }
    if (!canRender) {
      return null;
    }
    if (stateRender.handler) {
      stateRender.handler({
        state: stateSnapshot ? (0, import_shared10.parseJson)(stateSnapshot, stateSnapshot) : (_a2 = agent == null ? void 0 : agent.state) != null ? _a2 : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
    if (stateRender.render) {
      const status = (agent == null ? void 0 : agent.isRunning) ? "inProgress" /* InProgress */ : "complete" /* Complete */;
      if (typeof stateRender.render === "string")
        return stateRender.render;
      return stateRender.render({
        status,
        // Always use state from claim, to make sure the state does not seem "wiped" for a fraction of a second
        state: (_b = claimsRef.current[message.id].stateSnapshot) != null ? _b : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
  }, [
    stateRender,
    stateRenderId,
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.isRunning,
    nodeName,
    message.id,
    stateSnapshot,
    canRender
  ]);
}
function CoAgentStateRenderBridge(props) {
  return useCoagentStateRenderBridge(props.agentId, props);
}

// src/components/CopilotListeners.tsx
var import_react14 = require("react");
var import_react15 = require("@copilotkitnext/react");
var import_shared11 = require("@copilotkit/shared");
var import_shared12 = require("@copilotkit/shared");
var usePredictStateSubscription = (agent) => {
  const predictStateToolsRef = (0, import_react14.useRef)([]);
  const getSubscriber = (0, import_react14.useCallback)(
    (agent2) => ({
      onCustomEvent: ({ event }) => {
        if (event.name === "PredictState") {
          predictStateToolsRef.current = event.value;
        }
      },
      onToolCallArgsEvent: ({ partialToolCallArgs, toolCallName }) => {
        predictStateToolsRef.current.forEach((t) => {
          if ((t == null ? void 0 : t.tool) !== toolCallName)
            return;
          const emittedState = typeof partialToolCallArgs === "string" ? (0, import_shared11.parseJson)(partialToolCallArgs, partialToolCallArgs) : partialToolCallArgs;
          agent2.setState({
            [t.state_key]: emittedState[t.state_key]
          });
        });
      }
    }),
    []
  );
  (0, import_react14.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = getSubscriber(agent);
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agent, getSubscriber]);
};
function CopilotListeners() {
  const { copilotkit } = (0, import_react15.useCopilotKit)();
  const existingConfig = (0, import_react15.useCopilotChatConfiguration)();
  const resolvedAgentId = existingConfig == null ? void 0 : existingConfig.agentId;
  const { setBannerError } = useToast();
  const { agent } = (0, import_react15.useAgent)({ agentId: resolvedAgentId });
  usePredictStateSubscription(agent);
  (0, import_react14.useEffect)(() => {
    const subscriber = {
      onError: ({ error }) => {
        setBannerError(new import_shared12.CopilotKitLowLevelError({ error, message: error.message }));
      }
    };
    const subscription = copilotkit.subscribe(subscriber);
    return () => {
      subscription.unsubscribe();
    };
  }, [copilotkit == null ? void 0 : copilotkit.subscribe]);
  return null;
}

// src/components/copilot-provider/copilotkit.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
function CopilotKit(_a) {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const enabled = shouldShowDevConsole(props.showDevConsole);
  const showInspector = shouldShowDevConsole(props.enableInspector);
  const publicApiKey = props.publicApiKey || props.publicLicenseKey;
  const renderArr = (0, import_react16.useMemo)(() => [{ render: CoAgentStateRenderBridge }], []);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ToastProvider, { enabled, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CopilotErrorBoundary, { publicApiKey, showUsageBanner: enabled, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ThreadsProvider, { threadId: props.threadId, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    import_react17.CopilotKitProvider,
    __spreadProps(__spreadValues({}, props), {
      showDevConsole: showInspector,
      renderCustomMessages: renderArr,
      useSingleEndpoint: true,
      children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CopilotKitInternal, __spreadProps(__spreadValues({}, props), { children }))
    })
  ) }) }) });
}
function CopilotKitErrorBridge() {
  const { copilotkit } = (0, import_react17.useCopilotKit)();
  const { onError, copilotApiConfig } = useCopilotContext();
  (0, import_react16.useEffect)(() => {
    if (!copilotkit)
      return;
    const subscription = copilotkit.subscribe({
      onError: (event) => __async(this, null, function* () {
        const errorEvent = {
          type: "error",
          timestamp: Date.now(),
          context: __spreadValues({
            source: "agent",
            request: {
              operation: event.code || "unknown",
              url: copilotApiConfig == null ? void 0 : copilotApiConfig.chatApiEndpoint,
              startTime: Date.now()
            },
            technical: {
              environment: "browser",
              userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
              stackTrace: event.error.stack
            }
          }, event.context),
          error: event.error
        };
        try {
          yield onError(errorEvent);
        } catch (handlerError) {
          console.error("Error in onError handler:", handlerError);
        }
      })
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [copilotkit, onError, copilotApiConfig]);
  return null;
}
function CopilotKitInternal(cpkProps) {
  var _b;
  const _a = cpkProps, { children } = _a, props = __objRest(_a, ["children"]);
  validateProps(cpkProps);
  const publicApiKey = props.publicLicenseKey || props.publicApiKey;
  const chatApiEndpoint = props.runtimeUrl || import_shared13.COPILOT_CLOUD_CHAT_URL;
  const [actions, setActions] = (0, import_react16.useState)({});
  const [registeredActionConfigs, setRegisteredActionConfigs] = (0, import_react16.useState)(/* @__PURE__ */ new Map());
  const chatComponentsCache = (0, import_react16.useRef)({
    actions: {},
    coAgentStateRenders: {}
  });
  const { addElement, removeElement, printTree, getAllElements } = use_tree_default();
  const [isLoading, setIsLoading] = (0, import_react16.useState)(false);
  const [chatInstructions, setChatInstructions] = (0, import_react16.useState)("");
  const [authStates, setAuthStates] = (0, import_react16.useState)({});
  const [extensions, setExtensions] = (0, import_react16.useState)({});
  const [additionalInstructions, setAdditionalInstructions] = (0, import_react16.useState)([]);
  const {
    addElement: addDocument,
    removeElement: removeDocument,
    allElements: allDocuments
  } = use_flat_category_store_default();
  const setAction = (0, import_react16.useCallback)((id, action) => {
    setActions((prevPoints) => {
      return __spreadProps(__spreadValues({}, prevPoints), {
        [id]: action
      });
    });
  }, []);
  const removeAction = (0, import_react16.useCallback)((id) => {
    setActions((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const getContextString = (0, import_react16.useCallback)(
    (documents, categories) => {
      const documentsString = documents.map((document) => {
        return `${document.name} (${document.sourceApplication}):
${document.getContents()}`;
      }).join("\n\n");
      const nonDocumentStrings = printTree(categories);
      return `${documentsString}

${nonDocumentStrings}`;
    },
    [printTree]
  );
  const addContext = (0, import_react16.useCallback)(
    (context, parentId, categories = defaultCopilotContextCategories) => {
      return addElement(context, categories, parentId);
    },
    [addElement]
  );
  const removeContext = (0, import_react16.useCallback)(
    (id) => {
      removeElement(id);
    },
    [removeElement]
  );
  const getAllContext = (0, import_react16.useCallback)(() => {
    return getAllElements();
  }, [getAllElements]);
  const getFunctionCallHandler = (0, import_react16.useCallback)(
    (customEntryPoints) => {
      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));
    },
    [actions]
  );
  const getDocumentsContext = (0, import_react16.useCallback)(
    (categories) => {
      return allDocuments(categories);
    },
    [allDocuments]
  );
  const addDocumentContext = (0, import_react16.useCallback)(
    (documentPointer, categories = defaultCopilotContextCategories) => {
      return addDocument(documentPointer, categories);
    },
    [addDocument]
  );
  const removeDocumentContext = (0, import_react16.useCallback)(
    (documentId) => {
      removeDocument(documentId);
    },
    [removeDocument]
  );
  const copilotApiConfig = (0, import_react16.useMemo)(() => {
    var _a2, _b2;
    let cloud = void 0;
    if (publicApiKey) {
      cloud = {
        guardrails: {
          input: {
            restrictToTopic: {
              enabled: Boolean(props.guardrails_c),
              validTopics: ((_a2 = props.guardrails_c) == null ? void 0 : _a2.validTopics) || [],
              invalidTopics: ((_b2 = props.guardrails_c) == null ? void 0 : _b2.invalidTopics) || []
            }
          }
        }
      };
    }
    return __spreadProps(__spreadValues({
      publicApiKey
    }, cloud ? { cloud } : {}), {
      chatApiEndpoint,
      headers: props.headers || {},
      properties: props.properties || {},
      transcribeAudioUrl: props.transcribeAudioUrl,
      textToSpeechUrl: props.textToSpeechUrl,
      credentials: props.credentials
    });
  }, [
    publicApiKey,
    props.headers,
    props.properties,
    props.transcribeAudioUrl,
    props.textToSpeechUrl,
    props.credentials,
    props.cloudRestrictToTopic,
    props.guardrails_c
  ]);
  const headers = (0, import_react16.useMemo)(() => {
    const authHeaders = Object.values(authStates || {}).reduce((acc, state) => {
      if (state.status === "authenticated" && state.authHeaders) {
        return __spreadValues(__spreadValues({}, acc), Object.entries(state.authHeaders).reduce(
          (headers2, [key, value]) => __spreadProps(__spreadValues({}, headers2), {
            [key.startsWith("X-Custom-") ? key : `X-Custom-${key}`]: value
          }),
          {}
        ));
      }
      return acc;
    }, {});
    return __spreadValues(__spreadValues(__spreadValues({}, copilotApiConfig.headers || {}), copilotApiConfig.publicApiKey ? { [import_shared13.COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: copilotApiConfig.publicApiKey } : {}), authHeaders);
  }, [copilotApiConfig.headers, copilotApiConfig.publicApiKey, authStates]);
  const [internalErrorHandlers, _setInternalErrorHandler] = (0, import_react16.useState)({});
  const setInternalErrorHandler = (0, import_react16.useCallback)((handler) => {
    _setInternalErrorHandler((prev) => __spreadValues(__spreadValues({}, prev), handler));
  }, []);
  const removeInternalErrorHandler = (0, import_react16.useCallback)((key) => {
    _setInternalErrorHandler((prev) => {
      const _a2 = prev, { [key]: _removed } = _a2, rest = __objRest(_a2, [__restKey(key)]);
      return rest;
    });
  }, []);
  const onErrorRef = (0, import_react16.useRef)(props.onError);
  (0, import_react16.useEffect)(() => {
    onErrorRef.current = props.onError;
  }, [props.onError]);
  const internalHandlersRef = (0, import_react16.useRef)({});
  (0, import_react16.useEffect)(() => {
    internalHandlersRef.current = internalErrorHandlers;
  }, [internalErrorHandlers]);
  const handleErrors = (0, import_react16.useCallback)(
    (error) => __async(this, null, function* () {
      if (copilotApiConfig.publicApiKey && onErrorRef.current) {
        try {
          yield onErrorRef.current(error);
        } catch (e) {
          console.error("Error in public onError handler:", e);
        }
      }
      const handlers = Object.values(internalHandlersRef.current);
      yield Promise.all(
        handlers.map(
          (h) => Promise.resolve(h(error)).catch(
            (e) => console.error("Error in internal error handler:", e)
          )
        )
      );
    }),
    [copilotApiConfig.publicApiKey]
  );
  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = (0, import_react16.useState)({});
  const addChatSuggestionConfiguration = (0, import_react16.useCallback)(
    (id, suggestion) => {
      setChatSuggestionConfiguration((prev) => __spreadProps(__spreadValues({}, prev), { [id]: suggestion }));
    },
    [setChatSuggestionConfiguration]
  );
  const removeChatSuggestionConfiguration = (0, import_react16.useCallback)(
    (id) => {
      setChatSuggestionConfiguration((prev) => {
        const _a2 = prev, { [id]: _ } = _a2, rest = __objRest(_a2, [__restKey(id)]);
        return rest;
      });
    },
    [setChatSuggestionConfiguration]
  );
  const [availableAgents, setAvailableAgents] = (0, import_react16.useState)([]);
  const [coagentStates, setCoagentStates] = (0, import_react16.useState)({});
  const coagentStatesRef = (0, import_react16.useRef)({});
  const setCoagentStatesWithRef = (0, import_react16.useCallback)(
    (value) => {
      const newValue = typeof value === "function" ? value(coagentStatesRef.current) : value;
      coagentStatesRef.current = newValue;
      setCoagentStates((prev) => {
        return newValue;
      });
    },
    []
  );
  let initialAgentSession = null;
  if (props.agent) {
    initialAgentSession = {
      agentName: props.agent
    };
  }
  const [agentSession, setAgentSession] = (0, import_react16.useState)(initialAgentSession);
  (0, import_react16.useEffect)(() => {
    if (props.agent) {
      setAgentSession({
        agentName: props.agent
      });
    } else {
      setAgentSession(null);
    }
  }, [props.agent]);
  const { threadId, setThreadId: setInternalThreadId } = useThreads();
  const setThreadId = (0, import_react16.useCallback)(
    (value) => {
      if (props.threadId) {
        throw new Error("Cannot call setThreadId() when threadId is provided via props.");
      }
      setInternalThreadId(value);
    },
    [props.threadId]
  );
  const [runId, setRunId] = (0, import_react16.useState)(null);
  const chatAbortControllerRef = (0, import_react16.useRef)(null);
  const showDevConsole = shouldShowDevConsole(props.showDevConsole);
  const [interruptActions, _setInterruptActions] = (0, import_react16.useState)({});
  const setInterruptAction = (0, import_react16.useCallback)((action) => {
    _setInterruptActions((prev) => {
      var _a2;
      if (action == null || !action.id) {
        return prev;
      }
      return __spreadProps(__spreadValues({}, prev), {
        [action.id]: __spreadValues(__spreadValues({}, (_a2 = prev[action.id]) != null ? _a2 : {}), action)
      });
    });
  }, []);
  const removeInterruptAction = (0, import_react16.useCallback)((actionId) => {
    _setInterruptActions((prev) => {
      const _a2 = prev, { [actionId]: _ } = _a2, rest = __objRest(_a2, [__restKey(actionId)]);
      return rest;
    });
  }, []);
  const [interruptEventQueue, setInterruptEventQueue] = (0, import_react16.useState)({});
  const addInterruptEvent = (0, import_react16.useCallback)((queuedEvent) => {
    setInterruptEventQueue((prev) => {
      const threadQueue = prev[queuedEvent.threadId] || [];
      return __spreadProps(__spreadValues({}, prev), {
        [queuedEvent.threadId]: [...threadQueue, queuedEvent]
      });
    });
  }, []);
  const resolveInterruptEvent = (0, import_react16.useCallback)(
    (threadId2, eventId, response) => {
      setInterruptEventQueue((prev) => {
        const threadQueue = prev[threadId2] || [];
        return __spreadProps(__spreadValues({}, prev), {
          [threadId2]: threadQueue.map(
            (queuedEvent) => queuedEvent.eventId === eventId ? __spreadProps(__spreadValues({}, queuedEvent), { event: __spreadProps(__spreadValues({}, queuedEvent.event), { response }) }) : queuedEvent
          )
        });
      });
    },
    []
  );
  const memoizedChildren = (0, import_react16.useMemo)(() => children, [children]);
  const [bannerError, setBannerError] = (0, import_react16.useState)(null);
  const agentLock = (0, import_react16.useMemo)(() => {
    var _a2;
    return (_a2 = props.agent) != null ? _a2 : null;
  }, [props.agent]);
  const forwardedParameters = (0, import_react16.useMemo)(
    () => {
      var _a2;
      return (_a2 = props.forwardedParameters) != null ? _a2 : {};
    },
    [props.forwardedParameters]
  );
  const updateExtensions = (0, import_react16.useCallback)(
    (newExtensions) => {
      setExtensions((prev) => {
        const resolved = typeof newExtensions === "function" ? newExtensions(prev) : newExtensions;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value]) => prev[key] === value);
        return isEqual ? prev : resolved;
      });
    },
    [setExtensions]
  );
  const updateAuthStates = (0, import_react16.useCallback)(
    (newAuthStates) => {
      setAuthStates((prev) => {
        const resolved = typeof newAuthStates === "function" ? newAuthStates(prev) : newAuthStates;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value]) => prev[key] === value);
        return isEqual ? prev : resolved;
      });
    },
    [setAuthStates]
  );
  const handleSetRegisteredActions = (0, import_react16.useCallback)((actionConfig) => {
    const key = actionConfig.action.name || (0, import_shared13.randomUUID)();
    setRegisteredActionConfigs((prev) => {
      const newMap = new Map(prev);
      newMap.set(key, actionConfig);
      return newMap;
    });
    return key;
  }, []);
  const handleRemoveRegisteredAction = (0, import_react16.useCallback)((actionKey) => {
    setRegisteredActionConfigs((prev) => {
      const newMap = new Map(prev);
      newMap.delete(actionKey);
      return newMap;
    });
  }, []);
  const RegisteredActionsRenderer = (0, import_react16.useMemo)(() => {
    return () => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_jsx_runtime9.Fragment, { children: Array.from(registeredActionConfigs.entries()).map(([key, config]) => {
      const Component = config.component;
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Component, { action: config.action }, key);
    }) });
  }, [registeredActionConfigs]);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    import_react17.CopilotChatConfigurationProvider,
    {
      agentId: (_b = props.agent) != null ? _b : "default",
      threadId,
      children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
        CopilotContext.Provider,
        {
          value: {
            actions,
            chatComponentsCache,
            getFunctionCallHandler,
            setAction,
            removeAction,
            setRegisteredActions: handleSetRegisteredActions,
            removeRegisteredAction: handleRemoveRegisteredAction,
            getContextString,
            addContext,
            removeContext,
            getAllContext,
            getDocumentsContext,
            addDocumentContext,
            removeDocumentContext,
            copilotApiConfig,
            isLoading,
            setIsLoading,
            chatSuggestionConfiguration,
            addChatSuggestionConfiguration,
            removeChatSuggestionConfiguration,
            chatInstructions,
            setChatInstructions,
            additionalInstructions,
            setAdditionalInstructions,
            showDevConsole,
            coagentStates,
            setCoagentStates,
            coagentStatesRef,
            setCoagentStatesWithRef,
            agentSession,
            setAgentSession,
            forwardedParameters,
            agentLock,
            threadId,
            setThreadId,
            runId,
            setRunId,
            chatAbortControllerRef,
            availableAgents,
            authConfig_c: props.authConfig_c,
            authStates_c: authStates,
            setAuthStates_c: updateAuthStates,
            extensions,
            setExtensions: updateExtensions,
            interruptActions,
            setInterruptAction,
            removeInterruptAction,
            interruptEventQueue,
            addInterruptEvent,
            resolveInterruptEvent,
            bannerError,
            setBannerError,
            onError: handleErrors,
            internalErrorHandlers,
            setInternalErrorHandler,
            removeInternalErrorHandler
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CopilotListeners, {}),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CopilotKitErrorBridge, {}),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(CoAgentStateRendersProvider, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(MessagesTapProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(CopilotMessages, { children: [
                memoizedChildren,
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(RegisteredActionsRenderer, {})
              ] }) }),
              bannerError && showDevConsole && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                UsageBanner,
                {
                  severity: bannerError.severity,
                  message: bannerError.message,
                  onClose: () => setBannerError(null),
                  actions: getErrorActions(bannerError)
                }
              )
            ] })
          ]
        }
      )
    }
  );
}
var defaultCopilotContextCategories = ["global"];
function entryPointsToFunctionCallHandler(actions) {
  return (_0) => __async(this, [_0], function* ({ name, args }) {
    let actionsByFunctionName = {};
    for (let action2 of actions) {
      actionsByFunctionName[action2.name] = action2;
    }
    const action = actionsByFunctionName[name];
    let result = void 0;
    if (action) {
      yield new Promise((resolve, reject) => {
        (0, import_react_dom.flushSync)(() => __async(this, null, function* () {
          var _a;
          try {
            result = yield (_a = action.handler) == null ? void 0 : _a.call(action, args);
            resolve();
          } catch (error) {
            reject(error);
          }
        }));
      });
      yield new Promise((resolve) => setTimeout(resolve, 20));
    }
    return result;
  });
}
function formatFeatureName(featureName) {
  return featureName.replace(/_c$/, "").split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
}
function validateProps(props) {
  const cloudFeatures = Object.keys(props).filter((key) => key.endsWith("_c"));
  const hasApiKey = props.publicApiKey || props.publicLicenseKey;
  if (!props.runtimeUrl && !hasApiKey) {
    throw new import_shared13.ConfigurationError(
      "Missing required prop: 'runtimeUrl' or 'publicApiKey' or 'publicLicenseKey'"
    );
  }
  if (cloudFeatures.length > 0 && !hasApiKey) {
    throw new import_shared13.MissingPublicApiKeyError(
      `Missing required prop: 'publicApiKey' or 'publicLicenseKey' to use cloud features: ${cloudFeatures.map(formatFeatureName).join(", ")}`
    );
  }
}

// src/hooks/use-copilot-chat_internal.ts
var import_react24 = require("react");
var import_runtime_client_gql2 = require("@copilotkit/runtime-client-gql");

// src/hooks/use-langgraph-interrupt-render.ts
var import_react20 = __toESM(require("react"));
var import_runtime_client_gql = require("@copilotkit/runtime-client-gql");
var import_shared14 = require("@copilotkit/shared");

// src/hooks/use-agent-nodename.ts
var import_react18 = require("react");
var import_react19 = require("@copilotkitnext/react");
function useAgentNodeName(agentName) {
  const { agent } = (0, import_react19.useAgent)({ agentId: agentName });
  const nodeNameRef = (0, import_react18.useRef)("start");
  (0, import_react18.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = {
      onStepStartedEvent: ({ event }) => {
        nodeNameRef.current = event.stepName;
      },
      onRunStartedEvent: () => {
        nodeNameRef.current = "start";
      },
      onRunFinishedEvent: () => {
        nodeNameRef.current = "end";
      }
    };
    const subscription = agent.subscribe(subscriber);
    return () => {
      subscription.unsubscribe();
    };
  }, [agent]);
  return nodeNameRef.current;
}

// src/hooks/use-langgraph-interrupt-render.ts
var import_react21 = require("@copilotkitnext/react");
var InterruptRenderer = ({ event, result, render, resolve }) => {
  return render({ event, result, resolve });
};
function useLangGraphInterruptRender(agent) {
  var _a;
  const {
    interruptActions,
    agentSession,
    threadId,
    interruptEventQueue,
    addInterruptEvent,
    resolveInterruptEvent
  } = useCopilotContext();
  const existingConfig = (0, import_react21.useCopilotChatConfiguration)();
  const resolvedAgentId = (_a = existingConfig == null ? void 0 : existingConfig.agentId) != null ? _a : "default";
  const nodeName = useAgentNodeName(resolvedAgentId);
  (0, import_react20.useEffect)(() => {
    if (!agent)
      return;
    let localInterrupt = null;
    const subscriber = {
      onCustomEvent: ({ event }) => {
        if (event.name === "on_interrupt") {
          const eventData = {
            name: import_runtime_client_gql.MetaEventName.LangGraphInterruptEvent,
            type: event.type,
            value: (0, import_shared14.parseJson)(event.value, event.value)
          };
          const eventId = (0, import_shared14.dataToUUID)(eventData, "interruptEvents");
          localInterrupt = {
            eventId,
            threadId,
            event: eventData
          };
        }
      },
      onRunStartedEvent: () => {
        localInterrupt = null;
      },
      onRunFinalized: () => {
        if (localInterrupt) {
          addInterruptEvent(localInterrupt);
          localInterrupt = null;
        }
      }
    };
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agent, threadId]);
  const handleResolve = (0, import_react20.useCallback)(
    (eventId, response) => {
      agent == null ? void 0 : agent.runAgent({
        forwardedProps: {
          command: {
            resume: response
          }
        }
      });
      resolveInterruptEvent(threadId, eventId, response != null ? response : "");
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [agent, threadId]
  );
  return (0, import_react20.useMemo)(() => {
    const eventQueue = interruptEventQueue[threadId] || [];
    const currentQueuedEvent = eventQueue.find((qe) => !qe.event.response);
    if (!currentQueuedEvent || !agentSession)
      return null;
    const allActions = Object.values(interruptActions);
    const matchingAction = allActions.find((action) => {
      if (!action.enabled)
        return true;
      return action.enabled({
        eventValue: currentQueuedEvent.event.value,
        agentMetadata: __spreadProps(__spreadValues({}, agentSession), {
          nodeName
        })
      });
    });
    if (!matchingAction)
      return null;
    const { render, handler } = matchingAction;
    const resolveInterrupt = (response) => {
      handleResolve(currentQueuedEvent.eventId, response);
    };
    let result = null;
    if (handler) {
      result = handler({
        event: currentQueuedEvent.event,
        resolve: resolveInterrupt
      });
    }
    if (!render)
      return null;
    return import_react20.default.createElement(InterruptRenderer, {
      event: currentQueuedEvent.event,
      result,
      render,
      resolve: resolveInterrupt
    });
  }, [interruptActions, interruptEventQueue, threadId, agentSession, handleResolve]);
}

// src/hooks/use-copilot-chat_internal.ts
var import_react25 = require("@copilotkitnext/react");

// src/hooks/use-lazy-tool-renderer.tsx
var import_react22 = require("@copilotkitnext/react");
var import_react23 = require("react");
function useLazyToolRenderer() {
  const renderToolCall = (0, import_react22.useRenderToolCall)();
  return (0, import_react23.useCallback)(
    (message, messages) => {
      var _a;
      if (!((_a = message == null ? void 0 : message.toolCalls) == null ? void 0 : _a.length))
        return null;
      const toolCall = message.toolCalls[0];
      if (!toolCall)
        return null;
      const toolMessage = messages == null ? void 0 : messages.find(
        (m) => m.role === "tool" && m.toolCallId === toolCall.id
      );
      return () => renderToolCall({
        toolCall,
        toolMessage
      });
    },
    [renderToolCall]
  );
}

// src/hooks/use-copilot-chat_internal.ts
var import_client = require("@ag-ui/client");
function useCopilotChatInternal({
  suggestions,
  onInProgress,
  onSubmitMessage,
  onStopGeneration,
  onReloadMessages
} = {}) {
  var _a, _b, _c;
  const { copilotkit } = (0, import_react25.useCopilotKit)();
  const { threadId, agentSession } = useCopilotContext();
  const existingConfig = (0, import_react25.useCopilotChatConfiguration)();
  const [agentAvailable, setAgentAvailable] = (0, import_react24.useState)(false);
  const resolvedAgentId = (_a = existingConfig == null ? void 0 : existingConfig.agentId) != null ? _a : "default";
  const { agent } = (0, import_react25.useAgent)({ agentId: resolvedAgentId });
  (0, import_react24.useEffect)(() => {
    const connect = (agent2) => __async(this, null, function* () {
      setAgentAvailable(false);
      try {
        yield copilotkit.connectAgent({ agent: agent2 });
        setAgentAvailable(true);
      } catch (error) {
        if (error instanceof import_client.AGUIConnectNotImplementedError) {
        } else {
          console.error("CopilotChat: connectAgent failed", error);
        }
      }
    });
    if (agent && (existingConfig == null ? void 0 : existingConfig.threadId) && agent.threadId !== existingConfig.threadId) {
      agent.threadId = existingConfig.threadId;
      connect(agent);
    }
    return () => {
    };
  }, [existingConfig == null ? void 0 : existingConfig.threadId, agent, copilotkit, resolvedAgentId]);
  (0, import_react24.useEffect)(() => {
    onInProgress == null ? void 0 : onInProgress(Boolean(agent == null ? void 0 : agent.isRunning));
  }, [agent == null ? void 0 : agent.isRunning, onInProgress]);
  const interrupt = useLangGraphInterruptRender(agent);
  const reset = () => {
    agent == null ? void 0 : agent.setMessages([]);
    agent == null ? void 0 : agent.setState(null);
  };
  const deleteMessage = (0, import_react24.useCallback)(
    (messageId) => {
      var _a2;
      const filteredMessages = ((_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : []).filter(
        (message) => message.id !== messageId
      );
      agent == null ? void 0 : agent.setMessages(filteredMessages);
    },
    [agent == null ? void 0 : agent.setMessages, agent == null ? void 0 : agent.messages]
  );
  const latestDelete = useUpdatedRef(deleteMessage);
  const latestDeleteFunc = (0, import_react24.useCallback)(
    (messageId) => {
      return latestDelete.current(messageId);
    },
    [latestDelete]
  );
  const currentSuggestions = (0, import_react25.useSuggestions)({ agentId: resolvedAgentId });
  const reload = useAsyncCallback(
    (reloadMessageId) => __async(this, null, function* () {
      var _a2;
      const messages = (_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : [];
      const isLoading = false;
      if (isLoading || messages.length === 0) {
        return;
      }
      const reloadMessageIndex = messages.findIndex((msg) => msg.id === reloadMessageId);
      if (reloadMessageIndex === -1) {
        console.warn(`Message with id ${reloadMessageId} not found`);
        return;
      }
      const reloadMessageRole = messages[reloadMessageIndex].role;
      if (reloadMessageRole !== "assistant") {
        console.warn(`Regenerate cannot be performed on ${reloadMessageRole} role`);
        return;
      }
      let historyCutoff = [messages[0]];
      if (messages.length > 2 && reloadMessageIndex !== 0) {
        const lastUserMessageBeforeRegenerate = messages.slice(0, reloadMessageIndex).reverse().find((msg) => msg.role === "user");
        if (!lastUserMessageBeforeRegenerate) {
          historyCutoff = [messages[0]];
        } else {
          const indexOfLastUserMessageBeforeRegenerate = messages.findIndex(
            (msg) => msg.id === lastUserMessageBeforeRegenerate.id
          );
          historyCutoff = messages.slice(0, indexOfLastUserMessageBeforeRegenerate + 1);
        }
      } else if (messages.length > 2 && reloadMessageIndex === 0) {
        historyCutoff = [messages[0], messages[1]];
      }
      agent == null ? void 0 : agent.setMessages(historyCutoff);
      if (agent) {
        try {
          yield copilotkit.runAgent({ agent });
        } catch (error) {
          console.error("CopilotChat: runAgent failed during reload", error);
        }
      }
      return;
    }),
    [agent == null ? void 0 : agent.setMessages, copilotkit == null ? void 0 : copilotkit.runAgent]
  );
  const latestSendMessageFunc = useAsyncCallback(
    (message, options) => __async(this, null, function* () {
      var _a2;
      if (!agent)
        return;
      const followUp = (_a2 = options == null ? void 0 : options.followUp) != null ? _a2 : true;
      if (options == null ? void 0 : options.clearSuggestions) {
        copilotkit.clearSuggestions(resolvedAgentId);
      }
      if (onSubmitMessage) {
        const content = typeof message.content === "string" ? message.content : message.content && "text" in message.content ? message.content.text : message.content && "filename" in message.content ? message.content.filename : "";
        try {
          yield onSubmitMessage(content);
        } catch (error) {
          console.error("Error in onSubmitMessage:", error);
        }
      }
      agent == null ? void 0 : agent.addMessage(message);
      if (followUp) {
        try {
          yield copilotkit.runAgent({ agent });
        } catch (error) {
          console.error("CopilotChat: runAgent failed", error);
        }
      }
    }),
    [agent, copilotkit, resolvedAgentId, onSubmitMessage]
  );
  const latestAppendFunc = useAsyncCallback(
    (message, options) => __async(this, null, function* () {
      return latestSendMessageFunc((0, import_runtime_client_gql2.gqlToAGUI)([message])[0], options);
    }),
    [latestSendMessageFunc]
  );
  const latestSetMessagesFunc = (0, import_react24.useCallback)(
    (messages) => {
      var _a2, _b2;
      if (messages.every((message) => message instanceof import_runtime_client_gql2.Message)) {
        return (_a2 = agent == null ? void 0 : agent.setMessages) == null ? void 0 : _a2.call(agent, (0, import_runtime_client_gql2.gqlToAGUI)(messages));
      }
      return (_b2 = agent == null ? void 0 : agent.setMessages) == null ? void 0 : _b2.call(agent, messages);
    },
    [agent == null ? void 0 : agent.setMessages, agent]
  );
  const latestReload = useUpdatedRef(reload);
  const latestReloadFunc = useAsyncCallback(
    (messageId) => __async(this, null, function* () {
      var _a2;
      onReloadMessages == null ? void 0 : onReloadMessages({
        messageId,
        currentAgentName: agent == null ? void 0 : agent.agentId,
        messages: (_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : []
      });
      return yield latestReload.current(messageId);
    }),
    [latestReload, agent, onReloadMessages]
  );
  const latestStopFunc = (0, import_react24.useCallback)(() => {
    var _a2, _b2;
    onStopGeneration == null ? void 0 : onStopGeneration({
      currentAgentName: agent == null ? void 0 : agent.agentId,
      messages: (_a2 = agent == null ? void 0 : agent.messages) != null ? _a2 : []
    });
    return (_b2 = agent == null ? void 0 : agent.abortRun) == null ? void 0 : _b2.call(agent);
  }, [onStopGeneration, agent]);
  const latestReset = useUpdatedRef(reset);
  const latestResetFunc = (0, import_react24.useCallback)(() => {
    return latestReset.current();
  }, [latestReset]);
  const lazyToolRendered = useLazyToolRenderer();
  const renderCustomMessage = (0, import_react25.useRenderCustomMessages)();
  const legacyCustomMessageRenderer = useLegacyCoagentRenderer({
    copilotkit,
    agent,
    agentId: resolvedAgentId,
    threadId: (_b = existingConfig == null ? void 0 : existingConfig.threadId) != null ? _b : threadId
  });
  const allMessages = (_c = agent == null ? void 0 : agent.messages) != null ? _c : [];
  const resolvedMessages = (0, import_react24.useMemo)(() => {
    var _a2, _b2;
    let processedMessages = allMessages.map((message) => {
      if (message.role !== "assistant") {
        return message;
      }
      const lazyRendered = lazyToolRendered(message, allMessages);
      if (lazyRendered) {
        const renderedGenUi = lazyRendered();
        if (renderedGenUi) {
          return __spreadProps(__spreadValues({}, message), { generativeUI: () => renderedGenUi });
        }
      }
      const bridgeRenderer = legacyCustomMessageRenderer || renderCustomMessage ? () => {
        var _a3;
        if (legacyCustomMessageRenderer) {
          return legacyCustomMessageRenderer({ message, position: "before" });
        }
        try {
          return (_a3 = renderCustomMessage == null ? void 0 : renderCustomMessage({ message, position: "before" })) != null ? _a3 : null;
        } catch (error) {
          console.warn(
            "[CopilotKit] renderCustomMessages failed, falling back to legacy renderer",
            error
          );
          return null;
        }
      } : null;
      if (bridgeRenderer) {
        return __spreadProps(__spreadValues({}, message), {
          generativeUI: bridgeRenderer,
          generativeUIPosition: "before"
        });
      }
      return message;
    });
    const hasAssistantMessages = processedMessages.some((msg) => msg.role === "assistant");
    const canUseCustomRenderer = Boolean(
      renderCustomMessage && ((_a2 = copilotkit == null ? void 0 : copilotkit.getAgent) == null ? void 0 : _a2.call(copilotkit, resolvedAgentId))
    );
    const placeholderRenderer = legacyCustomMessageRenderer ? legacyCustomMessageRenderer : canUseCustomRenderer ? renderCustomMessage : null;
    const shouldRenderPlaceholder = Boolean(agent == null ? void 0 : agent.isRunning) || Boolean((agent == null ? void 0 : agent.state) && Object.keys(agent.state).length);
    const effectiveThreadId = (_b2 = threadId != null ? threadId : agent == null ? void 0 : agent.threadId) != null ? _b2 : "default";
    let latestUserIndex = -1;
    for (let i = processedMessages.length - 1; i >= 0; i -= 1) {
      if (processedMessages[i].role === "user") {
        latestUserIndex = i;
        break;
      }
    }
    const latestUserMessageId = latestUserIndex >= 0 ? processedMessages[latestUserIndex].id : void 0;
    const currentRunId = latestUserMessageId ? copilotkit.getRunIdForMessage(resolvedAgentId, effectiveThreadId, latestUserMessageId) || `pending:${latestUserMessageId}` : void 0;
    const hasAssistantForCurrentRun = latestUserIndex >= 0 ? processedMessages.slice(latestUserIndex + 1).some((msg) => msg.role === "assistant") : hasAssistantMessages;
    if (placeholderRenderer && shouldRenderPlaceholder && !hasAssistantForCurrentRun) {
      const placeholderId = currentRunId ? `coagent-state-render-${resolvedAgentId}-${currentRunId}` : `coagent-state-render-${resolvedAgentId}`;
      const placeholderMessage = {
        id: placeholderId,
        role: "assistant",
        content: "",
        name: "coagent-state-render",
        runId: currentRunId
      };
      processedMessages = [
        ...processedMessages,
        __spreadProps(__spreadValues({}, placeholderMessage), {
          generativeUIPosition: "before",
          generativeUI: () => placeholderRenderer({
            message: placeholderMessage,
            position: "before"
          })
        })
      ];
    }
    return processedMessages;
  }, [
    agent == null ? void 0 : agent.messages,
    lazyToolRendered,
    allMessages,
    renderCustomMessage,
    legacyCustomMessageRenderer,
    resolvedAgentId,
    copilotkit,
    agent == null ? void 0 : agent.isRunning,
    agent == null ? void 0 : agent.state
  ]);
  const renderedSuggestions = (0, import_react24.useMemo)(() => {
    if (Array.isArray(suggestions)) {
      return {
        suggestions: suggestions.map((s) => __spreadProps(__spreadValues({}, s), { isLoading: false })),
        isLoading: false
      };
    }
    return currentSuggestions;
  }, [suggestions, currentSuggestions]);
  return {
    messages: resolvedMessages,
    sendMessage: latestSendMessageFunc,
    appendMessage: latestAppendFunc,
    setMessages: latestSetMessagesFunc,
    reloadMessages: latestReloadFunc,
    stopGeneration: latestStopFunc,
    reset: latestResetFunc,
    deleteMessage: latestDeleteFunc,
    isAvailable: agentAvailable,
    isLoading: Boolean(agent == null ? void 0 : agent.isRunning),
    // mcpServers,
    // setMcpServers,
    suggestions: renderedSuggestions.suggestions,
    setSuggestions: (suggestions2) => copilotkit.addSuggestionsConfig({ suggestions: suggestions2 }),
    generateSuggestions: () => __async(this, null, function* () {
      return copilotkit.reloadSuggestions(resolvedAgentId);
    }),
    resetSuggestions: () => copilotkit.clearSuggestions(resolvedAgentId),
    isLoadingSuggestions: renderedSuggestions.isLoading,
    interrupt,
    agent,
    threadId
  };
}
function useUpdatedRef(value) {
  const ref = (0, import_react24.useRef)(value);
  (0, import_react24.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref;
}
function useLegacyCoagentRenderer({
  copilotkit,
  agent,
  agentId,
  threadId
}) {
  return (0, import_react24.useMemo)(() => {
    if (!copilotkit || !agent) {
      return null;
    }
    return ({ message, position }) => {
      var _a;
      const effectiveThreadId = (_a = threadId != null ? threadId : agent.threadId) != null ? _a : "default";
      const providedRunId = message.runId;
      const existingRunId = providedRunId ? providedRunId : copilotkit.getRunIdForMessage(agentId, effectiveThreadId, message.id);
      const runId = existingRunId || `pending:${message.id}`;
      const messageIndex = Math.max(
        agent.messages.findIndex((msg) => msg.id === message.id),
        0
      );
      const bridgeProps = {
        message,
        position,
        runId,
        messageIndex,
        messageIndexInRun: 0,
        numberOfMessagesInRun: 1,
        agentId,
        stateSnapshot: message.state
      };
      return (0, import_react24.createElement)(CoAgentStateRenderBridge, bridgeProps);
    };
  }, [agent, agentId, copilotkit, threadId]);
}

// src/hooks/use-copilot-chat.ts
function useCopilotChat(options = {}) {
  const {
    visibleMessages,
    appendMessage,
    reloadMessages,
    stopGeneration,
    reset,
    isLoading,
    isAvailable,
    runChatCompletion,
    mcpServers,
    setMcpServers
  } = useCopilotChatInternal(options);
  return {
    visibleMessages,
    appendMessage,
    reloadMessages,
    stopGeneration,
    reset,
    isLoading,
    isAvailable,
    runChatCompletion,
    mcpServers,
    setMcpServers
  };
}

// src/hooks/use-copilot-chat-headless_c.ts
var import_react26 = require("react");
var import_shared15 = require("@copilotkit/shared");
var createNonFunctionalReturn = () => ({
  visibleMessages: [],
  messages: [],
  sendMessage: () => __async(void 0, null, function* () {
  }),
  appendMessage: () => __async(void 0, null, function* () {
  }),
  setMessages: () => {
  },
  deleteMessage: () => {
  },
  reloadMessages: () => __async(void 0, null, function* () {
  }),
  stopGeneration: () => {
  },
  reset: () => {
  },
  isLoading: false,
  isAvailable: false,
  runChatCompletion: () => __async(void 0, null, function* () {
    return [];
  }),
  mcpServers: [],
  setMcpServers: () => {
  },
  suggestions: [],
  setSuggestions: () => {
  },
  generateSuggestions: () => __async(void 0, null, function* () {
  }),
  resetSuggestions: () => {
  },
  isLoadingSuggestions: false,
  interrupt: null
});
function useCopilotChatHeadless_c(options = {}) {
  const { copilotApiConfig, setBannerError } = useCopilotContext();
  const hasPublicApiKey = Boolean(copilotApiConfig.publicApiKey);
  const internalResult = useCopilotChatInternal(options);
  (0, import_react26.useEffect)(() => {
    if (!hasPublicApiKey) {
      setBannerError(
        new import_shared15.CopilotKitError({
          message: (
            // add link to documentation here
            "You're using useCopilotChatHeadless_c, a premium-only feature, which offers extensive headless chat capabilities. To continue, you'll need to provide a free public license key."
          ),
          code: import_shared15.CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR,
          severity: import_shared15.Severity.WARNING,
          visibility: import_shared15.ErrorVisibility.BANNER
        })
      );
      import_shared15.styledConsole.logCopilotKitPlatformMessage();
    } else {
      setBannerError(null);
    }
  }, [hasPublicApiKey]);
  if (hasPublicApiKey) {
    return internalResult;
  }
  return createNonFunctionalReturn();
}

// src/hooks/use-copilot-action.ts
var import_react33 = require("react");

// src/hooks/use-frontend-tool.ts
var import_react27 = __toESM(require("react"));
var import_shared16 = require("@copilotkit/shared");
var import_shared17 = require("@copilotkit/shared");
var import_react28 = require("@copilotkitnext/react");
function useFrontendTool(tool, dependencies) {
  const { name, description, parameters, render, followUp } = tool;
  const zodParameters = (0, import_shared16.getZodParameters)(parameters);
  const renderRef = (0, import_react27.useRef)(render);
  (0, import_react27.useEffect)(() => {
    renderRef.current = render;
  }, [render, ...dependencies != null ? dependencies : []]);
  const normalizedRender = (0, import_react27.useMemo)(() => {
    if (typeof render === "undefined") {
      return void 0;
    }
    return (args) => {
      const currentRender = renderRef.current;
      if (typeof currentRender === "undefined") {
        return null;
      }
      if (typeof currentRender === "string") {
        return import_react27.default.createElement(import_react27.default.Fragment, null, currentRender);
      }
      const renderArgs = __spreadProps(__spreadValues({}, args), {
        result: typeof args.result === "string" ? (0, import_shared17.parseJson)(args.result, args.result) : args.result
      });
      const rendered = currentRender(renderArgs);
      if (typeof rendered === "string") {
        return import_react27.default.createElement(import_react27.default.Fragment, null, rendered);
      }
      return rendered != null ? rendered : null;
    };
  }, []);
  const handlerRef = (0, import_react27.useRef)(tool.handler);
  (0, import_react27.useEffect)(() => {
    handlerRef.current = tool.handler;
  }, [tool.handler, ...dependencies != null ? dependencies : []]);
  const normalizedHandler = tool.handler ? (args) => {
    var _a;
    return (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, args);
  } : void 0;
  (0, import_react28.useFrontendTool)({
    name,
    description,
    parameters: zodParameters,
    handler: normalizedHandler,
    followUp,
    render: normalizedRender
  });
}

// src/hooks/use-render-tool-call.ts
var import_shared18 = require("@copilotkit/shared");
var import_react29 = require("react");
var import_react30 = require("@copilotkitnext/react");
var import_shared19 = require("@copilotkit/shared");
function useRenderToolCall2(tool, dependencies) {
  const { copilotkit } = (0, import_react30.useCopilotKit)();
  const hasAddedRef = (0, import_react29.useRef)(false);
  (0, import_react29.useEffect)(() => {
    const { name, parameters, render } = tool;
    const zodParameters = (0, import_shared18.getZodParameters)(parameters);
    const renderToolCall = name === "*" ? (0, import_react30.defineToolCallRenderer)({
      name: "*",
      render: (args) => {
        return render(__spreadProps(__spreadValues({}, args), {
          result: args.result ? (0, import_shared19.parseJson)(args.result, args.result) : args.result
        }));
      }
    }) : (0, import_react30.defineToolCallRenderer)({
      name,
      args: zodParameters,
      render: (args) => {
        return render(__spreadProps(__spreadValues({}, args), {
          result: args.result ? (0, import_shared19.parseJson)(args.result, args.result) : args.result
        }));
      }
    });
    const existingIndex = copilotkit.renderToolCalls.findIndex((r) => r.name === name);
    if (existingIndex !== -1) {
      copilotkit.renderToolCalls.splice(existingIndex, 1);
    }
    copilotkit.renderToolCalls.push(renderToolCall);
    hasAddedRef.current = true;
    return () => {
      if (hasAddedRef.current) {
        const index = copilotkit.renderToolCalls.findIndex((r) => r.name === name);
        if (index !== -1) {
          copilotkit.renderToolCalls.splice(index, 1);
        }
        hasAddedRef.current = false;
      }
    };
  }, [tool, ...dependencies != null ? dependencies : []]);
}

// src/hooks/use-human-in-the-loop.ts
var import_shared20 = require("@copilotkit/shared");
var import_react31 = require("@copilotkitnext/react");
var import_core = require("@copilotkitnext/core");
var import_react32 = __toESM(require("react"));
function useHumanInTheLoop(tool, dependencies) {
  const _a = tool, { render } = _a, toolRest = __objRest(_a, ["render"]);
  const { name, description, parameters, followUp } = toolRest;
  const zodParameters = (0, import_shared20.getZodParameters)(parameters);
  const renderRef = (0, import_react32.useRef)(null);
  (0, import_react32.useEffect)(() => {
    renderRef.current = (args) => {
      if (typeof render === "string") {
        return import_react32.default.createElement(import_react32.default.Fragment, null, render);
      }
      if (!render) {
        return null;
      }
      const renderProps = (() => {
        const mappedArgs = args.args;
        switch (args.status) {
          case import_core.ToolCallStatus.InProgress:
            return {
              args: mappedArgs,
              respond: args.respond,
              status: args.status,
              handler: void 0
            };
          case import_core.ToolCallStatus.Executing:
            return {
              args: mappedArgs,
              respond: args.respond,
              status: args.status,
              handler: () => {
              }
            };
          case import_core.ToolCallStatus.Complete:
            return {
              args: mappedArgs,
              respond: args.respond,
              status: args.status,
              result: args.result ? (0, import_shared20.parseJson)(args.result, args.result) : args.result,
              handler: void 0
            };
          default:
            throw new import_shared20.CopilotKitError({
              code: import_shared20.CopilotKitErrorCode.UNKNOWN,
              message: `Invalid tool call status: ${args.status}`
            });
        }
      })();
      const rendered = render(renderProps);
      if (typeof rendered === "string") {
        return import_react32.default.createElement(import_react32.default.Fragment, null, rendered);
      }
      return rendered != null ? rendered : null;
    };
  }, [render, ...dependencies != null ? dependencies : []]);
  (0, import_react31.useHumanInTheLoop)({
    name,
    description,
    followUp,
    parameters: zodParameters,
    render: (args) => {
      var _a2, _b;
      return (_b = (_a2 = renderRef.current) == null ? void 0 : _a2.call(renderRef, args)) != null ? _b : null;
    }
  });
}

// src/hooks/use-copilot-action.ts
function getActionConfig(action) {
  if (action.name === "*") {
    return {
      type: "render",
      action
    };
  }
  if ("renderAndWaitForResponse" in action || "renderAndWait" in action) {
    let render = action.render;
    if (!render && "renderAndWaitForResponse" in action) {
      render = action.renderAndWaitForResponse;
    }
    if (!render && "renderAndWait" in action) {
      render = action.renderAndWait;
    }
    return {
      type: "hitl",
      action: __spreadProps(__spreadValues({}, action), { render })
    };
  }
  if ("available" in action) {
    if (action.available === "enabled" || action.available === "remote") {
      return {
        type: "frontend",
        action
      };
    }
    if (action.available === "frontend" || action.available === "disabled") {
      return {
        type: "render",
        action
      };
    }
  }
  if ("handler" in action) {
    return {
      type: "frontend",
      action
    };
  }
  throw new Error("Invalid action configuration");
}
function useCopilotAction(action, dependencies) {
  const [initialActionConfig] = (0, import_react33.useState)(getActionConfig(action));
  const currentActionConfig = getActionConfig(action);
  if (initialActionConfig.type !== currentActionConfig.type) {
    throw new Error("Action configuration changed between renders");
  }
  switch (currentActionConfig.type) {
    case "render":
      return useRenderToolCall2(currentActionConfig.action, dependencies);
    case "hitl":
      return useHumanInTheLoop(currentActionConfig.action, dependencies);
    case "frontend":
      return useFrontendTool(currentActionConfig.action, dependencies);
    default:
      throw new Error("Invalid action configuration");
  }
}

// src/hooks/use-coagent-state-render.ts
var import_react34 = require("react");
var import_shared21 = require("@copilotkit/shared");
function useCoAgentStateRender(action, dependencies) {
  const { chatComponentsCache, availableAgents } = (0, import_react34.useContext)(CopilotContext);
  const { setCoAgentStateRender, removeCoAgentStateRender, coAgentStateRenders } = useCoAgentStateRenders();
  const idRef = (0, import_react34.useRef)((0, import_shared21.randomId)());
  const { setBannerError, addToast } = useToast();
  (0, import_react34.useEffect)(() => {
    if ((availableAgents == null ? void 0 : availableAgents.length) && !availableAgents.some((a) => a.name === action.name)) {
      const message = `(useCoAgentStateRender): Agent "${action.name}" not found. Make sure the agent exists and is properly configured.`;
      const agentError = new import_shared21.CopilotKitAgentDiscoveryError({
        agentName: action.name,
        availableAgents: availableAgents.map((a) => ({ name: a.name, id: a.id }))
      });
      setBannerError(agentError);
    }
  }, [availableAgents]);
  const key = `${action.name}-${action.nodeName || "global"}`;
  if (dependencies === void 0) {
    if (coAgentStateRenders[idRef.current]) {
      coAgentStateRenders[idRef.current].handler = action.handler;
      if (typeof action.render === "function") {
        if (chatComponentsCache.current !== null) {
          chatComponentsCache.current.coAgentStateRenders[key] = action.render;
        }
      }
    }
  }
  (0, import_react34.useEffect)(() => {
    const currentId = idRef.current;
    const hasDuplicate = Object.entries(coAgentStateRenders).some(([id, otherAction]) => {
      if (id === currentId)
        return false;
      if (otherAction.name !== action.name)
        return false;
      const hasNodeName = !!action.nodeName;
      const hasOtherNodeName = !!otherAction.nodeName;
      if (!hasNodeName && !hasOtherNodeName)
        return true;
      if (hasNodeName !== hasOtherNodeName)
        return false;
      return action.nodeName === otherAction.nodeName;
    });
    if (hasDuplicate) {
      const message = action.nodeName ? `Found multiple state renders for agent ${action.name} and node ${action.nodeName}. State renders might get overridden` : `Found multiple state renders for agent ${action.name}. State renders might get overridden`;
      addToast({
        type: "warning",
        message,
        id: `dup-action-${action.name}`
      });
    }
  }, [coAgentStateRenders]);
  (0, import_react34.useEffect)(() => {
    setCoAgentStateRender(idRef.current, action);
    if (chatComponentsCache.current !== null && action.render !== void 0) {
      chatComponentsCache.current.coAgentStateRenders[key] = action.render;
    }
    return () => {
      removeCoAgentStateRender(idRef.current);
    };
  }, [
    setCoAgentStateRender,
    removeCoAgentStateRender,
    action.name,
    // include render only if it's a string
    typeof action.render === "string" ? action.render : void 0,
    // dependencies set by the developer
    ...dependencies || []
  ]);
}

// src/hooks/use-make-copilot-document-readable.ts
var import_react35 = require("react");
function useMakeCopilotDocumentReadable(document, categories, dependencies = []) {
  const { addDocumentContext, removeDocumentContext } = useCopilotContext();
  const idRef = (0, import_react35.useRef)(void 0);
  (0, import_react35.useEffect)(() => {
    const id = addDocumentContext(document, categories);
    idRef.current = id;
    return () => {
      removeDocumentContext(id);
    };
  }, [addDocumentContext, removeDocumentContext, ...dependencies]);
  return idRef.current;
}

// src/hooks/use-copilot-readable.ts
var import_react36 = require("@copilotkitnext/react");
var import_react37 = require("react");
function useCopilotReadable({ description, value, convert, available }, dependencies) {
  const { copilotkit } = (0, import_react36.useCopilotKit)();
  const ctxIdRef = (0, import_react37.useRef)(void 0);
  (0, import_react37.useEffect)(() => {
    if (!copilotkit)
      return;
    const found = Object.entries(copilotkit.context).find(([id, ctxItem]) => {
      return JSON.stringify({ description, value }) == JSON.stringify(ctxItem);
    });
    if (found) {
      ctxIdRef.current = found[0];
      if (available === "disabled")
        copilotkit.removeContext(ctxIdRef.current);
      return;
    }
    if (!found && available === "disabled")
      return;
    ctxIdRef.current = copilotkit.addContext({
      description,
      value: (convert != null ? convert : JSON.stringify)(value)
    });
    return () => {
      if (!ctxIdRef.current)
        return;
      copilotkit.removeContext(ctxIdRef.current);
    };
  }, [description, value, convert]);
  return ctxIdRef.current;
}

// src/hooks/use-coagent.ts
var import_react38 = require("react");
var import_react39 = require("@copilotkitnext/react");
function useCoAgent(options) {
  const { agent } = (0, import_react39.useAgent)({ agentId: options.name });
  const { copilotkit } = (0, import_react39.useCopilotKit)();
  const nodeName = useAgentNodeName(options.name);
  const handleStateUpdate = (0, import_react38.useCallback)(
    (newState) => {
      if (!agent)
        return;
      if (typeof newState === "function") {
        const updater = newState;
        agent.setState(updater(agent.state));
      } else {
        agent.setState(__spreadValues(__spreadValues({}, agent.state), newState));
      }
    },
    [agent == null ? void 0 : agent.state, agent == null ? void 0 : agent.setState]
  );
  (0, import_react38.useEffect)(() => {
    var _a;
    if (!options.config && !options.configurable)
      return;
    let config = (_a = options.config) != null ? _a : {};
    if (options.configurable) {
      config = __spreadProps(__spreadValues({}, config), {
        configurable: __spreadValues(__spreadValues({}, options.configurable), config.configurable)
      });
    }
    copilotkit.setProperties(config);
  }, [options.config, options.configurable]);
  const externalStateStr = (0, import_react38.useMemo)(
    () => isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0,
    [isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0]
  );
  (0, import_react38.useEffect)(() => {
    if ((agent == null ? void 0 : agent.state) && isExternalStateManagement(options) && JSON.stringify(options.state) !== JSON.stringify(agent.state)) {
      handleStateUpdate(options.state);
    }
  }, [agent, externalStateStr, handleStateUpdate]);
  const hasStateValues = (0, import_react38.useCallback)((value) => {
    return Boolean(value && Object.keys(value).length);
  }, []);
  const initialStateRef = (0, import_react38.useRef)(
    isExternalStateManagement(options) ? options.state : "initialState" in options ? options.initialState : void 0
  );
  (0, import_react38.useEffect)(() => {
    if (isExternalStateManagement(options)) {
      initialStateRef.current = options.state;
    } else if ("initialState" in options) {
      initialStateRef.current = options.initialState;
    }
  }, [
    isExternalStateManagement(options) ? JSON.stringify(options.state) : "initialState" in options ? JSON.stringify(options.initialState) : void 0
  ]);
  (0, import_react38.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = {
      onStateChanged: (args) => {
        if (isExternalStateManagement(options)) {
          options.setState(args.state);
        }
      },
      onRunInitialized: (args) => {
        const runHasState = hasStateValues(args.state);
        if (runHasState) {
          handleStateUpdate(args.state);
          return;
        }
        if (hasStateValues(agent.state)) {
          return;
        }
        if (initialStateRef.current !== void 0) {
          handleStateUpdate(initialStateRef.current);
        }
      }
    };
    const subscription = agent.subscribe(subscriber);
    return () => {
      subscription.unsubscribe();
    };
  }, [agent, handleStateUpdate, hasStateValues]);
  return (0, import_react38.useMemo)(() => {
    var _a, _b, _c;
    if (!agent) {
      const noop = () => {
      };
      const noopAsync = () => __async(this, null, function* () {
      });
      const initialState = (
        // prefer externally provided state if available
        (_b = (_a = "state" in options && options.state) != null ? _a : (
          // then initialState if provided
          "initialState" in options && options.initialState
        )) != null ? _b : {}
      );
      return {
        name: options.name,
        nodeName,
        threadId: void 0,
        running: false,
        state: initialState,
        setState: noop,
        start: noop,
        stop: noop,
        run: noopAsync
      };
    }
    return {
      name: (_c = agent == null ? void 0 : agent.agentId) != null ? _c : options.name,
      nodeName,
      threadId: agent.threadId,
      running: agent.isRunning,
      state: agent.state,
      setState: handleStateUpdate,
      // TODO: start and run both have same thing. need to figure out
      start: agent.runAgent,
      stop: agent.abortRun,
      run: agent.runAgent
    };
  }, [
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.runAgent,
    agent == null ? void 0 : agent.abortRun,
    agent == null ? void 0 : agent.runAgent,
    agent == null ? void 0 : agent.threadId,
    agent == null ? void 0 : agent.isRunning,
    agent == null ? void 0 : agent.agentId,
    handleStateUpdate,
    options.name
  ]);
}
var isExternalStateManagement = (options) => {
  return "state" in options && "setState" in options;
};

// src/hooks/use-copilot-runtime-client.ts
var import_runtime_client_gql3 = require("@copilotkit/runtime-client-gql");
var import_react40 = require("react");
var import_shared22 = require("@copilotkit/shared");
var useCopilotRuntimeClient = (options) => {
  const { setBannerError } = useToast();
  const _a = options, { showDevConsole, onError } = _a, runtimeOptions = __objRest(_a, ["showDevConsole", "onError"]);
  const lastStructuredErrorRef = (0, import_react40.useRef)(null);
  const traceUIError = (error, originalError) => __async(void 0, null, function* () {
    try {
      const errorEvent = {
        type: "error",
        timestamp: Date.now(),
        context: {
          source: "ui",
          request: {
            operation: "runtimeClient",
            url: runtimeOptions.url,
            startTime: Date.now()
          },
          technical: {
            environment: "browser",
            userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
            stackTrace: originalError instanceof Error ? originalError.stack : void 0
          }
        },
        error
      };
      yield onError(errorEvent);
    } catch (error2) {
      console.error("Error in onError handler:", error2);
    }
  });
  const runtimeClient = (0, import_react40.useMemo)(() => {
    return new import_runtime_client_gql3.CopilotRuntimeClient(__spreadProps(__spreadValues({}, runtimeOptions), {
      handleGQLErrors: (error) => {
        var _a2;
        if ((_a2 = error.graphQLErrors) == null ? void 0 : _a2.length) {
          const graphQLErrors = error.graphQLErrors;
          const routeError = (gqlError) => {
            const extensions = gqlError.extensions;
            const visibility = extensions == null ? void 0 : extensions.visibility;
            if (visibility === import_shared22.ErrorVisibility.SILENT) {
              console.error("CopilotKit Silent Error:", gqlError.message);
              return;
            }
            const now = Date.now();
            const errorMessage = gqlError.message;
            if (lastStructuredErrorRef.current && lastStructuredErrorRef.current.message === errorMessage && now - lastStructuredErrorRef.current.timestamp < 150) {
              return;
            }
            lastStructuredErrorRef.current = { message: errorMessage, timestamp: now };
            const ckError = createStructuredError(gqlError);
            if (ckError) {
              setBannerError(ckError);
              traceUIError(ckError, gqlError);
            } else {
              const fallbackError = new import_shared22.CopilotKitError({
                message: gqlError.message,
                code: import_shared22.CopilotKitErrorCode.UNKNOWN
              });
              setBannerError(fallbackError);
              traceUIError(fallbackError, gqlError);
            }
          };
          graphQLErrors.forEach(routeError);
        } else {
          const fallbackError = new import_shared22.CopilotKitError({
            message: (error == null ? void 0 : error.message) || String(error),
            code: import_shared22.CopilotKitErrorCode.UNKNOWN
          });
          setBannerError(fallbackError);
          traceUIError(fallbackError, error);
        }
      },
      handleGQLWarning: (message) => {
        console.warn(message);
        const warningError = new import_shared22.CopilotKitError({
          message,
          code: import_shared22.CopilotKitErrorCode.UNKNOWN
        });
        setBannerError(warningError);
      }
    }));
  }, [runtimeOptions, setBannerError, onError]);
  return runtimeClient;
};
function createStructuredError(gqlError) {
  var _a, _b, _c;
  const extensions = gqlError.extensions;
  const originalError = extensions == null ? void 0 : extensions.originalError;
  const message = (originalError == null ? void 0 : originalError.message) || gqlError.message;
  const code = extensions == null ? void 0 : extensions.code;
  if (code) {
    return new import_shared22.CopilotKitError({ message, code });
  }
  if ((_a = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _a.includes("CopilotApiDiscoveryError")) {
    return new import_shared22.CopilotKitApiDiscoveryError({ message });
  }
  if ((_b = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _b.includes("CopilotKitRemoteEndpointDiscoveryError")) {
    return new import_shared22.CopilotKitRemoteEndpointDiscoveryError({ message });
  }
  if ((_c = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _c.includes("CopilotKitAgentDiscoveryError")) {
    return new import_shared22.CopilotKitAgentDiscoveryError({
      agentName: "",
      availableAgents: []
    });
  }
  return null;
}

// src/hooks/use-copilot-authenticated-action.ts
var import_react41 = require("react");
var import_react42 = __toESM(require("react"));
function useCopilotAuthenticatedAction_c(action, dependencies) {
  const { authConfig_c, authStates_c, setAuthStates_c } = useCopilotContext();
  const pendingActionRef = (0, import_react41.useRef)(null);
  const executeAction = (0, import_react41.useCallback)(
    (props) => {
      if (typeof action.render === "function") {
        return action.render(props);
      }
      return action.render || import_react42.default.createElement(import_react41.Fragment);
    },
    [action]
  );
  const wrappedRender = (0, import_react41.useCallback)(
    (props) => {
      const isAuthenticated = Object.values(authStates_c || {}).some(
        (state) => state.status === "authenticated"
      );
      if (!isAuthenticated) {
        pendingActionRef.current = props;
        return (authConfig_c == null ? void 0 : authConfig_c.SignInComponent) ? import_react42.default.createElement(authConfig_c.SignInComponent, {
          onSignInComplete: (authState) => {
            setAuthStates_c == null ? void 0 : setAuthStates_c((prev) => __spreadProps(__spreadValues({}, prev), { [action.name]: authState }));
            if (pendingActionRef.current) {
              executeAction(pendingActionRef.current);
              pendingActionRef.current = null;
            }
          }
        }) : import_react42.default.createElement(import_react41.Fragment);
      }
      return executeAction(props);
    },
    [action, authStates_c, setAuthStates_c]
  );
  useCopilotAction(
    __spreadProps(__spreadValues({}, action), {
      render: wrappedRender
    }),
    dependencies
  );
}

// src/hooks/use-langgraph-interrupt.ts
var import_react43 = require("react");
var import_shared23 = require("@copilotkit/shared");
function useLangGraphInterrupt(action, dependencies) {
  const { setInterruptAction, removeInterruptAction, interruptActions, threadId } = (0, import_react43.useContext)(CopilotContext);
  const { addToast } = useToast();
  const actionId = (0, import_shared23.dataToUUID)(action, "lgAction");
  (0, import_react43.useEffect)(() => {
    if (!action)
      return;
    setInterruptAction(__spreadProps(__spreadValues({}, action), { id: actionId }));
    return () => {
      removeInterruptAction(actionId);
    };
  }, [setInterruptAction, removeInterruptAction, threadId, actionId, ...dependencies || []]);
}

// src/hooks/use-copilot-additional-instructions.ts
var import_react44 = require("react");
function useCopilotAdditionalInstructions({ instructions, available = "enabled" }, dependencies) {
  const { setAdditionalInstructions } = useCopilotContext();
  (0, import_react44.useEffect)(() => {
    if (available === "disabled")
      return;
    setAdditionalInstructions((prevInstructions) => [...prevInstructions || [], instructions]);
    return () => {
      setAdditionalInstructions(
        (prevInstructions) => (prevInstructions == null ? void 0 : prevInstructions.filter((instruction) => instruction !== instructions)) || []
      );
    };
  }, [available, instructions, setAdditionalInstructions, ...dependencies || []]);
}

// src/hooks/use-default-tool.ts
function useDefaultTool(tool, dependencies) {
  useCopilotAction(__spreadProps(__spreadValues({}, tool), { name: "*" }), dependencies);
}

// src/hooks/use-copilot-chat-suggestions.tsx
var import_react45 = require("@copilotkitnext/react");
function useCopilotChatSuggestions(config, dependencies = []) {
  var _a, _b;
  const existingConfig = (0, import_react45.useCopilotChatConfiguration)();
  const resolvedAgentId = (_a = existingConfig == null ? void 0 : existingConfig.agentId) != null ? _a : "default";
  const available = (_b = config.available === "enabled" ? "always" : config.available) != null ? _b : "before-first-message";
  const finalSuggestionConfig = __spreadProps(__spreadValues({}, config), {
    available,
    consumerAgentId: resolvedAgentId
    // Use chatConfig.agentId here
  });
  (0, import_react45.useConfigureSuggestions)(finalSuggestionConfig, dependencies);
}

// src/lib/copilot-task.ts
var import_runtime_client_gql5 = require("@copilotkit/runtime-client-gql");

// src/types/frontend-action.ts
var import_runtime_client_gql4 = require("@copilotkit/runtime-client-gql");
var import_shared24 = require("@copilotkit/shared");
function processActionsForRuntimeRequest(actions) {
  const filteredActions = actions.filter(
    (action) => action.available !== import_runtime_client_gql4.ActionInputAvailability.Disabled && action.disabled !== true && action.name !== "*" && action.available != "frontend" && !action.pairedAction
  ).map((action) => {
    let available = import_runtime_client_gql4.ActionInputAvailability.Enabled;
    if (action.disabled) {
      available = import_runtime_client_gql4.ActionInputAvailability.Disabled;
    } else if (action.available === "disabled") {
      available = import_runtime_client_gql4.ActionInputAvailability.Disabled;
    } else if (action.available === "remote") {
      available = import_runtime_client_gql4.ActionInputAvailability.Remote;
    }
    return {
      name: action.name,
      description: action.description || "",
      jsonSchema: JSON.stringify((0, import_shared24.actionParametersToJsonSchema)(action.parameters || [])),
      available
    };
  });
  return filteredActions;
}

// src/lib/copilot-task.ts
var CopilotTask = class {
  constructor(config) {
    this.instructions = config.instructions;
    this.actions = config.actions || [];
    this.includeCopilotReadable = config.includeCopilotReadable !== false;
    this.includeCopilotActions = config.includeCopilotActions !== false;
    this.forwardedParameters = config.forwardedParameters;
  }
  /**
   * Run the task.
   * @param context The CopilotContext to use for the task. Use `useCopilotContext` to obtain the current context.
   * @param data The data to use for the task.
   */
  run(context, data) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const actions = this.includeCopilotActions ? Object.assign({}, context.actions) : {};
      for (const fn of this.actions) {
        actions[fn.name] = fn;
      }
      let contextString = "";
      if (data) {
        contextString = (typeof data === "string" ? data : JSON.stringify(data)) + "\n\n";
      }
      if (this.includeCopilotReadable) {
        contextString += context.getContextString([], defaultCopilotContextCategories);
      }
      const systemMessage = new import_runtime_client_gql5.TextMessage({
        content: taskSystemMessage(contextString, this.instructions),
        role: import_runtime_client_gql5.Role.System
      });
      const messages = [systemMessage];
      const runtimeClient = new import_runtime_client_gql5.CopilotRuntimeClient({
        url: context.copilotApiConfig.chatApiEndpoint,
        publicApiKey: context.copilotApiConfig.publicApiKey,
        headers: context.copilotApiConfig.headers,
        credentials: context.copilotApiConfig.credentials
      });
      const response = yield runtimeClient.generateCopilotResponse({
        data: {
          frontend: {
            actions: processActionsForRuntimeRequest(Object.values(actions)),
            url: window.location.href
          },
          messages: (0, import_runtime_client_gql5.convertMessagesToGqlInput)((0, import_runtime_client_gql5.filterAgentStateMessages)(messages)),
          metadata: {
            requestType: import_runtime_client_gql5.CopilotRequestType.Task
          },
          forwardedParameters: __spreadValues({
            // if forwardedParameters is provided, use it
            toolChoice: "required"
          }, (_a = this.forwardedParameters) != null ? _a : {})
        },
        properties: context.copilotApiConfig.properties
      }).toPromise();
      const functionCallHandler = context.getFunctionCallHandler(actions);
      const functionCalls = (0, import_runtime_client_gql5.convertGqlOutputToMessages)(
        ((_c = (_b = response.data) == null ? void 0 : _b.generateCopilotResponse) == null ? void 0 : _c.messages) || []
      ).filter((m) => m.isActionExecutionMessage());
      for (const functionCall of functionCalls) {
        yield functionCallHandler({
          messages,
          name: functionCall.name,
          args: functionCall.arguments
        });
      }
    });
  }
};
function taskSystemMessage(contextString, instructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf.

Please assist them as best you can.

This is not a conversation, so please do not ask questions. Just call a function without saying anything else.

The user has given you the following task to complete:

\`\`\`
${instructions}
\`\`\`
`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CoAgentStateRendersContext,
  CoAgentStateRendersProvider,
  CopilotContext,
  CopilotKit,
  CopilotMessagesContext,
  CopilotTask,
  SUGGESTION_RETRY_CONFIG,
  ThreadsContext,
  ThreadsProvider,
  defaultCopilotContextCategories,
  shouldShowDevConsole,
  useCoAgent,
  useCoAgentStateRender,
  useCoAgentStateRenders,
  useCopilotAction,
  useCopilotAdditionalInstructions,
  useCopilotAuthenticatedAction_c,
  useCopilotChat,
  useCopilotChatHeadless_c,
  useCopilotChatInternal,
  useCopilotChatSuggestions,
  useCopilotContext,
  useCopilotMessagesContext,
  useCopilotReadable,
  useCopilotRuntimeClient,
  useDefaultTool,
  useFrontendTool,
  useHumanInTheLoop,
  useLangGraphInterrupt,
  useLangGraphInterruptRender,
  useLazyToolRenderer,
  useMakeCopilotDocumentReadable,
  useRenderToolCall,
  useThreads
});
//# sourceMappingURL=index.js.map