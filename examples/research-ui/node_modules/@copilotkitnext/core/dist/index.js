"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AgentRegistry: () => AgentRegistry,
  ContextStore: () => ContextStore,
  CopilotKitCore: () => CopilotKitCore,
  CopilotKitCoreErrorCode: () => CopilotKitCoreErrorCode,
  CopilotKitCoreRuntimeConnectionStatus: () => CopilotKitCoreRuntimeConnectionStatus,
  ProxiedCopilotRuntimeAgent: () => ProxiedCopilotRuntimeAgent,
  RunHandler: () => RunHandler,
  StateManager: () => StateManager,
  SuggestionEngine: () => SuggestionEngine,
  ToolCallStatus: () => ToolCallStatus,
  completePartialMarkdown: () => completePartialMarkdown
});
module.exports = __toCommonJS(index_exports);

// src/core/agent-registry.ts
var import_client2 = require("@ag-ui/client");
var import_shared = require("@copilotkitnext/shared");

// src/agent.ts
var import_client = require("@ag-ui/client");
var ProxiedCopilotRuntimeAgent = class extends import_client.HttpAgent {
  runtimeUrl;
  credentials;
  transport;
  singleEndpointUrl;
  constructor(config) {
    const normalizedRuntimeUrl = config.runtimeUrl ? config.runtimeUrl.replace(/\/$/, "") : void 0;
    const transport = config.transport ?? "rest";
    const runUrl = transport === "single" ? normalizedRuntimeUrl ?? config.runtimeUrl ?? "" : `${normalizedRuntimeUrl ?? config.runtimeUrl}/agent/${encodeURIComponent(config.agentId ?? "")}/run`;
    if (!runUrl) {
      throw new Error("ProxiedCopilotRuntimeAgent requires a runtimeUrl when transport is set to 'single'.");
    }
    super({
      ...config,
      url: runUrl
    });
    this.runtimeUrl = normalizedRuntimeUrl ?? config.runtimeUrl;
    this.credentials = config.credentials;
    this.transport = transport;
    if (this.transport === "single") {
      this.singleEndpointUrl = this.runtimeUrl;
    }
  }
  abortRun() {
    if (!this.agentId || !this.threadId) {
      return;
    }
    if (typeof fetch === "undefined") {
      return;
    }
    if (this.transport === "single") {
      if (!this.singleEndpointUrl) {
        return;
      }
      const headers = new Headers({ ...this.headers, "Content-Type": "application/json" });
      void fetch(this.singleEndpointUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          method: "agent/stop",
          params: {
            agentId: this.agentId,
            threadId: this.threadId
          }
        }),
        ...this.credentials ? { credentials: this.credentials } : {}
      }).catch((error) => {
        console.error("ProxiedCopilotRuntimeAgent: stop request failed", error);
      });
      return;
    }
    if (!this.runtimeUrl) {
      return;
    }
    const stopPath = `${this.runtimeUrl}/agent/${encodeURIComponent(this.agentId)}/stop/${encodeURIComponent(this.threadId)}`;
    const origin = typeof window !== "undefined" && window.location ? window.location.origin : "http://localhost";
    const base = new URL(this.runtimeUrl, origin);
    const stopUrl = new URL(stopPath, base);
    void fetch(stopUrl.toString(), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...this.headers
      },
      ...this.credentials ? { credentials: this.credentials } : {}
    }).catch((error) => {
      console.error("ProxiedCopilotRuntimeAgent: stop request failed", error);
    });
  }
  connect(input) {
    if (this.transport === "single") {
      if (!this.singleEndpointUrl) {
        throw new Error("Single endpoint transport requires a runtimeUrl");
      }
      const requestInit = this.createSingleRouteRequestInit(input, "agent/connect", {
        agentId: this.agentId
      });
      const httpEvents2 = (0, import_client.runHttpRequest)(this.singleEndpointUrl, requestInit);
      return (0, import_client.transformHttpEventStream)(httpEvents2);
    }
    const httpEvents = (0, import_client.runHttpRequest)(`${this.runtimeUrl}/agent/${this.agentId}/connect`, this.requestInit(input));
    return (0, import_client.transformHttpEventStream)(httpEvents);
  }
  run(input) {
    if (this.transport === "single") {
      if (!this.singleEndpointUrl) {
        throw new Error("Single endpoint transport requires a runtimeUrl");
      }
      const requestInit = this.createSingleRouteRequestInit(input, "agent/run", {
        agentId: this.agentId
      });
      const httpEvents = (0, import_client.runHttpRequest)(this.singleEndpointUrl, requestInit);
      return (0, import_client.transformHttpEventStream)(httpEvents);
    }
    return super.run(input);
  }
  clone() {
    const cloned = super.clone();
    cloned.runtimeUrl = this.runtimeUrl;
    cloned.credentials = this.credentials;
    cloned.transport = this.transport;
    cloned.singleEndpointUrl = this.singleEndpointUrl;
    return cloned;
  }
  createSingleRouteRequestInit(input, method, params) {
    if (!this.agentId) {
      throw new Error("ProxiedCopilotRuntimeAgent requires agentId to make runtime requests");
    }
    const baseInit = super.requestInit(input);
    const headers = new Headers(baseInit.headers ?? {});
    headers.set("Content-Type", "application/json");
    headers.set("Accept", headers.get("Accept") ?? "text/event-stream");
    let originalBody = void 0;
    if (typeof baseInit.body === "string") {
      try {
        originalBody = JSON.parse(baseInit.body);
      } catch (error) {
        console.warn("ProxiedCopilotRuntimeAgent: failed to parse request body for single route transport", error);
        originalBody = void 0;
      }
    }
    const envelope = {
      method
    };
    if (params && Object.keys(params).length > 0) {
      envelope.params = params;
    }
    if (originalBody !== void 0) {
      envelope.body = originalBody;
    }
    return {
      ...baseInit,
      headers,
      body: JSON.stringify(envelope),
      ...this.credentials ? { credentials: this.credentials } : {}
    };
  }
};

// src/core/agent-registry.ts
var AgentRegistry = class {
  constructor(core) {
    this.core = core;
  }
  _agents = {};
  localAgents = {};
  remoteAgents = {};
  _runtimeUrl;
  _runtimeVersion;
  _runtimeConnectionStatus = "disconnected" /* Disconnected */;
  _runtimeTransport = "rest";
  _audioFileTranscriptionEnabled = false;
  /**
   * Get all agents as a readonly record
   */
  get agents() {
    return this._agents;
  }
  get runtimeUrl() {
    return this._runtimeUrl;
  }
  get runtimeVersion() {
    return this._runtimeVersion;
  }
  get runtimeConnectionStatus() {
    return this._runtimeConnectionStatus;
  }
  get runtimeTransport() {
    return this._runtimeTransport;
  }
  get audioFileTranscriptionEnabled() {
    return this._audioFileTranscriptionEnabled;
  }
  /**
   * Initialize agents from configuration
   */
  initialize(agents) {
    this.localAgents = this.assignAgentIds(agents);
    this.applyHeadersToAgents(this.localAgents);
    this._agents = this.localAgents;
  }
  /**
   * Set the runtime URL and update connection
   */
  setRuntimeUrl(runtimeUrl) {
    const normalizedRuntimeUrl = runtimeUrl ? runtimeUrl.replace(/\/$/, "") : void 0;
    if (this._runtimeUrl === normalizedRuntimeUrl) {
      return;
    }
    this._runtimeUrl = normalizedRuntimeUrl;
    void this.updateRuntimeConnection();
  }
  setRuntimeTransport(runtimeTransport) {
    if (this._runtimeTransport === runtimeTransport) {
      return;
    }
    this._runtimeTransport = runtimeTransport;
    void this.updateRuntimeConnection();
  }
  /**
   * Set all agents at once (for development use)
   */
  setAgents__unsafe_dev_only(agents) {
    Object.entries(agents).forEach(([id, agent]) => {
      if (agent) {
        this.validateAndAssignAgentId(id, agent);
      }
    });
    this.localAgents = agents;
    this._agents = { ...this.localAgents, ...this.remoteAgents };
    this.applyHeadersToAgents(this._agents);
    void this.notifyAgentsChanged();
  }
  /**
   * Add a single agent (for development use)
   */
  addAgent__unsafe_dev_only({ id, agent }) {
    this.validateAndAssignAgentId(id, agent);
    this.localAgents[id] = agent;
    this.applyHeadersToAgent(agent);
    this._agents = { ...this.localAgents, ...this.remoteAgents };
    void this.notifyAgentsChanged();
  }
  /**
   * Remove an agent by ID (for development use)
   */
  removeAgent__unsafe_dev_only(id) {
    delete this.localAgents[id];
    this._agents = { ...this.localAgents, ...this.remoteAgents };
    void this.notifyAgentsChanged();
  }
  /**
   * Get an agent by ID
   */
  getAgent(id) {
    if (id in this._agents) {
      return this._agents[id];
    }
    if (this.runtimeUrl !== void 0 && (this.runtimeConnectionStatus === "disconnected" /* Disconnected */ || this.runtimeConnectionStatus === "connecting" /* Connecting */)) {
      return void 0;
    }
    console.warn(`Agent ${id} not found`);
    return void 0;
  }
  /**
   * Apply current headers to an agent
   */
  applyHeadersToAgent(agent) {
    if (agent instanceof import_client2.HttpAgent) {
      agent.headers = { ...this.core.headers };
    }
  }
  /**
   * Apply current headers to all agents
   */
  applyHeadersToAgents(agents) {
    Object.values(agents).forEach((agent) => {
      this.applyHeadersToAgent(agent);
    });
  }
  /**
   * Apply current credentials to an agent
   */
  applyCredentialsToAgent(agent) {
    if (agent instanceof ProxiedCopilotRuntimeAgent) {
      agent.credentials = this.core.credentials;
    }
  }
  /**
   * Apply current credentials to all agents
   */
  applyCredentialsToAgents(agents) {
    Object.values(agents).forEach((agent) => {
      this.applyCredentialsToAgent(agent);
    });
  }
  /**
   * Update runtime connection and fetch remote agents
   */
  async updateRuntimeConnection() {
    if (typeof window === "undefined") {
      return;
    }
    if (!this.runtimeUrl) {
      this._runtimeConnectionStatus = "disconnected" /* Disconnected */;
      this._runtimeVersion = void 0;
      this._audioFileTranscriptionEnabled = false;
      this.remoteAgents = {};
      this._agents = this.localAgents;
      await this.notifyRuntimeStatusChanged("disconnected" /* Disconnected */);
      await this.notifyAgentsChanged();
      return;
    }
    this._runtimeConnectionStatus = "connecting" /* Connecting */;
    await this.notifyRuntimeStatusChanged("connecting" /* Connecting */);
    try {
      const runtimeInfoResponse = await this.fetchRuntimeInfo();
      const {
        version,
        ...runtimeInfo
      } = runtimeInfoResponse;
      const credentials = this.core.credentials;
      const agents = Object.fromEntries(
        Object.entries(runtimeInfo.agents).map(([id, { description }]) => {
          const agent = new ProxiedCopilotRuntimeAgent({
            runtimeUrl: this.runtimeUrl,
            agentId: id,
            // Runtime agents always have their ID set correctly
            description,
            transport: this._runtimeTransport,
            credentials
          });
          this.applyHeadersToAgent(agent);
          return [id, agent];
        })
      );
      this.remoteAgents = agents;
      this._agents = { ...this.localAgents, ...this.remoteAgents };
      this._runtimeConnectionStatus = "connected" /* Connected */;
      this._runtimeVersion = version;
      this._audioFileTranscriptionEnabled = runtimeInfoResponse.audioFileTranscriptionEnabled ?? false;
      await this.notifyRuntimeStatusChanged("connected" /* Connected */);
      await this.notifyAgentsChanged();
    } catch (error) {
      this._runtimeConnectionStatus = "error" /* Error */;
      this._runtimeVersion = void 0;
      this._audioFileTranscriptionEnabled = false;
      this.remoteAgents = {};
      this._agents = this.localAgents;
      await this.notifyRuntimeStatusChanged("error" /* Error */);
      await this.notifyAgentsChanged();
      const message = error instanceof Error ? error.message : JSON.stringify(error);
      import_shared.logger.warn(`Failed to load runtime info (${this.runtimeUrl}/info): ${message}`);
      const runtimeError = error instanceof Error ? error : new Error(String(error));
      await this.core.emitError({
        error: runtimeError,
        code: "runtime_info_fetch_failed" /* RUNTIME_INFO_FETCH_FAILED */,
        context: {
          runtimeUrl: this.runtimeUrl
        }
      });
    }
  }
  async fetchRuntimeInfo() {
    if (!this.runtimeUrl) {
      throw new Error("Runtime URL is not set");
    }
    const baseHeaders = this.core.headers;
    const credentials = this.core.credentials;
    const headers = {
      ...baseHeaders
    };
    if (this._runtimeTransport === "single") {
      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "application/json";
      }
      const response2 = await fetch(this.runtimeUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({ method: "info" }),
        ...credentials ? { credentials } : {}
      });
      if ("ok" in response2 && !response2.ok) {
        throw new Error(`Runtime info request failed with status ${response2.status}`);
      }
      return await response2.json();
    }
    const response = await fetch(`${this.runtimeUrl}/info`, {
      headers,
      ...credentials ? { credentials } : {}
    });
    if ("ok" in response && !response.ok) {
      throw new Error(`Runtime info request failed with status ${response.status}`);
    }
    return await response.json();
  }
  /**
   * Assign agent IDs to a record of agents
   */
  assignAgentIds(agents) {
    Object.entries(agents).forEach(([id, agent]) => {
      if (agent) {
        this.validateAndAssignAgentId(id, agent);
      }
    });
    return agents;
  }
  /**
   * Validate and assign an agent ID
   */
  validateAndAssignAgentId(registrationId, agent) {
    if (agent.agentId && agent.agentId !== registrationId) {
      throw new Error(
        `Agent registration mismatch: Agent with ID "${agent.agentId}" cannot be registered under key "${registrationId}". The agent ID must match the registration key or be undefined.`
      );
    }
    if (!agent.agentId) {
      agent.agentId = registrationId;
    }
  }
  /**
   * Notify subscribers of runtime status changes
   */
  async notifyRuntimeStatusChanged(status) {
    await this.core.notifySubscribers(
      (subscriber) => subscriber.onRuntimeConnectionStatusChanged?.({
        copilotkit: this.core,
        status
      }),
      "Error in CopilotKitCore subscriber (onRuntimeConnectionStatusChanged):"
    );
  }
  /**
   * Notify subscribers of agent changes
   */
  async notifyAgentsChanged() {
    await this.core.notifySubscribers(
      (subscriber) => subscriber.onAgentsChanged?.({
        copilotkit: this.core,
        agents: this._agents
      }),
      "Subscriber onAgentsChanged error:"
    );
  }
};

// src/core/context-store.ts
var import_shared2 = require("@copilotkitnext/shared");
var ContextStore = class {
  constructor(core) {
    this.core = core;
  }
  _context = {};
  /**
   * Get all context entries as a readonly record
   */
  get context() {
    return this._context;
  }
  /**
   * Add a new context entry
   * @returns The ID of the created context entry
   */
  addContext({ description, value }) {
    const id = (0, import_shared2.randomUUID)();
    this._context[id] = { description, value };
    void this.notifySubscribers();
    return id;
  }
  /**
   * Remove a context entry by ID
   */
  removeContext(id) {
    delete this._context[id];
    void this.notifySubscribers();
  }
  /**
   * Notify all subscribers of context changes
   */
  async notifySubscribers() {
    await this.core.notifySubscribers(
      (subscriber) => subscriber.onContextChanged?.({
        copilotkit: this.core,
        context: this._context
      }),
      "Subscriber onContextChanged error:"
    );
  }
};

// src/core/suggestion-engine.ts
var import_shared3 = require("@copilotkitnext/shared");
var SuggestionEngine = class {
  constructor(core) {
    this.core = core;
  }
  _suggestionsConfig = {};
  _suggestions = {};
  _runningSuggestions = {};
  /**
   * Initialize with suggestion configs
   */
  initialize(suggestionsConfig) {
    for (const config of suggestionsConfig) {
      this._suggestionsConfig[(0, import_shared3.randomUUID)()] = config;
    }
  }
  /**
   * Add a suggestion configuration
   * @returns The ID of the created config
   */
  addSuggestionsConfig(config) {
    const id = (0, import_shared3.randomUUID)();
    this._suggestionsConfig[id] = config;
    void this.notifySuggestionsConfigChanged();
    return id;
  }
  /**
   * Remove a suggestion configuration by ID
   */
  removeSuggestionsConfig(id) {
    delete this._suggestionsConfig[id];
    void this.notifySuggestionsConfigChanged();
  }
  /**
   * Reload suggestions for a specific agent
   * This triggers generation of new suggestions based on current configs
   */
  reloadSuggestions(agentId) {
    this.clearSuggestions(agentId);
    const agent = this.core.getAgent(agentId);
    if (!agent) {
      return;
    }
    const messageCount = agent.messages?.length ?? 0;
    let hasAnySuggestions = false;
    for (const config of Object.values(this._suggestionsConfig)) {
      if (config.consumerAgentId !== void 0 && config.consumerAgentId !== "*" && config.consumerAgentId !== agentId) {
        continue;
      }
      if (!this.shouldShowSuggestions(config, messageCount)) {
        continue;
      }
      const suggestionId = (0, import_shared3.randomUUID)();
      if (isDynamicSuggestionsConfig(config)) {
        if (!hasAnySuggestions) {
          hasAnySuggestions = true;
          void this.notifySuggestionsStartedLoading(agentId);
        }
        void this.generateSuggestions(suggestionId, config, agentId);
      } else if (isStaticSuggestionsConfig(config)) {
        this.addStaticSuggestions(suggestionId, config, agentId);
      }
    }
  }
  /**
   * Clear all suggestions for a specific agent
   */
  clearSuggestions(agentId) {
    const runningAgents = this._runningSuggestions[agentId];
    if (runningAgents) {
      for (const agent of runningAgents) {
        agent.abortRun();
      }
      delete this._runningSuggestions[agentId];
    }
    this._suggestions[agentId] = {};
    void this.notifySuggestionsChanged(agentId, []);
  }
  /**
   * Get current suggestions for an agent
   */
  getSuggestions(agentId) {
    const suggestions = Object.values(this._suggestions[agentId] ?? {}).flat();
    const isLoading = (this._runningSuggestions[agentId]?.length ?? 0) > 0;
    return { suggestions, isLoading };
  }
  /**
   * Generate suggestions using a provider agent
   */
  async generateSuggestions(suggestionId, config, consumerAgentId) {
    let agent = void 0;
    try {
      const suggestionsProviderAgent = this.core.getAgent(
        config.providerAgentId ?? "default"
      );
      if (!suggestionsProviderAgent) {
        throw new Error(`Suggestions provider agent not found: ${config.providerAgentId}`);
      }
      const suggestionsConsumerAgent = this.core.getAgent(consumerAgentId);
      if (!suggestionsConsumerAgent) {
        throw new Error(`Suggestions consumer agent not found: ${consumerAgentId}`);
      }
      const clonedAgent = suggestionsProviderAgent.clone();
      agent = clonedAgent;
      agent.threadId = suggestionId;
      agent.messages = JSON.parse(JSON.stringify(suggestionsConsumerAgent.messages));
      agent.state = JSON.parse(JSON.stringify(suggestionsConsumerAgent.state));
      this._suggestions[consumerAgentId] = {
        ...this._suggestions[consumerAgentId] ?? {},
        [suggestionId]: []
      };
      this._runningSuggestions[consumerAgentId] = [...this._runningSuggestions[consumerAgentId] ?? [], agent];
      agent.addMessage({
        id: suggestionId,
        role: "user",
        content: [
          `Suggest what the user could say next. Provide clear, highly relevant suggestions by calling the \`copilotkitSuggest\` tool.`,
          `Provide at least ${config.minSuggestions ?? 1} and at most ${config.maxSuggestions ?? 3} suggestions.`,
          `The user has the following tools available: ${JSON.stringify(this.core.buildFrontendTools(consumerAgentId))}.`,
          ` ${config.instructions}`
        ].join("\n")
      });
      await agent.runAgent(
        {
          context: Object.values(this.core.context),
          forwardedProps: {
            ...this.core.properties,
            toolChoice: { type: "function", function: { name: "copilotkitSuggest" } }
          },
          tools: [SUGGEST_TOOL]
        },
        {
          onMessagesChanged: ({ messages }) => {
            this.extractSuggestions(messages, suggestionId, consumerAgentId, true);
          }
        }
      );
    } catch (error) {
      console.warn("Error generating suggestions:", error);
    } finally {
      this.finalizeSuggestions(suggestionId, consumerAgentId);
      const runningAgents = this._runningSuggestions[consumerAgentId];
      if (agent && runningAgents) {
        const filteredAgents = runningAgents.filter((a) => a !== agent);
        this._runningSuggestions[consumerAgentId] = filteredAgents;
        if (filteredAgents.length === 0) {
          delete this._runningSuggestions[consumerAgentId];
          await this.notifySuggestionsFinishedLoading(consumerAgentId);
        }
      }
    }
  }
  /**
   * Finalize suggestions by marking them as no longer loading
   */
  finalizeSuggestions(suggestionId, consumerAgentId) {
    const agentSuggestions = this._suggestions[consumerAgentId];
    const currentSuggestions = agentSuggestions?.[suggestionId];
    if (agentSuggestions && currentSuggestions && currentSuggestions.length > 0) {
      const finalizedSuggestions = currentSuggestions.filter((suggestion) => suggestion.title !== "" || suggestion.message !== "").map((suggestion) => ({
        ...suggestion,
        isLoading: false
      }));
      if (finalizedSuggestions.length > 0) {
        agentSuggestions[suggestionId] = finalizedSuggestions;
      } else {
        delete agentSuggestions[suggestionId];
      }
      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "finalized");
    }
  }
  /**
   * Extract suggestions from messages (called during streaming)
   */
  extractSuggestions(messages, suggestionId, consumerAgentId, isRunning) {
    const idx = messages.findIndex((message) => message.id === suggestionId);
    if (idx == -1) {
      return;
    }
    const suggestions = [];
    const newMessages = messages.slice(idx + 1);
    for (const message of newMessages) {
      if (message.role === "assistant" && message.toolCalls) {
        for (const toolCall of message.toolCalls) {
          if (toolCall.function.name === "copilotkitSuggest") {
            const fullArgs = Array.isArray(toolCall.function.arguments) ? toolCall.function.arguments.join("") : toolCall.function.arguments;
            const parsed = (0, import_shared3.partialJSONParse)(fullArgs);
            if (parsed && typeof parsed === "object" && "suggestions" in parsed) {
              const parsedSuggestions = parsed.suggestions;
              if (Array.isArray(parsedSuggestions)) {
                for (const item of parsedSuggestions) {
                  if (item && typeof item === "object" && "title" in item) {
                    suggestions.push({
                      title: item.title ?? "",
                      message: item.message ?? "",
                      isLoading: false
                      // Will be set correctly below
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
    if (isRunning && suggestions.length > 0) {
      suggestions[suggestions.length - 1].isLoading = true;
    }
    const agentSuggestions = this._suggestions[consumerAgentId];
    if (agentSuggestions) {
      agentSuggestions[suggestionId] = suggestions;
      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "suggestions changed");
    }
  }
  /**
   * Notify subscribers of suggestions config changes
   */
  async notifySuggestionsConfigChanged() {
    await this.core.notifySubscribers(
      (subscriber) => subscriber.onSuggestionsConfigChanged?.({
        copilotkit: this.core,
        suggestionsConfig: this._suggestionsConfig
      }),
      "Subscriber onSuggestionsConfigChanged error:"
    );
  }
  /**
   * Notify subscribers of suggestions changes
   */
  async notifySuggestionsChanged(agentId, suggestions, context = "") {
    await this.core.notifySubscribers(
      (subscriber) => subscriber.onSuggestionsChanged?.({
        copilotkit: this.core,
        agentId,
        suggestions
      }),
      `Subscriber onSuggestionsChanged error: ${context}`
    );
  }
  /**
   * Notify subscribers that suggestions started loading
   */
  async notifySuggestionsStartedLoading(agentId) {
    await this.core.notifySubscribers(
      (subscriber) => subscriber.onSuggestionsStartedLoading?.({
        copilotkit: this.core,
        agentId
      }),
      "Subscriber onSuggestionsStartedLoading error:"
    );
  }
  /**
   * Notify subscribers that suggestions finished loading
   */
  async notifySuggestionsFinishedLoading(agentId) {
    await this.core.notifySubscribers(
      (subscriber) => subscriber.onSuggestionsFinishedLoading?.({
        copilotkit: this.core,
        agentId
      }),
      "Subscriber onSuggestionsFinishedLoading error:"
    );
  }
  /**
   * Check if suggestions should be shown based on availability and message count
   */
  shouldShowSuggestions(config, messageCount) {
    const availability = config.available;
    if (!availability) {
      if (isDynamicSuggestionsConfig(config)) {
        return messageCount > 0;
      } else {
        return messageCount === 0;
      }
    }
    switch (availability) {
      case "disabled":
        return false;
      case "before-first-message":
        return messageCount === 0;
      case "after-first-message":
        return messageCount > 0;
      case "always":
        return true;
      default:
        return false;
    }
  }
  /**
   * Add static suggestions directly without AI generation
   */
  addStaticSuggestions(suggestionId, config, consumerAgentId) {
    const suggestions = config.suggestions.map((s) => ({
      ...s,
      isLoading: false
    }));
    this._suggestions[consumerAgentId] = {
      ...this._suggestions[consumerAgentId] ?? {},
      [suggestionId]: suggestions
    };
    const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
    void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "static suggestions added");
  }
};
function isDynamicSuggestionsConfig(config) {
  return "instructions" in config;
}
function isStaticSuggestionsConfig(config) {
  return "suggestions" in config;
}
var SUGGEST_TOOL = {
  name: "copilotkitSuggest",
  description: "Suggest what the user could say next",
  parameters: {
    type: "object",
    properties: {
      suggestions: {
        type: "array",
        description: "List of suggestions shown to the user as buttons.",
        items: {
          type: "object",
          properties: {
            title: {
              type: "string",
              description: "The title of the suggestion. This is shown as a button and should be short."
            },
            message: {
              type: "string",
              description: "The message to send when the suggestion is clicked. This should be a clear, complete sentence and will be sent as an instruction to the AI."
            }
          },
          required: ["title", "message"]
        }
      }
    },
    required: ["suggestions"]
  }
};

// src/core/run-handler.ts
var import_client3 = require("@ag-ui/client");
var import_shared4 = require("@copilotkitnext/shared");
var import_zod_to_json_schema = require("zod-to-json-schema");
var RunHandler = class {
  constructor(core) {
    this.core = core;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _tools = [];
  /**
   * Get all tools as a readonly array
   */
  get tools() {
    return this._tools;
  }
  /**
   * Initialize with tools
   */
  initialize(tools) {
    this._tools = tools;
  }
  /**
   * Add a tool to the registry
   */
  addTool(tool) {
    const existingToolIndex = this._tools.findIndex((t) => t.name === tool.name && t.agentId === tool.agentId);
    if (existingToolIndex !== -1) {
      import_shared4.logger.warn(`Tool already exists: '${tool.name}' for agent '${tool.agentId || "global"}', skipping.`);
      return;
    }
    this._tools.push(tool);
  }
  /**
   * Remove a tool by name and optionally by agentId
   */
  removeTool(id, agentId) {
    this._tools = this._tools.filter((tool) => {
      if (agentId !== void 0) {
        return !(tool.name === id && tool.agentId === agentId);
      }
      return !(tool.name === id && !tool.agentId);
    });
  }
  /**
   * Get a tool by name and optionally by agentId.
   * If agentId is provided, it will first look for an agent-specific tool,
   * then fall back to a global tool with the same name.
   */
  getTool(params) {
    const { toolName, agentId } = params;
    if (agentId) {
      const agentTool = this._tools.find((tool) => tool.name === toolName && tool.agentId === agentId);
      if (agentTool) {
        return agentTool;
      }
    }
    return this._tools.find((tool) => tool.name === toolName && !tool.agentId);
  }
  /**
   * Set all tools at once. Replaces existing tools.
   */
  setTools(tools) {
    this._tools = [...tools];
  }
  /**
   * Connect an agent (establish initial connection)
   */
  async connectAgent({ agent }) {
    try {
      await agent.detachActiveRun();
      agent.setMessages([]);
      agent.setState({});
      if (agent instanceof import_client3.HttpAgent) {
        agent.headers = { ...this.core.headers };
      }
      const runAgentResult = await agent.connectAgent(
        {
          forwardedProps: this.core.properties,
          tools: this.buildFrontendTools(agent.agentId)
        },
        this.createAgentErrorSubscriber(agent)
      );
      return this.processAgentResult({ runAgentResult, agent });
    } catch (error) {
      const connectError = error instanceof Error ? error : new Error(String(error));
      const context = {};
      if (agent.agentId) {
        context.agentId = agent.agentId;
      }
      await this.core.emitError({
        error: connectError,
        code: "agent_connect_failed" /* AGENT_CONNECT_FAILED */,
        context
      });
      throw error;
    }
  }
  /**
   * Run an agent
   */
  async runAgent({ agent }) {
    if (agent.agentId) {
      void this.core.suggestionEngine.clearSuggestions(agent.agentId);
    }
    if (agent instanceof import_client3.HttpAgent) {
      agent.headers = { ...this.core.headers };
    }
    try {
      const runAgentResult = await agent.runAgent(
        {
          forwardedProps: this.core.properties,
          tools: this.buildFrontendTools(agent.agentId),
          context: Object.values(this.core.context)
        },
        this.createAgentErrorSubscriber(agent)
      );
      return this.processAgentResult({ runAgentResult, agent });
    } catch (error) {
      const runError = error instanceof Error ? error : new Error(String(error));
      const context = {};
      if (agent.agentId) {
        context.agentId = agent.agentId;
      }
      await this.core.emitError({
        error: runError,
        code: "agent_run_failed" /* AGENT_RUN_FAILED */,
        context
      });
      throw error;
    }
  }
  /**
   * Process agent result and execute tools
   */
  async processAgentResult({
    runAgentResult,
    agent
  }) {
    const { newMessages } = runAgentResult;
    const agentId = agent.agentId;
    let needsFollowUp = false;
    for (const message of newMessages) {
      if (message.role === "assistant") {
        for (const toolCall of message.toolCalls || []) {
          if (newMessages.findIndex((m) => m.role === "tool" && m.toolCallId === toolCall.id) === -1) {
            const tool = this.getTool({
              toolName: toolCall.function.name,
              agentId: agent.agentId
            });
            if (tool) {
              const followUp = await this.executeSpecificTool(tool, toolCall, message, agent, agentId);
              if (followUp) {
                needsFollowUp = true;
              }
            } else {
              const wildcardTool = this.getTool({ toolName: "*", agentId: agent.agentId });
              if (wildcardTool) {
                const followUp = await this.executeWildcardTool(wildcardTool, toolCall, message, agent, agentId);
                if (followUp) {
                  needsFollowUp = true;
                }
              }
            }
          }
        }
      }
    }
    if (needsFollowUp) {
      return await this.runAgent({ agent });
    }
    void this.core.suggestionEngine.reloadSuggestions(agentId);
    return runAgentResult;
  }
  /**
   * Execute a specific tool
   */
  async executeSpecificTool(tool, toolCall, message, agent, agentId) {
    if (tool?.agentId && tool.agentId !== agent.agentId) {
      return false;
    }
    let toolCallResult = "";
    let errorMessage;
    let isArgumentError = false;
    if (tool?.handler) {
      let parsedArgs;
      try {
        parsedArgs = JSON.parse(toolCall.function.arguments);
      } catch (error) {
        const parseError = error instanceof Error ? error : new Error(String(error));
        errorMessage = parseError.message;
        isArgumentError = true;
        await this.core.emitError({
          error: parseError,
          code: "tool_argument_parse_failed" /* TOOL_ARGUMENT_PARSE_FAILED */,
          context: {
            agentId,
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            rawArguments: toolCall.function.arguments,
            toolType: "specific",
            messageId: message.id
          }
        });
      }
      await this.core.notifySubscribers(
        (subscriber) => subscriber.onToolExecutionStart?.({
          copilotkit: this.core,
          toolCallId: toolCall.id,
          agentId,
          toolName: toolCall.function.name,
          args: parsedArgs
        }),
        "Subscriber onToolExecutionStart error:"
      );
      if (!errorMessage) {
        try {
          const result = await tool.handler(parsedArgs, toolCall);
          if (result === void 0 || result === null) {
            toolCallResult = "";
          } else if (typeof result === "string") {
            toolCallResult = result;
          } else {
            toolCallResult = JSON.stringify(result);
          }
        } catch (error) {
          const handlerError = error instanceof Error ? error : new Error(String(error));
          errorMessage = handlerError.message;
          await this.core.emitError({
            error: handlerError,
            code: "tool_handler_failed" /* TOOL_HANDLER_FAILED */,
            context: {
              agentId,
              toolCallId: toolCall.id,
              toolName: toolCall.function.name,
              parsedArgs,
              toolType: "specific",
              messageId: message.id
            }
          });
        }
      }
      if (errorMessage) {
        toolCallResult = `Error: ${errorMessage}`;
      }
      await this.core.notifySubscribers(
        (subscriber) => subscriber.onToolExecutionEnd?.({
          copilotkit: this.core,
          toolCallId: toolCall.id,
          agentId,
          toolName: toolCall.function.name,
          result: errorMessage ? "" : toolCallResult,
          error: errorMessage
        }),
        "Subscriber onToolExecutionEnd error:"
      );
      if (isArgumentError) {
        throw new Error(errorMessage ?? "Tool execution failed");
      }
    }
    if (!errorMessage || !isArgumentError) {
      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);
      const toolMessage = {
        id: (0, import_shared4.randomUUID)(),
        role: "tool",
        toolCallId: toolCall.id,
        content: toolCallResult
      };
      agent.messages.splice(messageIndex + 1, 0, toolMessage);
      if (!errorMessage && tool?.followUp !== false) {
        return true;
      }
    }
    return false;
  }
  /**
   * Execute a wildcard tool
   */
  async executeWildcardTool(wildcardTool, toolCall, message, agent, agentId) {
    if (wildcardTool?.agentId && wildcardTool.agentId !== agent.agentId) {
      return false;
    }
    let toolCallResult = "";
    let errorMessage;
    let isArgumentError = false;
    if (wildcardTool?.handler) {
      let parsedArgs;
      try {
        parsedArgs = JSON.parse(toolCall.function.arguments);
      } catch (error) {
        const parseError = error instanceof Error ? error : new Error(String(error));
        errorMessage = parseError.message;
        isArgumentError = true;
        await this.core.emitError({
          error: parseError,
          code: "tool_argument_parse_failed" /* TOOL_ARGUMENT_PARSE_FAILED */,
          context: {
            agentId,
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            rawArguments: toolCall.function.arguments,
            toolType: "wildcard",
            messageId: message.id
          }
        });
      }
      const wildcardArgs = {
        toolName: toolCall.function.name,
        args: parsedArgs
      };
      await this.core.notifySubscribers(
        (subscriber) => subscriber.onToolExecutionStart?.({
          copilotkit: this.core,
          toolCallId: toolCall.id,
          agentId,
          toolName: toolCall.function.name,
          args: wildcardArgs
        }),
        "Subscriber onToolExecutionStart error:"
      );
      if (!errorMessage) {
        try {
          const result = await wildcardTool.handler(wildcardArgs, toolCall);
          if (result === void 0 || result === null) {
            toolCallResult = "";
          } else if (typeof result === "string") {
            toolCallResult = result;
          } else {
            toolCallResult = JSON.stringify(result);
          }
        } catch (error) {
          const handlerError = error instanceof Error ? error : new Error(String(error));
          errorMessage = handlerError.message;
          await this.core.emitError({
            error: handlerError,
            code: "tool_handler_failed" /* TOOL_HANDLER_FAILED */,
            context: {
              agentId,
              toolCallId: toolCall.id,
              toolName: toolCall.function.name,
              parsedArgs: wildcardArgs,
              toolType: "wildcard",
              messageId: message.id
            }
          });
        }
      }
      if (errorMessage) {
        toolCallResult = `Error: ${errorMessage}`;
      }
      await this.core.notifySubscribers(
        (subscriber) => subscriber.onToolExecutionEnd?.({
          copilotkit: this.core,
          toolCallId: toolCall.id,
          agentId,
          toolName: toolCall.function.name,
          result: errorMessage ? "" : toolCallResult,
          error: errorMessage
        }),
        "Subscriber onToolExecutionEnd error:"
      );
      if (isArgumentError) {
        throw new Error(errorMessage ?? "Tool execution failed");
      }
    }
    if (!errorMessage || !isArgumentError) {
      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);
      const toolMessage = {
        id: (0, import_shared4.randomUUID)(),
        role: "tool",
        toolCallId: toolCall.id,
        content: toolCallResult
      };
      agent.messages.splice(messageIndex + 1, 0, toolMessage);
      if (!errorMessage && wildcardTool?.followUp !== false) {
        return true;
      }
    }
    return false;
  }
  /**
   * Build frontend tools for an agent
   */
  buildFrontendTools(agentId) {
    return this._tools.filter((tool) => !tool.agentId || tool.agentId === agentId).map((tool) => ({
      name: tool.name,
      description: tool.description ?? "",
      parameters: createToolSchema(tool)
    }));
  }
  /**
   * Create an agent error subscriber
   */
  createAgentErrorSubscriber(agent) {
    const emitAgentError = async (error, code, extraContext = {}) => {
      const context = { ...extraContext };
      if (agent.agentId) {
        context.agentId = agent.agentId;
      }
      await this.core.emitError({
        error,
        code,
        context
      });
    };
    return {
      onRunFailed: async ({ error }) => {
        await emitAgentError(error, "agent_run_failed_event" /* AGENT_RUN_FAILED_EVENT */, {
          source: "onRunFailed"
        });
      },
      onRunErrorEvent: async ({ event }) => {
        const eventError = event?.rawEvent instanceof Error ? event.rawEvent : event?.rawEvent?.error instanceof Error ? event.rawEvent.error : void 0;
        const errorMessage = typeof event?.rawEvent?.error === "string" ? event.rawEvent.error : event?.message ?? "Agent run error";
        const rawError = eventError ?? new Error(errorMessage);
        if (event?.code && !rawError.code) {
          rawError.code = event.code;
        }
        await emitAgentError(rawError, "agent_run_error_event" /* AGENT_RUN_ERROR_EVENT */, {
          source: "onRunErrorEvent",
          event,
          runtimeErrorCode: event?.code
        });
      }
    };
  }
};
var EMPTY_TOOL_SCHEMA = {
  type: "object",
  properties: {}
};
function createToolSchema(tool) {
  if (!tool.parameters) {
    return { ...EMPTY_TOOL_SCHEMA };
  }
  const rawSchema = (0, import_zod_to_json_schema.zodToJsonSchema)(tool.parameters, {
    $refStrategy: "none"
  });
  if (!rawSchema || typeof rawSchema !== "object") {
    return { ...EMPTY_TOOL_SCHEMA };
  }
  const { $schema, ...schema } = rawSchema;
  if (typeof schema.type !== "string") {
    schema.type = "object";
  }
  if (typeof schema.properties !== "object" || schema.properties === null) {
    schema.properties = {};
  }
  stripAdditionalProperties(schema);
  return schema;
}
function stripAdditionalProperties(schema) {
  if (!schema || typeof schema !== "object") {
    return;
  }
  if (Array.isArray(schema)) {
    schema.forEach(stripAdditionalProperties);
    return;
  }
  const record = schema;
  if (record.additionalProperties !== void 0) {
    delete record.additionalProperties;
  }
  for (const value of Object.values(record)) {
    stripAdditionalProperties(value);
  }
}

// src/core/state-manager.ts
var StateManager = class {
  constructor(core) {
    this.core = core;
  }
  // State tracking: agentId -> threadId -> runId -> state
  stateByRun = /* @__PURE__ */ new Map();
  // Message tracking: agentId -> threadId -> messageId -> runId
  messageToRun = /* @__PURE__ */ new Map();
  // Agent subscriptions for cleanup
  agentSubscriptions = /* @__PURE__ */ new Map();
  /**
   * Initialize state tracking for an agent
   */
  initialize() {
  }
  /**
   * Subscribe to an agent's events to track state and messages
   */
  subscribeToAgent(agent) {
    if (!agent.agentId) {
      return;
    }
    const agentId = agent.agentId;
    this.unsubscribeFromAgent(agentId);
    const { unsubscribe } = agent.subscribe({
      onRunStartedEvent: ({ event, state }) => {
        this.handleRunStarted(agent, event, state);
      },
      onRunFinishedEvent: ({ event, state }) => {
        this.handleRunFinished(agent, event, state);
      },
      onStateSnapshotEvent: ({ event, input, state }) => {
        this.handleStateSnapshot(agent, event, input, state);
      },
      onStateDeltaEvent: ({ event, input, state }) => {
        this.handleStateDelta(agent, event, input, state);
      },
      onMessagesSnapshotEvent: ({ event, input, messages }) => {
        this.handleMessagesSnapshot(agent, event, input, messages);
      },
      onNewMessage: ({ message, input }) => {
        this.handleNewMessage(agent, message, input);
      }
    });
    this.agentSubscriptions.set(agentId, unsubscribe);
  }
  /**
   * Unsubscribe from an agent's events
   */
  unsubscribeFromAgent(agentId) {
    const unsubscribe = this.agentSubscriptions.get(agentId);
    if (unsubscribe) {
      unsubscribe();
      this.agentSubscriptions.delete(agentId);
    }
  }
  /**
   * Get state for a specific run
   * Returns a deep copy to prevent external mutations
   */
  getStateByRun(agentId, threadId, runId) {
    const state = this.stateByRun.get(agentId)?.get(threadId)?.get(runId);
    if (!state) return void 0;
    return JSON.parse(JSON.stringify(state));
  }
  /**
   * Get runId associated with a message
   */
  getRunIdForMessage(agentId, threadId, messageId) {
    return this.messageToRun.get(agentId)?.get(threadId)?.get(messageId);
  }
  /**
   * Get all states for an agent's thread
   */
  getStatesForThread(agentId, threadId) {
    return this.stateByRun.get(agentId)?.get(threadId) ?? /* @__PURE__ */ new Map();
  }
  /**
   * Get all run IDs for an agent's thread
   */
  getRunIdsForThread(agentId, threadId) {
    const threadStates = this.stateByRun.get(agentId)?.get(threadId);
    return threadStates ? Array.from(threadStates.keys()) : [];
  }
  /**
   * Handle run started event
   */
  handleRunStarted(agent, event, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = event;
    this.saveState(agent.agentId, threadId, runId, state);
  }
  /**
   * Handle run finished event
   */
  handleRunFinished(agent, event, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = event;
    this.saveState(agent.agentId, threadId, runId, state);
  }
  /**
   * Handle state snapshot event
   */
  handleStateSnapshot(agent, event, input, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = input;
    const mergedState = { ...state, ...event.snapshot };
    this.saveState(agent.agentId, threadId, runId, mergedState);
  }
  /**
   * Handle state delta event
   */
  handleStateDelta(agent, event, input, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = input;
    this.saveState(agent.agentId, threadId, runId, state);
  }
  /**
   * Handle messages snapshot event
   */
  handleMessagesSnapshot(agent, event, input, messages) {
    if (!agent.agentId) return;
    const { threadId, runId } = input;
    for (const message of event.messages) {
      this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);
    }
  }
  /**
   * Handle new message event
   */
  handleNewMessage(agent, message, input) {
    if (!agent.agentId || !input) return;
    const { threadId, runId } = input;
    this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);
  }
  /**
   * Save state for a specific run
   */
  saveState(agentId, threadId, runId, state) {
    if (!this.stateByRun.has(agentId)) {
      this.stateByRun.set(agentId, /* @__PURE__ */ new Map());
    }
    const agentStates = this.stateByRun.get(agentId);
    if (!agentStates.has(threadId)) {
      agentStates.set(threadId, /* @__PURE__ */ new Map());
    }
    const threadStates = agentStates.get(threadId);
    threadStates.set(runId, JSON.parse(JSON.stringify(state)));
  }
  /**
   * Associate a message with a run
   */
  associateMessageWithRun(agentId, threadId, messageId, runId) {
    if (!this.messageToRun.has(agentId)) {
      this.messageToRun.set(agentId, /* @__PURE__ */ new Map());
    }
    const agentMessages = this.messageToRun.get(agentId);
    if (!agentMessages.has(threadId)) {
      agentMessages.set(threadId, /* @__PURE__ */ new Map());
    }
    const threadMessages = agentMessages.get(threadId);
    threadMessages.set(messageId, runId);
  }
  /**
   * Clear all state for an agent
   */
  clearAgentState(agentId) {
    this.stateByRun.delete(agentId);
    this.messageToRun.delete(agentId);
  }
  /**
   * Clear all state for a thread
   */
  clearThreadState(agentId, threadId) {
    this.stateByRun.get(agentId)?.delete(threadId);
    this.messageToRun.get(agentId)?.delete(threadId);
  }
};

// src/core/core.ts
var CopilotKitCoreErrorCode = /* @__PURE__ */ ((CopilotKitCoreErrorCode2) => {
  CopilotKitCoreErrorCode2["RUNTIME_INFO_FETCH_FAILED"] = "runtime_info_fetch_failed";
  CopilotKitCoreErrorCode2["AGENT_CONNECT_FAILED"] = "agent_connect_failed";
  CopilotKitCoreErrorCode2["AGENT_RUN_FAILED"] = "agent_run_failed";
  CopilotKitCoreErrorCode2["AGENT_RUN_FAILED_EVENT"] = "agent_run_failed_event";
  CopilotKitCoreErrorCode2["AGENT_RUN_ERROR_EVENT"] = "agent_run_error_event";
  CopilotKitCoreErrorCode2["TOOL_ARGUMENT_PARSE_FAILED"] = "tool_argument_parse_failed";
  CopilotKitCoreErrorCode2["TOOL_HANDLER_FAILED"] = "tool_handler_failed";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_FAILED"] = "transcription_failed";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_SERVICE_NOT_CONFIGURED"] = "transcription_service_not_configured";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_INVALID_AUDIO"] = "transcription_invalid_audio";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_RATE_LIMITED"] = "transcription_rate_limited";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_AUTH_FAILED"] = "transcription_auth_failed";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_NETWORK_ERROR"] = "transcription_network_error";
  return CopilotKitCoreErrorCode2;
})(CopilotKitCoreErrorCode || {});
var CopilotKitCoreRuntimeConnectionStatus = /* @__PURE__ */ ((CopilotKitCoreRuntimeConnectionStatus2) => {
  CopilotKitCoreRuntimeConnectionStatus2["Disconnected"] = "disconnected";
  CopilotKitCoreRuntimeConnectionStatus2["Connected"] = "connected";
  CopilotKitCoreRuntimeConnectionStatus2["Connecting"] = "connecting";
  CopilotKitCoreRuntimeConnectionStatus2["Error"] = "error";
  return CopilotKitCoreRuntimeConnectionStatus2;
})(CopilotKitCoreRuntimeConnectionStatus || {});
var CopilotKitCore = class {
  _headers;
  _credentials;
  _properties;
  subscribers = /* @__PURE__ */ new Set();
  // Delegate classes
  agentRegistry;
  contextStore;
  suggestionEngine;
  runHandler;
  stateManager;
  constructor({
    runtimeUrl,
    runtimeTransport = "rest",
    headers = {},
    credentials,
    properties = {},
    agents__unsafe_dev_only = {},
    tools = [],
    suggestionsConfig = []
  }) {
    this._headers = headers;
    this._credentials = credentials;
    this._properties = properties;
    this.agentRegistry = new AgentRegistry(this);
    this.contextStore = new ContextStore(this);
    this.suggestionEngine = new SuggestionEngine(this);
    this.runHandler = new RunHandler(this);
    this.stateManager = new StateManager(this);
    this.agentRegistry.initialize(agents__unsafe_dev_only);
    this.runHandler.initialize(tools);
    this.suggestionEngine.initialize(suggestionsConfig);
    this.stateManager.initialize();
    this.agentRegistry.setRuntimeTransport(runtimeTransport);
    this.agentRegistry.setRuntimeUrl(runtimeUrl);
    this.subscribe({
      onAgentsChanged: ({ agents }) => {
        Object.values(agents).forEach((agent) => {
          if (agent.agentId) {
            this.stateManager.subscribeToAgent(agent);
          }
        });
      }
    });
  }
  /**
   * Internal method used by delegate classes and subclasses to notify subscribers
   */
  async notifySubscribers(handler, errorMessage) {
    await Promise.all(
      Array.from(this.subscribers).map(async (subscriber) => {
        try {
          await handler(subscriber);
        } catch (error) {
          console.error(errorMessage, error);
        }
      })
    );
  }
  /**
   * Internal method used by delegate classes to emit errors
   */
  async emitError({
    error,
    code,
    context = {}
  }) {
    await this.notifySubscribers(
      (subscriber) => subscriber.onError?.({
        copilotkit: this,
        error,
        code,
        context
      }),
      "Subscriber onError error:"
    );
  }
  /**
   * Snapshot accessors
   */
  get context() {
    return this.contextStore.context;
  }
  get agents() {
    return this.agentRegistry.agents;
  }
  get tools() {
    return this.runHandler.tools;
  }
  get runtimeUrl() {
    return this.agentRegistry.runtimeUrl;
  }
  setRuntimeUrl(runtimeUrl) {
    this.agentRegistry.setRuntimeUrl(runtimeUrl);
  }
  get runtimeTransport() {
    return this.agentRegistry.runtimeTransport;
  }
  setRuntimeTransport(runtimeTransport) {
    this.agentRegistry.setRuntimeTransport(runtimeTransport);
  }
  get runtimeVersion() {
    return this.agentRegistry.runtimeVersion;
  }
  get headers() {
    return this._headers;
  }
  get credentials() {
    return this._credentials;
  }
  get properties() {
    return this._properties;
  }
  get runtimeConnectionStatus() {
    return this.agentRegistry.runtimeConnectionStatus;
  }
  get audioFileTranscriptionEnabled() {
    return this.agentRegistry.audioFileTranscriptionEnabled;
  }
  /**
   * Configuration updates
   */
  setHeaders(headers) {
    this._headers = headers;
    this.agentRegistry.applyHeadersToAgents(this.agentRegistry.agents);
    void this.notifySubscribers(
      (subscriber) => subscriber.onHeadersChanged?.({
        copilotkit: this,
        headers: this.headers
      }),
      "Subscriber onHeadersChanged error:"
    );
  }
  setCredentials(credentials) {
    this._credentials = credentials;
    this.agentRegistry.applyCredentialsToAgents(this.agentRegistry.agents);
  }
  setProperties(properties) {
    this._properties = properties;
    void this.notifySubscribers(
      (subscriber) => subscriber.onPropertiesChanged?.({
        copilotkit: this,
        properties: this.properties
      }),
      "Subscriber onPropertiesChanged error:"
    );
  }
  /**
   * Agent management (delegated to AgentRegistry)
   */
  setAgents__unsafe_dev_only(agents) {
    this.agentRegistry.setAgents__unsafe_dev_only(agents);
  }
  addAgent__unsafe_dev_only(params) {
    this.agentRegistry.addAgent__unsafe_dev_only(params);
  }
  removeAgent__unsafe_dev_only(id) {
    this.agentRegistry.removeAgent__unsafe_dev_only(id);
  }
  getAgent(id) {
    return this.agentRegistry.getAgent(id);
  }
  /**
   * Context management (delegated to ContextStore)
   */
  addContext(context) {
    return this.contextStore.addContext(context);
  }
  removeContext(id) {
    this.contextStore.removeContext(id);
  }
  /**
   * Suggestions management (delegated to SuggestionEngine)
   */
  addSuggestionsConfig(config) {
    return this.suggestionEngine.addSuggestionsConfig(config);
  }
  removeSuggestionsConfig(id) {
    this.suggestionEngine.removeSuggestionsConfig(id);
  }
  reloadSuggestions(agentId) {
    this.suggestionEngine.reloadSuggestions(agentId);
  }
  clearSuggestions(agentId) {
    this.suggestionEngine.clearSuggestions(agentId);
  }
  getSuggestions(agentId) {
    return this.suggestionEngine.getSuggestions(agentId);
  }
  /**
   * Tool management (delegated to RunHandler)
   */
  addTool(tool) {
    this.runHandler.addTool(tool);
  }
  removeTool(id, agentId) {
    this.runHandler.removeTool(id, agentId);
  }
  getTool(params) {
    return this.runHandler.getTool(params);
  }
  setTools(tools) {
    this.runHandler.setTools(tools);
  }
  /**
   * Subscription lifecycle
   */
  subscribe(subscriber) {
    this.subscribers.add(subscriber);
    return {
      unsubscribe: () => {
        this.subscribers.delete(subscriber);
      }
    };
  }
  /**
   * Agent connectivity (delegated to RunHandler)
   */
  async connectAgent(params) {
    return this.runHandler.connectAgent(params);
  }
  stopAgent(params) {
    params.agent.abortRun();
  }
  async runAgent(params) {
    return this.runHandler.runAgent(params);
  }
  /**
   * State management (delegated to StateManager)
   */
  getStateByRun(agentId, threadId, runId) {
    return this.stateManager.getStateByRun(agentId, threadId, runId);
  }
  getRunIdForMessage(agentId, threadId, messageId) {
    return this.stateManager.getRunIdForMessage(agentId, threadId, messageId);
  }
  getRunIdsForThread(agentId, threadId) {
    return this.stateManager.getRunIdsForThread(agentId, threadId);
  }
  /**
   * Internal method used by RunHandler to build frontend tools
   */
  buildFrontendTools(agentId) {
    return this.runHandler.buildFrontendTools(agentId);
  }
};

// src/types.ts
var ToolCallStatus = /* @__PURE__ */ ((ToolCallStatus2) => {
  ToolCallStatus2["InProgress"] = "inProgress";
  ToolCallStatus2["Executing"] = "executing";
  ToolCallStatus2["Complete"] = "complete";
  return ToolCallStatus2;
})(ToolCallStatus || {});

// src/utils/markdown.ts
function completePartialMarkdown(input) {
  let s = input;
  const fenceMatches = Array.from(s.matchAll(/^(\s*)(`{3,}|~{3,})/gm));
  if (fenceMatches.length % 2 === 1) {
    const [, indent, fence] = fenceMatches[0];
    s += `
${indent}${fence}`;
  }
  const incompleteLinkMatch = s.match(/\[([^\]]*)\]\(([^)]*)$/);
  if (incompleteLinkMatch) {
    s += ")";
  }
  const openElements = [];
  const chars = Array.from(s);
  const codeBlockRanges = [];
  const inlineCodeRanges = [];
  let tempCodeFenceCount = 0;
  let currentCodeBlockStart = -1;
  for (let i = 0; i < chars.length; i++) {
    if (i === 0 || chars[i - 1] === "\n") {
      const lineMatch = s.substring(i).match(/^(\s*)(`{3,}|~{3,})/);
      if (lineMatch) {
        tempCodeFenceCount++;
        if (tempCodeFenceCount % 2 === 1) {
          currentCodeBlockStart = i;
        } else if (currentCodeBlockStart !== -1) {
          codeBlockRanges.push({
            start: currentCodeBlockStart,
            end: i + lineMatch[0].length
          });
          currentCodeBlockStart = -1;
        }
        i += lineMatch[0].length - 1;
      }
    }
  }
  for (let i = 0; i < chars.length; i++) {
    if (chars[i] === "`") {
      let backslashCount = 0;
      for (let j = i - 1; j >= 0 && chars[j] === "\\"; j--) {
        backslashCount++;
      }
      if (backslashCount % 2 === 0) {
        for (let j = i + 1; j < chars.length; j++) {
          if (chars[j] === "`") {
            let closingBackslashCount = 0;
            for (let k = j - 1; k >= 0 && chars[k] === "\\"; k--) {
              closingBackslashCount++;
            }
            if (closingBackslashCount % 2 === 0) {
              inlineCodeRanges.push({ start: i, end: j + 1 });
              i = j;
              break;
            }
          }
        }
      }
    }
  }
  const isInCode = (pos) => {
    return codeBlockRanges.some((range) => pos >= range.start && pos < range.end) || inlineCodeRanges.some((range) => pos >= range.start && pos < range.end);
  };
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    const nextChar = chars[i + 1];
    const prevChar = chars[i - 1];
    if (isInCode(i)) {
      continue;
    }
    if (char === "[") {
      let isCompleteLink = false;
      let bracketDepth = 1;
      let j = i + 1;
      while (j < chars.length && bracketDepth > 0) {
        if (chars[j] === "[" && !isInCode(j)) bracketDepth++;
        if (chars[j] === "]" && !isInCode(j)) bracketDepth--;
        j++;
      }
      if (bracketDepth === 0 && chars[j] === "(") {
        let parenDepth = 1;
        j++;
        while (j < chars.length && parenDepth > 0) {
          if (chars[j] === "(" && !isInCode(j)) parenDepth++;
          if (chars[j] === ")" && !isInCode(j)) parenDepth--;
          j++;
        }
        if (parenDepth === 0) {
          isCompleteLink = true;
          i = j - 1;
          continue;
        }
      }
      if (!isCompleteLink) {
        const existingIndex = openElements.findIndex(
          (el) => el.type === "bracket"
        );
        if (existingIndex !== -1) {
          openElements.splice(existingIndex, 1);
        } else {
          openElements.push({ type: "bracket", marker: "[", position: i });
        }
      }
    } else if (char === "*" && nextChar === "*") {
      const existingIndex = openElements.findIndex(
        (el) => el.type === "bold_star"
      );
      if (existingIndex !== -1) {
        openElements.splice(existingIndex, 1);
      } else {
        openElements.push({ type: "bold_star", marker: "**", position: i });
      }
      i++;
    } else if (char === "_" && nextChar === "_") {
      const existingIndex = openElements.findIndex(
        (el) => el.type === "bold_underscore"
      );
      if (existingIndex !== -1) {
        openElements.splice(existingIndex, 1);
      } else {
        openElements.push({
          type: "bold_underscore",
          marker: "__",
          position: i
        });
      }
      i++;
    } else if (char === "~" && nextChar === "~") {
      const existingIndex = openElements.findIndex(
        (el) => el.type === "strike"
      );
      if (existingIndex !== -1) {
        openElements.splice(existingIndex, 1);
      } else {
        openElements.push({ type: "strike", marker: "~~", position: i });
      }
      i++;
    } else if (char === "*" && prevChar !== "*" && nextChar !== "*") {
      const existingIndex = openElements.findIndex(
        (el) => el.type === "italic_star"
      );
      if (existingIndex !== -1) {
        openElements.splice(existingIndex, 1);
      } else {
        openElements.push({ type: "italic_star", marker: "*", position: i });
      }
    } else if (char === "_" && prevChar !== "_" && nextChar !== "_") {
      const existingIndex = openElements.findIndex(
        (el) => el.type === "italic_underscore"
      );
      if (existingIndex !== -1) {
        openElements.splice(existingIndex, 1);
      } else {
        openElements.push({
          type: "italic_underscore",
          marker: "_",
          position: i
        });
      }
    }
  }
  let backtickCount = 0;
  for (let i = 0; i < chars.length; i++) {
    if (chars[i] === "`" && !isInCode(i)) {
      backtickCount++;
    }
  }
  if (backtickCount % 2 === 1) {
    s += "`";
  }
  openElements.sort((a, b) => b.position - a.position);
  const closers = openElements.map((el) => {
    switch (el.type) {
      case "bracket":
        return "]";
      case "bold_star":
        return "**";
      case "bold_underscore":
        return "__";
      case "strike":
        return "~~";
      case "italic_star":
        return "*";
      case "italic_underscore":
        return "_";
      default:
        return "";
    }
  });
  let result = s + closers.join("");
  const finalFenceMatches = Array.from(
    result.matchAll(/^(\s*)(`{3,}|~{3,})/gm)
  );
  const hasUnclosedBacktick = (result.match(/`/g) || []).length % 2 === 1;
  const hasUnclosedCodeFence = finalFenceMatches.length % 2 === 1;
  let shouldCloseParens = !hasUnclosedBacktick && !hasUnclosedCodeFence;
  if (shouldCloseParens) {
    const lastOpenParen = result.lastIndexOf("(");
    if (lastOpenParen !== -1) {
      const beforeParen = result.substring(0, lastOpenParen);
      const backticksBeforeParen = (beforeParen.match(/`/g) || []).length;
      if (backticksBeforeParen % 2 === 1) {
        shouldCloseParens = false;
      }
    }
  }
  if (shouldCloseParens) {
    const openParens = (result.match(/\(/g) || []).length;
    const closeParens = (result.match(/\)/g) || []).length;
    if (openParens > closeParens) {
      result += ")".repeat(openParens - closeParens);
    }
  }
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AgentRegistry,
  ContextStore,
  CopilotKitCore,
  CopilotKitCoreErrorCode,
  CopilotKitCoreRuntimeConnectionStatus,
  ProxiedCopilotRuntimeAgent,
  RunHandler,
  StateManager,
  SuggestionEngine,
  ToolCallStatus,
  completePartialMarkdown
});
//# sourceMappingURL=index.js.map