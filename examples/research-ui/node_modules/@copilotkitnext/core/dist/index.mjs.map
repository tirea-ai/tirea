{"version":3,"sources":["../src/core/agent-registry.ts","../src/agent.ts","../src/core/context-store.ts","../src/core/suggestion-engine.ts","../src/core/run-handler.ts","../src/core/state-manager.ts","../src/core/core.ts","../src/types.ts","../src/utils/markdown.ts"],"sourcesContent":["import { AbstractAgent, HttpAgent } from \"@ag-ui/client\";\nimport { logger, RuntimeInfo, AgentDescription } from \"@copilotkitnext/shared\";\nimport { ProxiedCopilotRuntimeAgent } from \"../agent\";\nimport type { CopilotKitCore } from \"./core\";\nimport { CopilotKitCoreErrorCode, CopilotKitCoreRuntimeConnectionStatus, CopilotKitCoreFriendsAccess } from \"./core\";\nimport { CopilotRuntimeTransport } from \"../types\";\n\nexport interface CopilotKitCoreAddAgentParams {\n  id: string;\n  agent: AbstractAgent;\n}\n\n/**\n * Manages agent registration, lifecycle, and runtime connectivity for CopilotKitCore.\n * Handles both local development agents and remote runtime agents.\n */\nexport class AgentRegistry {\n  private _agents: Record<string, AbstractAgent> = {};\n  private localAgents: Record<string, AbstractAgent> = {};\n  private remoteAgents: Record<string, AbstractAgent> = {};\n\n  private _runtimeUrl?: string;\n  private _runtimeVersion?: string;\n  private _runtimeConnectionStatus: CopilotKitCoreRuntimeConnectionStatus =\n    CopilotKitCoreRuntimeConnectionStatus.Disconnected;\n  private _runtimeTransport: CopilotRuntimeTransport = \"rest\";\n  private _audioFileTranscriptionEnabled: boolean = false;\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Get all agents as a readonly record\n   */\n  get agents(): Readonly<Record<string, AbstractAgent>> {\n    return this._agents;\n  }\n\n  get runtimeUrl(): string | undefined {\n    return this._runtimeUrl;\n  }\n\n  get runtimeVersion(): string | undefined {\n    return this._runtimeVersion;\n  }\n\n  get runtimeConnectionStatus(): CopilotKitCoreRuntimeConnectionStatus {\n    return this._runtimeConnectionStatus;\n  }\n\n  get runtimeTransport(): CopilotRuntimeTransport {\n    return this._runtimeTransport;\n  }\n\n  get audioFileTranscriptionEnabled(): boolean {\n    return this._audioFileTranscriptionEnabled;\n  }\n\n  /**\n   * Initialize agents from configuration\n   */\n  initialize(agents: Record<string, AbstractAgent>): void {\n    this.localAgents = this.assignAgentIds(agents);\n    this.applyHeadersToAgents(this.localAgents);\n    this._agents = this.localAgents;\n  }\n\n  /**\n   * Set the runtime URL and update connection\n   */\n  setRuntimeUrl(runtimeUrl: string | undefined): void {\n    const normalizedRuntimeUrl = runtimeUrl ? runtimeUrl.replace(/\\/$/, \"\") : undefined;\n\n    if (this._runtimeUrl === normalizedRuntimeUrl) {\n      return;\n    }\n\n    this._runtimeUrl = normalizedRuntimeUrl;\n    void this.updateRuntimeConnection();\n  }\n\n  setRuntimeTransport(runtimeTransport: CopilotRuntimeTransport): void {\n    if (this._runtimeTransport === runtimeTransport) {\n      return;\n    }\n\n    this._runtimeTransport = runtimeTransport;\n    void this.updateRuntimeConnection();\n  }\n\n  /**\n   * Set all agents at once (for development use)\n   */\n  setAgents__unsafe_dev_only(agents: Record<string, AbstractAgent>): void {\n    // Validate all agents before making any changes\n    Object.entries(agents).forEach(([id, agent]) => {\n      if (agent) {\n        this.validateAndAssignAgentId(id, agent);\n      }\n    });\n    this.localAgents = agents;\n    this._agents = { ...this.localAgents, ...this.remoteAgents };\n    this.applyHeadersToAgents(this._agents);\n    void this.notifyAgentsChanged();\n  }\n\n  /**\n   * Add a single agent (for development use)\n   */\n  addAgent__unsafe_dev_only({ id, agent }: CopilotKitCoreAddAgentParams): void {\n    this.validateAndAssignAgentId(id, agent);\n    this.localAgents[id] = agent;\n    this.applyHeadersToAgent(agent);\n    this._agents = { ...this.localAgents, ...this.remoteAgents };\n    void this.notifyAgentsChanged();\n  }\n\n  /**\n   * Remove an agent by ID (for development use)\n   */\n  removeAgent__unsafe_dev_only(id: string): void {\n    delete this.localAgents[id];\n    this._agents = { ...this.localAgents, ...this.remoteAgents };\n    void this.notifyAgentsChanged();\n  }\n\n  /**\n   * Get an agent by ID\n   */\n  getAgent(id: string): AbstractAgent | undefined {\n    if (id in this._agents) {\n      return this._agents[id] as AbstractAgent;\n    }\n\n    // Silently return undefined if we're still loading runtime agents\n    if (\n      this.runtimeUrl !== undefined &&\n      (this.runtimeConnectionStatus === CopilotKitCoreRuntimeConnectionStatus.Disconnected ||\n        this.runtimeConnectionStatus === CopilotKitCoreRuntimeConnectionStatus.Connecting)\n    ) {\n      return undefined;\n    }\n\n    console.warn(`Agent ${id} not found`);\n    return undefined;\n  }\n\n  /**\n   * Apply current headers to an agent\n   */\n  applyHeadersToAgent(agent: AbstractAgent): void {\n    if (agent instanceof HttpAgent) {\n      agent.headers = { ...(this.core as unknown as CopilotKitCoreFriendsAccess).headers };\n    }\n  }\n\n  /**\n   * Apply current headers to all agents\n   */\n  applyHeadersToAgents(agents: Record<string, AbstractAgent>): void {\n    Object.values(agents).forEach((agent) => {\n      this.applyHeadersToAgent(agent);\n    });\n  }\n\n  /**\n   * Apply current credentials to an agent\n   */\n  applyCredentialsToAgent(agent: AbstractAgent): void {\n    if (agent instanceof ProxiedCopilotRuntimeAgent) {\n      agent.credentials = (this.core as unknown as CopilotKitCoreFriendsAccess).credentials;\n    }\n  }\n\n  /**\n   * Apply current credentials to all agents\n   */\n  applyCredentialsToAgents(agents: Record<string, AbstractAgent>): void {\n    Object.values(agents).forEach((agent) => {\n      this.applyCredentialsToAgent(agent);\n    });\n  }\n\n  /**\n   * Update runtime connection and fetch remote agents\n   */\n  private async updateRuntimeConnection(): Promise<void> {\n    // Skip fetching on the server (SSR)\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    if (!this.runtimeUrl) {\n      this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Disconnected;\n      this._runtimeVersion = undefined;\n      this._audioFileTranscriptionEnabled = false;\n      this.remoteAgents = {};\n      this._agents = this.localAgents;\n\n      await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Disconnected);\n      await this.notifyAgentsChanged();\n      return;\n    }\n\n    this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Connecting;\n    await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Connecting);\n\n    try {\n      const runtimeInfoResponse = await this.fetchRuntimeInfo();\n      const {\n        version,\n        ...runtimeInfo\n      }: {\n        agents: Record<string, AgentDescription>;\n        version: string;\n      } = runtimeInfoResponse;\n\n      const credentials = (this.core as unknown as CopilotKitCoreFriendsAccess).credentials;\n      const agents: Record<string, AbstractAgent> = Object.fromEntries(\n        Object.entries(runtimeInfo.agents).map(([id, { description }]) => {\n          const agent = new ProxiedCopilotRuntimeAgent({\n            runtimeUrl: this.runtimeUrl,\n            agentId: id, // Runtime agents always have their ID set correctly\n            description: description,\n            transport: this._runtimeTransport,\n            credentials,\n          });\n          this.applyHeadersToAgent(agent);\n          return [id, agent];\n        }),\n      );\n\n      this.remoteAgents = agents;\n      this._agents = { ...this.localAgents, ...this.remoteAgents };\n      this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Connected;\n      this._runtimeVersion = version;\n      this._audioFileTranscriptionEnabled = runtimeInfoResponse.audioFileTranscriptionEnabled ?? false;\n\n      await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Connected);\n      await this.notifyAgentsChanged();\n    } catch (error) {\n      this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Error;\n      this._runtimeVersion = undefined;\n      this._audioFileTranscriptionEnabled = false;\n      this.remoteAgents = {};\n      this._agents = this.localAgents;\n\n      await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Error);\n      await this.notifyAgentsChanged();\n\n      const message = error instanceof Error ? error.message : JSON.stringify(error);\n      logger.warn(`Failed to load runtime info (${this.runtimeUrl}/info): ${message}`);\n      const runtimeError = error instanceof Error ? error : new Error(String(error));\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error: runtimeError,\n        code: CopilotKitCoreErrorCode.RUNTIME_INFO_FETCH_FAILED,\n        context: {\n          runtimeUrl: this.runtimeUrl,\n        },\n      });\n    }\n  }\n\n  private async fetchRuntimeInfo(): Promise<RuntimeInfo> {\n    if (!this.runtimeUrl) {\n      throw new Error(\"Runtime URL is not set\");\n    }\n\n    const baseHeaders = (this.core as unknown as CopilotKitCoreFriendsAccess).headers;\n    const credentials = (this.core as unknown as CopilotKitCoreFriendsAccess).credentials;\n    const headers: Record<string, string> = {\n      ...baseHeaders,\n    };\n\n    if (this._runtimeTransport === \"single\") {\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"application/json\";\n      }\n      const response = await fetch(this.runtimeUrl, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify({ method: \"info\" }),\n        ...(credentials ? { credentials } : {}),\n      });\n      if (\"ok\" in response && !(response as Response).ok) {\n        throw new Error(`Runtime info request failed with status ${response.status}`);\n      }\n      return (await response.json()) as RuntimeInfo;\n    }\n\n    const response = await fetch(`${this.runtimeUrl}/info`, {\n      headers,\n      ...(credentials ? { credentials } : {}),\n    });\n    if (\"ok\" in response && !(response as Response).ok) {\n      throw new Error(`Runtime info request failed with status ${response.status}`);\n    }\n    return (await response.json()) as RuntimeInfo;\n  }\n\n  /**\n   * Assign agent IDs to a record of agents\n   */\n  private assignAgentIds(agents: Record<string, AbstractAgent>): Record<string, AbstractAgent> {\n    Object.entries(agents).forEach(([id, agent]) => {\n      if (agent) {\n        this.validateAndAssignAgentId(id, agent);\n      }\n    });\n    return agents;\n  }\n\n  /**\n   * Validate and assign an agent ID\n   */\n  private validateAndAssignAgentId(registrationId: string, agent: AbstractAgent): void {\n    if (agent.agentId && agent.agentId !== registrationId) {\n      throw new Error(\n        `Agent registration mismatch: Agent with ID \"${agent.agentId}\" cannot be registered under key \"${registrationId}\". ` +\n          `The agent ID must match the registration key or be undefined.`,\n      );\n    }\n    if (!agent.agentId) {\n      agent.agentId = registrationId;\n    }\n  }\n\n  /**\n   * Notify subscribers of runtime status changes\n   */\n  private async notifyRuntimeStatusChanged(status: CopilotKitCoreRuntimeConnectionStatus): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onRuntimeConnectionStatusChanged?.({\n          copilotkit: this.core,\n          status,\n        }),\n      \"Error in CopilotKitCore subscriber (onRuntimeConnectionStatusChanged):\",\n    );\n  }\n\n  /**\n   * Notify subscribers of agent changes\n   */\n  private async notifyAgentsChanged(): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onAgentsChanged?.({\n          copilotkit: this.core,\n          agents: this._agents,\n        }),\n      \"Subscriber onAgentsChanged error:\",\n    );\n  }\n}\n","import {\n  BaseEvent,\n  HttpAgent,\n  HttpAgentConfig,\n  RunAgentInput,\n  runHttpRequest,\n  transformHttpEventStream,\n} from \"@ag-ui/client\";\nimport { Observable } from \"rxjs\";\nimport { CopilotRuntimeTransport } from \"./types\";\n\nexport interface ProxiedCopilotRuntimeAgentConfig extends Omit<HttpAgentConfig, \"url\"> {\n  runtimeUrl?: string;\n  transport?: CopilotRuntimeTransport;\n  credentials?: RequestCredentials;\n}\n\nexport class ProxiedCopilotRuntimeAgent extends HttpAgent {\n  runtimeUrl?: string;\n  credentials?: RequestCredentials;\n  private transport: CopilotRuntimeTransport;\n  private singleEndpointUrl?: string;\n\n  constructor(config: ProxiedCopilotRuntimeAgentConfig) {\n    const normalizedRuntimeUrl = config.runtimeUrl ? config.runtimeUrl.replace(/\\/$/, \"\") : undefined;\n    const transport = config.transport ?? \"rest\";\n    const runUrl =\n      transport === \"single\"\n        ? normalizedRuntimeUrl ?? config.runtimeUrl ?? \"\"\n        : `${normalizedRuntimeUrl ?? config.runtimeUrl}/agent/${encodeURIComponent(config.agentId ?? \"\")}/run`;\n\n    if (!runUrl) {\n      throw new Error(\"ProxiedCopilotRuntimeAgent requires a runtimeUrl when transport is set to 'single'.\");\n    }\n\n    super({\n      ...config,\n      url: runUrl,\n    });\n    this.runtimeUrl = normalizedRuntimeUrl ?? config.runtimeUrl;\n    this.credentials = config.credentials;\n    this.transport = transport;\n    if (this.transport === \"single\") {\n      this.singleEndpointUrl = this.runtimeUrl;\n    }\n  }\n\n  abortRun(): void {\n    if (!this.agentId || !this.threadId) {\n      return;\n    }\n\n    if (typeof fetch === \"undefined\") {\n      return;\n    }\n\n    if (this.transport === \"single\") {\n      if (!this.singleEndpointUrl) {\n        return;\n      }\n\n      const headers = new Headers({ ...this.headers, \"Content-Type\": \"application/json\" });\n      void fetch(this.singleEndpointUrl, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify({\n          method: \"agent/stop\",\n          params: {\n            agentId: this.agentId,\n            threadId: this.threadId,\n          },\n        }),\n        ...(this.credentials ? { credentials: this.credentials } : {}),\n      }).catch((error) => {\n        console.error(\"ProxiedCopilotRuntimeAgent: stop request failed\", error);\n      });\n      return;\n    }\n\n    if (!this.runtimeUrl) {\n      return;\n    }\n\n    const stopPath = `${this.runtimeUrl}/agent/${encodeURIComponent(this.agentId)}/stop/${encodeURIComponent(this.threadId)}`;\n    const origin = typeof window !== \"undefined\" && window.location ? window.location.origin : \"http://localhost\";\n    const base = new URL(this.runtimeUrl, origin);\n    const stopUrl = new URL(stopPath, base);\n\n    void fetch(stopUrl.toString(), {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...this.headers,\n      },\n      ...(this.credentials ? { credentials: this.credentials } : {}),\n    }).catch((error) => {\n      console.error(\"ProxiedCopilotRuntimeAgent: stop request failed\", error);\n    });\n  }\n\n  connect(input: RunAgentInput): Observable<BaseEvent> {\n    if (this.transport === \"single\") {\n      if (!this.singleEndpointUrl) {\n        throw new Error(\"Single endpoint transport requires a runtimeUrl\");\n      }\n\n      const requestInit = this.createSingleRouteRequestInit(input, \"agent/connect\", {\n        agentId: this.agentId!,\n      });\n      const httpEvents = runHttpRequest(this.singleEndpointUrl, requestInit);\n      return transformHttpEventStream(httpEvents);\n    }\n\n    const httpEvents = runHttpRequest(`${this.runtimeUrl}/agent/${this.agentId}/connect`, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n\n  public run(input: RunAgentInput): Observable<BaseEvent> {\n    if (this.transport === \"single\") {\n      if (!this.singleEndpointUrl) {\n        throw new Error(\"Single endpoint transport requires a runtimeUrl\");\n      }\n\n      const requestInit = this.createSingleRouteRequestInit(input, \"agent/run\", {\n        agentId: this.agentId!,\n      });\n      const httpEvents = runHttpRequest(this.singleEndpointUrl, requestInit);\n      return transformHttpEventStream(httpEvents);\n    }\n\n    return super.run(input);\n  }\n\n  public override clone(): ProxiedCopilotRuntimeAgent {\n    const cloned = super.clone() as ProxiedCopilotRuntimeAgent;\n    cloned.runtimeUrl = this.runtimeUrl;\n    cloned.credentials = this.credentials;\n    cloned.transport = this.transport;\n    cloned.singleEndpointUrl = this.singleEndpointUrl;\n    return cloned;\n  }\n\n  private createSingleRouteRequestInit(input: RunAgentInput, method: string, params?: Record<string, string>): RequestInit {\n    if (!this.agentId) {\n      throw new Error(\"ProxiedCopilotRuntimeAgent requires agentId to make runtime requests\");\n    }\n\n    const baseInit = super.requestInit(input);\n    const headers = new Headers(baseInit.headers ?? {});\n    headers.set(\"Content-Type\", \"application/json\");\n    headers.set(\"Accept\", headers.get(\"Accept\") ?? \"text/event-stream\");\n\n    let originalBody: unknown = undefined;\n    if (typeof baseInit.body === \"string\") {\n      try {\n        originalBody = JSON.parse(baseInit.body);\n      } catch (error) {\n        console.warn(\"ProxiedCopilotRuntimeAgent: failed to parse request body for single route transport\", error);\n        originalBody = undefined;\n      }\n    }\n\n    const envelope: Record<string, unknown> = {\n      method,\n    };\n\n    if (params && Object.keys(params).length > 0) {\n      envelope.params = params;\n    }\n\n    if (originalBody !== undefined) {\n      envelope.body = originalBody;\n    }\n\n    return {\n      ...baseInit,\n      headers,\n      body: JSON.stringify(envelope),\n      ...(this.credentials ? { credentials: this.credentials } : {}),\n    };\n  }\n}\n","import { Context } from \"@ag-ui/client\";\nimport { randomUUID } from \"@copilotkitnext/shared\";\nimport type { CopilotKitCore } from \"./core\";\nimport { CopilotKitCoreFriendsAccess } from \"./core\";\n\n/**\n * Manages context storage and lifecycle for CopilotKitCore.\n * Context represents additional information available to agents during execution.\n */\nexport class ContextStore {\n  private _context: Record<string, Context> = {};\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Get all context entries as a readonly record\n   */\n  get context(): Readonly<Record<string, Context>> {\n    return this._context;\n  }\n\n  /**\n   * Add a new context entry\n   * @returns The ID of the created context entry\n   */\n  addContext({ description, value }: Context): string {\n    const id = randomUUID();\n    this._context[id] = { description, value };\n    void this.notifySubscribers();\n    return id;\n  }\n\n  /**\n   * Remove a context entry by ID\n   */\n  removeContext(id: string): void {\n    delete this._context[id];\n    void this.notifySubscribers();\n  }\n\n  /**\n   * Notify all subscribers of context changes\n   */\n  private async notifySubscribers(): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onContextChanged?.({\n          copilotkit: this.core,\n          context: this._context,\n        }),\n      \"Subscriber onContextChanged error:\",\n    );\n  }\n}\n","import { AbstractAgent, Message, Tool, Context } from \"@ag-ui/client\";\nimport { randomUUID, partialJSONParse } from \"@copilotkitnext/shared\";\nimport type { CopilotKitCore } from \"./core\";\nimport type { CopilotKitCoreGetSuggestionsResult } from \"./core\";\nimport { CopilotKitCoreFriendsAccess } from \"./core\";\nimport { DynamicSuggestionsConfig, StaticSuggestionsConfig, Suggestion, SuggestionsConfig } from \"../types\";\n\n/**\n * Manages suggestion generation, streaming, and lifecycle for CopilotKitCore.\n * Handles both dynamic (AI-generated) and static suggestions.\n */\nexport class SuggestionEngine {\n  private _suggestionsConfig: Record<string, SuggestionsConfig> = {};\n  private _suggestions: Record<string, Record<string, Suggestion[]>> = {};\n  private _runningSuggestions: Record<string, AbstractAgent[]> = {};\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Initialize with suggestion configs\n   */\n  initialize(suggestionsConfig: SuggestionsConfig[]): void {\n    for (const config of suggestionsConfig) {\n      this._suggestionsConfig[randomUUID()] = config;\n    }\n  }\n\n  /**\n   * Add a suggestion configuration\n   * @returns The ID of the created config\n   */\n  addSuggestionsConfig(config: SuggestionsConfig): string {\n    const id = randomUUID();\n    this._suggestionsConfig[id] = config;\n    void this.notifySuggestionsConfigChanged();\n    return id;\n  }\n\n  /**\n   * Remove a suggestion configuration by ID\n   */\n  removeSuggestionsConfig(id: string): void {\n    delete this._suggestionsConfig[id];\n    void this.notifySuggestionsConfigChanged();\n  }\n\n  /**\n   * Reload suggestions for a specific agent\n   * This triggers generation of new suggestions based on current configs\n   */\n  public reloadSuggestions(agentId: string): void {\n    this.clearSuggestions(agentId);\n\n    // Get agent to check message count for availability filtering\n    const agent = (this.core as unknown as CopilotKitCoreFriendsAccess).getAgent(agentId);\n    if (!agent) {\n      return;\n    }\n\n    const messageCount = agent.messages?.length ?? 0;\n    let hasAnySuggestions = false;\n\n    for (const config of Object.values(this._suggestionsConfig)) {\n      // Check if config applies to this agent\n      if (\n        config.consumerAgentId !== undefined &&\n        config.consumerAgentId !== \"*\" &&\n        config.consumerAgentId !== agentId\n      ) {\n        continue;\n      }\n\n      // Check availability based on message count\n      if (!this.shouldShowSuggestions(config, messageCount)) {\n        continue;\n      }\n\n      const suggestionId = randomUUID();\n\n      if (isDynamicSuggestionsConfig(config)) {\n        if (!hasAnySuggestions) {\n          hasAnySuggestions = true;\n          void this.notifySuggestionsStartedLoading(agentId);\n        }\n        void this.generateSuggestions(suggestionId, config, agentId);\n      } else if (isStaticSuggestionsConfig(config)) {\n        this.addStaticSuggestions(suggestionId, config, agentId);\n      }\n    }\n  }\n\n  /**\n   * Clear all suggestions for a specific agent\n   */\n  public clearSuggestions(agentId: string): void {\n    const runningAgents = this._runningSuggestions[agentId];\n    if (runningAgents) {\n      for (const agent of runningAgents) {\n        agent.abortRun();\n      }\n      delete this._runningSuggestions[agentId];\n    }\n    this._suggestions[agentId] = {};\n\n    void this.notifySuggestionsChanged(agentId, []);\n  }\n\n  /**\n   * Get current suggestions for an agent\n   */\n  public getSuggestions(agentId: string): CopilotKitCoreGetSuggestionsResult {\n    const suggestions = Object.values(this._suggestions[agentId] ?? {}).flat();\n    const isLoading = (this._runningSuggestions[agentId]?.length ?? 0) > 0;\n    return { suggestions, isLoading };\n  }\n\n  /**\n   * Generate suggestions using a provider agent\n   */\n  private async generateSuggestions(\n    suggestionId: string,\n    config: DynamicSuggestionsConfig,\n    consumerAgentId: string,\n  ): Promise<void> {\n    let agent: AbstractAgent | undefined = undefined;\n    try {\n      const suggestionsProviderAgent = (this.core as unknown as CopilotKitCoreFriendsAccess).getAgent(\n        config.providerAgentId ?? \"default\",\n      );\n      if (!suggestionsProviderAgent) {\n        throw new Error(`Suggestions provider agent not found: ${config.providerAgentId}`);\n      }\n      const suggestionsConsumerAgent = (this.core as unknown as CopilotKitCoreFriendsAccess).getAgent(consumerAgentId);\n      if (!suggestionsConsumerAgent) {\n        throw new Error(`Suggestions consumer agent not found: ${consumerAgentId}`);\n      }\n\n      const clonedAgent: AbstractAgent = suggestionsProviderAgent.clone();\n      agent = clonedAgent;\n      //agent.agentId = suggestionId;\n      agent.threadId = suggestionId;\n      agent.messages = JSON.parse(JSON.stringify(suggestionsConsumerAgent.messages));\n      agent.state = JSON.parse(JSON.stringify(suggestionsConsumerAgent.state));\n\n      // Initialize suggestion storage for this agent/suggestion combo\n      this._suggestions[consumerAgentId] = {\n        ...(this._suggestions[consumerAgentId] ?? {}),\n        [suggestionId]: [],\n      };\n      this._runningSuggestions[consumerAgentId] = [...(this._runningSuggestions[consumerAgentId] ?? []), agent];\n\n      agent.addMessage({\n        id: suggestionId,\n        role: \"user\",\n        content: [\n          `Suggest what the user could say next. Provide clear, highly relevant suggestions by calling the \\`copilotkitSuggest\\` tool.`,\n          `Provide at least ${config.minSuggestions ?? 1} and at most ${config.maxSuggestions ?? 3} suggestions.`,\n          `The user has the following tools available: ${JSON.stringify((this.core as unknown as CopilotKitCoreFriendsAccess).buildFrontendTools(consumerAgentId))}.`,\n          ` ${config.instructions}`,\n        ].join(\"\\n\"),\n      });\n\n      await agent.runAgent(\n        {\n          context: Object.values((this.core as unknown as CopilotKitCoreFriendsAccess).context),\n          forwardedProps: {\n            ...(this.core as unknown as CopilotKitCoreFriendsAccess).properties,\n            toolChoice: { type: \"function\", function: { name: \"copilotkitSuggest\" } },\n          },\n          tools: [SUGGEST_TOOL],\n        },\n        {\n          onMessagesChanged: ({ messages }: { messages: Message[] }) => {\n            this.extractSuggestions(messages, suggestionId, consumerAgentId, true);\n          },\n        },\n      );\n    } catch (error) {\n      console.warn(\"Error generating suggestions:\", error);\n    } finally {\n      // Finalize suggestions by marking them as no longer loading\n      this.finalizeSuggestions(suggestionId, consumerAgentId);\n\n      // Remove this agent from running suggestions\n      const runningAgents = this._runningSuggestions[consumerAgentId];\n      if (agent && runningAgents) {\n        const filteredAgents = runningAgents.filter((a) => a !== agent);\n        this._runningSuggestions[consumerAgentId] = filteredAgents;\n\n        // If no more suggestions are running, emit loading end event\n        if (filteredAgents.length === 0) {\n          delete this._runningSuggestions[consumerAgentId];\n          await this.notifySuggestionsFinishedLoading(consumerAgentId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Finalize suggestions by marking them as no longer loading\n   */\n  private finalizeSuggestions(suggestionId: string, consumerAgentId: string): void {\n    const agentSuggestions = this._suggestions[consumerAgentId];\n    const currentSuggestions = agentSuggestions?.[suggestionId];\n\n    if (agentSuggestions && currentSuggestions && currentSuggestions.length > 0) {\n      // Filter out empty suggestions and mark remaining as no longer loading\n      const finalizedSuggestions = currentSuggestions\n        .filter((suggestion) => suggestion.title !== \"\" || suggestion.message !== \"\")\n        .map((suggestion) => ({\n          ...suggestion,\n          isLoading: false,\n        }));\n\n      if (finalizedSuggestions.length > 0) {\n        agentSuggestions[suggestionId] = finalizedSuggestions;\n      } else {\n        delete agentSuggestions[suggestionId];\n      }\n\n      // Get all aggregated suggestions for this agent\n      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();\n\n      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, \"finalized\");\n    }\n  }\n\n  /**\n   * Extract suggestions from messages (called during streaming)\n   */\n  extractSuggestions(messages: Message[], suggestionId: string, consumerAgentId: string, isRunning: boolean): void {\n    const idx = messages.findIndex((message) => message.id === suggestionId);\n    if (idx == -1) {\n      return;\n    }\n\n    const suggestions: Suggestion[] = [];\n    const newMessages = messages.slice(idx + 1);\n\n    for (const message of newMessages) {\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          if (toolCall.function.name === \"copilotkitSuggest\") {\n            // Join all argument chunks into a single string for parsing\n            // arguments can be either a string or an array of strings\n            const fullArgs = Array.isArray(toolCall.function.arguments)\n              ? toolCall.function.arguments.join(\"\")\n              : toolCall.function.arguments;\n            const parsed = partialJSONParse(fullArgs);\n            if (parsed && typeof parsed === \"object\" && \"suggestions\" in parsed) {\n              const parsedSuggestions = (parsed as any).suggestions;\n              if (Array.isArray(parsedSuggestions)) {\n                for (const item of parsedSuggestions) {\n                  if (item && typeof item === \"object\" && \"title\" in item) {\n                    suggestions.push({\n                      title: item.title ?? \"\",\n                      message: item.message ?? \"\",\n                      isLoading: false, // Will be set correctly below\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Set isLoading for the last suggestion if still running\n    if (isRunning && suggestions.length > 0) {\n      suggestions[suggestions.length - 1]!.isLoading = true;\n    }\n\n    const agentSuggestions = this._suggestions[consumerAgentId];\n    if (agentSuggestions) {\n      agentSuggestions[suggestionId] = suggestions;\n\n      // Get all aggregated suggestions for this agent\n      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();\n\n      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, \"suggestions changed\");\n    }\n  }\n\n  /**\n   * Notify subscribers of suggestions config changes\n   */\n  private async notifySuggestionsConfigChanged(): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsConfigChanged?.({\n          copilotkit: this.core,\n          suggestionsConfig: this._suggestionsConfig,\n        }),\n      \"Subscriber onSuggestionsConfigChanged error:\",\n    );\n  }\n\n  /**\n   * Notify subscribers of suggestions changes\n   */\n  private async notifySuggestionsChanged(\n    agentId: string,\n    suggestions: Suggestion[],\n    context: string = \"\",\n  ): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsChanged?.({\n          copilotkit: this.core,\n          agentId,\n          suggestions,\n        }),\n      `Subscriber onSuggestionsChanged error: ${context}`,\n    );\n  }\n\n  /**\n   * Notify subscribers that suggestions started loading\n   */\n  private async notifySuggestionsStartedLoading(agentId: string): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsStartedLoading?.({\n          copilotkit: this.core,\n          agentId,\n        }),\n      \"Subscriber onSuggestionsStartedLoading error:\",\n    );\n  }\n\n  /**\n   * Notify subscribers that suggestions finished loading\n   */\n  private async notifySuggestionsFinishedLoading(agentId: string): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsFinishedLoading?.({\n          copilotkit: this.core,\n          agentId,\n        }),\n      \"Subscriber onSuggestionsFinishedLoading error:\",\n    );\n  }\n\n  /**\n   * Check if suggestions should be shown based on availability and message count\n   */\n  private shouldShowSuggestions(config: SuggestionsConfig, messageCount: number): boolean {\n    const availability = config.available;\n\n    // Default behavior if no availability specified\n    if (!availability) {\n      if (isDynamicSuggestionsConfig(config)) {\n        return messageCount > 0; // Default: after-first-message\n      } else {\n        return messageCount === 0; // Default: before-first-message\n      }\n    }\n\n    switch (availability) {\n      case \"disabled\":\n        return false;\n      case \"before-first-message\":\n        return messageCount === 0;\n      case \"after-first-message\":\n        return messageCount > 0;\n      case \"always\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Add static suggestions directly without AI generation\n   */\n  private addStaticSuggestions(suggestionId: string, config: StaticSuggestionsConfig, consumerAgentId: string): void {\n    // Mark all as not loading since they're static\n    const suggestions = config.suggestions.map((s) => ({\n      ...s,\n      isLoading: false,\n    }));\n\n    // Store suggestions\n    this._suggestions[consumerAgentId] = {\n      ...(this._suggestions[consumerAgentId] ?? {}),\n      [suggestionId]: suggestions,\n    };\n\n    // Notify subscribers\n    const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();\n\n    void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, \"static suggestions added\");\n  }\n}\n\n/**\n * Type guard for dynamic suggestions config\n */\nfunction isDynamicSuggestionsConfig(config: SuggestionsConfig): config is DynamicSuggestionsConfig {\n  return \"instructions\" in config;\n}\n\n/**\n * Type guard for static suggestions config\n */\nfunction isStaticSuggestionsConfig(config: SuggestionsConfig): config is StaticSuggestionsConfig {\n  return \"suggestions\" in config;\n}\n\n/**\n * The tool definition for AI-generated suggestions\n */\nconst SUGGEST_TOOL: Tool = {\n  name: \"copilotkitSuggest\",\n  description: \"Suggest what the user could say next\",\n  parameters: {\n    type: \"object\",\n    properties: {\n      suggestions: {\n        type: \"array\",\n        description: \"List of suggestions shown to the user as buttons.\",\n        items: {\n          type: \"object\",\n          properties: {\n            title: {\n              type: \"string\",\n              description: \"The title of the suggestion. This is shown as a button and should be short.\",\n            },\n            message: {\n              type: \"string\",\n              description:\n                \"The message to send when the suggestion is clicked. This should be a clear, complete sentence \" +\n                \"and will be sent as an instruction to the AI.\",\n            },\n          },\n          required: [\"title\", \"message\"],\n        },\n      },\n    },\n    required: [\"suggestions\"],\n  },\n};\n","import { AbstractAgent, AgentSubscriber, HttpAgent, Message, RunAgentResult, Tool } from \"@ag-ui/client\";\nimport { randomUUID, logger } from \"@copilotkitnext/shared\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport type { CopilotKitCore } from \"./core\";\nimport { CopilotKitCoreErrorCode, CopilotKitCoreFriendsAccess } from \"./core\";\nimport { FrontendTool } from \"../types\";\n\nexport interface CopilotKitCoreRunAgentParams {\n  agent: AbstractAgent;\n}\n\nexport interface CopilotKitCoreConnectAgentParams {\n  agent: AbstractAgent;\n}\n\nexport interface CopilotKitCoreGetToolParams {\n  toolName: string;\n  agentId?: string;\n}\n\n/**\n * Handles agent execution, tool calling, and agent connectivity for CopilotKitCore.\n * Manages the complete lifecycle of agent runs including tool execution and follow-ups.\n */\nexport class RunHandler {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _tools: FrontendTool<any>[] = [];\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Get all tools as a readonly array\n   */\n  get tools(): Readonly<FrontendTool<any>[]> {\n    return this._tools;\n  }\n\n  /**\n   * Initialize with tools\n   */\n  initialize(tools: FrontendTool<any>[]): void {\n    this._tools = tools;\n  }\n\n  /**\n   * Add a tool to the registry\n   */\n  addTool<T extends Record<string, unknown> = Record<string, unknown>>(tool: FrontendTool<T>): void {\n    // Check if a tool with the same name and agentId already exists\n    const existingToolIndex = this._tools.findIndex((t) => t.name === tool.name && t.agentId === tool.agentId);\n\n    if (existingToolIndex !== -1) {\n      logger.warn(`Tool already exists: '${tool.name}' for agent '${tool.agentId || \"global\"}', skipping.`);\n      return;\n    }\n\n    this._tools.push(tool);\n  }\n\n  /**\n   * Remove a tool by name and optionally by agentId\n   */\n  removeTool(id: string, agentId?: string): void {\n    this._tools = this._tools.filter((tool) => {\n      // Remove tool if both name and agentId match\n      if (agentId !== undefined) {\n        return !(tool.name === id && tool.agentId === agentId);\n      }\n      // If no agentId specified, only remove global tools with matching name\n      return !(tool.name === id && !tool.agentId);\n    });\n  }\n\n  /**\n   * Get a tool by name and optionally by agentId.\n   * If agentId is provided, it will first look for an agent-specific tool,\n   * then fall back to a global tool with the same name.\n   */\n  getTool(params: CopilotKitCoreGetToolParams): FrontendTool<any> | undefined {\n    const { toolName, agentId } = params;\n\n    // If agentId is provided, first look for agent-specific tool\n    if (agentId) {\n      const agentTool = this._tools.find((tool) => tool.name === toolName && tool.agentId === agentId);\n      if (agentTool) {\n        return agentTool;\n      }\n    }\n\n    // Fall back to global tool (no agentId)\n    return this._tools.find((tool) => tool.name === toolName && !tool.agentId);\n  }\n\n  /**\n   * Set all tools at once. Replaces existing tools.\n   */\n  setTools(tools: FrontendTool<any>[]): void {\n    this._tools = [...tools];\n  }\n\n  /**\n   * Connect an agent (establish initial connection)\n   */\n  async connectAgent({ agent }: CopilotKitCoreConnectAgentParams): Promise<RunAgentResult> {\n    try {\n      // Detach any active run before connecting to avoid previous runs interfering\n      await agent.detachActiveRun();\n      agent.setMessages([]);\n      agent.setState({});\n\n      if (agent instanceof HttpAgent) {\n        agent.headers = { ...(this.core as unknown as CopilotKitCoreFriendsAccess).headers };\n      }\n\n      const runAgentResult = await agent.connectAgent(\n        {\n          forwardedProps: (this.core as unknown as CopilotKitCoreFriendsAccess).properties,\n          tools: this.buildFrontendTools(agent.agentId),\n        },\n        this.createAgentErrorSubscriber(agent),\n      );\n\n      return this.processAgentResult({ runAgentResult, agent });\n    } catch (error) {\n      const connectError = error instanceof Error ? error : new Error(String(error));\n      const context: Record<string, any> = {};\n      if (agent.agentId) {\n        context.agentId = agent.agentId;\n      }\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error: connectError,\n        code: CopilotKitCoreErrorCode.AGENT_CONNECT_FAILED,\n        context,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Run an agent\n   */\n  async runAgent({ agent }: CopilotKitCoreRunAgentParams): Promise<RunAgentResult> {\n    // Agent ID is guaranteed to be set by validateAndAssignAgentId\n    if (agent.agentId) {\n      void (this.core as unknown as CopilotKitCoreFriendsAccess).suggestionEngine.clearSuggestions(agent.agentId);\n    }\n\n    if (agent instanceof HttpAgent) {\n      agent.headers = { ...(this.core as unknown as CopilotKitCoreFriendsAccess).headers };\n    }\n\n    try {\n      const runAgentResult = await agent.runAgent(\n        {\n          forwardedProps: (this.core as unknown as CopilotKitCoreFriendsAccess).properties,\n          tools: this.buildFrontendTools(agent.agentId),\n          context: Object.values((this.core as unknown as CopilotKitCoreFriendsAccess).context),\n        },\n        this.createAgentErrorSubscriber(agent),\n      );\n      return this.processAgentResult({ runAgentResult, agent });\n    } catch (error) {\n      const runError = error instanceof Error ? error : new Error(String(error));\n      const context: Record<string, any> = {};\n      if (agent.agentId) {\n        context.agentId = agent.agentId;\n      }\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error: runError,\n        code: CopilotKitCoreErrorCode.AGENT_RUN_FAILED,\n        context,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Process agent result and execute tools\n   */\n  private async processAgentResult({\n    runAgentResult,\n    agent,\n  }: {\n    runAgentResult: RunAgentResult;\n    agent: AbstractAgent;\n  }): Promise<RunAgentResult> {\n    const { newMessages } = runAgentResult;\n    // Agent ID is guaranteed to be set by validateAndAssignAgentId\n    const agentId = agent.agentId!;\n\n    let needsFollowUp = false;\n\n    for (const message of newMessages) {\n      if (message.role === \"assistant\") {\n        for (const toolCall of message.toolCalls || []) {\n          if (newMessages.findIndex((m) => m.role === \"tool\" && m.toolCallId === toolCall.id) === -1) {\n            const tool = this.getTool({\n              toolName: toolCall.function.name,\n              agentId: agent.agentId,\n            });\n            if (tool) {\n              const followUp = await this.executeSpecificTool(tool, toolCall, message, agent, agentId);\n              if (followUp) {\n                needsFollowUp = true;\n              }\n            } else {\n              // Wildcard fallback for undefined tools\n              const wildcardTool = this.getTool({ toolName: \"*\", agentId: agent.agentId });\n              if (wildcardTool) {\n                const followUp = await this.executeWildcardTool(wildcardTool, toolCall, message, agent, agentId);\n                if (followUp) {\n                  needsFollowUp = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (needsFollowUp) {\n      return await this.runAgent({ agent });\n    }\n\n    void (this.core as unknown as CopilotKitCoreFriendsAccess).suggestionEngine.reloadSuggestions(agentId);\n\n    return runAgentResult;\n  }\n\n  /**\n   * Execute a specific tool\n   */\n  private async executeSpecificTool(\n    tool: FrontendTool<any>,\n    toolCall: any,\n    message: Message,\n    agent: AbstractAgent,\n    agentId: string,\n  ): Promise<boolean> {\n    // Check if tool is constrained to a specific agent\n    if (tool?.agentId && tool.agentId !== agent.agentId) {\n      // Tool is not available for this agent, skip it\n      return false;\n    }\n\n    let toolCallResult = \"\";\n    let errorMessage: string | undefined;\n    let isArgumentError = false;\n\n    if (tool?.handler) {\n      let parsedArgs: unknown;\n      try {\n        parsedArgs = JSON.parse(toolCall.function.arguments);\n      } catch (error) {\n        const parseError = error instanceof Error ? error : new Error(String(error));\n        errorMessage = parseError.message;\n        isArgumentError = true;\n        await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n          error: parseError,\n          code: CopilotKitCoreErrorCode.TOOL_ARGUMENT_PARSE_FAILED,\n          context: {\n            agentId: agentId,\n            toolCallId: toolCall.id,\n            toolName: toolCall.function.name,\n            rawArguments: toolCall.function.arguments,\n            toolType: \"specific\",\n            messageId: message.id,\n          },\n        });\n      }\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionStart?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            args: parsedArgs,\n          }),\n        \"Subscriber onToolExecutionStart error:\",\n      );\n\n      if (!errorMessage) {\n        try {\n          const result = await tool.handler(parsedArgs as any, toolCall);\n          if (result === undefined || result === null) {\n            toolCallResult = \"\";\n          } else if (typeof result === \"string\") {\n            toolCallResult = result;\n          } else {\n            toolCallResult = JSON.stringify(result);\n          }\n        } catch (error) {\n          const handlerError = error instanceof Error ? error : new Error(String(error));\n          errorMessage = handlerError.message;\n          await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n            error: handlerError,\n            code: CopilotKitCoreErrorCode.TOOL_HANDLER_FAILED,\n            context: {\n              agentId: agentId,\n              toolCallId: toolCall.id,\n              toolName: toolCall.function.name,\n              parsedArgs,\n              toolType: \"specific\",\n              messageId: message.id,\n            },\n          });\n        }\n      }\n\n      if (errorMessage) {\n        toolCallResult = `Error: ${errorMessage}`;\n      }\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionEnd?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            result: errorMessage ? \"\" : toolCallResult,\n            error: errorMessage,\n          }),\n        \"Subscriber onToolExecutionEnd error:\",\n      );\n\n      if (isArgumentError) {\n        throw new Error(errorMessage ?? \"Tool execution failed\");\n      }\n    }\n\n    if (!errorMessage || !isArgumentError) {\n      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);\n      const toolMessage = {\n        id: randomUUID(),\n        role: \"tool\" as const,\n        toolCallId: toolCall.id,\n        content: toolCallResult,\n      };\n      agent.messages.splice(messageIndex + 1, 0, toolMessage);\n\n      if (!errorMessage && tool?.followUp !== false) {\n        return true; // Needs follow-up\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute a wildcard tool\n   */\n  private async executeWildcardTool(\n    wildcardTool: FrontendTool<any>,\n    toolCall: any,\n    message: Message,\n    agent: AbstractAgent,\n    agentId: string,\n  ): Promise<boolean> {\n    // Check if wildcard tool is constrained to a specific agent\n    if (wildcardTool?.agentId && wildcardTool.agentId !== agent.agentId) {\n      // Wildcard tool is not available for this agent, skip it\n      return false;\n    }\n\n    let toolCallResult = \"\";\n    let errorMessage: string | undefined;\n    let isArgumentError = false;\n\n    if (wildcardTool?.handler) {\n      let parsedArgs: unknown;\n      try {\n        parsedArgs = JSON.parse(toolCall.function.arguments);\n      } catch (error) {\n        const parseError = error instanceof Error ? error : new Error(String(error));\n        errorMessage = parseError.message;\n        isArgumentError = true;\n        await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n          error: parseError,\n          code: CopilotKitCoreErrorCode.TOOL_ARGUMENT_PARSE_FAILED,\n          context: {\n            agentId: agentId,\n            toolCallId: toolCall.id,\n            toolName: toolCall.function.name,\n            rawArguments: toolCall.function.arguments,\n            toolType: \"wildcard\",\n            messageId: message.id,\n          },\n        });\n      }\n\n      const wildcardArgs = {\n        toolName: toolCall.function.name,\n        args: parsedArgs,\n      };\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionStart?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            args: wildcardArgs,\n          }),\n        \"Subscriber onToolExecutionStart error:\",\n      );\n\n      if (!errorMessage) {\n        try {\n          const result = await wildcardTool.handler(wildcardArgs as any, toolCall);\n          if (result === undefined || result === null) {\n            toolCallResult = \"\";\n          } else if (typeof result === \"string\") {\n            toolCallResult = result;\n          } else {\n            toolCallResult = JSON.stringify(result);\n          }\n        } catch (error) {\n          const handlerError = error instanceof Error ? error : new Error(String(error));\n          errorMessage = handlerError.message;\n          await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n            error: handlerError,\n            code: CopilotKitCoreErrorCode.TOOL_HANDLER_FAILED,\n            context: {\n              agentId: agentId,\n              toolCallId: toolCall.id,\n              toolName: toolCall.function.name,\n              parsedArgs: wildcardArgs,\n              toolType: \"wildcard\",\n              messageId: message.id,\n            },\n          });\n        }\n      }\n\n      if (errorMessage) {\n        toolCallResult = `Error: ${errorMessage}`;\n      }\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionEnd?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            result: errorMessage ? \"\" : toolCallResult,\n            error: errorMessage,\n          }),\n        \"Subscriber onToolExecutionEnd error:\",\n      );\n\n      if (isArgumentError) {\n        throw new Error(errorMessage ?? \"Tool execution failed\");\n      }\n    }\n\n    if (!errorMessage || !isArgumentError) {\n      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);\n      const toolMessage = {\n        id: randomUUID(),\n        role: \"tool\" as const,\n        toolCallId: toolCall.id,\n        content: toolCallResult,\n      };\n      agent.messages.splice(messageIndex + 1, 0, toolMessage);\n\n      if (!errorMessage && wildcardTool?.followUp !== false) {\n        return true; // Needs follow-up\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Build frontend tools for an agent\n   */\n  buildFrontendTools(agentId?: string): Tool[] {\n    return this._tools\n      .filter((tool) => !tool.agentId || tool.agentId === agentId)\n      .map((tool) => ({\n        name: tool.name,\n        description: tool.description ?? \"\",\n        parameters: createToolSchema(tool),\n      }));\n  }\n\n  /**\n   * Create an agent error subscriber\n   */\n  private createAgentErrorSubscriber(agent: AbstractAgent): AgentSubscriber {\n    const emitAgentError = async (\n      error: Error,\n      code: CopilotKitCoreErrorCode,\n      extraContext: Record<string, any> = {},\n    ) => {\n      const context: Record<string, any> = { ...extraContext };\n      if (agent.agentId) {\n        context.agentId = agent.agentId;\n      }\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error,\n        code,\n        context,\n      });\n    };\n\n    return {\n      onRunFailed: async ({ error }: { error: Error }) => {\n        await emitAgentError(error, CopilotKitCoreErrorCode.AGENT_RUN_FAILED_EVENT, {\n          source: \"onRunFailed\",\n        });\n      },\n      onRunErrorEvent: async ({ event }) => {\n        const eventError =\n          event?.rawEvent instanceof Error\n            ? event.rawEvent\n            : event?.rawEvent?.error instanceof Error\n              ? event.rawEvent.error\n              : undefined;\n\n        const errorMessage =\n          typeof event?.rawEvent?.error === \"string\" ? event.rawEvent.error : (event?.message ?? \"Agent run error\");\n\n        const rawError = eventError ?? new Error(errorMessage);\n\n        if (event?.code && !(rawError as any).code) {\n          (rawError as any).code = event.code;\n        }\n\n        await emitAgentError(rawError, CopilotKitCoreErrorCode.AGENT_RUN_ERROR_EVENT, {\n          source: \"onRunErrorEvent\",\n          event,\n          runtimeErrorCode: event?.code,\n        });\n      },\n    };\n  }\n}\n\n/**\n * Empty tool schema constant\n */\nconst EMPTY_TOOL_SCHEMA = {\n  type: \"object\",\n  properties: {},\n} as const satisfies Record<string, unknown>;\n\n/**\n * Create a JSON schema from a tool's parameters\n */\nfunction createToolSchema(tool: FrontendTool<any>): Record<string, unknown> {\n  if (!tool.parameters) {\n    return { ...EMPTY_TOOL_SCHEMA };\n  }\n\n  const rawSchema = zodToJsonSchema(tool.parameters, {\n    $refStrategy: \"none\",\n  });\n\n  if (!rawSchema || typeof rawSchema !== \"object\") {\n    return { ...EMPTY_TOOL_SCHEMA };\n  }\n\n  const { $schema, ...schema } = rawSchema as Record<string, unknown>;\n\n  if (typeof schema.type !== \"string\") {\n    schema.type = \"object\";\n  }\n  if (typeof schema.properties !== \"object\" || schema.properties === null) {\n    schema.properties = {};\n  }\n\n  stripAdditionalProperties(schema);\n  return schema;\n}\n\nfunction stripAdditionalProperties(schema: unknown): void {\n  if (!schema || typeof schema !== \"object\") {\n    return;\n  }\n\n  if (Array.isArray(schema)) {\n    schema.forEach(stripAdditionalProperties);\n    return;\n  }\n\n  const record = schema as Record<string, unknown>;\n\n  if (record.additionalProperties !== undefined) {\n    delete record.additionalProperties;\n  }\n\n  for (const value of Object.values(record)) {\n    stripAdditionalProperties(value);\n  }\n}\n","import {\n  AbstractAgent,\n  Message,\n  State,\n  RunAgentInput,\n  RunStartedEvent,\n  RunFinishedEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n} from \"@ag-ui/client\";\nimport type { CopilotKitCore } from \"./core\";\n\n/**\n * Manages state and message tracking by run for CopilotKitCore.\n * Tracks agent state snapshots and message-to-run associations.\n */\nexport class StateManager {\n  // State tracking: agentId -> threadId -> runId -> state\n  private stateByRun: Map<string, Map<string, Map<string, State>>> = new Map();\n\n  // Message tracking: agentId -> threadId -> messageId -> runId\n  private messageToRun: Map<string, Map<string, Map<string, string>>> = new Map();\n\n  // Agent subscriptions for cleanup\n  private agentSubscriptions: Map<string, () => void> = new Map();\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Initialize state tracking for an agent\n   */\n  initialize(): void {\n    // Will be called when CopilotKitCore is initialized\n  }\n\n  /**\n   * Subscribe to an agent's events to track state and messages\n   */\n  subscribeToAgent(agent: AbstractAgent): void {\n    if (!agent.agentId) {\n      return; // Skip agents without IDs\n    }\n\n    const agentId = agent.agentId;\n\n    // Unsubscribe existing subscription if any\n    this.unsubscribeFromAgent(agentId);\n\n    // Subscribe to agent events\n    const { unsubscribe } = agent.subscribe({\n      onRunStartedEvent: ({ event, state }) => {\n        this.handleRunStarted(agent, event, state);\n      },\n      onRunFinishedEvent: ({ event, state }) => {\n        this.handleRunFinished(agent, event, state);\n      },\n      onStateSnapshotEvent: ({ event, input, state }) => {\n        this.handleStateSnapshot(agent, event, input, state);\n      },\n      onStateDeltaEvent: ({ event, input, state }) => {\n        this.handleStateDelta(agent, event, input, state);\n      },\n      onMessagesSnapshotEvent: ({ event, input, messages }) => {\n        this.handleMessagesSnapshot(agent, event, input, messages);\n      },\n      onNewMessage: ({ message, input }) => {\n        this.handleNewMessage(agent, message, input);\n      },\n    });\n\n    this.agentSubscriptions.set(agentId, unsubscribe);\n  }\n\n  /**\n   * Unsubscribe from an agent's events\n   */\n  unsubscribeFromAgent(agentId: string): void {\n    const unsubscribe = this.agentSubscriptions.get(agentId);\n    if (unsubscribe) {\n      unsubscribe();\n      this.agentSubscriptions.delete(agentId);\n    }\n  }\n\n  /**\n   * Get state for a specific run\n   * Returns a deep copy to prevent external mutations\n   */\n  getStateByRun(agentId: string, threadId: string, runId: string): State | undefined {\n    const state = this.stateByRun.get(agentId)?.get(threadId)?.get(runId);\n    if (!state) return undefined;\n    // Return a deep copy to prevent mutations\n    return JSON.parse(JSON.stringify(state));\n  }\n\n  /**\n   * Get runId associated with a message\n   */\n  getRunIdForMessage(agentId: string, threadId: string, messageId: string): string | undefined {\n    return this.messageToRun.get(agentId)?.get(threadId)?.get(messageId);\n  }\n\n  /**\n   * Get all states for an agent's thread\n   */\n  getStatesForThread(agentId: string, threadId: string): Map<string, State> {\n    return this.stateByRun.get(agentId)?.get(threadId) ?? new Map();\n  }\n\n  /**\n   * Get all run IDs for an agent's thread\n   */\n  getRunIdsForThread(agentId: string, threadId: string): string[] {\n    const threadStates = this.stateByRun.get(agentId)?.get(threadId);\n    return threadStates ? Array.from(threadStates.keys()) : [];\n  }\n\n  /**\n   * Handle run started event\n   */\n  private handleRunStarted(agent: AbstractAgent, event: RunStartedEvent, state: State): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = event;\n    this.saveState(agent.agentId, threadId, runId, state);\n  }\n\n  /**\n   * Handle run finished event\n   */\n  private handleRunFinished(agent: AbstractAgent, event: RunFinishedEvent, state: State): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = event;\n    this.saveState(agent.agentId, threadId, runId, state);\n  }\n\n  /**\n   * Handle state snapshot event\n   */\n  private handleStateSnapshot(\n    agent: AbstractAgent,\n    event: StateSnapshotEvent,\n    input: RunAgentInput,\n    state: State,\n  ): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = input;\n    // Merge snapshot into current state\n    const mergedState = { ...state, ...event.snapshot };\n    this.saveState(agent.agentId, threadId, runId, mergedState);\n  }\n\n  /**\n   * Handle state delta event\n   */\n  private handleStateDelta(agent: AbstractAgent, event: StateDeltaEvent, input: RunAgentInput, state: State): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = input;\n    // State is already updated by the agent, just save it\n    this.saveState(agent.agentId, threadId, runId, state);\n  }\n\n  /**\n   * Handle messages snapshot event\n   */\n  private handleMessagesSnapshot(\n    agent: AbstractAgent,\n    event: MessagesSnapshotEvent,\n    input: RunAgentInput,\n    messages: Message[],\n  ): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = input;\n\n    // Associate all messages in the snapshot with this run\n    for (const message of event.messages) {\n      this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);\n    }\n  }\n\n  /**\n   * Handle new message event\n   */\n  private handleNewMessage(agent: AbstractAgent, message: Message, input?: RunAgentInput): void {\n    if (!agent.agentId || !input) return;\n\n    const { threadId, runId } = input;\n    this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);\n  }\n\n  /**\n   * Save state for a specific run\n   */\n  private saveState(agentId: string, threadId: string, runId: string, state: State): void {\n    // Ensure nested maps exist\n    if (!this.stateByRun.has(agentId)) {\n      this.stateByRun.set(agentId, new Map());\n    }\n    const agentStates = this.stateByRun.get(agentId)!;\n\n    if (!agentStates.has(threadId)) {\n      agentStates.set(threadId, new Map());\n    }\n    const threadStates = agentStates.get(threadId)!;\n\n    // Deep copy the state to prevent mutations\n    threadStates.set(runId, JSON.parse(JSON.stringify(state)));\n  }\n\n  /**\n   * Associate a message with a run\n   */\n  private associateMessageWithRun(agentId: string, threadId: string, messageId: string, runId: string): void {\n    // Ensure nested maps exist\n    if (!this.messageToRun.has(agentId)) {\n      this.messageToRun.set(agentId, new Map());\n    }\n    const agentMessages = this.messageToRun.get(agentId)!;\n\n    if (!agentMessages.has(threadId)) {\n      agentMessages.set(threadId, new Map());\n    }\n    const threadMessages = agentMessages.get(threadId)!;\n\n    threadMessages.set(messageId, runId);\n  }\n\n  /**\n   * Clear all state for an agent\n   */\n  clearAgentState(agentId: string): void {\n    this.stateByRun.delete(agentId);\n    this.messageToRun.delete(agentId);\n  }\n\n  /**\n   * Clear all state for a thread\n   */\n  clearThreadState(agentId: string, threadId: string): void {\n    this.stateByRun.get(agentId)?.delete(threadId);\n    this.messageToRun.get(agentId)?.delete(threadId);\n  }\n}\n","import { AbstractAgent, Context, State } from \"@ag-ui/client\";\nimport { FrontendTool, SuggestionsConfig, Suggestion, CopilotRuntimeTransport } from \"../types\";\nimport { AgentRegistry, CopilotKitCoreAddAgentParams } from \"./agent-registry\";\nimport { ContextStore } from \"./context-store\";\nimport { SuggestionEngine } from \"./suggestion-engine\";\nimport {\n  RunHandler,\n  CopilotKitCoreRunAgentParams,\n  CopilotKitCoreConnectAgentParams,\n  CopilotKitCoreGetToolParams,\n} from \"./run-handler\";\nimport { StateManager } from \"./state-manager\";\n\n/** Configuration options for `CopilotKitCore`. */\nexport interface CopilotKitCoreConfig {\n  /** The endpoint of the CopilotRuntime. */\n  runtimeUrl?: string;\n  /** Transport style for CopilotRuntime endpoints. Defaults to REST. */\n  runtimeTransport?: CopilotRuntimeTransport;\n  /** Mapping from agent name to its `AbstractAgent` instance. For development only - production requires CopilotRuntime. */\n  agents__unsafe_dev_only?: Record<string, AbstractAgent>;\n  /** Headers appended to every HTTP request made by `CopilotKitCore`. */\n  headers?: Record<string, string>;\n  /** Credentials mode for fetch requests (e.g., \"include\" for HTTP-only cookies). */\n  credentials?: RequestCredentials;\n  /** Properties sent as `forwardedProps` to the AG-UI agent. */\n  properties?: Record<string, unknown>;\n  /** Ordered collection of frontend tools available to the core. */\n  tools?: FrontendTool<any>[];\n  /** Suggestions config for the core. */\n  suggestionsConfig?: SuggestionsConfig[];\n}\n\nexport type { CopilotKitCoreAddAgentParams };\nexport type { CopilotKitCoreRunAgentParams, CopilotKitCoreConnectAgentParams, CopilotKitCoreGetToolParams };\n\nexport interface CopilotKitCoreStopAgentParams {\n  agent: AbstractAgent;\n}\n\nexport type CopilotKitCoreGetSuggestionsResult = {\n  suggestions: Suggestion[];\n  isLoading: boolean;\n};\n\nexport enum CopilotKitCoreErrorCode {\n  RUNTIME_INFO_FETCH_FAILED = \"runtime_info_fetch_failed\",\n  AGENT_CONNECT_FAILED = \"agent_connect_failed\",\n  AGENT_RUN_FAILED = \"agent_run_failed\",\n  AGENT_RUN_FAILED_EVENT = \"agent_run_failed_event\",\n  AGENT_RUN_ERROR_EVENT = \"agent_run_error_event\",\n  TOOL_ARGUMENT_PARSE_FAILED = \"tool_argument_parse_failed\",\n  TOOL_HANDLER_FAILED = \"tool_handler_failed\",\n  // Transcription errors\n  TRANSCRIPTION_FAILED = \"transcription_failed\",\n  TRANSCRIPTION_SERVICE_NOT_CONFIGURED = \"transcription_service_not_configured\",\n  TRANSCRIPTION_INVALID_AUDIO = \"transcription_invalid_audio\",\n  TRANSCRIPTION_RATE_LIMITED = \"transcription_rate_limited\",\n  TRANSCRIPTION_AUTH_FAILED = \"transcription_auth_failed\",\n  TRANSCRIPTION_NETWORK_ERROR = \"transcription_network_error\",\n}\n\nexport interface CopilotKitCoreSubscriber {\n  onRuntimeConnectionStatusChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    status: CopilotKitCoreRuntimeConnectionStatus;\n  }) => void | Promise<void>;\n  onToolExecutionStart?: (event: {\n    copilotkit: CopilotKitCore;\n    toolCallId: string;\n    agentId: string;\n    toolName: string;\n    args: unknown;\n  }) => void | Promise<void>;\n  onToolExecutionEnd?: (event: {\n    copilotkit: CopilotKitCore;\n    toolCallId: string;\n    agentId: string;\n    toolName: string;\n    result: string;\n    error?: string;\n  }) => void | Promise<void>;\n  onAgentsChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    agents: Readonly<Record<string, AbstractAgent>>;\n  }) => void | Promise<void>;\n  onContextChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    context: Readonly<Record<string, Context>>;\n  }) => void | Promise<void>;\n  onSuggestionsConfigChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    suggestionsConfig: Readonly<Record<string, SuggestionsConfig>>;\n  }) => void | Promise<void>;\n  onSuggestionsChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    agentId: string;\n    suggestions: Suggestion[];\n  }) => void | Promise<void>;\n  onSuggestionsStartedLoading?: (event: { copilotkit: CopilotKitCore; agentId: string }) => void | Promise<void>;\n  onSuggestionsFinishedLoading?: (event: { copilotkit: CopilotKitCore; agentId: string }) => void | Promise<void>;\n  onPropertiesChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    properties: Readonly<Record<string, unknown>>;\n  }) => void | Promise<void>;\n  onHeadersChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    headers: Readonly<Record<string, string>>;\n  }) => void | Promise<void>;\n  onError?: (event: {\n    copilotkit: CopilotKitCore;\n    error: Error;\n    code: CopilotKitCoreErrorCode;\n    context: Record<string, any>;\n  }) => void | Promise<void>;\n}\n\n// Subscription object returned by subscribe()\nexport interface CopilotKitCoreSubscription {\n  unsubscribe: () => void;\n}\n\nexport enum CopilotKitCoreRuntimeConnectionStatus {\n  Disconnected = \"disconnected\",\n  Connected = \"connected\",\n  Connecting = \"connecting\",\n  Error = \"error\",\n}\n\n/**\n * Internal interface for delegate classes to access CopilotKitCore methods.\n * This provides type safety while allowing controlled access to private functionality.\n */\nexport interface CopilotKitCoreFriendsAccess {\n  // Notification methods\n  notifySubscribers(\n    handler: (subscriber: CopilotKitCoreSubscriber) => void | Promise<void>,\n    errorMessage: string,\n  ): Promise<void>;\n\n  emitError(params: { error: Error; code: CopilotKitCoreErrorCode; context?: Record<string, any> }): Promise<void>;\n\n  // Getters for internal state\n  readonly headers: Readonly<Record<string, string>>;\n  readonly credentials: RequestCredentials | undefined;\n  readonly properties: Readonly<Record<string, unknown>>;\n  readonly context: Readonly<Record<string, Context>>;\n\n  // Internal methods\n  buildFrontendTools(agentId?: string): import(\"@ag-ui/client\").Tool[];\n  getAgent(id: string): AbstractAgent | undefined;\n\n  // References to delegate subsystems\n  readonly suggestionEngine: {\n    clearSuggestions(agentId: string): void;\n    reloadSuggestions(agentId: string): void;\n  };\n}\n\nexport class CopilotKitCore {\n  private _headers: Record<string, string>;\n  private _credentials?: RequestCredentials;\n  private _properties: Record<string, unknown>;\n\n  private subscribers: Set<CopilotKitCoreSubscriber> = new Set();\n\n  // Delegate classes\n  private agentRegistry: AgentRegistry;\n  private contextStore: ContextStore;\n  private suggestionEngine: SuggestionEngine;\n  private runHandler: RunHandler;\n  private stateManager: StateManager;\n\n  constructor({\n    runtimeUrl,\n    runtimeTransport = \"rest\",\n    headers = {},\n    credentials,\n    properties = {},\n    agents__unsafe_dev_only = {},\n    tools = [],\n    suggestionsConfig = [],\n  }: CopilotKitCoreConfig) {\n    this._headers = headers;\n    this._credentials = credentials;\n    this._properties = properties;\n\n    // Initialize delegate classes\n    this.agentRegistry = new AgentRegistry(this);\n    this.contextStore = new ContextStore(this);\n    this.suggestionEngine = new SuggestionEngine(this);\n    this.runHandler = new RunHandler(this);\n    this.stateManager = new StateManager(this);\n\n    // Initialize each subsystem\n    this.agentRegistry.initialize(agents__unsafe_dev_only);\n    this.runHandler.initialize(tools);\n    this.suggestionEngine.initialize(suggestionsConfig);\n    this.stateManager.initialize();\n\n    this.agentRegistry.setRuntimeTransport(runtimeTransport);\n    this.agentRegistry.setRuntimeUrl(runtimeUrl);\n\n    // Subscribe to agent changes to track state for new agents\n    this.subscribe({\n      onAgentsChanged: ({ agents }) => {\n        Object.values(agents).forEach((agent) => {\n          if (agent.agentId) {\n            this.stateManager.subscribeToAgent(agent);\n          }\n        });\n      },\n    });\n  }\n\n  /**\n   * Internal method used by delegate classes and subclasses to notify subscribers\n   */\n  protected async notifySubscribers(\n    handler: (subscriber: CopilotKitCoreSubscriber) => void | Promise<void>,\n    errorMessage: string,\n  ): Promise<void> {\n    await Promise.all(\n      Array.from(this.subscribers).map(async (subscriber) => {\n        try {\n          await handler(subscriber);\n        } catch (error) {\n          console.error(errorMessage, error);\n        }\n      }),\n    );\n  }\n\n  /**\n   * Internal method used by delegate classes to emit errors\n   */\n  private async emitError({\n    error,\n    code,\n    context = {},\n  }: {\n    error: Error;\n    code: CopilotKitCoreErrorCode;\n    context?: Record<string, any>;\n  }): Promise<void> {\n    await this.notifySubscribers(\n      (subscriber) =>\n        subscriber.onError?.({\n          copilotkit: this,\n          error,\n          code,\n          context,\n        }),\n      \"Subscriber onError error:\",\n    );\n  }\n\n  /**\n   * Snapshot accessors\n   */\n  get context(): Readonly<Record<string, Context>> {\n    return this.contextStore.context;\n  }\n\n  get agents(): Readonly<Record<string, AbstractAgent>> {\n    return this.agentRegistry.agents;\n  }\n\n  get tools(): Readonly<FrontendTool<any>[]> {\n    return this.runHandler.tools;\n  }\n\n  get runtimeUrl(): string | undefined {\n    return this.agentRegistry.runtimeUrl;\n  }\n\n  setRuntimeUrl(runtimeUrl: string | undefined): void {\n    this.agentRegistry.setRuntimeUrl(runtimeUrl);\n  }\n\n  get runtimeTransport(): CopilotRuntimeTransport {\n    return this.agentRegistry.runtimeTransport;\n  }\n\n  setRuntimeTransport(runtimeTransport: CopilotRuntimeTransport): void {\n    this.agentRegistry.setRuntimeTransport(runtimeTransport);\n  }\n\n  get runtimeVersion(): string | undefined {\n    return this.agentRegistry.runtimeVersion;\n  }\n\n  get headers(): Readonly<Record<string, string>> {\n    return this._headers;\n  }\n\n  get credentials(): RequestCredentials | undefined {\n    return this._credentials;\n  }\n\n  get properties(): Readonly<Record<string, unknown>> {\n    return this._properties;\n  }\n\n  get runtimeConnectionStatus(): CopilotKitCoreRuntimeConnectionStatus {\n    return this.agentRegistry.runtimeConnectionStatus;\n  }\n\n  get audioFileTranscriptionEnabled(): boolean {\n    return this.agentRegistry.audioFileTranscriptionEnabled;\n  }\n\n  /**\n   * Configuration updates\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this._headers = headers;\n    this.agentRegistry.applyHeadersToAgents(this.agentRegistry.agents as Record<string, AbstractAgent>);\n    void this.notifySubscribers(\n      (subscriber) =>\n        subscriber.onHeadersChanged?.({\n          copilotkit: this,\n          headers: this.headers,\n        }),\n      \"Subscriber onHeadersChanged error:\",\n    );\n  }\n\n  setCredentials(credentials: RequestCredentials | undefined): void {\n    this._credentials = credentials;\n    this.agentRegistry.applyCredentialsToAgents(this.agentRegistry.agents as Record<string, AbstractAgent>);\n  }\n\n  setProperties(properties: Record<string, unknown>): void {\n    this._properties = properties;\n    void this.notifySubscribers(\n      (subscriber) =>\n        subscriber.onPropertiesChanged?.({\n          copilotkit: this,\n          properties: this.properties,\n        }),\n      \"Subscriber onPropertiesChanged error:\",\n    );\n  }\n\n  /**\n   * Agent management (delegated to AgentRegistry)\n   */\n  setAgents__unsafe_dev_only(agents: Record<string, AbstractAgent>): void {\n    this.agentRegistry.setAgents__unsafe_dev_only(agents);\n  }\n\n  addAgent__unsafe_dev_only(params: CopilotKitCoreAddAgentParams): void {\n    this.agentRegistry.addAgent__unsafe_dev_only(params);\n  }\n\n  removeAgent__unsafe_dev_only(id: string): void {\n    this.agentRegistry.removeAgent__unsafe_dev_only(id);\n  }\n\n  getAgent(id: string): AbstractAgent | undefined {\n    return this.agentRegistry.getAgent(id);\n  }\n\n  /**\n   * Context management (delegated to ContextStore)\n   */\n  addContext(context: Context): string {\n    return this.contextStore.addContext(context);\n  }\n\n  removeContext(id: string): void {\n    this.contextStore.removeContext(id);\n  }\n\n  /**\n   * Suggestions management (delegated to SuggestionEngine)\n   */\n  addSuggestionsConfig(config: SuggestionsConfig): string {\n    return this.suggestionEngine.addSuggestionsConfig(config);\n  }\n\n  removeSuggestionsConfig(id: string): void {\n    this.suggestionEngine.removeSuggestionsConfig(id);\n  }\n\n  reloadSuggestions(agentId: string): void {\n    this.suggestionEngine.reloadSuggestions(agentId);\n  }\n\n  clearSuggestions(agentId: string): void {\n    this.suggestionEngine.clearSuggestions(agentId);\n  }\n\n  getSuggestions(agentId: string): CopilotKitCoreGetSuggestionsResult {\n    return this.suggestionEngine.getSuggestions(agentId);\n  }\n\n  /**\n   * Tool management (delegated to RunHandler)\n   */\n  addTool<T extends Record<string, unknown> = Record<string, unknown>>(tool: FrontendTool<T>): void {\n    this.runHandler.addTool(tool);\n  }\n\n  removeTool(id: string, agentId?: string): void {\n    this.runHandler.removeTool(id, agentId);\n  }\n\n  getTool(params: CopilotKitCoreGetToolParams): FrontendTool<any> | undefined {\n    return this.runHandler.getTool(params);\n  }\n\n  setTools(tools: FrontendTool<any>[]): void {\n    this.runHandler.setTools(tools);\n  }\n\n  /**\n   * Subscription lifecycle\n   */\n  subscribe(subscriber: CopilotKitCoreSubscriber): CopilotKitCoreSubscription {\n    this.subscribers.add(subscriber);\n\n    // Return subscription with unsubscribe method\n    return {\n      unsubscribe: () => {\n        this.subscribers.delete(subscriber);\n      },\n    };\n  }\n\n  /**\n   * Agent connectivity (delegated to RunHandler)\n   */\n  async connectAgent(params: CopilotKitCoreConnectAgentParams): Promise<import(\"@ag-ui/client\").RunAgentResult> {\n    return this.runHandler.connectAgent(params);\n  }\n\n  stopAgent(params: CopilotKitCoreStopAgentParams): void {\n    params.agent.abortRun();\n  }\n\n  async runAgent(params: CopilotKitCoreRunAgentParams): Promise<import(\"@ag-ui/client\").RunAgentResult> {\n    return this.runHandler.runAgent(params);\n  }\n\n  /**\n   * State management (delegated to StateManager)\n   */\n  getStateByRun(agentId: string, threadId: string, runId: string): State | undefined {\n    return this.stateManager.getStateByRun(agentId, threadId, runId);\n  }\n\n  getRunIdForMessage(agentId: string, threadId: string, messageId: string): string | undefined {\n    return this.stateManager.getRunIdForMessage(agentId, threadId, messageId);\n  }\n\n  getRunIdsForThread(agentId: string, threadId: string): string[] {\n    return this.stateManager.getRunIdsForThread(agentId, threadId);\n  }\n\n  /**\n   * Internal method used by RunHandler to build frontend tools\n   */\n  private buildFrontendTools(agentId?: string): import(\"@ag-ui/client\").Tool[] {\n    return this.runHandler.buildFrontendTools(agentId);\n  }\n}\n","import { ToolCall } from \"@ag-ui/client\";\nimport { z } from \"zod\";\n\n/**\n * Status of a tool call execution\n */\nexport enum ToolCallStatus {\n  InProgress = \"inProgress\",\n  Executing = \"executing\",\n  Complete = \"complete\",\n}\n\nexport type CopilotRuntimeTransport = \"rest\" | \"single\";\n\nexport type FrontendTool<T extends Record<string, unknown> = Record<string, unknown>> = {\n  name: string;\n  description?: string;\n  parameters?: z.ZodType<T>;\n  handler?: (args: T, toolCall: ToolCall) => Promise<unknown>;\n  followUp?: boolean;\n  /**\n   * Optional agent ID to constrain this tool to a specific agent.\n   * If specified, this tool will only be available to the specified agent.\n   */\n  agentId?: string;\n};\n\nexport type Suggestion = {\n  title: string;\n  message: string;\n  /** Indicates whether this suggestion is still being generated. */\n  isLoading: boolean;\n};\n\nexport type SuggestionAvailability = \"before-first-message\" | \"after-first-message\" | \"always\" | \"disabled\";\n\nexport type DynamicSuggestionsConfig = {\n  /**\n   * A prompt or instructions for the GPT to generate suggestions.\n   */\n  instructions: string;\n  /**\n   * The minimum number of suggestions to generate. Defaults to `1`.\n   * @default 1\n   */\n  minSuggestions?: number;\n  /**\n   * The maximum number of suggestions to generate. Defaults to `3`.\n   * @default 1\n   */\n  maxSuggestions?: number;\n\n  /**\n   * When the suggestions are available. Defaults to \"after-first-message\".\n   */\n  available?: SuggestionAvailability;\n\n  /**\n   * The agent ID of the provider of the suggestions. Defaults to `\"default\"`.\n   */\n  providerAgentId?: string;\n\n  /**\n   * The agent ID of the consumer of the suggestions. Defaults to `\"*\"` (all agents).\n   */\n  consumerAgentId?: string;\n};\n\nexport type StaticSuggestionsConfig = {\n  /**\n   * The suggestions to display.\n   */\n  suggestions: Omit<Suggestion, \"isLoading\">[];\n\n  /**\n   * When the suggestions are available. Defaults to \"before-first-message\".\n   */\n  available?: SuggestionAvailability;\n\n  /**\n   * The agent ID of the consumer of the suggestions. Defaults to `\"*\"` (all agents).\n   */\n  consumerAgentId?: string;\n};\n\nexport type SuggestionsConfig = DynamicSuggestionsConfig | StaticSuggestionsConfig;\n","export function completePartialMarkdown(input: string): string {\n  let s = input;\n\n  // Handle code fences first - use FIRST unmatched fence for proper nesting\n  const fenceMatches = Array.from(s.matchAll(/^(\\s*)(`{3,}|~{3,})/gm));\n  if (fenceMatches.length % 2 === 1) {\n    const [, indent, fence] = fenceMatches[0]!;\n    s += `\\n${indent}${fence}`;\n  }\n\n  // Identify incomplete links at the end and close them\n  const incompleteLinkMatch = s.match(/\\[([^\\]]*)\\]\\(([^)]*)$/);\n  if (incompleteLinkMatch) {\n    s += \")\";\n  }\n\n  // State-based parsing\n  interface OpenElement {\n    type: string;\n    marker: string;\n    position: number;\n  }\n\n  const openElements: OpenElement[] = [];\n  const chars = Array.from(s);\n\n  // First pass: identify code block boundaries and inline code to avoid processing their content\n  const codeBlockRanges: Array<{ start: number; end: number }> = [];\n  const inlineCodeRanges: Array<{ start: number; end: number }> = [];\n\n  // Find code block ranges\n  let tempCodeFenceCount = 0;\n  let currentCodeBlockStart = -1;\n\n  for (let i = 0; i < chars.length; i++) {\n    if (i === 0 || chars[i - 1] === \"\\n\") {\n      const lineMatch = s.substring(i).match(/^(\\s*)(`{3,}|~{3,})/);\n      if (lineMatch) {\n        tempCodeFenceCount++;\n        if (tempCodeFenceCount % 2 === 1) {\n          currentCodeBlockStart = i;\n        } else if (currentCodeBlockStart !== -1) {\n          codeBlockRanges.push({\n            start: currentCodeBlockStart,\n            end: i + lineMatch[0].length,\n          });\n          currentCodeBlockStart = -1;\n        }\n        i += lineMatch[0].length - 1;\n      }\n    }\n  }\n\n  // Find inline code ranges\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === \"`\") {\n      // Check if escaped\n      let backslashCount = 0;\n      for (let j = i - 1; j >= 0 && chars[j] === \"\\\\\"; j--) {\n        backslashCount++;\n      }\n      if (backslashCount % 2 === 0) {\n        // Not escaped - find the closing backtick\n        for (let j = i + 1; j < chars.length; j++) {\n          if (chars[j] === \"`\") {\n            let closingBackslashCount = 0;\n            for (let k = j - 1; k >= 0 && chars[k] === \"\\\\\"; k--) {\n              closingBackslashCount++;\n            }\n            if (closingBackslashCount % 2 === 0) {\n              inlineCodeRanges.push({ start: i, end: j + 1 });\n              i = j;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Helper function to check if position is in code\n  const isInCode = (pos: number): boolean => {\n    return (\n      codeBlockRanges.some((range) => pos >= range.start && pos < range.end) ||\n      inlineCodeRanges.some((range) => pos >= range.start && pos < range.end)\n    );\n  };\n\n  // Second pass: process markdown elements, skipping code regions\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    const nextChar = chars[i + 1];\n    const prevChar = chars[i - 1];\n\n    if (isInCode(i)) {\n      continue;\n    }\n\n    // Handle brackets (but not if they're part of already-complete links)\n    if (char === \"[\") {\n      // Check if this is part of a complete link [text](url)\n      let isCompleteLink = false;\n      let bracketDepth = 1;\n      let j = i + 1;\n\n      // Find the matching ]\n      while (j < chars.length && bracketDepth > 0) {\n        if (chars[j] === \"[\" && !isInCode(j)) bracketDepth++;\n        if (chars[j] === \"]\" && !isInCode(j)) bracketDepth--;\n        j++;\n      }\n\n      // Check if followed by (\n      if (bracketDepth === 0 && chars[j] === \"(\") {\n        // Find the closing )\n        let parenDepth = 1;\n        j++;\n        while (j < chars.length && parenDepth > 0) {\n          if (chars[j] === \"(\" && !isInCode(j)) parenDepth++;\n          if (chars[j] === \")\" && !isInCode(j)) parenDepth--;\n          j++;\n        }\n        if (parenDepth === 0) {\n          isCompleteLink = true;\n          i = j - 1;\n          continue;\n        }\n      }\n\n      // This is a standalone bracket, treat as markdown\n      if (!isCompleteLink) {\n        const existingIndex = openElements.findIndex(\n          (el) => el.type === \"bracket\"\n        );\n        if (existingIndex !== -1) {\n          openElements.splice(existingIndex, 1);\n        } else {\n          openElements.push({ type: \"bracket\", marker: \"[\", position: i });\n        }\n      }\n    }\n\n    // Handle double emphasis first (**, __, ~~) - these take precedence\n    else if (char === \"*\" && nextChar === \"*\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"bold_star\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({ type: \"bold_star\", marker: \"**\", position: i });\n      }\n      i++; // Skip next character\n    } else if (char === \"_\" && nextChar === \"_\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"bold_underscore\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({\n          type: \"bold_underscore\",\n          marker: \"__\",\n          position: i,\n        });\n      }\n      i++; // Skip next character\n    } else if (char === \"~\" && nextChar === \"~\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"strike\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({ type: \"strike\", marker: \"~~\", position: i });\n      }\n      i++; // Skip next character\n    }\n\n    // Handle single emphasis (*, _) - only if not part of double\n    else if (char === \"*\" && prevChar !== \"*\" && nextChar !== \"*\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"italic_star\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({ type: \"italic_star\", marker: \"*\", position: i });\n      }\n    } else if (char === \"_\" && prevChar !== \"_\" && nextChar !== \"_\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"italic_underscore\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({\n          type: \"italic_underscore\",\n          marker: \"_\",\n          position: i,\n        });\n      }\n    }\n  }\n\n  // Handle remaining unmatched backticks (outside of inline code ranges)\n  let backtickCount = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === \"`\" && !isInCode(i)) {\n      backtickCount++;\n    }\n  }\n  if (backtickCount % 2 === 1) {\n    s += \"`\";\n  }\n\n  // Close remaining open elements in reverse order (LIFO stack semantics)\n  openElements.sort((a, b) => b.position - a.position);\n\n  const closers = openElements.map((el) => {\n    switch (el.type) {\n      case \"bracket\":\n        return \"]\";\n      case \"bold_star\":\n        return \"**\";\n      case \"bold_underscore\":\n        return \"__\";\n      case \"strike\":\n        return \"~~\";\n      case \"italic_star\":\n        return \"*\";\n      case \"italic_underscore\":\n        return \"_\";\n      default:\n        return \"\";\n    }\n  });\n\n  let result = s + closers.join(\"\");\n\n  // Handle parentheses ONLY if not inside code\n  const finalFenceMatches = Array.from(\n    result.matchAll(/^(\\s*)(`{3,}|~{3,})/gm)\n  );\n  const hasUnclosedBacktick = (result.match(/`/g) || []).length % 2 === 1;\n  const hasUnclosedCodeFence = finalFenceMatches.length % 2 === 1;\n\n  let shouldCloseParens = !hasUnclosedBacktick && !hasUnclosedCodeFence;\n\n  if (shouldCloseParens) {\n    const lastOpenParen = result.lastIndexOf(\"(\");\n    if (lastOpenParen !== -1) {\n      // Check if this paren is inside a backtick pair\n      const beforeParen = result.substring(0, lastOpenParen);\n      const backticksBeforeParen = (beforeParen.match(/`/g) || []).length;\n      if (backticksBeforeParen % 2 === 1) {\n        shouldCloseParens = false;\n      }\n    }\n  }\n\n  if (shouldCloseParens) {\n    const openParens = (result.match(/\\(/g) || []).length;\n    const closeParens = (result.match(/\\)/g) || []).length;\n    if (openParens > closeParens) {\n      result += \")\".repeat(openParens - closeParens);\n    }\n  }\n\n  return result;\n}"],"mappings":"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","names":["HttpAgent","httpEvents","HttpAgent","response","randomUUID","HttpAgent","randomUUID","logger","logger","HttpAgent","randomUUID","CopilotKitCoreErrorCode","CopilotKitCoreRuntimeConnectionStatus","ToolCallStatus"]}