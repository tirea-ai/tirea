import { AbstractAgent } from '@ag-ui/client';
export * from '@ag-ui/client';
import * as React$1 from 'react';
import React__default, { ReactNode } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { AssistantMessage, Message, UserMessage, ToolCall, ToolMessage, ActivityMessage } from '@ag-ui/core';
import { Streamdown } from 'streamdown';
import { Suggestion, CopilotKitCore, ToolCallStatus, FrontendTool, DynamicSuggestionsConfig, StaticSuggestionsConfig, CopilotKitCoreConfig, CopilotKitCoreSubscriber, CopilotKitCoreSubscription } from '@copilotkitnext/core';
import { z } from 'zod';

/** Finite-state machine for every recorder implementation */
type AudioRecorderState = "idle" | "recording" | "processing";
/** Error subclass so callers can `instanceof`-guard recorder failures */
declare class AudioRecorderError extends Error {
    constructor(message: string);
}
interface AudioRecorderRef {
    state: AudioRecorderState;
    start: () => Promise<void>;
    stop: () => Promise<Blob>;
    dispose: () => void;
}
declare const CopilotChatAudioRecorder: React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<HTMLDivElement> & React$1.RefAttributes<AudioRecorderRef>>;

declare const CopilotChatDefaultLabels: {
    chatInputPlaceholder: string;
    chatInputToolbarStartTranscribeButtonLabel: string;
    chatInputToolbarCancelTranscribeButtonLabel: string;
    chatInputToolbarFinishTranscribeButtonLabel: string;
    chatInputToolbarAddButtonLabel: string;
    chatInputToolbarToolsButtonLabel: string;
    assistantMessageToolbarCopyCodeLabel: string;
    assistantMessageToolbarCopyCodeCopiedLabel: string;
    assistantMessageToolbarCopyMessageLabel: string;
    assistantMessageToolbarThumbsUpLabel: string;
    assistantMessageToolbarThumbsDownLabel: string;
    assistantMessageToolbarReadAloudLabel: string;
    assistantMessageToolbarRegenerateLabel: string;
    userMessageToolbarCopyMessageLabel: string;
    userMessageToolbarEditMessageLabel: string;
    chatDisclaimerText: string;
    chatToggleOpenLabel: string;
    chatToggleCloseLabel: string;
    modalHeaderTitle: string;
    welcomeMessageText: string;
};
type CopilotChatLabels = typeof CopilotChatDefaultLabels;
interface CopilotChatConfigurationValue {
    labels: CopilotChatLabels;
    agentId: string;
    threadId: string;
    isModalOpen: boolean;
    setModalOpen: (open: boolean) => void;
    isModalDefaultOpen: boolean;
}
interface CopilotChatConfigurationProviderProps {
    children: ReactNode;
    labels?: Partial<CopilotChatLabels>;
    agentId?: string;
    threadId?: string;
    isModalDefaultOpen?: boolean;
}
declare const CopilotChatConfigurationProvider: React__default.FC<CopilotChatConfigurationProviderProps>;
declare const useCopilotChatConfiguration: () => CopilotChatConfigurationValue | null;

/** Existing union (unchanged) */
type SlotValue<C extends React__default.ComponentType<any>> = C | string | Partial<React__default.ComponentProps<C>>;
/** Utility: concrete React elements for every slot */
type SlotElements<S> = {
    [K in keyof S]: React__default.ReactElement;
};
type WithSlots<S extends Record<string, React__default.ComponentType<any>>, Rest = {}> = {
    [K in keyof S]?: SlotValue<S[K]>;
} & {
    children?: (props: SlotElements<S> & Rest) => React__default.ReactNode;
} & Omit<Rest, "children">;

type CopilotChatInputMode = "input" | "transcribe" | "processing";
type ToolsMenuItem = {
    label: string;
} & ({
    action: () => void;
    items?: never;
} | {
    action?: never;
    items: (ToolsMenuItem | "-")[];
});
type CopilotChatInputSlots = {
    textArea: typeof CopilotChatInput.TextArea;
    sendButton: typeof CopilotChatInput.SendButton;
    startTranscribeButton: typeof CopilotChatInput.StartTranscribeButton;
    cancelTranscribeButton: typeof CopilotChatInput.CancelTranscribeButton;
    finishTranscribeButton: typeof CopilotChatInput.FinishTranscribeButton;
    addMenuButton: typeof CopilotChatInput.AddMenuButton;
    audioRecorder: typeof CopilotChatAudioRecorder;
};
type CopilotChatInputRestProps = {
    mode?: CopilotChatInputMode;
    toolsMenu?: (ToolsMenuItem | "-")[];
    autoFocus?: boolean;
    onSubmitMessage?: (value: string) => void;
    onStop?: () => void;
    isRunning?: boolean;
    onStartTranscribe?: () => void;
    onCancelTranscribe?: () => void;
    onFinishTranscribe?: () => void;
    onFinishTranscribeWithAudio?: (audioBlob: Blob) => Promise<void>;
    onAddFile?: () => void;
    value?: string;
    onChange?: (value: string) => void;
} & Omit<React__default.HTMLAttributes<HTMLDivElement>, "onChange">;
type CopilotChatInputBaseProps = WithSlots<CopilotChatInputSlots, CopilotChatInputRestProps>;
type CopilotChatInputChildrenArgs = CopilotChatInputBaseProps extends {
    children?: infer C;
} ? C extends (props: infer P) => React__default.ReactNode ? P : never : never;
type CopilotChatInputProps = Omit<CopilotChatInputBaseProps, "children"> & {
    children?: (props: CopilotChatInputChildrenArgs) => React__default.ReactNode;
};
declare function CopilotChatInput({ mode, onSubmitMessage, onStop, isRunning, onStartTranscribe, onCancelTranscribe, onFinishTranscribe, onFinishTranscribeWithAudio, onAddFile, onChange, value, toolsMenu, autoFocus, textArea, sendButton, startTranscribeButton, cancelTranscribeButton, finishTranscribeButton, addMenuButton, audioRecorder, children, className, ...props }: CopilotChatInputProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotChatInput {
    const SendButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>;
    const ToolbarButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement> & {
        icon: React__default.ReactNode;
        labelKey: keyof CopilotChatLabels;
        defaultClassName?: string;
    }>;
    const StartTranscribeButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>;
    const CancelTranscribeButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>;
    const FinishTranscribeButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>;
    const AddMenuButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement> & {
        toolsMenu?: (ToolsMenuItem | "-")[];
        onAddFile?: () => void;
    }>;
    type TextAreaProps = React__default.TextareaHTMLAttributes<HTMLTextAreaElement>;
    const TextArea: React__default.ForwardRefExoticComponent<TextAreaProps & React__default.RefAttributes<HTMLTextAreaElement>>;
    const AudioRecorder: React__default.ForwardRefExoticComponent<React__default.HTMLAttributes<HTMLDivElement> & React__default.RefAttributes<AudioRecorderRef>>;
}

type CopilotChatToolCallsViewProps = {
    message: AssistantMessage;
    messages?: Message[];
};
declare function CopilotChatToolCallsView({ message, messages, }: CopilotChatToolCallsViewProps): react_jsx_runtime.JSX.Element | null;

type CopilotChatAssistantMessageProps = WithSlots<{
    markdownRenderer: typeof CopilotChatAssistantMessage.MarkdownRenderer;
    toolbar: typeof CopilotChatAssistantMessage.Toolbar;
    copyButton: typeof CopilotChatAssistantMessage.CopyButton;
    thumbsUpButton: typeof CopilotChatAssistantMessage.ThumbsUpButton;
    thumbsDownButton: typeof CopilotChatAssistantMessage.ThumbsDownButton;
    readAloudButton: typeof CopilotChatAssistantMessage.ReadAloudButton;
    regenerateButton: typeof CopilotChatAssistantMessage.RegenerateButton;
    toolCallsView: typeof CopilotChatToolCallsView;
}, {
    onThumbsUp?: (message: AssistantMessage) => void;
    onThumbsDown?: (message: AssistantMessage) => void;
    onReadAloud?: (message: AssistantMessage) => void;
    onRegenerate?: (message: AssistantMessage) => void;
    message: AssistantMessage;
    messages?: Message[];
    isRunning?: boolean;
    additionalToolbarItems?: React.ReactNode;
    toolbarVisible?: boolean;
} & React.HTMLAttributes<HTMLDivElement>>;
declare function CopilotChatAssistantMessage({ message, messages, isRunning, onThumbsUp, onThumbsDown, onReadAloud, onRegenerate, additionalToolbarItems, toolbarVisible, markdownRenderer, toolbar, copyButton, thumbsUpButton, thumbsDownButton, readAloudButton, regenerateButton, toolCallsView, children, className, ...props }: CopilotChatAssistantMessageProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotChatAssistantMessage {
    const MarkdownRenderer: React.FC<Omit<React.ComponentProps<typeof Streamdown>, "children"> & {
        content: string;
    }>;
    const Toolbar: React.FC<React.HTMLAttributes<HTMLDivElement>>;
    const ToolbarButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement> & {
        title: string;
        children: React.ReactNode;
    }>;
    const CopyButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement>>;
    const ThumbsUpButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement>>;
    const ThumbsDownButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement>>;
    const ReadAloudButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement>>;
    const RegenerateButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement>>;
}

interface CopilotChatUserMessageOnEditMessageProps {
    message: UserMessage;
}
interface CopilotChatUserMessageOnSwitchToBranchProps {
    message: UserMessage;
    branchIndex: number;
    numberOfBranches: number;
}
type CopilotChatUserMessageProps = WithSlots<{
    messageRenderer: typeof CopilotChatUserMessage.MessageRenderer;
    toolbar: typeof CopilotChatUserMessage.Toolbar;
    copyButton: typeof CopilotChatUserMessage.CopyButton;
    editButton: typeof CopilotChatUserMessage.EditButton;
    branchNavigation: typeof CopilotChatUserMessage.BranchNavigation;
}, {
    onEditMessage?: (props: CopilotChatUserMessageOnEditMessageProps) => void;
    onSwitchToBranch?: (props: CopilotChatUserMessageOnSwitchToBranchProps) => void;
    message: UserMessage;
    branchIndex?: number;
    numberOfBranches?: number;
    additionalToolbarItems?: React.ReactNode;
} & React.HTMLAttributes<HTMLDivElement>>;
declare function CopilotChatUserMessage({ message, onEditMessage, branchIndex, numberOfBranches, onSwitchToBranch, additionalToolbarItems, messageRenderer, toolbar, copyButton, editButton, branchNavigation, children, className, ...props }: CopilotChatUserMessageProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotChatUserMessage {
    const Container: React.FC<React.PropsWithChildren<React.HTMLAttributes<HTMLDivElement>>>;
    const MessageRenderer: React.FC<{
        content: string;
        className?: string;
    }>;
    const Toolbar: React.FC<React.HTMLAttributes<HTMLDivElement>>;
    const ToolbarButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement> & {
        title: string;
        children: React.ReactNode;
    }>;
    const CopyButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement> & {
        copied?: boolean;
    }>;
    const EditButton: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement>>;
    const BranchNavigation: React.FC<React.HTMLAttributes<HTMLDivElement> & {
        currentBranch?: number;
        numberOfBranches?: number;
        onSwitchToBranch?: (props: CopilotChatUserMessageOnSwitchToBranchProps) => void;
        message: UserMessage;
    }>;
}

interface CopilotChatSuggestionPillProps extends React__default.ButtonHTMLAttributes<HTMLButtonElement> {
    /** Optional icon to render on the left side when not loading. */
    icon?: React__default.ReactNode;
    /** Whether the pill should display a loading spinner. */
    isLoading?: boolean;
}
declare const CopilotChatSuggestionPill: React__default.ForwardRefExoticComponent<CopilotChatSuggestionPillProps & React__default.RefAttributes<HTMLButtonElement>>;

declare const DefaultContainer: React__default.ForwardRefExoticComponent<React__default.HTMLAttributes<HTMLDivElement> & React__default.RefAttributes<HTMLDivElement>>;
type CopilotChatSuggestionViewProps = WithSlots<{
    container: typeof DefaultContainer;
    suggestion: typeof CopilotChatSuggestionPill;
}, {
    suggestions: Suggestion[];
    onSelectSuggestion?: (suggestion: Suggestion, index: number) => void;
    loadingIndexes?: ReadonlyArray<number>;
} & React__default.HTMLAttributes<HTMLDivElement>>;
declare const CopilotChatSuggestionView: React__default.ForwardRefExoticComponent<{
    container?: SlotValue<React__default.ForwardRefExoticComponent<React__default.HTMLAttributes<HTMLDivElement> & React__default.RefAttributes<HTMLDivElement>>> | undefined;
    suggestion?: SlotValue<React__default.ForwardRefExoticComponent<CopilotChatSuggestionPillProps & React__default.RefAttributes<HTMLButtonElement>>> | undefined;
} & {
    children?: ((props: {
        container: React__default.ReactElement<unknown, string | React__default.JSXElementConstructor<any>>;
        suggestion: React__default.ReactElement<unknown, string | React__default.JSXElementConstructor<any>>;
    } & {
        suggestions: Suggestion[];
        onSelectSuggestion?: (suggestion: Suggestion, index: number) => void;
        loadingIndexes?: ReadonlyArray<number>;
    } & React__default.HTMLAttributes<HTMLDivElement>) => React__default.ReactNode) | undefined;
} & Omit<{
    suggestions: Suggestion[];
    onSelectSuggestion?: (suggestion: Suggestion, index: number) => void;
    loadingIndexes?: ReadonlyArray<number>;
} & React__default.HTMLAttributes<HTMLDivElement>, "children"> & React__default.RefAttributes<HTMLDivElement>>;

type CopilotChatMessageViewProps = Omit<WithSlots<{
    assistantMessage: typeof CopilotChatAssistantMessage;
    userMessage: typeof CopilotChatUserMessage;
    cursor: typeof CopilotChatMessageView.Cursor;
}, {
    isRunning?: boolean;
    messages?: Message[];
} & React__default.HTMLAttributes<HTMLDivElement>>, "children"> & {
    children?: (props: {
        isRunning: boolean;
        messages: Message[];
        messageElements: React__default.ReactElement[];
    }) => React__default.ReactElement;
};
declare function CopilotChatMessageView({ messages, assistantMessage, userMessage, cursor, isRunning, children, className, ...props }: CopilotChatMessageViewProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotChatMessageView {
    var Cursor: ({ className, ...props }: React__default.HTMLAttributes<HTMLDivElement>) => react_jsx_runtime.JSX.Element;
}

type WelcomeScreenProps = WithSlots<{
    welcomeMessage: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
}, {
    input: React__default.ReactElement;
    suggestionView: React__default.ReactElement;
} & React__default.HTMLAttributes<HTMLDivElement>>;
type CopilotChatViewProps = WithSlots<{
    messageView: typeof CopilotChatMessageView;
    scrollView: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
    scrollToBottomButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>;
    input: typeof CopilotChatInput;
    inputContainer: React__default.FC<React__default.HTMLAttributes<HTMLDivElement> & {
        children: React__default.ReactNode;
    }>;
    feather: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
    disclaimer: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
    suggestionView: typeof CopilotChatSuggestionView;
}, {
    messages?: Message[];
    autoScroll?: boolean;
    inputProps?: Partial<Omit<CopilotChatInputProps, "children">>;
    isRunning?: boolean;
    suggestions?: Suggestion[];
    suggestionLoadingIndexes?: ReadonlyArray<number>;
    onSelectSuggestion?: (suggestion: Suggestion, index: number) => void;
    welcomeScreen?: SlotValue<React__default.FC<WelcomeScreenProps>> | boolean;
} & React__default.HTMLAttributes<HTMLDivElement>>;
declare function CopilotChatView({ messageView, input, scrollView, scrollToBottomButton, feather, inputContainer, disclaimer, suggestionView, welcomeScreen, messages, autoScroll, inputProps, isRunning, suggestions, suggestionLoadingIndexes, onSelectSuggestion, children, className, ...props }: CopilotChatViewProps): string | number | bigint | boolean | Iterable<React__default.ReactNode> | Promise<string | number | bigint | boolean | React__default.ReactPortal | React__default.ReactElement<unknown, string | React__default.JSXElementConstructor<any>> | Iterable<React__default.ReactNode> | null | undefined> | react_jsx_runtime.JSX.Element | null | undefined;
declare namespace CopilotChatView {
    const ScrollView: React__default.FC<React__default.HTMLAttributes<HTMLDivElement> & {
        autoScroll?: boolean;
        scrollToBottomButton?: SlotValue<React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>>;
        inputContainerHeight?: number;
        isResizing?: boolean;
    }>;
    const ScrollToBottomButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>;
    const Feather: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
    const InputContainer: React__default.ForwardRefExoticComponent<React__default.HTMLAttributes<HTMLDivElement> & {
        children: React__default.ReactNode;
        keyboardHeight?: number;
    } & React__default.RefAttributes<HTMLDivElement>>;
    const Disclaimer: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
    const WelcomeMessage: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
    const WelcomeScreen: React__default.FC<WelcomeScreenProps>;
}

type CopilotChatProps = Omit<CopilotChatViewProps, "messages" | "isRunning" | "suggestions" | "suggestionLoadingIndexes" | "onSelectSuggestion"> & {
    agentId?: string;
    threadId?: string;
    labels?: Partial<CopilotChatLabels>;
    chatView?: SlotValue<typeof CopilotChatView>;
    isModalDefaultOpen?: boolean;
};
declare function CopilotChat({ agentId, threadId, labels, chatView, isModalDefaultOpen, ...props }: CopilotChatProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotChat {
    const View: typeof CopilotChatView;
}

declare const DefaultOpenIcon: React__default.FC<React__default.SVGProps<SVGSVGElement>>;
declare const DefaultCloseIcon: React__default.FC<React__default.SVGProps<SVGSVGElement>>;
interface CopilotChatToggleButtonProps extends Omit<React__default.ButtonHTMLAttributes<HTMLButtonElement>, "children"> {
    /** Optional slot override for the chat (closed) icon. */
    openIcon?: SlotValue<typeof DefaultOpenIcon>;
    /** Optional slot override for the close icon. */
    closeIcon?: SlotValue<typeof DefaultCloseIcon>;
}
declare const CopilotChatToggleButton: React__default.ForwardRefExoticComponent<CopilotChatToggleButtonProps & React__default.RefAttributes<HTMLButtonElement>>;

type HeaderSlots = {
    titleContent: typeof CopilotModalHeader.Title;
    closeButton: typeof CopilotModalHeader.CloseButton;
};
type HeaderRestProps = {
    title?: string;
} & Omit<React__default.HTMLAttributes<HTMLDivElement>, "children">;
type CopilotModalHeaderProps = WithSlots<HeaderSlots, HeaderRestProps>;
declare function CopilotModalHeader({ title, titleContent, closeButton, children, className, ...rest }: CopilotModalHeaderProps): string | number | bigint | boolean | Iterable<React__default.ReactNode> | Promise<string | number | bigint | boolean | React__default.ReactPortal | React__default.ReactElement<unknown, string | React__default.JSXElementConstructor<any>> | Iterable<React__default.ReactNode> | null | undefined> | react_jsx_runtime.JSX.Element | null | undefined;
declare namespace CopilotModalHeader {
    var displayName: string;
}
declare namespace CopilotModalHeader {
    const Title: React__default.FC<React__default.HTMLAttributes<HTMLDivElement>>;
    const CloseButton: React__default.FC<React__default.ButtonHTMLAttributes<HTMLButtonElement>>;
}

type CopilotSidebarViewProps = CopilotChatViewProps & {
    header?: SlotValue<typeof CopilotModalHeader>;
    width?: number | string;
};
declare function CopilotSidebarView({ header, width, ...props }: CopilotSidebarViewProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotSidebarView {
    var displayName: string;
}
declare namespace CopilotSidebarView {
    /**
     * Sidebar-specific welcome screen layout:
     * - Suggestions at the top
     * - Welcome message in the middle
     * - Input fixed at the bottom (like normal chat)
     */
    const WelcomeScreen: React__default.FC<WelcomeScreenProps>;
}

type CopilotPopupViewProps = CopilotChatViewProps & {
    header?: SlotValue<typeof CopilotModalHeader>;
    width?: number | string;
    height?: number | string;
    clickOutsideToClose?: boolean;
};
declare function CopilotPopupView({ header, width, height, clickOutsideToClose, className, ...restProps }: CopilotPopupViewProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotPopupView {
    var displayName: string;
}
declare namespace CopilotPopupView {
    /**
     * Popup-specific welcome screen layout:
     * - Welcome message centered vertically
     * - Suggestions just above input
     * - Input fixed at the bottom
     */
    const WelcomeScreen: React__default.FC<WelcomeScreenProps>;
}

type CopilotSidebarProps = Omit<CopilotChatProps, "chatView"> & {
    header?: CopilotSidebarViewProps["header"];
    defaultOpen?: boolean;
    width?: number | string;
};
declare function CopilotSidebar({ header, defaultOpen, width, ...chatProps }: CopilotSidebarProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotSidebar {
    var displayName: string;
}

type CopilotPopupProps = Omit<CopilotChatProps, "chatView"> & {
    header?: CopilotPopupViewProps["header"];
    defaultOpen?: boolean;
    width?: CopilotPopupViewProps["width"];
    height?: CopilotPopupViewProps["height"];
    clickOutsideToClose?: CopilotPopupViewProps["clickOutsideToClose"];
};
declare function CopilotPopup({ header, defaultOpen, width, height, clickOutsideToClose, ...chatProps }: CopilotPopupProps): react_jsx_runtime.JSX.Element;
declare namespace CopilotPopup {
    var displayName: string;
}

declare const WildcardToolCallRender: ReactToolCallRenderer<any>;

type CopilotKitInspectorBaseProps = {
    core?: CopilotKitCore | null;
    [key: string]: unknown;
};
interface CopilotKitInspectorProps extends CopilotKitInspectorBaseProps {
}
declare const CopilotKitInspector: React$1.FC<CopilotKitInspectorProps>;

/**
 * Activity type for MCP Apps events - must match the middleware's MCPAppsActivityType
 */
declare const MCPAppsActivityType = "mcp-apps";
declare const MCPAppsActivityContentSchema: z.ZodObject<{
    result: z.ZodObject<{
        content: z.ZodOptional<z.ZodArray<z.ZodAny, "many">>;
        structuredContent: z.ZodOptional<z.ZodAny>;
        isError: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        content?: any[] | undefined;
        structuredContent?: any;
        isError?: boolean | undefined;
    }, {
        content?: any[] | undefined;
        structuredContent?: any;
        isError?: boolean | undefined;
    }>;
    resourceUri: z.ZodString;
    serverHash: z.ZodString;
    serverId: z.ZodOptional<z.ZodString>;
    toolInput: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}, "strip", z.ZodTypeAny, {
    result: {
        content?: any[] | undefined;
        structuredContent?: any;
        isError?: boolean | undefined;
    };
    resourceUri: string;
    serverHash: string;
    serverId?: string | undefined;
    toolInput?: Record<string, unknown> | undefined;
}, {
    result: {
        content?: any[] | undefined;
        structuredContent?: any;
        isError?: boolean | undefined;
    };
    resourceUri: string;
    serverHash: string;
    serverId?: string | undefined;
    toolInput?: Record<string, unknown> | undefined;
}>;
type MCPAppsActivityContent = z.infer<typeof MCPAppsActivityContentSchema>;
/**
 * Props for the activity renderer component
 */
interface MCPAppsActivityRendererProps {
    activityType: string;
    content: MCPAppsActivityContent;
    message: unknown;
    agent: AbstractAgent | undefined;
}
/**
 * MCP Apps Extension Activity Renderer
 *
 * Renders MCP Apps UI in a sandboxed iframe with full protocol support.
 * Fetches resource content on-demand via proxied MCP requests.
 */
declare const MCPAppsActivityRenderer: React__default.FC<MCPAppsActivityRendererProps>;

interface UseRenderToolCallProps {
    toolCall: ToolCall;
    toolMessage?: ToolMessage;
}
/**
 * Hook that returns a function to render tool calls based on the render functions
 * defined in CopilotKitProvider.
 *
 * @returns A function that takes a tool call and optional tool message and returns the rendered component
 */
declare function useRenderToolCall(): ({ toolCall, toolMessage, }: UseRenderToolCallProps) => React__default.ReactElement | null;

type ReactCustomMessageRendererPosition = "before" | "after";
interface ReactCustomMessageRenderer {
    agentId?: string;
    render: React.ComponentType<{
        message: Message;
        position: ReactCustomMessageRendererPosition;
        runId: string;
        messageIndex: number;
        messageIndexInRun: number;
        numberOfMessagesInRun: number;
        agentId: string;
        stateSnapshot: any;
    }> | null;
}

interface UseRenderCustomMessagesParams {
    message: Message;
    position: ReactCustomMessageRendererPosition;
}
declare function useRenderCustomMessages(): ((params: UseRenderCustomMessagesParams) => react_jsx_runtime.JSX.Element | null) | null;

interface ReactToolCallRenderer<T> {
    name: string;
    args: z.ZodSchema<T>;
    /**
     * Optional agent ID to constrain this tool renderer to a specific agent.
     * If specified, this renderer will only be used for the specified agent.
     */
    agentId?: string;
    render: React.ComponentType<{
        name: string;
        args: Partial<T>;
        status: ToolCallStatus.InProgress;
        result: undefined;
    } | {
        name: string;
        args: T;
        status: ToolCallStatus.Executing;
        result: undefined;
    } | {
        name: string;
        args: T;
        status: ToolCallStatus.Complete;
        result: string;
    }>;
}

interface ReactActivityMessageRenderer<TActivityContent> {
    /**
     * Activity type to match when rendering. Use "*" as a wildcard renderer.
     */
    activityType: string;
    /**
     * Optional agent ID to scope the renderer to a particular agent.
     */
    agentId?: string;
    /**
     * Schema describing the activity content payload.
     */
    content: z.ZodSchema<TActivityContent>;
    /**
     * React component invoked to render the activity message.
     */
    render: React.ComponentType<{
        activityType: string;
        content: TActivityContent;
        message: ActivityMessage;
        agent: AbstractAgent | undefined;
    }>;
}

type ReactFrontendTool<T extends Record<string, unknown> = Record<string, unknown>> = FrontendTool<T> & {
    render?: ReactToolCallRenderer<T>["render"];
};

type ReactHumanInTheLoop<T extends Record<string, unknown> = Record<string, unknown>> = Omit<FrontendTool<T>, "handler"> & {
    render: React__default.ComponentType<{
        name: string;
        description: string;
        args: Partial<T>;
        status: ToolCallStatus.InProgress;
        result: undefined;
        respond: undefined;
    } | {
        name: string;
        description: string;
        args: T;
        status: ToolCallStatus.Executing;
        result: undefined;
        respond: (result: unknown) => Promise<void>;
    } | {
        name: string;
        description: string;
        args: T;
        status: ToolCallStatus.Complete;
        result: string;
        respond: undefined;
    }>;
};

/**
 * Helper to define a type-safe tool call renderer entry.
 * - Accepts a single object whose keys match ReactToolCallRenderer's fields: { name, args, render, agentId? }.
 * - Derives `args` type from the provided Zod schema.
 * - Ensures the render function param type exactly matches ReactToolCallRenderer<T>["render"]'s param.
 * - For wildcard tools (name: "*"), args is optional and defaults to z.any()
 */
type RenderProps<T> = {
    name: string;
    args: Partial<T>;
    status: ToolCallStatus.InProgress;
    result: undefined;
} | {
    name: string;
    args: T;
    status: ToolCallStatus.Executing;
    result: undefined;
} | {
    name: string;
    args: T;
    status: ToolCallStatus.Complete;
    result: string;
};
declare function defineToolCallRenderer(def: {
    name: "*";
    render: (props: RenderProps<any>) => React__default.ReactElement;
    agentId?: string;
}): ReactToolCallRenderer<any>;
declare function defineToolCallRenderer<S extends z.ZodTypeAny>(def: {
    name: string;
    args: S;
    render: (props: RenderProps<z.infer<S>>) => React__default.ReactElement;
    agentId?: string;
}): ReactToolCallRenderer<z.infer<S>>;

declare function useRenderActivityMessage(): {
    renderActivityMessage: (message: ActivityMessage) => React.ReactElement | null;
    findRenderer: (activityType: string) => ReactActivityMessageRenderer<unknown> | null;
};

declare function useFrontendTool<T extends Record<string, unknown> = Record<string, unknown>>(tool: ReactFrontendTool<T>, deps?: ReadonlyArray<unknown>): void;

declare function useHumanInTheLoop<T extends Record<string, unknown> = Record<string, unknown>>(tool: ReactHumanInTheLoop<T>, deps?: ReadonlyArray<unknown>): void;

declare enum UseAgentUpdate {
    OnMessagesChanged = "OnMessagesChanged",
    OnStateChanged = "OnStateChanged",
    OnRunStatusChanged = "OnRunStatusChanged"
}
interface UseAgentProps {
    agentId?: string;
    updates?: UseAgentUpdate[];
}
declare function useAgent({ agentId, updates }?: UseAgentProps): {
    agent: AbstractAgent;
};

/**
 * Represents any value that can be serialized to JSON.
 */
type JsonSerializable = string | number | boolean | null | JsonSerializable[] | {
    [key: string]: JsonSerializable;
};
/**
 * Context configuration for useAgentContext.
 * Accepts any JSON-serializable value which will be converted to a string.
 */
interface AgentContextInput {
    /** A human-readable description of what this context represents */
    description: string;
    /** The context value - will be converted to a JSON string if not already a string */
    value: JsonSerializable;
}
declare function useAgentContext(context: AgentContextInput): void;

interface UseSuggestionsOptions {
    agentId?: string;
}
interface UseSuggestionsResult {
    suggestions: Suggestion[];
    reloadSuggestions: () => void;
    clearSuggestions: () => void;
    isLoading: boolean;
}
declare function useSuggestions({ agentId }?: UseSuggestionsOptions): UseSuggestionsResult;

type StaticSuggestionInput = Omit<Suggestion, "isLoading"> & Partial<Pick<Suggestion, "isLoading">>;
type StaticSuggestionsConfigInput = Omit<StaticSuggestionsConfig, "suggestions"> & {
    suggestions: StaticSuggestionInput[];
};
type SuggestionsConfigInput = DynamicSuggestionsConfig | StaticSuggestionsConfigInput;
declare function useConfigureSuggestions(config: SuggestionsConfigInput | null | undefined, deps?: ReadonlyArray<unknown>): void;

interface CopilotKitCoreReactConfig extends CopilotKitCoreConfig {
    renderToolCalls?: ReactToolCallRenderer<any>[];
    renderActivityMessages?: ReactActivityMessageRenderer<any>[];
    renderCustomMessages?: ReactCustomMessageRenderer[];
}
interface CopilotKitCoreReactSubscriber extends CopilotKitCoreSubscriber {
    onRenderToolCallsChanged?: (event: {
        copilotkit: CopilotKitCore;
        renderToolCalls: ReactToolCallRenderer<any>[];
    }) => void | Promise<void>;
}
declare class CopilotKitCoreReact extends CopilotKitCore {
    private _renderToolCalls;
    private _renderCustomMessages;
    private _renderActivityMessages;
    constructor(config: CopilotKitCoreReactConfig);
    get renderCustomMessages(): Readonly<ReactCustomMessageRenderer[]>;
    get renderActivityMessages(): Readonly<ReactActivityMessageRenderer<any>>[];
    get renderToolCalls(): Readonly<ReactToolCallRenderer<any>>[];
    setRenderToolCalls(renderToolCalls: ReactToolCallRenderer<any>[]): void;
    subscribe(subscriber: CopilotKitCoreReactSubscriber): CopilotKitCoreSubscription;
}

interface CopilotKitContextValue {
    copilotkit: CopilotKitCoreReact;
    /**
     * Set of tool call IDs currently being executed.
     * This is tracked at the provider level to ensure tool execution events
     * are captured even before child components mount.
     */
    executingToolCallIds: ReadonlySet<string>;
}
interface CopilotKitProviderProps {
    children: ReactNode;
    runtimeUrl?: string;
    headers?: Record<string, string>;
    /**
     * Credentials mode for fetch requests (e.g., "include" for HTTP-only cookies in cross-origin requests).
     */
    credentials?: RequestCredentials;
    /**
     * The Copilot Cloud public API key.
     */
    publicApiKey?: string;
    /**
     * Alias for `publicApiKey`
     **/
    publicLicenseKey?: string;
    properties?: Record<string, unknown>;
    useSingleEndpoint?: boolean;
    agents__unsafe_dev_only?: Record<string, AbstractAgent>;
    renderToolCalls?: ReactToolCallRenderer<any>[];
    renderActivityMessages?: ReactActivityMessageRenderer<any>[];
    renderCustomMessages?: ReactCustomMessageRenderer[];
    frontendTools?: ReactFrontendTool[];
    humanInTheLoop?: ReactHumanInTheLoop[];
    showDevConsole?: boolean | "auto";
}
declare const CopilotKitProvider: React__default.FC<CopilotKitProviderProps>;
declare const useCopilotKit: () => CopilotKitContextValue;

export { type AgentContextInput, AudioRecorderError, type AudioRecorderState, CopilotChat, CopilotChatAssistantMessage, type CopilotChatAssistantMessageProps, CopilotChatAudioRecorder, CopilotChatConfigurationProvider, type CopilotChatConfigurationProviderProps, type CopilotChatConfigurationValue, CopilotChatInput, type CopilotChatInputProps, type CopilotChatLabels, CopilotChatMessageView, type CopilotChatMessageViewProps, type CopilotChatProps, CopilotChatSuggestionPill, type CopilotChatSuggestionPillProps, CopilotChatSuggestionView, type CopilotChatSuggestionViewProps, CopilotChatToggleButton, DefaultCloseIcon as CopilotChatToggleButtonCloseIcon, DefaultOpenIcon as CopilotChatToggleButtonOpenIcon, type CopilotChatToggleButtonProps, CopilotChatToolCallsView, type CopilotChatToolCallsViewProps, CopilotChatUserMessage, type CopilotChatUserMessageProps, CopilotChatView, type CopilotChatViewProps, type CopilotKitContextValue, CopilotKitCoreReact, type CopilotKitCoreReactConfig, type CopilotKitCoreReactSubscriber, CopilotKitInspector, type CopilotKitInspectorProps, CopilotKitProvider, type CopilotKitProviderProps, CopilotModalHeader, type CopilotModalHeaderProps, CopilotPopup, type CopilotPopupProps, CopilotPopupView, type CopilotPopupViewProps, CopilotSidebar, type CopilotSidebarProps, CopilotSidebarView, type CopilotSidebarViewProps, type JsonSerializable, type MCPAppsActivityContent, MCPAppsActivityContentSchema, MCPAppsActivityRenderer, MCPAppsActivityType, type ReactActivityMessageRenderer, type ReactCustomMessageRenderer, type ReactCustomMessageRendererPosition, type ReactFrontendTool, type ReactHumanInTheLoop, type ReactToolCallRenderer, type ToolsMenuItem, UseAgentUpdate, WildcardToolCallRender, defineToolCallRenderer, useAgent, useAgentContext, useConfigureSuggestions, useCopilotChatConfiguration, useCopilotKit, useFrontendTool, useHumanInTheLoop, useRenderActivityMessage, useRenderCustomMessages, useRenderToolCall, useSuggestions };
