"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape";
exports.ids = ["vendor-chunks/cytoscape"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape/dist/cytoscape.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cytoscape)\n/* harmony export */ });\n/**\n * Copyright (c) 2016-2025, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the “Software”), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n        writable: false\n    }), e;\n}\nfunction _createForOfIteratorHelper(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (!t) {\n        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n            t && (r = t);\n            var n = 0, F = function() {};\n            return {\n                s: F,\n                n: function() {\n                    return n >= r.length ? {\n                        done: true\n                    } : {\n                        done: false,\n                        value: r[n++]\n                    };\n                },\n                e: function(r) {\n                    throw r;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var o, a = true, u = false;\n    return {\n        s: function() {\n            t = t.call(r);\n        },\n        n: function() {\n            var r = t.next();\n            return a = r.done, r;\n        },\n        e: function(r) {\n            u = true, o = r;\n        },\n        f: function() {\n            try {\n                a || null == t.return || t.return();\n            } finally{\n                if (u) throw o;\n            }\n        }\n    };\n}\nfunction _defineProperty$1(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    }) : e[r] = t, e;\n}\nfunction _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = true, o = false;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = true, n = r;\n        } finally{\n            try {\n                if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (undefined !== e) {\n        var i = e.call(t, r);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return String(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n    }\n}\nvar _window =  true ? null : 0; // eslint-disable-line no-undef\nvar navigator = _window ? _window.navigator : null;\n_window ? _window.document : null;\nvar typeofstr = _typeof('');\nvar typeofobj = _typeof({});\nvar typeoffn = _typeof(function() {});\nvar typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\nvar instanceStr = function instanceStr(obj) {\n    return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n};\nvar string = function string(obj) {\n    return obj != null && _typeof(obj) == typeofstr;\n};\nvar fn$6 = function fn(obj) {\n    return obj != null && _typeof(obj) === typeoffn;\n};\nvar array = function array(obj) {\n    return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n};\nvar plainObject = function plainObject(obj) {\n    return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n};\nvar object = function object(obj) {\n    return obj != null && _typeof(obj) === typeofobj;\n};\nvar number$1 = function number(obj) {\n    return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n};\nvar integer = function integer(obj) {\n    return number$1(obj) && Math.floor(obj) === obj;\n};\nvar htmlElement = function htmlElement(obj) {\n    if ('undefined' === typeofhtmlele) {\n        return undefined;\n    } else {\n        return null != obj && obj instanceof HTMLElement;\n    }\n};\nvar elementOrCollection = function elementOrCollection(obj) {\n    return element(obj) || collection(obj);\n};\nvar element = function element(obj) {\n    return instanceStr(obj) === 'collection' && obj._private.single;\n};\nvar collection = function collection(obj) {\n    return instanceStr(obj) === 'collection' && !obj._private.single;\n};\nvar core = function core(obj) {\n    return instanceStr(obj) === 'core';\n};\nvar stylesheet = function stylesheet(obj) {\n    return instanceStr(obj) === 'stylesheet';\n};\nvar event = function event(obj) {\n    return instanceStr(obj) === 'event';\n};\nvar emptyString = function emptyString(obj) {\n    if (obj === undefined || obj === null) {\n        // null is empty\n        return true;\n    } else if (obj === '' || obj.match(/^\\s+$/)) {\n        return true; // empty string is empty\n    }\n    return false; // otherwise, we don't know what we've got\n};\nvar domElement = function domElement(obj) {\n    if (typeof HTMLElement === 'undefined') {\n        return false; // we're not in a browser so it doesn't matter\n    } else {\n        return obj instanceof HTMLElement;\n    }\n};\nvar boundingBox = function boundingBox(obj) {\n    return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n};\nvar promise = function promise(obj) {\n    return object(obj) && fn$6(obj.then);\n};\nvar ms = function ms() {\n    return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n}; // probably a better way to detect this...\nvar memoize = function memoize(fn, keyFn) {\n    if (!keyFn) {\n        keyFn = function keyFn() {\n            if (arguments.length === 1) {\n                return arguments[0];\n            } else if (arguments.length === 0) {\n                return 'undefined';\n            }\n            var args = [];\n            for(var i = 0; i < arguments.length; i++){\n                args.push(arguments[i]);\n            }\n            return args.join('$');\n        };\n    }\n    var _memoizedFn = function memoizedFn() {\n        var self1 = this;\n        var args = arguments;\n        var ret;\n        var k = keyFn.apply(self1, args);\n        var cache = _memoizedFn.cache;\n        if (!(ret = cache[k])) {\n            ret = cache[k] = fn.apply(self1, args);\n        }\n        return ret;\n    };\n    _memoizedFn.cache = {};\n    return _memoizedFn;\n};\nvar camel2dash = memoize(function(str) {\n    return str.replace(/([A-Z])/g, function(v) {\n        return '-' + v.toLowerCase();\n    });\n});\nvar dash2camel = memoize(function(str) {\n    return str.replace(/(-\\w)/g, function(v) {\n        return v[1].toUpperCase();\n    });\n});\nvar prependCamel = memoize(function(prefix, str) {\n    return prefix + str[0].toUpperCase() + str.substring(1);\n}, function(prefix, str) {\n    return prefix + '$' + str;\n});\nvar capitalize = function capitalize(str) {\n    if (emptyString(str)) {\n        return str;\n    }\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nvar endsWith = function endsWith(string, suffix) {\n    return string.slice(-1 * suffix.length) === suffix;\n};\nvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\nvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hex3 = '\\\\#[0-9a-fA-F]{3}';\nvar hex6 = '\\\\#[0-9a-fA-F]{6}';\nvar ascending = function ascending(a, b) {\n    if (a < b) {\n        return -1;\n    } else if (a > b) {\n        return 1;\n    } else {\n        return 0;\n    }\n};\nvar descending = function descending(a, b) {\n    return -1 * ascending(a, b);\n};\nvar extend = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {\n    var args = arguments;\n    for(var i = 1; i < args.length; i++){\n        var obj = args[i];\n        if (obj == null) {\n            continue;\n        }\n        var keys = Object.keys(obj);\n        for(var j = 0; j < keys.length; j++){\n            var k = keys[j];\n            tgt[k] = obj[k];\n        }\n    }\n    return tgt;\n};\n// get [r, g, b] from #abc or #aabbcc\nvar hex2tuple = function hex2tuple(hex) {\n    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n        return;\n    }\n    var shortHex = hex.length === 4;\n    var r, g, b;\n    var base = 16;\n    if (shortHex) {\n        r = parseInt(hex[1] + hex[1], base);\n        g = parseInt(hex[2] + hex[2], base);\n        b = parseInt(hex[3] + hex[3], base);\n    } else {\n        r = parseInt(hex[1] + hex[2], base);\n        g = parseInt(hex[3] + hex[4], base);\n        b = parseInt(hex[5] + hex[6], base);\n    }\n    return [\n        r,\n        g,\n        b\n    ];\n};\n// get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\nvar hsl2tuple = function hsl2tuple(hsl) {\n    var ret;\n    var h, s, l, a, r, g, b;\n    function hue2rgb(p, q, t) {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n    }\n    var m1 = new RegExp('^' + hsla + '$').exec(hsl);\n    if (m1) {\n        // get hue\n        h = parseInt(m1[1]);\n        if (h < 0) {\n            h = (360 - -1 * h % 360) % 360;\n        } else if (h > 360) {\n            h = h % 360;\n        }\n        h /= 360; // normalise on [0, 1]\n        s = parseFloat(m1[2]);\n        if (s < 0 || s > 100) {\n            return;\n        } // saturation is [0, 100]\n        s = s / 100; // normalise on [0, 1]\n        l = parseFloat(m1[3]);\n        if (l < 0 || l > 100) {\n            return;\n        } // lightness is [0, 100]\n        l = l / 100; // normalise on [0, 1]\n        a = m1[4];\n        if (a !== undefined) {\n            a = parseFloat(a);\n            if (a < 0 || a > 1) {\n                return;\n            } // alpha is [0, 1]\n        }\n        // now, convert to rgb\n        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n        if (s === 0) {\n            r = g = b = Math.round(l * 255); // achromatic\n        } else {\n            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            var p = 2 * l - q;\n            r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n            g = Math.round(255 * hue2rgb(p, q, h));\n            b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n        }\n        ret = [\n            r,\n            g,\n            b,\n            a\n        ];\n    }\n    return ret;\n};\n// get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\nvar rgb2tuple = function rgb2tuple(rgb) {\n    var ret;\n    var m1 = new RegExp('^' + rgba + '$').exec(rgb);\n    if (m1) {\n        ret = [];\n        var isPct = [];\n        for(var i = 1; i <= 3; i++){\n            var channel = m1[i];\n            if (channel[channel.length - 1] === '%') {\n                isPct[i] = true;\n            }\n            channel = parseFloat(channel);\n            if (isPct[i]) {\n                channel = channel / 100 * 255; // normalise to [0, 255]\n            }\n            if (channel < 0 || channel > 255) {\n                return;\n            } // invalid channel value\n            ret.push(Math.floor(channel));\n        }\n        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n        var allArePct = isPct[1] && isPct[2] && isPct[3];\n        if (atLeastOneIsPct && !allArePct) {\n            return;\n        } // must all be percent values if one is\n        var alpha = m1[4];\n        if (alpha !== undefined) {\n            alpha = parseFloat(alpha);\n            if (alpha < 0 || alpha > 1) {\n                return;\n            } // invalid alpha value\n            ret.push(alpha);\n        }\n    }\n    return ret;\n};\nvar colorname2tuple = function colorname2tuple(color) {\n    return colors[color.toLowerCase()];\n};\nvar color2tuple = function color2tuple(color) {\n    return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n};\nvar colors = {\n    // special colour names\n    transparent: [\n        0,\n        0,\n        0,\n        0\n    ],\n    // NB alpha === 0\n    // regular colours\n    aliceblue: [\n        240,\n        248,\n        255\n    ],\n    antiquewhite: [\n        250,\n        235,\n        215\n    ],\n    aqua: [\n        0,\n        255,\n        255\n    ],\n    aquamarine: [\n        127,\n        255,\n        212\n    ],\n    azure: [\n        240,\n        255,\n        255\n    ],\n    beige: [\n        245,\n        245,\n        220\n    ],\n    bisque: [\n        255,\n        228,\n        196\n    ],\n    black: [\n        0,\n        0,\n        0\n    ],\n    blanchedalmond: [\n        255,\n        235,\n        205\n    ],\n    blue: [\n        0,\n        0,\n        255\n    ],\n    blueviolet: [\n        138,\n        43,\n        226\n    ],\n    brown: [\n        165,\n        42,\n        42\n    ],\n    burlywood: [\n        222,\n        184,\n        135\n    ],\n    cadetblue: [\n        95,\n        158,\n        160\n    ],\n    chartreuse: [\n        127,\n        255,\n        0\n    ],\n    chocolate: [\n        210,\n        105,\n        30\n    ],\n    coral: [\n        255,\n        127,\n        80\n    ],\n    cornflowerblue: [\n        100,\n        149,\n        237\n    ],\n    cornsilk: [\n        255,\n        248,\n        220\n    ],\n    crimson: [\n        220,\n        20,\n        60\n    ],\n    cyan: [\n        0,\n        255,\n        255\n    ],\n    darkblue: [\n        0,\n        0,\n        139\n    ],\n    darkcyan: [\n        0,\n        139,\n        139\n    ],\n    darkgoldenrod: [\n        184,\n        134,\n        11\n    ],\n    darkgray: [\n        169,\n        169,\n        169\n    ],\n    darkgreen: [\n        0,\n        100,\n        0\n    ],\n    darkgrey: [\n        169,\n        169,\n        169\n    ],\n    darkkhaki: [\n        189,\n        183,\n        107\n    ],\n    darkmagenta: [\n        139,\n        0,\n        139\n    ],\n    darkolivegreen: [\n        85,\n        107,\n        47\n    ],\n    darkorange: [\n        255,\n        140,\n        0\n    ],\n    darkorchid: [\n        153,\n        50,\n        204\n    ],\n    darkred: [\n        139,\n        0,\n        0\n    ],\n    darksalmon: [\n        233,\n        150,\n        122\n    ],\n    darkseagreen: [\n        143,\n        188,\n        143\n    ],\n    darkslateblue: [\n        72,\n        61,\n        139\n    ],\n    darkslategray: [\n        47,\n        79,\n        79\n    ],\n    darkslategrey: [\n        47,\n        79,\n        79\n    ],\n    darkturquoise: [\n        0,\n        206,\n        209\n    ],\n    darkviolet: [\n        148,\n        0,\n        211\n    ],\n    deeppink: [\n        255,\n        20,\n        147\n    ],\n    deepskyblue: [\n        0,\n        191,\n        255\n    ],\n    dimgray: [\n        105,\n        105,\n        105\n    ],\n    dimgrey: [\n        105,\n        105,\n        105\n    ],\n    dodgerblue: [\n        30,\n        144,\n        255\n    ],\n    firebrick: [\n        178,\n        34,\n        34\n    ],\n    floralwhite: [\n        255,\n        250,\n        240\n    ],\n    forestgreen: [\n        34,\n        139,\n        34\n    ],\n    fuchsia: [\n        255,\n        0,\n        255\n    ],\n    gainsboro: [\n        220,\n        220,\n        220\n    ],\n    ghostwhite: [\n        248,\n        248,\n        255\n    ],\n    gold: [\n        255,\n        215,\n        0\n    ],\n    goldenrod: [\n        218,\n        165,\n        32\n    ],\n    gray: [\n        128,\n        128,\n        128\n    ],\n    grey: [\n        128,\n        128,\n        128\n    ],\n    green: [\n        0,\n        128,\n        0\n    ],\n    greenyellow: [\n        173,\n        255,\n        47\n    ],\n    honeydew: [\n        240,\n        255,\n        240\n    ],\n    hotpink: [\n        255,\n        105,\n        180\n    ],\n    indianred: [\n        205,\n        92,\n        92\n    ],\n    indigo: [\n        75,\n        0,\n        130\n    ],\n    ivory: [\n        255,\n        255,\n        240\n    ],\n    khaki: [\n        240,\n        230,\n        140\n    ],\n    lavender: [\n        230,\n        230,\n        250\n    ],\n    lavenderblush: [\n        255,\n        240,\n        245\n    ],\n    lawngreen: [\n        124,\n        252,\n        0\n    ],\n    lemonchiffon: [\n        255,\n        250,\n        205\n    ],\n    lightblue: [\n        173,\n        216,\n        230\n    ],\n    lightcoral: [\n        240,\n        128,\n        128\n    ],\n    lightcyan: [\n        224,\n        255,\n        255\n    ],\n    lightgoldenrodyellow: [\n        250,\n        250,\n        210\n    ],\n    lightgray: [\n        211,\n        211,\n        211\n    ],\n    lightgreen: [\n        144,\n        238,\n        144\n    ],\n    lightgrey: [\n        211,\n        211,\n        211\n    ],\n    lightpink: [\n        255,\n        182,\n        193\n    ],\n    lightsalmon: [\n        255,\n        160,\n        122\n    ],\n    lightseagreen: [\n        32,\n        178,\n        170\n    ],\n    lightskyblue: [\n        135,\n        206,\n        250\n    ],\n    lightslategray: [\n        119,\n        136,\n        153\n    ],\n    lightslategrey: [\n        119,\n        136,\n        153\n    ],\n    lightsteelblue: [\n        176,\n        196,\n        222\n    ],\n    lightyellow: [\n        255,\n        255,\n        224\n    ],\n    lime: [\n        0,\n        255,\n        0\n    ],\n    limegreen: [\n        50,\n        205,\n        50\n    ],\n    linen: [\n        250,\n        240,\n        230\n    ],\n    magenta: [\n        255,\n        0,\n        255\n    ],\n    maroon: [\n        128,\n        0,\n        0\n    ],\n    mediumaquamarine: [\n        102,\n        205,\n        170\n    ],\n    mediumblue: [\n        0,\n        0,\n        205\n    ],\n    mediumorchid: [\n        186,\n        85,\n        211\n    ],\n    mediumpurple: [\n        147,\n        112,\n        219\n    ],\n    mediumseagreen: [\n        60,\n        179,\n        113\n    ],\n    mediumslateblue: [\n        123,\n        104,\n        238\n    ],\n    mediumspringgreen: [\n        0,\n        250,\n        154\n    ],\n    mediumturquoise: [\n        72,\n        209,\n        204\n    ],\n    mediumvioletred: [\n        199,\n        21,\n        133\n    ],\n    midnightblue: [\n        25,\n        25,\n        112\n    ],\n    mintcream: [\n        245,\n        255,\n        250\n    ],\n    mistyrose: [\n        255,\n        228,\n        225\n    ],\n    moccasin: [\n        255,\n        228,\n        181\n    ],\n    navajowhite: [\n        255,\n        222,\n        173\n    ],\n    navy: [\n        0,\n        0,\n        128\n    ],\n    oldlace: [\n        253,\n        245,\n        230\n    ],\n    olive: [\n        128,\n        128,\n        0\n    ],\n    olivedrab: [\n        107,\n        142,\n        35\n    ],\n    orange: [\n        255,\n        165,\n        0\n    ],\n    orangered: [\n        255,\n        69,\n        0\n    ],\n    orchid: [\n        218,\n        112,\n        214\n    ],\n    palegoldenrod: [\n        238,\n        232,\n        170\n    ],\n    palegreen: [\n        152,\n        251,\n        152\n    ],\n    paleturquoise: [\n        175,\n        238,\n        238\n    ],\n    palevioletred: [\n        219,\n        112,\n        147\n    ],\n    papayawhip: [\n        255,\n        239,\n        213\n    ],\n    peachpuff: [\n        255,\n        218,\n        185\n    ],\n    peru: [\n        205,\n        133,\n        63\n    ],\n    pink: [\n        255,\n        192,\n        203\n    ],\n    plum: [\n        221,\n        160,\n        221\n    ],\n    powderblue: [\n        176,\n        224,\n        230\n    ],\n    purple: [\n        128,\n        0,\n        128\n    ],\n    red: [\n        255,\n        0,\n        0\n    ],\n    rosybrown: [\n        188,\n        143,\n        143\n    ],\n    royalblue: [\n        65,\n        105,\n        225\n    ],\n    saddlebrown: [\n        139,\n        69,\n        19\n    ],\n    salmon: [\n        250,\n        128,\n        114\n    ],\n    sandybrown: [\n        244,\n        164,\n        96\n    ],\n    seagreen: [\n        46,\n        139,\n        87\n    ],\n    seashell: [\n        255,\n        245,\n        238\n    ],\n    sienna: [\n        160,\n        82,\n        45\n    ],\n    silver: [\n        192,\n        192,\n        192\n    ],\n    skyblue: [\n        135,\n        206,\n        235\n    ],\n    slateblue: [\n        106,\n        90,\n        205\n    ],\n    slategray: [\n        112,\n        128,\n        144\n    ],\n    slategrey: [\n        112,\n        128,\n        144\n    ],\n    snow: [\n        255,\n        250,\n        250\n    ],\n    springgreen: [\n        0,\n        255,\n        127\n    ],\n    steelblue: [\n        70,\n        130,\n        180\n    ],\n    tan: [\n        210,\n        180,\n        140\n    ],\n    teal: [\n        0,\n        128,\n        128\n    ],\n    thistle: [\n        216,\n        191,\n        216\n    ],\n    tomato: [\n        255,\n        99,\n        71\n    ],\n    turquoise: [\n        64,\n        224,\n        208\n    ],\n    violet: [\n        238,\n        130,\n        238\n    ],\n    wheat: [\n        245,\n        222,\n        179\n    ],\n    white: [\n        255,\n        255,\n        255\n    ],\n    whitesmoke: [\n        245,\n        245,\n        245\n    ],\n    yellow: [\n        255,\n        255,\n        0\n    ],\n    yellowgreen: [\n        154,\n        205,\n        50\n    ]\n};\n// sets the value in a map (map may not be built)\nvar setMap = function setMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    for(var i = 0; i < l; i++){\n        var key = keys[i];\n        if (plainObject(key)) {\n            throw Error('Tried to set map with object key');\n        }\n        if (i < keys.length - 1) {\n            // extend the map if necessary\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        } else {\n            // set the value\n            obj[key] = options.value;\n        }\n    }\n};\n// gets the value in a map even if it's not built in places\nvar getMap = function getMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    for(var i = 0; i < l; i++){\n        var key = keys[i];\n        if (plainObject(key)) {\n            throw Error('Tried to get map with object key');\n        }\n        obj = obj[key];\n        if (obj == null) {\n            return obj;\n        }\n    }\n    return obj;\n};\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis :  false ? 0 : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ var isObject_1;\nvar hasRequiredIsObject;\nfunction requireIsObject() {\n    if (hasRequiredIsObject) return isObject_1;\n    hasRequiredIsObject = 1;\n    function isObject(value) {\n        var type = typeof value;\n        return value != null && (type == 'object' || type == 'function');\n    }\n    isObject_1 = isObject;\n    return isObject_1;\n}\n/** Detect free variable `global` from Node.js. */ var _freeGlobal;\nvar hasRequired_freeGlobal;\nfunction require_freeGlobal() {\n    if (hasRequired_freeGlobal) return _freeGlobal;\n    hasRequired_freeGlobal = 1;\n    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n    _freeGlobal = freeGlobal;\n    return _freeGlobal;\n}\nvar _root;\nvar hasRequired_root;\nfunction require_root() {\n    if (hasRequired_root) return _root;\n    hasRequired_root = 1;\n    var freeGlobal = require_freeGlobal();\n    /** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n    /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();\n    _root = root;\n    return _root;\n}\nvar now_1;\nvar hasRequiredNow;\nfunction requireNow() {\n    if (hasRequiredNow) return now_1;\n    hasRequiredNow = 1;\n    var root = require_root();\n    /**\n\t * Gets the timestamp of the number of milliseconds that have elapsed since\n\t * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Date\n\t * @returns {number} Returns the timestamp.\n\t * @example\n\t *\n\t * _.defer(function(stamp) {\n\t *   console.log(_.now() - stamp);\n\t * }, _.now());\n\t * // => Logs the number of milliseconds it took for the deferred invocation.\n\t */ var now = function() {\n        return root.Date.now();\n    };\n    now_1 = now;\n    return now_1;\n}\n/** Used to match a single whitespace character. */ var _trimmedEndIndex;\nvar hasRequired_trimmedEndIndex;\nfunction require_trimmedEndIndex() {\n    if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;\n    hasRequired_trimmedEndIndex = 1;\n    var reWhitespace = /\\s/;\n    /**\n\t * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n\t * character of `string`.\n\t *\n\t * @private\n\t * @param {string} string The string to inspect.\n\t * @returns {number} Returns the index of the last non-whitespace character.\n\t */ function trimmedEndIndex(string) {\n        var index = string.length;\n        while(index-- && reWhitespace.test(string.charAt(index))){}\n        return index;\n    }\n    _trimmedEndIndex = trimmedEndIndex;\n    return _trimmedEndIndex;\n}\nvar _baseTrim;\nvar hasRequired_baseTrim;\nfunction require_baseTrim() {\n    if (hasRequired_baseTrim) return _baseTrim;\n    hasRequired_baseTrim = 1;\n    var trimmedEndIndex = require_trimmedEndIndex();\n    /** Used to match leading whitespace. */ var reTrimStart = /^\\s+/;\n    /**\n\t * The base implementation of `_.trim`.\n\t *\n\t * @private\n\t * @param {string} string The string to trim.\n\t * @returns {string} Returns the trimmed string.\n\t */ function baseTrim(string) {\n        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;\n    }\n    _baseTrim = baseTrim;\n    return _baseTrim;\n}\nvar _Symbol;\nvar hasRequired_Symbol;\nfunction require_Symbol() {\n    if (hasRequired_Symbol) return _Symbol;\n    hasRequired_Symbol = 1;\n    var root = require_root();\n    /** Built-in value references. */ var Symbol1 = root.Symbol;\n    _Symbol = Symbol1;\n    return _Symbol;\n}\nvar _getRawTag;\nvar hasRequired_getRawTag;\nfunction require_getRawTag() {\n    if (hasRequired_getRawTag) return _getRawTag;\n    hasRequired_getRawTag = 1;\n    var Symbol1 = require_Symbol();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */ var nativeObjectToString = objectProto.toString;\n    /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n    /**\n\t * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the raw `toStringTag`.\n\t */ function getRawTag(value) {\n        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n        try {\n            value[symToStringTag] = undefined;\n            var unmasked = true;\n        } catch (e) {}\n        var result = nativeObjectToString.call(value);\n        if (unmasked) {\n            if (isOwn) {\n                value[symToStringTag] = tag;\n            } else {\n                delete value[symToStringTag];\n            }\n        }\n        return result;\n    }\n    _getRawTag = getRawTag;\n    return _getRawTag;\n}\n/** Used for built-in method references. */ var _objectToString;\nvar hasRequired_objectToString;\nfunction require_objectToString() {\n    if (hasRequired_objectToString) return _objectToString;\n    hasRequired_objectToString = 1;\n    var objectProto = Object.prototype;\n    /**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */ var nativeObjectToString = objectProto.toString;\n    /**\n\t * Converts `value` to a string using `Object.prototype.toString`.\n\t *\n\t * @private\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t */ function objectToString(value) {\n        return nativeObjectToString.call(value);\n    }\n    _objectToString = objectToString;\n    return _objectToString;\n}\nvar _baseGetTag;\nvar hasRequired_baseGetTag;\nfunction require_baseGetTag() {\n    if (hasRequired_baseGetTag) return _baseGetTag;\n    hasRequired_baseGetTag = 1;\n    var Symbol1 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();\n    /** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';\n    /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n    /**\n\t * The base implementation of `getTag` without fallbacks for buggy environments.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */ function baseGetTag(value) {\n        if (value == null) {\n            return value === undefined ? undefinedTag : nullTag;\n        }\n        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    _baseGetTag = baseGetTag;\n    return _baseGetTag;\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ var isObjectLike_1;\nvar hasRequiredIsObjectLike;\nfunction requireIsObjectLike() {\n    if (hasRequiredIsObjectLike) return isObjectLike_1;\n    hasRequiredIsObjectLike = 1;\n    function isObjectLike(value) {\n        return value != null && typeof value == 'object';\n    }\n    isObjectLike_1 = isObjectLike;\n    return isObjectLike_1;\n}\nvar isSymbol_1;\nvar hasRequiredIsSymbol;\nfunction requireIsSymbol() {\n    if (hasRequiredIsSymbol) return isSymbol_1;\n    hasRequiredIsSymbol = 1;\n    var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();\n    /** `Object#toString` result references. */ var symbolTag = '[object Symbol]';\n    /**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */ function isSymbol(value) {\n        return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n    }\n    isSymbol_1 = isSymbol;\n    return isSymbol_1;\n}\nvar toNumber_1;\nvar hasRequiredToNumber;\nfunction requireToNumber() {\n    if (hasRequiredToNumber) return toNumber_1;\n    hasRequiredToNumber = 1;\n    var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();\n    /** Used as references for various `Number` constants. */ var NAN = 0 / 0;\n    /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;\n    /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;\n    /** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;\n    /**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3.2);\n\t * // => 3.2\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3.2');\n\t * // => 3.2\n\t */ function toNumber(value) {\n        if (typeof value == 'number') {\n            return value;\n        }\n        if (isSymbol(value)) {\n            return NAN;\n        }\n        if (isObject(value)) {\n            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n            value = isObject(other) ? other + '' : other;\n        }\n        if (typeof value != 'string') {\n            return value === 0 ? value : +value;\n        }\n        value = baseTrim(value);\n        var isBinary = reIsBinary.test(value);\n        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    toNumber_1 = toNumber;\n    return toNumber_1;\n}\nvar debounce_1;\nvar hasRequiredDebounce;\nfunction requireDebounce() {\n    if (hasRequiredDebounce) return debounce_1;\n    hasRequiredDebounce = 1;\n    var isObject = requireIsObject(), now = requireNow(), toNumber = requireToNumber();\n    /** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';\n    /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;\n    /**\n\t * Creates a debounced function that delays invoking `func` until after `wait`\n\t * milliseconds have elapsed since the last time the debounced function was\n\t * invoked. The debounced function comes with a `cancel` method to cancel\n\t * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t * Provide `options` to indicate whether `func` should be invoked on the\n\t * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t * with the last arguments provided to the debounced function. Subsequent\n\t * calls to the debounced function return the result of the last `func`\n\t * invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t * invoked on the trailing edge of the timeout only if the debounced function\n\t * is invoked more than once during the `wait` timeout.\n\t *\n\t * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t *\n\t * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t * for details over the differences between `_.debounce` and `_.throttle`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to debounce.\n\t * @param {number} [wait=0] The number of milliseconds to delay.\n\t * @param {Object} [options={}] The options object.\n\t * @param {boolean} [options.leading=false]\n\t *  Specify invoking on the leading edge of the timeout.\n\t * @param {number} [options.maxWait]\n\t *  The maximum time `func` is allowed to be delayed before it's invoked.\n\t * @param {boolean} [options.trailing=true]\n\t *  Specify invoking on the trailing edge of the timeout.\n\t * @returns {Function} Returns the new debounced function.\n\t * @example\n\t *\n\t * // Avoid costly calculations while the window size is in flux.\n\t * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t *\n\t * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t *   'leading': true,\n\t *   'trailing': false\n\t * }));\n\t *\n\t * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t * var source = new EventSource('/stream');\n\t * jQuery(source).on('message', debounced);\n\t *\n\t * // Cancel the trailing debounced invocation.\n\t * jQuery(window).on('popstate', debounced.cancel);\n\t */ function debounce(func, wait, options) {\n        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n        if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        wait = toNumber(wait) || 0;\n        if (isObject(options)) {\n            leading = !!options.leading;\n            maxing = 'maxWait' in options;\n            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n            trailing = 'trailing' in options ? !!options.trailing : trailing;\n        }\n        function invokeFunc(time) {\n            var args = lastArgs, thisArg = lastThis;\n            lastArgs = lastThis = undefined;\n            lastInvokeTime = time;\n            result = func.apply(thisArg, args);\n            return result;\n        }\n        function leadingEdge(time) {\n            // Reset any `maxWait` timer.\n            lastInvokeTime = time;\n            // Start the timer for the trailing edge.\n            timerId = setTimeout(timerExpired, wait);\n            // Invoke the leading edge.\n            return leading ? invokeFunc(time) : result;\n        }\n        function remainingWait(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n        }\n        function shouldInvoke(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n            // Either this is the first call, activity has stopped and we're at the\n            // trailing edge, the system time has gone backwards and we're treating\n            // it as the trailing edge, or we've hit the `maxWait` limit.\n            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n        }\n        function timerExpired() {\n            var time = now();\n            if (shouldInvoke(time)) {\n                return trailingEdge(time);\n            }\n            // Restart the timer.\n            timerId = setTimeout(timerExpired, remainingWait(time));\n        }\n        function trailingEdge(time) {\n            timerId = undefined;\n            // Only invoke if we have `lastArgs` which means `func` has been\n            // debounced at least once.\n            if (trailing && lastArgs) {\n                return invokeFunc(time);\n            }\n            lastArgs = lastThis = undefined;\n            return result;\n        }\n        function cancel() {\n            if (timerId !== undefined) {\n                clearTimeout(timerId);\n            }\n            lastInvokeTime = 0;\n            lastArgs = lastCallTime = lastThis = timerId = undefined;\n        }\n        function flush() {\n            return timerId === undefined ? result : trailingEdge(now());\n        }\n        function debounced() {\n            var time = now(), isInvoking = shouldInvoke(time);\n            lastArgs = arguments;\n            lastThis = this;\n            lastCallTime = time;\n            if (isInvoking) {\n                if (timerId === undefined) {\n                    return leadingEdge(lastCallTime);\n                }\n                if (maxing) {\n                    // Handle invocations in a tight loop.\n                    clearTimeout(timerId);\n                    timerId = setTimeout(timerExpired, wait);\n                    return invokeFunc(lastCallTime);\n                }\n            }\n            if (timerId === undefined) {\n                timerId = setTimeout(timerExpired, wait);\n            }\n            return result;\n        }\n        debounced.cancel = cancel;\n        debounced.flush = flush;\n        return debounced;\n    }\n    debounce_1 = debounce;\n    return debounce_1;\n}\nvar debounceExports = requireDebounce();\nvar debounce = /*@__PURE__*/ getDefaultExportFromCjs(debounceExports);\nvar performance$1 = _window ? _window.performance : null;\nvar pnow = performance$1 && performance$1.now ? function() {\n    return performance$1.now();\n} : function() {\n    return Date.now();\n};\nvar raf = function() {\n    if (_window) {\n        if (_window.requestAnimationFrame) {\n            return function(fn) {\n                _window.requestAnimationFrame(fn);\n            };\n        } else if (_window.mozRequestAnimationFrame) {\n            return function(fn) {\n                _window.mozRequestAnimationFrame(fn);\n            };\n        } else if (_window.webkitRequestAnimationFrame) {\n            return function(fn) {\n                _window.webkitRequestAnimationFrame(fn);\n            };\n        } else if (_window.msRequestAnimationFrame) {\n            return function(fn) {\n                _window.msRequestAnimationFrame(fn);\n            };\n        }\n    }\n    return function(fn) {\n        if (fn) {\n            setTimeout(function() {\n                fn(pnow());\n            }, 1000 / 60);\n        }\n    };\n}();\nvar requestAnimationFrame = function requestAnimationFrame(fn) {\n    return raf(fn);\n};\nvar performanceNow = pnow;\nvar DEFAULT_HASH_SEED = 9261;\nvar K = 65599; // 37 also works pretty well\nvar DEFAULT_HASH_SEED_ALT = 5381;\nvar hashIterableInts = function hashIterableInts(iterator) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    var hash = seed;\n    var entry;\n    for(;;){\n        entry = iterator.next();\n        if (entry.done) {\n            break;\n        }\n        hash = hash * K + entry.value | 0;\n    }\n    return hash;\n};\nvar hashInt = function hashInt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    return seed * K + num | 0;\n};\nvar hashIntAlt = function hashIntAlt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n    // djb2/string-hash\n    return (seed << 5) + seed + num | 0;\n};\nvar combineHashes = function combineHashes(hash1, hash2) {\n    return hash1 * 0x200000 + hash2;\n};\nvar combineHashesArray = function combineHashesArray(hashes) {\n    return hashes[0] * 0x200000 + hashes[1];\n};\nvar hashArrays = function hashArrays(hashes1, hashes2) {\n    return [\n        hashInt(hashes1[0], hashes2[0]),\n        hashIntAlt(hashes1[1], hashes2[1])\n    ];\n};\nvar hashIntsArray = function hashIntsArray(ints, seed) {\n    var entry = {\n        value: 0,\n        done: false\n    };\n    var i = 0;\n    var length = ints.length;\n    var iterator = {\n        next: function next() {\n            if (i < length) {\n                entry.value = ints[i++];\n            } else {\n                entry.done = true;\n            }\n            return entry;\n        }\n    };\n    return hashIterableInts(iterator, seed);\n};\nvar hashString = function hashString(str, seed) {\n    var entry = {\n        value: 0,\n        done: false\n    };\n    var i = 0;\n    var length = str.length;\n    var iterator = {\n        next: function next() {\n            if (i < length) {\n                entry.value = str.charCodeAt(i++);\n            } else {\n                entry.done = true;\n            }\n            return entry;\n        }\n    };\n    return hashIterableInts(iterator, seed);\n};\nvar hashStrings = function hashStrings() {\n    return hashStringsArray(arguments);\n};\nvar hashStringsArray = function hashStringsArray(strs) {\n    var hash;\n    for(var i = 0; i < strs.length; i++){\n        var str = strs[i];\n        if (i === 0) {\n            hash = hashString(str);\n        } else {\n            hash = hashString(str, hash);\n        }\n    }\n    return hash;\n};\nfunction rotatePoint(x, y, centerX, centerY, angleDegrees) {\n    var angleRadians = angleDegrees * Math.PI / 180;\n    var rotatedX = Math.cos(angleRadians) * (x - centerX) - Math.sin(angleRadians) * (y - centerY) + centerX;\n    var rotatedY = Math.sin(angleRadians) * (x - centerX) + Math.cos(angleRadians) * (y - centerY) + centerY;\n    return {\n        x: rotatedX,\n        y: rotatedY\n    };\n}\nvar movePointByBoxAspect = function movePointByBoxAspect(x, y, boxX, boxY, skewX, skewY) {\n    return {\n        x: (x - boxX) * skewX + boxX,\n        y: (y - boxY) * skewY + boxY\n    };\n};\nfunction rotatePosAndSkewByBox(pos, box, angleDegrees) {\n    if (angleDegrees === 0) return pos;\n    var centerX = (box.x1 + box.x2) / 2;\n    var centerY = (box.y1 + box.y2) / 2;\n    var skewX = box.w / box.h;\n    var skewY = 1 / skewX;\n    var rotated = rotatePoint(pos.x, pos.y, centerX, centerY, angleDegrees);\n    var skewed = movePointByBoxAspect(rotated.x, rotated.y, centerX, centerY, skewX, skewY);\n    return {\n        x: skewed.x,\n        y: skewed.y\n    };\n}\nvar warningsEnabled = true;\nvar warnSupported = console.warn != null;\nvar traceSupported = console.trace != null;\nvar MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar trueify = function trueify() {\n    return true;\n};\nvar falsify = function falsify() {\n    return false;\n};\nvar zeroify = function zeroify() {\n    return 0;\n};\nvar noop$1 = function noop() {};\nvar error = function error(msg) {\n    throw new Error(msg);\n};\nvar warnings = function warnings(enabled) {\n    if (enabled !== undefined) {\n        warningsEnabled = !!enabled;\n    } else {\n        return warningsEnabled;\n    }\n};\nvar warn = function warn(msg) {\n    if (!warnings()) {\n        return;\n    }\n    if (warnSupported) {\n        console.warn(msg);\n    } else {\n        console.log(msg);\n        if (traceSupported) {\n            console.trace();\n        }\n    }\n};\nvar clone = function clone(obj) {\n    return extend({}, obj);\n};\n// gets a shallow copy of the argument\nvar copy = function copy(obj) {\n    if (obj == null) {\n        return obj;\n    }\n    if (array(obj)) {\n        return obj.slice();\n    } else if (plainObject(obj)) {\n        return clone(obj);\n    } else {\n        return obj;\n    }\n};\nvar copyArray = function copyArray(arr) {\n    return arr.slice();\n};\nvar uuid = function uuid(a, b /* placeholders */ ) {\n    for(// loop :)\n    b = a = ''; // b - result , a - numeric letiable\n    a++ < 36; //\n    b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n     ? //  return a random number or 4\n    (a ^ 15 // if \"a\" is not 15\n     ? // generate a random number from 0 to 15\n    8 ^ Math.random() * (a ^ 20 ? 16 : 4 // unless \"a\" is 20, in which case a random number from 8 to 11\n    ) : 4 //  otherwise 4\n    ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n    );\n    return b;\n};\nvar _staticEmptyObject = {};\nvar staticEmptyObject = function staticEmptyObject() {\n    return _staticEmptyObject;\n};\nvar defaults$g = function defaults(_defaults) {\n    var keys = Object.keys(_defaults);\n    return function(opts) {\n        var filledOpts = {};\n        for(var i = 0; i < keys.length; i++){\n            var key = keys[i];\n            var optVal = opts == null ? undefined : opts[key];\n            filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n        }\n        return filledOpts;\n    };\n};\nvar removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n    for(var i = arr.length - 1; i >= 0; i--){\n        if (arr[i] === ele) {\n            arr.splice(i, 1);\n        }\n    }\n};\nvar clearArray = function clearArray(arr) {\n    arr.splice(0, arr.length);\n};\nvar push = function push(arr, otherArr) {\n    for(var i = 0; i < otherArr.length; i++){\n        var el = otherArr[i];\n        arr.push(el);\n    }\n};\nvar getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n    if (prefix) {\n        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n    return obj[propName];\n};\nvar setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n    if (prefix) {\n        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n    obj[propName] = value;\n};\n/* global Map */ var ObjectMap = /*#__PURE__*/ function() {\n    function ObjectMap() {\n        _classCallCheck(this, ObjectMap);\n        this._obj = {};\n    }\n    return _createClass(ObjectMap, [\n        {\n            key: \"set\",\n            value: function set(key, val) {\n                this._obj[key] = val;\n                return this;\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(key) {\n                this._obj[key] = undefined;\n                return this;\n            }\n        },\n        {\n            key: \"clear\",\n            value: function clear() {\n                this._obj = {};\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(key) {\n                return this._obj[key] !== undefined;\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(key) {\n                return this._obj[key];\n            }\n        }\n    ]);\n}();\nvar Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;\n/* global Set */ var undef = \"undefined\";\nvar ObjectSet = /*#__PURE__*/ function() {\n    function ObjectSet(arrayOrObjectSet) {\n        _classCallCheck(this, ObjectSet);\n        this._obj = Object.create(null);\n        this.size = 0;\n        if (arrayOrObjectSet != null) {\n            var arr;\n            if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n                arr = arrayOrObjectSet.toArray();\n            } else {\n                arr = arrayOrObjectSet;\n            }\n            for(var i = 0; i < arr.length; i++){\n                this.add(arr[i]);\n            }\n        }\n    }\n    return _createClass(ObjectSet, [\n        {\n            key: \"instanceString\",\n            value: function instanceString() {\n                return 'set';\n            }\n        },\n        {\n            key: \"add\",\n            value: function add(val) {\n                var o = this._obj;\n                if (o[val] !== 1) {\n                    o[val] = 1;\n                    this.size++;\n                }\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(val) {\n                var o = this._obj;\n                if (o[val] === 1) {\n                    o[val] = 0;\n                    this.size--;\n                }\n            }\n        },\n        {\n            key: \"clear\",\n            value: function clear() {\n                this._obj = Object.create(null);\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(val) {\n                return this._obj[val] === 1;\n            }\n        },\n        {\n            key: \"toArray\",\n            value: function toArray() {\n                var _this = this;\n                return Object.keys(this._obj).filter(function(key) {\n                    return _this.has(key);\n                });\n            }\n        },\n        {\n            key: \"forEach\",\n            value: function forEach(callback, thisArg) {\n                return this.toArray().forEach(callback, thisArg);\n            }\n        }\n    ]);\n}();\nvar Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n// represents a node or an edge\nvar Element = function Element(cy, params) {\n    var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (cy === undefined || params === undefined || !core(cy)) {\n        error('An element must have a core reference and parameters set');\n        return;\n    }\n    var group = params.group;\n    // try to automatically infer the group if unspecified\n    if (group == null) {\n        if (params.data && params.data.source != null && params.data.target != null) {\n            group = 'edges';\n        } else {\n            group = 'nodes';\n        }\n    }\n    // validate group\n    if (group !== 'nodes' && group !== 'edges') {\n        error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n        return;\n    }\n    // make the element array-like, just like a collection\n    this.length = 1;\n    this[0] = this;\n    // NOTE: when something is added here, add also to ele.json()\n    var _p = this._private = {\n        cy: cy,\n        single: true,\n        // indicates this is an element\n        data: params.data || {},\n        // data object\n        position: params.position || {\n            x: 0,\n            y: 0\n        },\n        // (x, y) position pair\n        autoWidth: undefined,\n        // width and height of nodes calculated by the renderer when set to special 'auto' value\n        autoHeight: undefined,\n        autoPadding: undefined,\n        compoundBoundsClean: false,\n        // whether the compound dimensions need to be recalculated the next time dimensions are read\n        listeners: [],\n        // array of bound listeners\n        group: group,\n        // string; 'nodes' or 'edges'\n        style: {},\n        // properties as set by the style\n        rstyle: {},\n        // properties for style sent from the renderer to the core\n        styleCxts: [],\n        // applied style contexts from the styler\n        styleKeys: {},\n        // per-group keys of style property values\n        removed: true,\n        // whether it's inside the vis; true if removed (set true here since we call restore)\n        selected: params.selected ? true : false,\n        // whether it's selected\n        selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n        // whether it's selectable\n        locked: params.locked ? true : false,\n        // whether the element is locked (cannot be moved)\n        grabbed: false,\n        // whether the element is grabbed by the mouse; renderer sets this privately\n        grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n        // whether the element can be grabbed\n        pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,\n        // whether the element has passthrough panning enabled\n        active: false,\n        // whether the element is active from user interaction\n        classes: new Set$1(),\n        // map ( className => true )\n        animation: {\n            // object for currently-running animations\n            current: [],\n            queue: []\n        },\n        rscratch: {},\n        // object in which the renderer can store information\n        scratch: params.scratch || {},\n        // scratch objects\n        edges: [],\n        // array of connected edges\n        children: [],\n        // array of children\n        parent: params.parent && params.parent.isNode() ? params.parent : null,\n        // parent ref\n        traversalCache: {},\n        // cache of output of traversal functions\n        backgrounding: false,\n        // whether background images are loading\n        bbCache: null,\n        // cache of the current bounding box\n        bbCacheShift: {\n            x: 0,\n            y: 0\n        },\n        // shift applied to cached bb to be applied on next get\n        bodyBounds: null,\n        // bounds cache of element body, w/o overlay\n        overlayBounds: null,\n        // bounds cache of element body, including overlay\n        labelBounds: {\n            // bounds cache of labels\n            all: null,\n            source: null,\n            target: null,\n            main: null\n        },\n        arrowBounds: {\n            // bounds cache of edge arrows\n            source: null,\n            target: null,\n            'mid-source': null,\n            'mid-target': null\n        }\n    };\n    if (_p.position.x == null) {\n        _p.position.x = 0;\n    }\n    if (_p.position.y == null) {\n        _p.position.y = 0;\n    }\n    // renderedPosition overrides if specified\n    if (params.renderedPosition) {\n        var rpos = params.renderedPosition;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        _p.position = {\n            x: (rpos.x - pan.x) / zoom,\n            y: (rpos.y - pan.y) / zoom\n        };\n    }\n    var classes = [];\n    if (array(params.classes)) {\n        classes = params.classes;\n    } else if (string(params.classes)) {\n        classes = params.classes.split(/\\s+/);\n    }\n    for(var i = 0, l = classes.length; i < l; i++){\n        var cls = classes[i];\n        if (!cls || cls === '') {\n            continue;\n        }\n        _p.classes.add(cls);\n    }\n    this.createEmitter();\n    if (restore === undefined || restore) {\n        this.restore();\n    }\n    var bypass = params.style || params.css;\n    if (bypass) {\n        warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');\n        this.style(bypass);\n    }\n};\nvar defineSearch = function defineSearch(params) {\n    params = {\n        bfs: params.bfs || !params.dfs,\n        dfs: params.dfs || !params.bfs\n    };\n    // from pseudocode on wikipedia\n    return function searchFn(roots, fn, directed) {\n        var options;\n        if (plainObject(roots) && !elementOrCollection(roots)) {\n            options = roots;\n            roots = options.roots || options.root;\n            fn = options.visit;\n            directed = options.directed;\n        }\n        directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n        fn = fn$6(fn) ? fn : function() {};\n        var cy = this._private.cy;\n        var v = roots = string(roots) ? this.filter(roots) : roots;\n        var Q = [];\n        var connectedNodes = [];\n        var connectedBy = {};\n        var id2depth = {};\n        var V = {};\n        var j = 0;\n        var found;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        // enqueue v\n        for(var i = 0; i < v.length; i++){\n            var vi = v[i];\n            var viId = vi.id();\n            if (vi.isNode()) {\n                Q.unshift(vi);\n                if (params.bfs) {\n                    V[viId] = true;\n                    connectedNodes.push(vi);\n                }\n                id2depth[viId] = 0;\n            }\n        }\n        var _loop = function _loop() {\n            var v = params.bfs ? Q.shift() : Q.pop();\n            var vId = v.id();\n            if (params.dfs) {\n                if (V[vId]) {\n                    return 0; // continue\n                }\n                V[vId] = true;\n                connectedNodes.push(v);\n            }\n            var depth = id2depth[vId];\n            var prevEdge = connectedBy[vId];\n            var src = prevEdge != null ? prevEdge.source() : null;\n            var tgt = prevEdge != null ? prevEdge.target() : null;\n            var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n            var ret;\n            ret = fn(v, prevEdge, prevNode, j++, depth);\n            if (ret === true) {\n                found = v;\n                return 1; // break\n            }\n            if (ret === false) {\n                return 1; // break\n            }\n            var vwEdges = v.connectedEdges().filter(function(e) {\n                return (!directed || e.source().same(v)) && edges.has(e);\n            });\n            for(var _i2 = 0; _i2 < vwEdges.length; _i2++){\n                var e = vwEdges[_i2];\n                var w = e.connectedNodes().filter(function(n) {\n                    return !n.same(v) && nodes.has(n);\n                });\n                var wId = w.id();\n                if (w.length !== 0 && !V[wId]) {\n                    w = w[0];\n                    Q.push(w);\n                    if (params.bfs) {\n                        V[wId] = true;\n                        connectedNodes.push(w);\n                    }\n                    connectedBy[wId] = e;\n                    id2depth[wId] = id2depth[vId] + 1;\n                }\n            }\n        }, _ret;\n        while(Q.length !== 0){\n            _ret = _loop();\n            if (_ret === 0) continue;\n            if (_ret === 1) break;\n        }\n        var connectedEles = cy.collection();\n        for(var _i = 0; _i < connectedNodes.length; _i++){\n            var node = connectedNodes[_i];\n            var edge = connectedBy[node.id()];\n            if (edge != null) {\n                connectedEles.push(edge);\n            }\n            connectedEles.push(node);\n        }\n        return {\n            path: cy.collection(connectedEles),\n            found: cy.collection(found)\n        };\n    };\n};\n// search, spanning trees, etc\nvar elesfn$v = {\n    breadthFirstSearch: defineSearch({\n        bfs: true\n    }),\n    depthFirstSearch: defineSearch({\n        dfs: true\n    })\n};\n// nice, short mathematical alias\nelesfn$v.bfs = elesfn$v.breadthFirstSearch;\nelesfn$v.dfs = elesfn$v.depthFirstSearch;\nvar heap$2 = {\n    exports: {}\n};\nvar heap$1 = heap$2.exports;\nvar hasRequiredHeap$1;\nfunction requireHeap$1() {\n    if (hasRequiredHeap$1) return heap$2.exports;\n    hasRequiredHeap$1 = 1;\n    (function(module, exports) {\n        // Generated by CoffeeScript 1.8.0\n        (function() {\n            var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n            floor = Math.floor, min = Math.min;\n            /*\n\t\t  Default comparison function to be used\n\t\t   */ defaultCmp = function(x, y) {\n                if (x < y) {\n                    return -1;\n                }\n                if (x > y) {\n                    return 1;\n                }\n                return 0;\n            };\n            /*\n\t\t  Insert item x in list a, and keep it sorted assuming a is sorted.\n\t\t  \n\t\t  If x is already in a, insert it to the right of the rightmost x.\n\t\t  \n\t\t  Optional args lo (default 0) and hi (default a.length) bound the slice\n\t\t  of a to be searched.\n\t\t   */ insort = function(a, x, lo, hi, cmp) {\n                var mid;\n                if (lo == null) {\n                    lo = 0;\n                }\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (lo < 0) {\n                    throw new Error('lo must be non-negative');\n                }\n                if (hi == null) {\n                    hi = a.length;\n                }\n                while(lo < hi){\n                    mid = floor((lo + hi) / 2);\n                    if (cmp(x, a[mid]) < 0) {\n                        hi = mid;\n                    } else {\n                        lo = mid + 1;\n                    }\n                }\n                return [].splice.apply(a, [\n                    lo,\n                    lo - lo\n                ].concat(x)), x;\n            };\n            /*\n\t\t  Push item onto heap, maintaining the heap invariant.\n\t\t   */ heappush = function(array, item, cmp) {\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                array.push(item);\n                return _siftdown(array, 0, array.length - 1, cmp);\n            };\n            /*\n\t\t  Pop the smallest item off the heap, maintaining the heap invariant.\n\t\t   */ heappop = function(array, cmp) {\n                var lastelt, returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                lastelt = array.pop();\n                if (array.length) {\n                    returnitem = array[0];\n                    array[0] = lastelt;\n                    _siftup(array, 0, cmp);\n                } else {\n                    returnitem = lastelt;\n                }\n                return returnitem;\n            };\n            /*\n\t\t  Pop and return the current smallest value, and add the new item.\n\t\t  \n\t\t  This is more efficient than heappop() followed by heappush(), and can be\n\t\t  more appropriate when using a fixed size heap. Note that the value\n\t\t  returned may be larger than item! That constrains reasonable use of\n\t\t  this routine unless written as part of a conditional replacement:\n\t\t      if item > array[0]\n\t\t        item = heapreplace(array, item)\n\t\t   */ heapreplace = function(array, item, cmp) {\n                var returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                returnitem = array[0];\n                array[0] = item;\n                _siftup(array, 0, cmp);\n                return returnitem;\n            };\n            /*\n\t\t  Fast version of a heappush followed by a heappop.\n\t\t   */ heappushpop = function(array, item, cmp) {\n                var _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (array.length && cmp(array[0], item) < 0) {\n                    _ref = [\n                        array[0],\n                        item\n                    ], item = _ref[0], array[0] = _ref[1];\n                    _siftup(array, 0, cmp);\n                }\n                return item;\n            };\n            /*\n\t\t  Transform list into a heap, in-place, in O(array.length) time.\n\t\t   */ heapify = function(array, cmp) {\n                var i, _i, _len, _ref1, _results, _results1;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                _ref1 = (function() {\n                    _results1 = [];\n                    for(var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){\n                        _results1.push(_j);\n                    }\n                    return _results1;\n                }).apply(this).reverse();\n                _results = [];\n                for(_i = 0, _len = _ref1.length; _i < _len; _i++){\n                    i = _ref1[_i];\n                    _results.push(_siftup(array, i, cmp));\n                }\n                return _results;\n            };\n            /*\n\t\t  Update the position of the given item in the heap.\n\t\t  This function should be called every time the item is being modified.\n\t\t   */ updateItem = function(array, item, cmp) {\n                var pos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                pos = array.indexOf(item);\n                if (pos === -1) {\n                    return;\n                }\n                _siftdown(array, 0, pos, cmp);\n                return _siftup(array, pos, cmp);\n            };\n            /*\n\t\t  Find the n largest elements in a dataset.\n\t\t   */ nlargest = function(array, n, cmp) {\n                var elem, result, _i, _len, _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                result = array.slice(0, n);\n                if (!result.length) {\n                    return result;\n                }\n                heapify(result, cmp);\n                _ref = array.slice(n);\n                for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                    elem = _ref[_i];\n                    heappushpop(result, elem, cmp);\n                }\n                return result.sort(cmp).reverse();\n            };\n            /*\n\t\t  Find the n smallest elements in a dataset.\n\t\t   */ nsmallest = function(array, n, cmp) {\n                var elem, los, result, _i, _j, _len, _ref, _ref1, _results;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (n * 10 <= array.length) {\n                    result = array.slice(0, n).sort(cmp);\n                    if (!result.length) {\n                        return result;\n                    }\n                    los = result[result.length - 1];\n                    _ref = array.slice(n);\n                    for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                        elem = _ref[_i];\n                        if (cmp(elem, los) < 0) {\n                            insort(result, elem, 0, null, cmp);\n                            result.pop();\n                            los = result[result.length - 1];\n                        }\n                    }\n                    return result;\n                }\n                heapify(array, cmp);\n                _results = [];\n                for(_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j){\n                    _results.push(heappop(array, cmp));\n                }\n                return _results;\n            };\n            _siftdown = function(array, startpos, pos, cmp) {\n                var newitem, parent, parentpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                newitem = array[pos];\n                while(pos > startpos){\n                    parentpos = pos - 1 >> 1;\n                    parent = array[parentpos];\n                    if (cmp(newitem, parent) < 0) {\n                        array[pos] = parent;\n                        pos = parentpos;\n                        continue;\n                    }\n                    break;\n                }\n                return array[pos] = newitem;\n            };\n            _siftup = function(array, pos, cmp) {\n                var childpos, endpos, newitem, rightpos, startpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                endpos = array.length;\n                startpos = pos;\n                newitem = array[pos];\n                childpos = 2 * pos + 1;\n                while(childpos < endpos){\n                    rightpos = childpos + 1;\n                    if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n                        childpos = rightpos;\n                    }\n                    array[pos] = array[childpos];\n                    pos = childpos;\n                    childpos = 2 * pos + 1;\n                }\n                array[pos] = newitem;\n                return _siftdown(array, startpos, pos, cmp);\n            };\n            Heap = function() {\n                Heap.push = heappush;\n                Heap.pop = heappop;\n                Heap.replace = heapreplace;\n                Heap.pushpop = heappushpop;\n                Heap.heapify = heapify;\n                Heap.updateItem = updateItem;\n                Heap.nlargest = nlargest;\n                Heap.nsmallest = nsmallest;\n                function Heap(cmp) {\n                    this.cmp = cmp != null ? cmp : defaultCmp;\n                    this.nodes = [];\n                }\n                Heap.prototype.push = function(x) {\n                    return heappush(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pop = function() {\n                    return heappop(this.nodes, this.cmp);\n                };\n                Heap.prototype.peek = function() {\n                    return this.nodes[0];\n                };\n                Heap.prototype.contains = function(x) {\n                    return this.nodes.indexOf(x) !== -1;\n                };\n                Heap.prototype.replace = function(x) {\n                    return heapreplace(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pushpop = function(x) {\n                    return heappushpop(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.heapify = function() {\n                    return heapify(this.nodes, this.cmp);\n                };\n                Heap.prototype.updateItem = function(x) {\n                    return updateItem(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.clear = function() {\n                    return this.nodes = [];\n                };\n                Heap.prototype.empty = function() {\n                    return this.nodes.length === 0;\n                };\n                Heap.prototype.size = function() {\n                    return this.nodes.length;\n                };\n                Heap.prototype.clone = function() {\n                    var heap;\n                    heap = new Heap();\n                    heap.nodes = this.nodes.slice(0);\n                    return heap;\n                };\n                Heap.prototype.toArray = function() {\n                    return this.nodes.slice(0);\n                };\n                Heap.prototype.insert = Heap.prototype.push;\n                Heap.prototype.top = Heap.prototype.peek;\n                Heap.prototype.front = Heap.prototype.peek;\n                Heap.prototype.has = Heap.prototype.contains;\n                Heap.prototype.copy = Heap.prototype.clone;\n                return Heap;\n            }();\n            (function(root, factory) {\n                {\n                    return module.exports = factory();\n                }\n            })(this, function() {\n                return Heap;\n            });\n        }).call(heap$1);\n    })(heap$2);\n    return heap$2.exports;\n}\nvar heap;\nvar hasRequiredHeap;\nfunction requireHeap() {\n    if (hasRequiredHeap) return heap;\n    hasRequiredHeap = 1;\n    heap = requireHeap$1();\n    return heap;\n}\nvar heapExports = requireHeap();\nvar Heap = /*@__PURE__*/ getDefaultExportFromCjs(heapExports);\nvar dijkstraDefaults = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false\n});\nvar elesfn$u = {\n    dijkstra: function dijkstra(options) {\n        if (!plainObject(options)) {\n            var args = arguments;\n            options = {\n                root: args[0],\n                weight: args[1],\n                directed: args[2]\n            };\n        }\n        var _dijkstraDefaults = dijkstraDefaults(options), root = _dijkstraDefaults.root, weight = _dijkstraDefaults.weight, directed = _dijkstraDefaults.directed;\n        var eles = this;\n        var weightFn = weight;\n        var source = string(root) ? this.filter(root)[0] : root[0];\n        var dist = {};\n        var prev = {};\n        var knownDist = {};\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        edges.unmergeBy(function(ele) {\n            return ele.isLoop();\n        });\n        var getDist = function getDist(node) {\n            return dist[node.id()];\n        };\n        var setDist = function setDist(node, d) {\n            dist[node.id()] = d;\n            Q.updateItem(node);\n        };\n        var Q = new Heap(function(a, b) {\n            return getDist(a) - getDist(b);\n        });\n        for(var i = 0; i < nodes.length; i++){\n            var node = nodes[i];\n            dist[node.id()] = node.same(source) ? 0 : Infinity;\n            Q.push(node);\n        }\n        var distBetween = function distBetween(u, v) {\n            var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n            var smallestDistance = Infinity;\n            var smallestEdge;\n            for(var _i = 0; _i < uvs.length; _i++){\n                var edge = uvs[_i];\n                var _weight = weightFn(edge);\n                if (_weight < smallestDistance || !smallestEdge) {\n                    smallestDistance = _weight;\n                    smallestEdge = edge;\n                }\n            }\n            return {\n                edge: smallestEdge,\n                dist: smallestDistance\n            };\n        };\n        while(Q.size() > 0){\n            var u = Q.pop();\n            var smalletsDist = getDist(u);\n            var uid = u.id();\n            knownDist[uid] = smalletsDist;\n            if (smalletsDist === Infinity) {\n                continue;\n            }\n            var neighbors = u.neighborhood().intersect(nodes);\n            for(var _i2 = 0; _i2 < neighbors.length; _i2++){\n                var v = neighbors[_i2];\n                var vid = v.id();\n                var vDist = distBetween(u, v);\n                var alt = smalletsDist + vDist.dist;\n                if (alt < getDist(v)) {\n                    setDist(v, alt);\n                    prev[vid] = {\n                        node: u,\n                        edge: vDist.edge\n                    };\n                }\n            } // for\n        } // while\n        return {\n            distanceTo: function distanceTo(node) {\n                var target = string(node) ? nodes.filter(node)[0] : node[0];\n                return knownDist[target.id()];\n            },\n            pathTo: function pathTo(node) {\n                var target = string(node) ? nodes.filter(node)[0] : node[0];\n                var S = [];\n                var u = target;\n                var uid = u.id();\n                if (target.length > 0) {\n                    S.unshift(target);\n                    while(prev[uid]){\n                        var p = prev[uid];\n                        S.unshift(p.edge);\n                        S.unshift(p.node);\n                        u = p.node;\n                        uid = u.id();\n                    }\n                }\n                return eles.spawn(S);\n            }\n        };\n    }\n};\nvar elesfn$t = {\n    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n    // implemented from pseudocode from wikipedia\n    kruskal: function kruskal(weightFn) {\n        weightFn = weightFn || function(edge) {\n            return 1;\n        };\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var numNodes = nodes.length;\n        var forest = new Array(numNodes);\n        var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n        var findSetIndex = function findSetIndex(ele) {\n            for(var i = 0; i < forest.length; i++){\n                var eles = forest[i];\n                if (eles.has(ele)) {\n                    return i;\n                }\n            }\n        };\n        // start with one forest per node\n        for(var i = 0; i < numNodes; i++){\n            forest[i] = this.spawn(nodes[i]);\n        }\n        var S = edges.sort(function(a, b) {\n            return weightFn(a) - weightFn(b);\n        });\n        for(var _i = 0; _i < S.length; _i++){\n            var edge = S[_i];\n            var u = edge.source()[0];\n            var v = edge.target()[0];\n            var setUIndex = findSetIndex(u);\n            var setVIndex = findSetIndex(v);\n            var setU = forest[setUIndex];\n            var setV = forest[setVIndex];\n            if (setUIndex !== setVIndex) {\n                A.merge(edge);\n                // combine forests for u and v\n                setU.merge(setV);\n                forest.splice(setVIndex, 1);\n            }\n        }\n        return A;\n    }\n};\nvar aStarDefaults = defaults$g({\n    root: null,\n    goal: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    heuristic: function heuristic(edge) {\n        return 0;\n    },\n    directed: false\n});\nvar elesfn$s = {\n    // Implemented from pseudocode from wikipedia\n    aStar: function aStar(options) {\n        var cy = this.cy();\n        var _aStarDefaults = aStarDefaults(options), root = _aStarDefaults.root, goal = _aStarDefaults.goal, heuristic = _aStarDefaults.heuristic, directed = _aStarDefaults.directed, weight = _aStarDefaults.weight;\n        root = cy.collection(root)[0];\n        goal = cy.collection(goal)[0];\n        var sid = root.id();\n        var tid = goal.id();\n        var gScore = {};\n        var fScore = {};\n        var closedSetIds = {};\n        var openSet = new Heap(function(a, b) {\n            return fScore[a.id()] - fScore[b.id()];\n        });\n        var openSetIds = new Set$1();\n        var cameFrom = {};\n        var cameFromEdge = {};\n        var addToOpenSet = function addToOpenSet(ele, id) {\n            openSet.push(ele);\n            openSetIds.add(id);\n        };\n        var cMin, cMinId;\n        var popFromOpenSet = function popFromOpenSet() {\n            cMin = openSet.pop();\n            cMinId = cMin.id();\n            openSetIds[\"delete\"](cMinId);\n        };\n        var isInOpenSet = function isInOpenSet(id) {\n            return openSetIds.has(id);\n        };\n        addToOpenSet(root, sid);\n        gScore[sid] = 0;\n        fScore[sid] = heuristic(root);\n        // Counter\n        var steps = 0;\n        // Main loop\n        while(openSet.size() > 0){\n            popFromOpenSet();\n            steps++;\n            // If we've found our goal, then we are done\n            if (cMinId === tid) {\n                var path = [];\n                var pathNode = goal;\n                var pathNodeId = tid;\n                var pathEdge = cameFromEdge[pathNodeId];\n                for(;;){\n                    path.unshift(pathNode);\n                    if (pathEdge != null) {\n                        path.unshift(pathEdge);\n                    }\n                    pathNode = cameFrom[pathNodeId];\n                    if (pathNode == null) {\n                        break;\n                    }\n                    pathNodeId = pathNode.id();\n                    pathEdge = cameFromEdge[pathNodeId];\n                }\n                return {\n                    found: true,\n                    distance: gScore[cMinId],\n                    path: this.spawn(path),\n                    steps: steps\n                };\n            }\n            // Add cMin to processed nodes\n            closedSetIds[cMinId] = true;\n            // Update scores for neighbors of cMin\n            // Take into account if graph is directed or not\n            var vwEdges = cMin._private.edges;\n            for(var i = 0; i < vwEdges.length; i++){\n                var e = vwEdges[i];\n                // edge must be in set of calling eles\n                if (!this.hasElementWithId(e.id())) {\n                    continue;\n                }\n                // cMin must be the source of edge if directed\n                if (directed && e.data('source') !== cMinId) {\n                    continue;\n                }\n                var wSrc = e.source();\n                var wTgt = e.target();\n                var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n                var wid = w.id();\n                // node must be in set of calling eles\n                if (!this.hasElementWithId(wid)) {\n                    continue;\n                }\n                // if node is in closedSet, ignore it\n                if (closedSetIds[wid]) {\n                    continue;\n                }\n                // New tentative score for node w\n                var tempScore = gScore[cMinId] + weight(e);\n                // Update gScore for node w if:\n                //   w not present in openSet\n                // OR\n                //   tentative gScore is less than previous value\n                // w not in openSet\n                if (!isInOpenSet(wid)) {\n                    gScore[wid] = tempScore;\n                    fScore[wid] = tempScore + heuristic(w);\n                    addToOpenSet(w, wid);\n                    cameFrom[wid] = cMin;\n                    cameFromEdge[wid] = e;\n                    continue;\n                }\n                // w already in openSet, but with greater gScore\n                if (tempScore < gScore[wid]) {\n                    gScore[wid] = tempScore;\n                    fScore[wid] = tempScore + heuristic(w);\n                    cameFrom[wid] = cMin;\n                    cameFromEdge[wid] = e;\n                }\n            } // End of neighbors update\n        } // End of main loop\n        // If we've reached here, then we've not reached our goal\n        return {\n            found: false,\n            distance: undefined,\n            path: undefined,\n            steps: steps\n        };\n    }\n}; // elesfn\nvar floydWarshallDefaults = defaults$g({\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false\n});\nvar elesfn$r = {\n    // Implemented from pseudocode from wikipedia\n    floydWarshall: function floydWarshall(options) {\n        var cy = this.cy();\n        var _floydWarshallDefault = floydWarshallDefaults(options), weight = _floydWarshallDefault.weight, directed = _floydWarshallDefault.directed;\n        var weightFn = weight;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var N = nodes.length;\n        var Nsq = N * N;\n        var indexOf = function indexOf(node) {\n            return nodes.indexOf(node);\n        };\n        var atIndex = function atIndex(i) {\n            return nodes[i];\n        };\n        // Initialize distance matrix\n        var dist = new Array(Nsq);\n        for(var n = 0; n < Nsq; n++){\n            var j = n % N;\n            var i = (n - j) / N;\n            if (i === j) {\n                dist[n] = 0;\n            } else {\n                dist[n] = Infinity;\n            }\n        }\n        // Initialize matrix used for path reconstruction\n        // Initialize distance matrix\n        var next = new Array(Nsq);\n        var edgeNext = new Array(Nsq);\n        // Process edges\n        for(var _i = 0; _i < edges.length; _i++){\n            var edge = edges[_i];\n            var src = edge.source()[0];\n            var tgt = edge.target()[0];\n            if (src === tgt) {\n                continue;\n            } // exclude loops\n            var s = indexOf(src);\n            var t = indexOf(tgt);\n            var st = s * N + t; // source to target index\n            var _weight = weightFn(edge);\n            // Check if already process another edge between same 2 nodes\n            if (dist[st] > _weight) {\n                dist[st] = _weight;\n                next[st] = t;\n                edgeNext[st] = edge;\n            }\n            // If undirected graph, process 'reversed' edge\n            if (!directed) {\n                var ts = t * N + s; // target to source index\n                if (!directed && dist[ts] > _weight) {\n                    dist[ts] = _weight;\n                    next[ts] = s;\n                    edgeNext[ts] = edge;\n                }\n            }\n        }\n        // Main loop\n        for(var k = 0; k < N; k++){\n            for(var _i2 = 0; _i2 < N; _i2++){\n                var ik = _i2 * N + k;\n                for(var _j = 0; _j < N; _j++){\n                    var ij = _i2 * N + _j;\n                    var kj = k * N + _j;\n                    if (dist[ik] + dist[kj] < dist[ij]) {\n                        dist[ij] = dist[ik] + dist[kj];\n                        next[ij] = next[ik];\n                    }\n                }\n            }\n        }\n        var getArgEle = function getArgEle(ele) {\n            return (string(ele) ? cy.filter(ele) : ele)[0];\n        };\n        var indexOfArgEle = function indexOfArgEle(ele) {\n            return indexOf(getArgEle(ele));\n        };\n        var res = {\n            distance: function distance(from, to) {\n                var i = indexOfArgEle(from);\n                var j = indexOfArgEle(to);\n                return dist[i * N + j];\n            },\n            path: function path(from, to) {\n                var i = indexOfArgEle(from);\n                var j = indexOfArgEle(to);\n                var fromNode = atIndex(i);\n                if (i === j) {\n                    return fromNode.collection();\n                }\n                if (next[i * N + j] == null) {\n                    return cy.collection();\n                }\n                var path = cy.collection();\n                var prev = i;\n                var edge;\n                path.merge(fromNode);\n                while(i !== j){\n                    prev = i;\n                    i = next[i * N + j];\n                    edge = edgeNext[prev * N + i];\n                    path.merge(edge);\n                    path.merge(atIndex(i));\n                }\n                return path;\n            }\n        };\n        return res;\n    } // floydWarshall\n}; // elesfn\nvar bellmanFordDefaults = defaults$g({\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false,\n    root: null\n});\nvar elesfn$q = {\n    // Implemented from pseudocode from wikipedia\n    bellmanFord: function bellmanFord(options) {\n        var _this = this;\n        var _bellmanFordDefaults = bellmanFordDefaults(options), weight = _bellmanFordDefaults.weight, directed = _bellmanFordDefaults.directed, root = _bellmanFordDefaults.root;\n        var weightFn = weight;\n        var eles = this;\n        var cy = this.cy();\n        var _this$byGroup = this.byGroup(), edges = _this$byGroup.edges, nodes = _this$byGroup.nodes;\n        var numNodes = nodes.length;\n        var infoMap = new Map$1();\n        var hasNegativeWeightCycle = false;\n        var negativeWeightCycles = [];\n        root = cy.collection(root)[0]; // in case selector passed\n        edges.unmergeBy(function(edge) {\n            return edge.isLoop();\n        });\n        var numEdges = edges.length;\n        var getInfo = function getInfo(node) {\n            var obj = infoMap.get(node.id());\n            if (!obj) {\n                obj = {};\n                infoMap.set(node.id(), obj);\n            }\n            return obj;\n        };\n        var getNodeFromTo = function getNodeFromTo(to) {\n            return (string(to) ? cy.$(to) : to)[0];\n        };\n        var distanceTo = function distanceTo(to) {\n            return getInfo(getNodeFromTo(to)).dist;\n        };\n        var pathTo = function pathTo(to) {\n            var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n            var end = getNodeFromTo(to);\n            var path = [];\n            var node = end;\n            for(;;){\n                if (node == null) {\n                    return _this.spawn();\n                }\n                var _getInfo = getInfo(node), edge = _getInfo.edge, pred = _getInfo.pred;\n                path.unshift(node[0]);\n                if (node.same(thisStart) && path.length > 0) {\n                    break;\n                }\n                if (edge != null) {\n                    path.unshift(edge);\n                }\n                node = pred;\n            }\n            return eles.spawn(path);\n        };\n        // Initializations { dist, pred, edge }\n        for(var i = 0; i < numNodes; i++){\n            var node = nodes[i];\n            var info = getInfo(node);\n            if (node.same(root)) {\n                info.dist = 0;\n            } else {\n                info.dist = Infinity;\n            }\n            info.pred = null;\n            info.edge = null;\n        }\n        // Edges relaxation\n        var replacedEdge = false;\n        var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n            var dist = info1.dist + weight;\n            if (dist < info2.dist && !edge.same(info1.edge)) {\n                info2.dist = dist;\n                info2.pred = node1;\n                info2.edge = edge;\n                replacedEdge = true;\n            }\n        };\n        for(var _i = 1; _i < numNodes; _i++){\n            replacedEdge = false;\n            for(var e = 0; e < numEdges; e++){\n                var edge = edges[e];\n                var src = edge.source();\n                var tgt = edge.target();\n                var _weight = weightFn(edge);\n                var srcInfo = getInfo(src);\n                var tgtInfo = getInfo(tgt);\n                checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight);\n                // If undirected graph, we need to take into account the 'reverse' edge\n                if (!directed) {\n                    checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n                }\n            }\n            if (!replacedEdge) {\n                break;\n            }\n        }\n        if (replacedEdge) {\n            // Check for negative weight cycles\n            var negativeWeightCycleIds = [];\n            for(var _e = 0; _e < numEdges; _e++){\n                var _edge = edges[_e];\n                var _src = _edge.source();\n                var _tgt = _edge.target();\n                var _weight2 = weightFn(_edge);\n                var srcDist = getInfo(_src).dist;\n                var tgtDist = getInfo(_tgt).dist;\n                if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n                    if (!hasNegativeWeightCycle) {\n                        warn('Graph contains a negative weight cycle for Bellman-Ford');\n                        hasNegativeWeightCycle = true;\n                    }\n                    if (options.findNegativeWeightCycles !== false) {\n                        var negativeNodes = [];\n                        if (srcDist + _weight2 < tgtDist) {\n                            negativeNodes.push(_src);\n                        }\n                        if (!directed && tgtDist + _weight2 < srcDist) {\n                            negativeNodes.push(_tgt);\n                        }\n                        var numNegativeNodes = negativeNodes.length;\n                        for(var n = 0; n < numNegativeNodes; n++){\n                            var start = negativeNodes[n];\n                            var cycle = [\n                                start\n                            ];\n                            cycle.push(getInfo(start).edge);\n                            var _node = getInfo(start).pred;\n                            while(cycle.indexOf(_node) === -1){\n                                cycle.push(_node);\n                                cycle.push(getInfo(_node).edge);\n                                _node = getInfo(_node).pred;\n                            }\n                            cycle = cycle.slice(cycle.indexOf(_node));\n                            var smallestId = cycle[0].id();\n                            var smallestIndex = 0;\n                            for(var c = 2; c < cycle.length; c += 2){\n                                if (cycle[c].id() < smallestId) {\n                                    smallestId = cycle[c].id();\n                                    smallestIndex = c;\n                                }\n                            }\n                            cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n                            cycle.push(cycle[0]);\n                            var cycleId = cycle.map(function(el) {\n                                return el.id();\n                            }).join(\",\");\n                            if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                                negativeWeightCycles.push(eles.spawn(cycle));\n                                negativeWeightCycleIds.push(cycleId);\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        return {\n            distanceTo: distanceTo,\n            pathTo: pathTo,\n            hasNegativeWeightCycle: hasNegativeWeightCycle,\n            negativeWeightCycles: negativeWeightCycles\n        };\n    } // bellmanFord\n}; // elesfn\nvar sqrt2 = Math.sqrt(2);\n// Function which colapses 2 (meta) nodes into one\n// Updates the remaining edge lists\n// Receives as a paramater the edge which causes the collapse\nvar collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n    if (remainingEdges.length === 0) {\n        error(\"Karger-Stein must be run on a connected (sub)graph\");\n    }\n    var edgeInfo = remainingEdges[edgeIndex];\n    var sourceIn = edgeInfo[1];\n    var targetIn = edgeInfo[2];\n    var partition1 = nodeMap[sourceIn];\n    var partition2 = nodeMap[targetIn];\n    var newEdges = remainingEdges; // re-use array\n    // Delete all edges between partition1 and partition2\n    for(var i = newEdges.length - 1; i >= 0; i--){\n        var edge = newEdges[i];\n        var src = edge[1];\n        var tgt = edge[2];\n        if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n            newEdges.splice(i, 1);\n        }\n    }\n    // All edges pointing to partition2 should now point to partition1\n    for(var _i = 0; _i < newEdges.length; _i++){\n        var _edge = newEdges[_i];\n        if (_edge[1] === partition2) {\n            // Check source\n            newEdges[_i] = _edge.slice(); // copy\n            newEdges[_i][1] = partition1;\n        } else if (_edge[2] === partition2) {\n            // Check target\n            newEdges[_i] = _edge.slice(); // copy\n            newEdges[_i][2] = partition1;\n        }\n    }\n    // Move all nodes from partition2 to partition1\n    for(var _i2 = 0; _i2 < nodeMap.length; _i2++){\n        if (nodeMap[_i2] === partition2) {\n            nodeMap[_i2] = partition1;\n        }\n    }\n    return newEdges;\n};\n// Contracts a graph until we reach a certain number of meta nodes\nvar contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n    while(size > sizeLimit){\n        // Choose an edge randomly\n        var edgeIndex = Math.floor(Math.random() * remainingEdges.length);\n        // Collapse graph based on edge\n        remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n        size--;\n    }\n    return remainingEdges;\n};\nvar elesfn$p = {\n    // Computes the minimum cut of an undirected graph\n    // Returns the correct answer with high probability\n    kargerStein: function kargerStein() {\n        var _this = this;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        edges.unmergeBy(function(edge) {\n            return edge.isLoop();\n        });\n        var numNodes = nodes.length;\n        var numEdges = edges.length;\n        var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n        var stopSize = Math.floor(numNodes / sqrt2);\n        if (numNodes < 2) {\n            error('At least 2 nodes are required for Karger-Stein algorithm');\n            return undefined;\n        }\n        // Now store edge destination as indexes\n        // Format for each edge (edge index, source node index, target node index)\n        var edgeIndexes = [];\n        for(var i = 0; i < numEdges; i++){\n            var e = edges[i];\n            edgeIndexes.push([\n                i,\n                nodes.indexOf(e.source()),\n                nodes.indexOf(e.target())\n            ]);\n        }\n        // We will store the best cut found here\n        var minCutSize = Infinity;\n        var minCutEdgeIndexes = [];\n        var minCutNodeMap = new Array(numNodes);\n        // Initial meta node partition\n        var metaNodeMap = new Array(numNodes);\n        var metaNodeMap2 = new Array(numNodes);\n        var copyNodesMap = function copyNodesMap(from, to) {\n            for(var _i3 = 0; _i3 < numNodes; _i3++){\n                to[_i3] = from[_i3];\n            }\n        };\n        // Main loop\n        for(var iter = 0; iter <= numIter; iter++){\n            // Reset meta node partition\n            for(var _i4 = 0; _i4 < numNodes; _i4++){\n                metaNodeMap[_i4] = _i4;\n            }\n            // Contract until stop point (stopSize nodes)\n            var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n            var edgesState2 = edgesState.slice(); // copy\n            // Create a copy of the colapsed nodes state\n            copyNodesMap(metaNodeMap, metaNodeMap2);\n            // Run 2 iterations starting in the stop state\n            var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n            var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2);\n            // Is any of the 2 results the best cut so far?\n            if (res1.length <= res2.length && res1.length < minCutSize) {\n                minCutSize = res1.length;\n                minCutEdgeIndexes = res1;\n                copyNodesMap(metaNodeMap, minCutNodeMap);\n            } else if (res2.length <= res1.length && res2.length < minCutSize) {\n                minCutSize = res2.length;\n                minCutEdgeIndexes = res2;\n                copyNodesMap(metaNodeMap2, minCutNodeMap);\n            }\n        } // end of main loop\n        // Construct result\n        var cut = this.spawn(minCutEdgeIndexes.map(function(e) {\n            return edges[e[0]];\n        }));\n        var partition1 = this.spawn();\n        var partition2 = this.spawn();\n        // traverse metaNodeMap for best cut\n        var witnessNodePartition = minCutNodeMap[0];\n        for(var _i5 = 0; _i5 < minCutNodeMap.length; _i5++){\n            var partitionId = minCutNodeMap[_i5];\n            var node = nodes[_i5];\n            if (partitionId === witnessNodePartition) {\n                partition1.merge(node);\n            } else {\n                partition2.merge(node);\n            }\n        }\n        // construct components corresponding to each disjoint subset of nodes\n        var constructComponent = function constructComponent(subset) {\n            var component = _this.spawn();\n            subset.forEach(function(node) {\n                component.merge(node);\n                node.connectedEdges().forEach(function(edge) {\n                    // ensure edge is within calling collection and edge is not in cut\n                    if (_this.contains(edge) && !cut.contains(edge)) {\n                        component.merge(edge);\n                    }\n                });\n            });\n            return component;\n        };\n        var components = [\n            constructComponent(partition1),\n            constructComponent(partition2)\n        ];\n        var ret = {\n            cut: cut,\n            components: components,\n            // n.b. partitions are included to be compatible with the old api spec\n            // (could be removed in a future major version)\n            partition1: partition1,\n            partition2: partition2\n        };\n        return ret;\n    }\n}; // elesfn\nvar _Math$hypot;\nvar copyPosition = function copyPosition(p) {\n    return {\n        x: p.x,\n        y: p.y\n    };\n};\nvar modelToRenderedPosition$1 = function modelToRenderedPosition(p, zoom, pan) {\n    return {\n        x: p.x * zoom + pan.x,\n        y: p.y * zoom + pan.y\n    };\n};\nvar renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n    return {\n        x: (p.x - pan.x) / zoom,\n        y: (p.y - pan.y) / zoom\n    };\n};\nvar array2point = function array2point(arr) {\n    return {\n        x: arr[0],\n        y: arr[1]\n    };\n};\nvar min = function min(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var min = Infinity;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            min = Math.min(val, min);\n        }\n    }\n    return min;\n};\nvar max = function max(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var max = -Infinity;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            max = Math.max(val, max);\n        }\n    }\n    return max;\n};\nvar mean = function mean(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var total = 0;\n    var n = 0;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            total += val;\n            n++;\n        }\n    }\n    return total / n;\n};\nvar median = function median(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (copy) {\n        arr = arr.slice(begin, end);\n    } else {\n        if (end < arr.length) {\n            arr.splice(end, arr.length - end);\n        }\n        if (begin > 0) {\n            arr.splice(0, begin);\n        }\n    }\n    // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n    var off = 0; // offset from non-finite values\n    for(var i = arr.length - 1; i >= 0; i--){\n        var v = arr[i];\n        if (includeHoles) {\n            if (!isFinite(v)) {\n                arr[i] = -Infinity;\n                off++;\n            }\n        } else {\n            // just remove it if we don't want to consider holes\n            arr.splice(i, 1);\n        }\n    }\n    if (sort) {\n        arr.sort(function(a, b) {\n            return a - b;\n        }); // requires copy = true if you don't want to change the orig\n    }\n    var len = arr.length;\n    var mid = Math.floor(len / 2);\n    if (len % 2 !== 0) {\n        return arr[mid + 1 + off];\n    } else {\n        return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n    }\n};\nvar deg2rad = function deg2rad(deg) {\n    return Math.PI * deg / 180;\n};\nvar getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n    return Math.atan2(dispY, dispX) - Math.PI / 2;\n};\nvar log2 = Math.log2 || function(n) {\n    return Math.log(n) / Math.log(2);\n};\nvar signum = function signum(x) {\n    if (x > 0) {\n        return 1;\n    } else if (x < 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n};\nvar dist = function dist(p1, p2) {\n    return Math.sqrt(sqdist(p1, p2));\n};\nvar sqdist = function sqdist(p1, p2) {\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n};\nvar inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n    var length = v.length;\n    // First, get sum of all elements\n    var total = 0;\n    for(var i = 0; i < length; i++){\n        total += v[i];\n    }\n    // Now, divide each by the sum of all elements\n    for(var _i = 0; _i < length; _i++){\n        v[_i] = v[_i] / total;\n    }\n    return v;\n};\n// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves\nvar qbezierAt = function qbezierAt(p0, p1, p2, t) {\n    return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n};\nvar qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n    return {\n        x: qbezierAt(p0.x, p1.x, p2.x, t),\n        y: qbezierAt(p0.y, p1.y, p2.y, t)\n    };\n};\nvar lineAt = function lineAt(p0, p1, t, d) {\n    var vec = {\n        x: p1.x - p0.x,\n        y: p1.y - p0.y\n    };\n    var vecDist = dist(p0, p1);\n    var normVec = {\n        x: vec.x / vecDist,\n        y: vec.y / vecDist\n    };\n    t = t == null ? 0 : t;\n    d = d != null ? d : t * vecDist;\n    return {\n        x: p0.x + normVec.x * d,\n        y: p0.y + normVec.y * d\n    };\n};\nvar bound = function bound(min, val, max) {\n    return Math.max(min, Math.min(max, val));\n};\n// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\nvar makeBoundingBox = function makeBoundingBox(bb) {\n    if (bb == null) {\n        return {\n            x1: Infinity,\n            y1: Infinity,\n            x2: -Infinity,\n            y2: -Infinity,\n            w: 0,\n            h: 0\n        };\n    } else if (bb.x1 != null && bb.y1 != null) {\n        if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n            return {\n                x1: bb.x1,\n                y1: bb.y1,\n                x2: bb.x2,\n                y2: bb.y2,\n                w: bb.x2 - bb.x1,\n                h: bb.y2 - bb.y1\n            };\n        } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n            return {\n                x1: bb.x1,\n                y1: bb.y1,\n                x2: bb.x1 + bb.w,\n                y2: bb.y1 + bb.h,\n                w: bb.w,\n                h: bb.h\n            };\n        }\n    }\n};\nvar copyBoundingBox = function copyBoundingBox(bb) {\n    return {\n        x1: bb.x1,\n        x2: bb.x2,\n        w: bb.w,\n        y1: bb.y1,\n        y2: bb.y2,\n        h: bb.h\n    };\n};\nvar clearBoundingBox = function clearBoundingBox(bb) {\n    bb.x1 = Infinity;\n    bb.y1 = Infinity;\n    bb.x2 = -Infinity;\n    bb.y2 = -Infinity;\n    bb.w = 0;\n    bb.h = 0;\n};\nvar updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n    // update bb1 with bb2 bounds\n    bb1.x1 = Math.min(bb1.x1, bb2.x1);\n    bb1.x2 = Math.max(bb1.x2, bb2.x2);\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.y1 = Math.min(bb1.y1, bb2.y1);\n    bb1.y2 = Math.max(bb1.y2, bb2.y2);\n    bb1.h = bb1.y2 - bb1.y1;\n};\nvar expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n    bb.x1 = Math.min(bb.x1, x);\n    bb.x2 = Math.max(bb.x2, x);\n    bb.w = bb.x2 - bb.x1;\n    bb.y1 = Math.min(bb.y1, y);\n    bb.y2 = Math.max(bb.y2, y);\n    bb.h = bb.y2 - bb.y1;\n};\nvar expandBoundingBox = function expandBoundingBox(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    bb.x1 -= padding;\n    bb.x2 += padding;\n    bb.y1 -= padding;\n    bb.y2 += padding;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n};\nvar expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\n        0\n    ];\n    var top, right, bottom, left;\n    if (padding.length === 1) {\n        top = right = bottom = left = padding[0];\n    } else if (padding.length === 2) {\n        top = bottom = padding[0];\n        left = right = padding[1];\n    } else if (padding.length === 4) {\n        var _padding = _slicedToArray(padding, 4);\n        top = _padding[0];\n        right = _padding[1];\n        bottom = _padding[2];\n        left = _padding[3];\n    }\n    bb.x1 -= left;\n    bb.x2 += right;\n    bb.y1 -= top;\n    bb.y2 += bottom;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n};\n// assign the values of bb2 into bb1\nvar assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n    bb1.x1 = bb2.x1;\n    bb1.y1 = bb2.y1;\n    bb1.x2 = bb2.x2;\n    bb1.y2 = bb2.y2;\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.h = bb1.y2 - bb1.y1;\n};\nvar boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n    // case: one bb to right of other\n    if (bb1.x1 > bb2.x2) {\n        return false;\n    }\n    if (bb2.x1 > bb1.x2) {\n        return false;\n    }\n    // case: one bb to left of other\n    if (bb1.x2 < bb2.x1) {\n        return false;\n    }\n    if (bb2.x2 < bb1.x1) {\n        return false;\n    }\n    // case: one bb above other\n    if (bb1.y2 < bb2.y1) {\n        return false;\n    }\n    if (bb2.y2 < bb1.y1) {\n        return false;\n    }\n    // case: one bb below other\n    if (bb1.y1 > bb2.y2) {\n        return false;\n    }\n    if (bb2.y1 > bb1.y2) {\n        return false;\n    }\n    // otherwise, must have some overlap\n    return true;\n};\nvar inBoundingBox = function inBoundingBox(bb, x, y) {\n    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n};\nvar pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n    return inBoundingBox(bb, pt.x, pt.y);\n};\nvar boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n    return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n};\nvar hypot = (_Math$hypot = Math.hypot) !== null && _Math$hypot !== undefined ? _Math$hypot : function(x, y) {\n    return Math.sqrt(x * x + y * y);\n};\nfunction inflatePolygon(polygon, d) {\n    if (polygon.length < 3) {\n        throw new Error('Need at least 3 vertices');\n    }\n    // Helpers\n    var add = function add(a, b) {\n        return {\n            x: a.x + b.x,\n            y: a.y + b.y\n        };\n    };\n    var sub = function sub(a, b) {\n        return {\n            x: a.x - b.x,\n            y: a.y - b.y\n        };\n    };\n    var scale = function scale(v, s) {\n        return {\n            x: v.x * s,\n            y: v.y * s\n        };\n    };\n    var cross = function cross(u, v) {\n        return u.x * v.y - u.y * v.x;\n    };\n    var normalize = function normalize(v) {\n        var len = hypot(v.x, v.y);\n        return len === 0 ? {\n            x: 0,\n            y: 0\n        } : {\n            x: v.x / len,\n            y: v.y / len\n        };\n    };\n    // Signed area (positive = CCW)\n    var signedArea = function signedArea(pts) {\n        var A = 0;\n        for(var i = 0; i < pts.length; i++){\n            var p = pts[i], q = pts[(i + 1) % pts.length];\n            A += p.x * q.y - q.x * p.y;\n        }\n        return A / 2;\n    };\n    // Line–line intersection (infinite lines)\n    var intersectLines = function intersectLines(p1, p2, p3, p4) {\n        var r = sub(p2, p1);\n        var s = sub(p4, p3);\n        var denom = cross(r, s);\n        if (Math.abs(denom) < 1e-9) {\n            // Parallel or nearly so — fallback to midpoint\n            return add(p1, scale(r, 0.5));\n        }\n        var t = cross(sub(p3, p1), s) / denom;\n        return add(p1, scale(r, t));\n    };\n    // Make a shallow copy and enforce CCW\n    var pts = polygon.map(function(p) {\n        return {\n            x: p.x,\n            y: p.y\n        };\n    });\n    if (signedArea(pts) < 0) pts.reverse();\n    var n = pts.length;\n    // Compute outward normals for each edge\n    var normals = [];\n    for(var i = 0; i < n; i++){\n        var p = pts[i], q = pts[(i + 1) % n];\n        var edge = sub(q, p);\n        // For CCW polygon, inward normal = (-edge.y, edge.x)\n        // so outward normal = (edge.y, -edge.x)\n        var out = normalize({\n            x: edge.y,\n            y: -edge.x\n        });\n        normals.push(out);\n    }\n    // Build offset edges\n    var offsetEdges = normals.map(function(nrm, i) {\n        var p1 = add(pts[i], scale(nrm, d));\n        var p2 = add(pts[(i + 1) % n], scale(nrm, d));\n        return {\n            p1: p1,\n            p2: p2\n        };\n    });\n    // Intersect consecutive offset edges\n    var inflated = [];\n    for(var _i2 = 0; _i2 < n; _i2++){\n        var prevEdge = offsetEdges[(_i2 - 1 + n) % n];\n        var currEdge = offsetEdges[_i2];\n        var ip = intersectLines(prevEdge.p1, prevEdge.p2, currEdge.p1, currEdge.p2);\n        inflated.push(ip);\n    }\n    return inflated;\n}\nfunction miterBox(pts, centerX, centerY, width, height, strokeWidth) {\n    var tpts = transformPoints(pts, centerX, centerY, width, height);\n    var offsetPoints = inflatePolygon(tpts, strokeWidth);\n    var bb = makeBoundingBox();\n    offsetPoints.forEach(function(pt) {\n        return expandBoundingBoxByPoint(bb, pt.x, pt.y);\n    });\n    return bb;\n}\nvar roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n    var radius = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'auto';\n    var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    cornerRadius = Math.min(cornerRadius, halfWidth, halfHeight);\n    var doWidth = cornerRadius !== halfWidth, doHeight = cornerRadius !== halfHeight;\n    // Check intersections with straight line segments\n    var straightLineIntersections;\n    // Top segment, left to right\n    if (doWidth) {\n        var topStartX = nodeX - halfWidth + cornerRadius - padding;\n        var topStartY = nodeY - halfHeight - padding;\n        var topEndX = nodeX + halfWidth - cornerRadius + padding;\n        var topEndY = topStartY;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Right segment, top to bottom\n    if (doHeight) {\n        var rightStartX = nodeX + halfWidth + padding;\n        var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n        var rightEndX = rightStartX;\n        var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Bottom segment, left to right\n    if (doWidth) {\n        var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n        var bottomStartY = nodeY + halfHeight + padding;\n        var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n        var bottomEndY = bottomStartY;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Left segment, top to bottom\n    if (doHeight) {\n        var leftStartX = nodeX - halfWidth - padding;\n        var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n        var leftEndX = leftStartX;\n        var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Check intersections with arc segments\n    var arcIntersections;\n    // Top Left\n    {\n        var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n        var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Top Right\n    {\n        var topRightCenterX = nodeX + halfWidth - cornerRadius;\n        var topRightCenterY = nodeY - halfHeight + cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Bottom Right\n    {\n        var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n        var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Bottom Left\n    {\n        var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n        var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    return []; // if nothing\n};\nvar inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n    var t = tolerance;\n    var x1 = Math.min(lx1, lx2);\n    var x2 = Math.max(lx1, lx2);\n    var y1 = Math.min(ly1, ly2);\n    var y2 = Math.max(ly1, ly2);\n    return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n};\nvar inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n    var bb = {\n        x1: Math.min(x1, x3, x2) - tolerance,\n        x2: Math.max(x1, x3, x2) + tolerance,\n        y1: Math.min(y1, y3, y2) - tolerance,\n        y2: Math.max(y1, y3, y2) + tolerance\n    };\n    // if outside the rough bounding box for the bezier, then it can't be a hit\n    if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n        // console.log('bezier out of rough bb')\n        return false;\n    } else {\n        // console.log('do more expensive check');\n        return true;\n    }\n};\nvar solveQuadratic = function solveQuadratic(a, b, c, val) {\n    c -= val;\n    var r = b * b - 4 * a * c;\n    if (r < 0) {\n        return [];\n    }\n    var sqrtR = Math.sqrt(r);\n    var denom = 2 * a;\n    var root1 = (-b + sqrtR) / denom;\n    var root2 = (-b - sqrtR) / denom;\n    return [\n        root1,\n        root2\n    ];\n};\nvar solveCubic = function solveCubic(a, b, c, d, result) {\n    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n    // r is the real component, i is the imaginary component\n    // An implementation of the Cardano method from the year 1545\n    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n    var epsilon = 0.00001;\n    // avoid division by zero while keeping the overall expression close in value\n    if (a === 0) {\n        a = epsilon;\n    }\n    b /= a;\n    c /= a;\n    d /= a;\n    var discriminant, q, r, dum1, s, t, term1, r13;\n    q = (3.0 * c - b * b) / 9.0;\n    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n    r /= 54.0;\n    discriminant = q * q * q + r * r;\n    result[1] = 0;\n    term1 = b / 3.0;\n    if (discriminant > 0) {\n        s = r + Math.sqrt(discriminant);\n        s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n        t = r - Math.sqrt(discriminant);\n        t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n        result[0] = -term1 + s + t;\n        term1 += (s + t) / 2.0;\n        result[4] = result[2] = -term1;\n        term1 = Math.sqrt(3.0) * (-t + s) / 2;\n        result[3] = term1;\n        result[5] = -term1;\n        return;\n    }\n    result[5] = result[3] = 0;\n    if (discriminant === 0) {\n        r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n        result[0] = -term1 + 2.0 * r13;\n        result[4] = result[2] = -(r13 + term1);\n        return;\n    }\n    q = -q;\n    dum1 = q * q * q;\n    dum1 = Math.acos(r / Math.sqrt(dum1));\n    r13 = 2.0 * Math.sqrt(q);\n    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n    return;\n};\nvar sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n    // Find minimum distance by using the minimum of the distance\n    // function between the given point and the curve\n    // This gives the coefficients of the resulting cubic equation\n    // whose roots tell us where a possible minimum is\n    // (Coefficients are divided by 4)\n    var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n    var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n    var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n    var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n    // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n    var roots = [];\n    // Use the cubic solving algorithm\n    solveCubic(a, b, c, d, roots);\n    var zeroThreshold = 0.0000001;\n    var params = [];\n    for(var index = 0; index < 6; index += 2){\n        if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n            params.push(roots[index]);\n        }\n    }\n    params.push(1.0);\n    params.push(0.0);\n    var minDistanceSquared = -1;\n    var curX, curY, distSquared;\n    for(var i = 0; i < params.length; i++){\n        curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n        curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n        distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n        // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n        if (minDistanceSquared >= 0) {\n            if (distSquared < minDistanceSquared) {\n                minDistanceSquared = distSquared;\n            }\n        } else {\n            minDistanceSquared = distSquared;\n        }\n    }\n    return minDistanceSquared;\n};\nvar sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n    var offset = [\n        x - x1,\n        y - y1\n    ];\n    var line = [\n        x2 - x1,\n        y2 - y1\n    ];\n    var lineSq = line[0] * line[0] + line[1] * line[1];\n    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n    var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n    var adjSq = dotProduct * dotProduct / lineSq;\n    if (dotProduct < 0) {\n        return hypSq;\n    }\n    if (adjSq > lineSq) {\n        return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n    }\n    return hypSq - adjSq;\n};\nvar pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n    var x1, y1, x2, y2;\n    var y3;\n    // Intersect with vertical line through (x, y)\n    var up = 0;\n    // let down = 0;\n    for(var i = 0; i < points.length / 2; i++){\n        x1 = points[i * 2];\n        y1 = points[i * 2 + 1];\n        if (i + 1 < points.length / 2) {\n            x2 = points[(i + 1) * 2];\n            y2 = points[(i + 1) * 2 + 1];\n        } else {\n            x2 = points[(i + 1 - points.length / 2) * 2];\n            y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n        }\n        if (x1 == x && x2 == x) ;\n        else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n            y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n            if (y3 > y) {\n                up++;\n            }\n        // if( y3 < y ){\n        // down++;\n        // }\n        } else {\n            continue;\n        }\n    }\n    if (up % 2 === 0) {\n        return false;\n    } else {\n        return true;\n    }\n};\nvar pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n    var transformedPoints = new Array(basePoints.length);\n    // Gives negative angle\n    var angle;\n    if (direction[0] != null) {\n        angle = Math.atan(direction[1] / direction[0]);\n        if (direction[0] < 0) {\n            angle = angle + Math.PI / 2;\n        } else {\n            angle = -angle - Math.PI / 2;\n        }\n    } else {\n        angle = direction;\n    }\n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle);\n    //    console.log(\"base: \" + basePoints);\n    for(var i = 0; i < transformedPoints.length / 2; i++){\n        transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n        transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n        transformedPoints[i * 2] += centerX;\n        transformedPoints[i * 2 + 1] += centerY;\n    }\n    var points;\n    if (padding > 0) {\n        var expandedLineSet = expandPolygon(transformedPoints, -padding);\n        points = joinLines(expandedLineSet);\n    } else {\n        points = transformedPoints;\n    }\n    return pointInsidePolygonPoints(x, y, points);\n};\nvar pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height, corners) {\n    var cutPolygonPoints = new Array(basePoints.length * 2);\n    for(var i = 0; i < corners.length; i++){\n        var corner = corners[i];\n        cutPolygonPoints[i * 4 + 0] = corner.startX;\n        cutPolygonPoints[i * 4 + 1] = corner.startY;\n        cutPolygonPoints[i * 4 + 2] = corner.stopX;\n        cutPolygonPoints[i * 4 + 3] = corner.stopY;\n        var squaredDistance = Math.pow(corner.cx - x, 2) + Math.pow(corner.cy - y, 2);\n        if (squaredDistance <= Math.pow(corner.radius, 2)) {\n            return true;\n        }\n    }\n    return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n};\nvar joinLines = function joinLines(lineSet) {\n    var vertices = new Array(lineSet.length / 2);\n    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n    for(var i = 0; i < lineSet.length / 4; i++){\n        currentLineStartX = lineSet[i * 4];\n        currentLineStartY = lineSet[i * 4 + 1];\n        currentLineEndX = lineSet[i * 4 + 2];\n        currentLineEndY = lineSet[i * 4 + 3];\n        if (i < lineSet.length / 4 - 1) {\n            nextLineStartX = lineSet[(i + 1) * 4];\n            nextLineStartY = lineSet[(i + 1) * 4 + 1];\n            nextLineEndX = lineSet[(i + 1) * 4 + 2];\n            nextLineEndY = lineSet[(i + 1) * 4 + 3];\n        } else {\n            nextLineStartX = lineSet[0];\n            nextLineStartY = lineSet[1];\n            nextLineEndX = lineSet[2];\n            nextLineEndY = lineSet[3];\n        }\n        var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n        vertices[i * 2] = intersection[0];\n        vertices[i * 2 + 1] = intersection[1];\n    }\n    return vertices;\n};\nvar expandPolygon = function expandPolygon(points, pad) {\n    var expandedLineSet = new Array(points.length * 2);\n    var currentPointX, currentPointY, nextPointX, nextPointY;\n    for(var i = 0; i < points.length / 2; i++){\n        currentPointX = points[i * 2];\n        currentPointY = points[i * 2 + 1];\n        if (i < points.length / 2 - 1) {\n            nextPointX = points[(i + 1) * 2];\n            nextPointY = points[(i + 1) * 2 + 1];\n        } else {\n            nextPointX = points[0];\n            nextPointY = points[1];\n        }\n        // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n        // Assume CCW polygon winding\n        var offsetX = nextPointY - currentPointY;\n        var offsetY = -(nextPointX - currentPointX);\n        // Normalize\n        var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n        var normalizedOffsetX = offsetX / offsetLength;\n        var normalizedOffsetY = offsetY / offsetLength;\n        expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n        expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n        expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n        expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n    }\n    return expandedLineSet;\n};\nvar intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n    var dispX = centerX - x;\n    var dispY = centerY - y;\n    dispX /= ellipseWradius;\n    dispY /= ellipseHradius;\n    var len = Math.sqrt(dispX * dispX + dispY * dispY);\n    var newLength = len - 1;\n    if (newLength < 0) {\n        return [];\n    }\n    var lenProportion = newLength / len;\n    return [\n        (centerX - x) * lenProportion + x,\n        (centerY - y) * lenProportion + y\n    ];\n};\nvar checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n    x -= centerX;\n    y -= centerY;\n    x /= width / 2 + padding;\n    y /= height / 2 + padding;\n    return x * x + y * y <= 1;\n};\n// Returns intersections of increasing distance from line's start point\nvar intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n    // Calculate d, direction vector of line\n    var d = [\n        x2 - x1,\n        y2 - y1\n    ]; // Direction vector of line\n    var f = [\n        x1 - centerX,\n        y1 - centerY\n    ];\n    var a = d[0] * d[0] + d[1] * d[1];\n    var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n    var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n    var discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        return [];\n    }\n    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    var tMin = Math.min(t1, t2);\n    var tMax = Math.max(t1, t2);\n    var inRangeParams = [];\n    if (tMin >= 0 && tMin <= 1) {\n        inRangeParams.push(tMin);\n    }\n    if (tMax >= 0 && tMax <= 1) {\n        inRangeParams.push(tMax);\n    }\n    if (inRangeParams.length === 0) {\n        return [];\n    }\n    var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n    var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n    if (inRangeParams.length > 1) {\n        if (inRangeParams[0] == inRangeParams[1]) {\n            return [\n                nearIntersectionX,\n                nearIntersectionY\n            ];\n        } else {\n            var farIntersectionX = inRangeParams[1] * d[0] + x1;\n            var farIntersectionY = inRangeParams[1] * d[1] + y1;\n            return [\n                nearIntersectionX,\n                nearIntersectionY,\n                farIntersectionX,\n                farIntersectionY\n            ];\n        }\n    } else {\n        return [\n            nearIntersectionX,\n            nearIntersectionY\n        ];\n    }\n};\nvar midOfThree = function midOfThree(a, b, c) {\n    if (b <= a && a <= c || c <= a && a <= b) {\n        return a;\n    } else if (a <= b && b <= c || c <= b && b <= a) {\n        return b;\n    } else {\n        return c;\n    }\n};\n// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\nvar finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n    var dx13 = x1 - x3;\n    var dx21 = x2 - x1;\n    var dx43 = x4 - x3;\n    var dy13 = y1 - y3;\n    var dy21 = y2 - y1;\n    var dy43 = y4 - y3;\n    var ua_t = dx43 * dy13 - dy43 * dx13;\n    var ub_t = dx21 * dy13 - dy21 * dx13;\n    var u_b = dy43 * dx21 - dx43 * dy21;\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        var flptThreshold = 0.001;\n        var _min = 0 - flptThreshold;\n        var _max = 1 + flptThreshold;\n        if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n            return [\n                x1 + ua * dx21,\n                y1 + ua * dy21\n            ];\n        } else {\n            if (!infiniteLines) {\n                return [];\n            } else {\n                return [\n                    x1 + ua * dx21,\n                    y1 + ua * dy21\n                ];\n            }\n        }\n    } else {\n        if (ua_t === 0 || ub_t === 0) {\n            // Parallel, coincident lines. Check if overlap\n            // Check endpoint of second line\n            if (midOfThree(x1, x2, x4) === x4) {\n                return [\n                    x4,\n                    y4\n                ];\n            }\n            // Check start point of second line\n            if (midOfThree(x1, x2, x3) === x3) {\n                return [\n                    x3,\n                    y3\n                ];\n            }\n            // Endpoint of first line\n            if (midOfThree(x3, x4, x2) === x2) {\n                return [\n                    x2,\n                    y2\n                ];\n            }\n            return [];\n        } else {\n            // Parallel, non-coincident\n            return [];\n        }\n    }\n};\nvar transformPoints = function transformPoints(points, centerX, centerY, width, height) {\n    var ret = [];\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var x = centerX;\n    var y = centerY;\n    ret.push({\n        x: x + halfW * points[0],\n        y: y + halfH * points[1]\n    });\n    for(var i = 1; i < points.length / 2; i++){\n        ret.push({\n            x: x + halfW * points[i * 2],\n            y: y + halfH * points[i * 2 + 1]\n        });\n    }\n    return ret;\n};\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n// intersect a node polygon (pts transformed)\n//\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n// intersect the points (no transform)\nvar polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n    var intersections = [];\n    var intersection;\n    var transformedPoints = new Array(basePoints.length);\n    var doTransform = true;\n    if (width == null) {\n        doTransform = false;\n    }\n    var points;\n    if (doTransform) {\n        for(var i = 0; i < transformedPoints.length / 2; i++){\n            transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n            transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n        }\n        if (padding > 0) {\n            var expandedLineSet = expandPolygon(transformedPoints, -padding);\n            points = joinLines(expandedLineSet);\n        } else {\n            points = transformedPoints;\n        }\n    } else {\n        points = basePoints;\n    }\n    var currentX, currentY, nextX, nextY;\n    for(var _i3 = 0; _i3 < points.length / 2; _i3++){\n        currentX = points[_i3 * 2];\n        currentY = points[_i3 * 2 + 1];\n        if (_i3 < points.length / 2 - 1) {\n            nextX = points[(_i3 + 1) * 2];\n            nextY = points[(_i3 + 1) * 2 + 1];\n        } else {\n            nextX = points[0];\n            nextY = points[1];\n        }\n        intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    }\n    return intersections;\n};\nvar roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding, corners) {\n    var intersections = [];\n    var intersection;\n    var lines = new Array(basePoints.length * 2);\n    corners.forEach(function(corner, i) {\n        if (i === 0) {\n            lines[lines.length - 2] = corner.startX;\n            lines[lines.length - 1] = corner.startY;\n        } else {\n            lines[i * 4 - 2] = corner.startX;\n            lines[i * 4 - 1] = corner.startY;\n        }\n        lines[i * 4] = corner.stopX;\n        lines[i * 4 + 1] = corner.stopY;\n        intersection = intersectLineCircle(x, y, centerX, centerY, corner.cx, corner.cy, corner.radius);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    });\n    for(var i = 0; i < lines.length / 4; i++){\n        intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[i * 4], lines[i * 4 + 1], lines[i * 4 + 2], lines[i * 4 + 3], false);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    }\n    if (intersections.length > 2) {\n        var lowestIntersection = [\n            intersections[0],\n            intersections[1]\n        ];\n        var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n        for(var _i4 = 1; _i4 < intersections.length / 2; _i4++){\n            var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);\n            if (squaredDistance <= lowestSquaredDistance) {\n                lowestIntersection[0] = intersections[_i4 * 2];\n                lowestIntersection[1] = intersections[_i4 * 2 + 1];\n                lowestSquaredDistance = squaredDistance;\n            }\n        }\n        return lowestIntersection;\n    }\n    return intersections;\n};\nvar shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n    var disp = [\n        intersection[0] - offset[0],\n        intersection[1] - offset[1]\n    ];\n    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n    var lenRatio = (length - amount) / length;\n    if (lenRatio < 0) {\n        lenRatio = 0.00001;\n    }\n    return [\n        offset[0] + lenRatio * disp[0],\n        offset[1] + lenRatio * disp[1]\n    ];\n};\nvar generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n    var points = generateUnitNgonPoints(sides, rotationRadians);\n    points = fitPolygonToSquare(points);\n    return points;\n};\nvar fitPolygonToSquare = function fitPolygonToSquare(points) {\n    var x, y;\n    var sides = points.length / 2;\n    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for(var i = 0; i < sides; i++){\n        x = points[2 * i];\n        y = points[2 * i + 1];\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n    // stretch factors\n    var sx = 2 / (maxX - minX);\n    var sy = 2 / (maxY - minY);\n    for(var _i5 = 0; _i5 < sides; _i5++){\n        x = points[2 * _i5] = points[2 * _i5] * sx;\n        y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n    if (minY < -1) {\n        for(var _i6 = 0; _i6 < sides; _i6++){\n            y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);\n        }\n    }\n    return points;\n};\nvar generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n    var increment = 1.0 / sides * 2 * Math.PI;\n    var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n    startAngle += rotationRadians;\n    var points = new Array(sides * 2);\n    var currentAngle;\n    for(var i = 0; i < sides; i++){\n        currentAngle = i * increment + startAngle;\n        points[2 * i] = Math.cos(currentAngle); // x\n        points[2 * i + 1] = Math.sin(-currentAngle); // y\n    }\n    return points;\n};\n// Set the default radius, unless half of width or height is smaller than default\nvar getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n    return Math.min(width / 4, height / 4, 8);\n};\n// Set the default radius\nvar getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n    return Math.min(width / 10, height / 10, 8);\n};\nvar getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n    return 8;\n};\nvar bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n    return [\n        p0 - 2 * p1 + p2,\n        2 * (p1 - p0),\n        p0\n    ];\n};\n// get curve width, height, and control point position offsets as a percentage of node height / width\nvar getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n    return {\n        heightOffset: Math.min(15, 0.05 * height),\n        widthOffset: Math.min(100, 0.25 * width),\n        ctrlPtOffsetPct: 0.05\n    };\n};\n// Separating Axis Theorem (SAT) to determine if two polygons intersect. \n// The function takes two polygons as input and returns a boolean value indicating \n// whether the two polygons intersect.\nfunction satPolygonIntersection(poly1, poly2) {\n    function getAxes(polygon) {\n        var axes = [];\n        for(var i = 0; i < polygon.length; i++){\n            var p1 = polygon[i];\n            var p2 = polygon[(i + 1) % polygon.length];\n            var edge = {\n                x: p2.x - p1.x,\n                y: p2.y - p1.y\n            };\n            var normal = {\n                x: -edge.y,\n                y: edge.x\n            };\n            var length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);\n            axes.push({\n                x: normal.x / length,\n                y: normal.y / length\n            });\n        }\n        return axes;\n    }\n    function project(polygon, axis) {\n        var min = Infinity;\n        var max = -Infinity;\n        var _iterator = _createForOfIteratorHelper(polygon), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var point = _step.value;\n                var projection = point.x * axis.x + point.y * axis.y;\n                min = Math.min(min, projection);\n                max = Math.max(max, projection);\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n        return {\n            min: min,\n            max: max\n        };\n    }\n    function overlaps(proj1, proj2) {\n        return !(proj1.max < proj2.min || proj2.max < proj1.min);\n    }\n    var axes = [].concat(_toConsumableArray(getAxes(poly1)), _toConsumableArray(getAxes(poly2)));\n    var _iterator2 = _createForOfIteratorHelper(axes), _step2;\n    try {\n        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n            var axis = _step2.value;\n            var proj1 = project(poly1, axis);\n            var proj2 = project(poly2, axis);\n            if (!overlaps(proj1, proj2)) {\n                return false; // No overlap, so the polygons do not intersect\n            }\n        }\n    } catch (err) {\n        _iterator2.e(err);\n    } finally{\n        _iterator2.f();\n    }\n    return true; // polygons intersect\n}\nvar pageRankDefaults = defaults$g({\n    dampingFactor: 0.8,\n    precision: 0.000001,\n    iterations: 200,\n    weight: function weight(edge) {\n        return 1;\n    }\n});\nvar elesfn$o = {\n    pageRank: function pageRank(options) {\n        var _pageRankDefaults = pageRankDefaults(options), dampingFactor = _pageRankDefaults.dampingFactor, precision = _pageRankDefaults.precision, iterations = _pageRankDefaults.iterations, weight = _pageRankDefaults.weight;\n        var cy = this._private.cy;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var numNodes = nodes.length;\n        var numNodesSqd = numNodes * numNodes;\n        var numEdges = edges.length;\n        // Construct transposed adjacency matrix\n        // First lets have a zeroed matrix of the right size\n        // We'll also keep track of the sum of each column\n        var matrix = new Array(numNodesSqd);\n        var columnSum = new Array(numNodes);\n        var additionalProb = (1 - dampingFactor) / numNodes;\n        // Create null matrix\n        for(var i = 0; i < numNodes; i++){\n            for(var j = 0; j < numNodes; j++){\n                var n = i * numNodes + j;\n                matrix[n] = 0;\n            }\n            columnSum[i] = 0;\n        }\n        // Now, process edges\n        for(var _i = 0; _i < numEdges; _i++){\n            var edge = edges[_i];\n            var srcId = edge.data('source');\n            var tgtId = edge.data('target');\n            // Don't include loops in the matrix\n            if (srcId === tgtId) {\n                continue;\n            }\n            var s = nodes.indexOfId(srcId);\n            var t = nodes.indexOfId(tgtId);\n            var w = weight(edge);\n            var _n = t * numNodes + s;\n            // Update matrix\n            matrix[_n] += w;\n            // Update column sum\n            columnSum[s] += w;\n        }\n        // Add additional probability based on damping factor\n        // Also, take into account columns that have sum = 0\n        var p = 1.0 / numNodes + additionalProb; // Shorthand\n        // Traverse matrix, column by column\n        for(var _j = 0; _j < numNodes; _j++){\n            if (columnSum[_j] === 0) {\n                // No 'links' out from node jth, assume equal probability for each possible node\n                for(var _i2 = 0; _i2 < numNodes; _i2++){\n                    var _n2 = _i2 * numNodes + _j;\n                    matrix[_n2] = p;\n                }\n            } else {\n                // Node jth has outgoing link, compute normalized probabilities\n                for(var _i3 = 0; _i3 < numNodes; _i3++){\n                    var _n3 = _i3 * numNodes + _j;\n                    matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n                }\n            }\n        }\n        // Compute dominant eigenvector using power method\n        var eigenvector = new Array(numNodes);\n        var temp = new Array(numNodes);\n        var previous;\n        // Start with a vector of all 1's\n        // Also, initialize a null vector which will be used as shorthand\n        for(var _i4 = 0; _i4 < numNodes; _i4++){\n            eigenvector[_i4] = 1;\n        }\n        for(var iter = 0; iter < iterations; iter++){\n            // Temp array with all 0's\n            for(var _i5 = 0; _i5 < numNodes; _i5++){\n                temp[_i5] = 0;\n            }\n            // Multiply matrix with previous result\n            for(var _i6 = 0; _i6 < numNodes; _i6++){\n                for(var _j2 = 0; _j2 < numNodes; _j2++){\n                    var _n4 = _i6 * numNodes + _j2;\n                    temp[_i6] += matrix[_n4] * eigenvector[_j2];\n                }\n            }\n            inPlaceSumNormalize(temp);\n            previous = eigenvector;\n            eigenvector = temp;\n            temp = previous;\n            var diff = 0;\n            // Compute difference (squared module) of both vectors\n            for(var _i7 = 0; _i7 < numNodes; _i7++){\n                var delta = previous[_i7] - eigenvector[_i7];\n                diff += delta * delta;\n            }\n            // If difference is less than the desired threshold, stop iterating\n            if (diff < precision) {\n                break;\n            }\n        }\n        // Construct result\n        var res = {\n            rank: function rank(node) {\n                node = cy.collection(node)[0];\n                return eigenvector[nodes.indexOf(node)];\n            }\n        };\n        return res;\n    } // pageRank\n}; // elesfn\nvar defaults$f = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false,\n    alpha: 0\n});\nvar elesfn$n = {\n    degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n        options = defaults$f(options);\n        var cy = this.cy();\n        var nodes = this.nodes();\n        var numNodes = nodes.length;\n        if (!options.directed) {\n            var degrees = {};\n            var maxDegree = 0;\n            for(var i = 0; i < numNodes; i++){\n                var node = nodes[i];\n                // add current node to the current options object and call degreeCentrality\n                options.root = node;\n                var currDegree = this.degreeCentrality(options);\n                if (maxDegree < currDegree.degree) {\n                    maxDegree = currDegree.degree;\n                }\n                degrees[node.id()] = currDegree.degree;\n            }\n            return {\n                degree: function degree(node) {\n                    if (maxDegree === 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return degrees[node.id()] / maxDegree;\n                }\n            };\n        } else {\n            var indegrees = {};\n            var outdegrees = {};\n            var maxIndegree = 0;\n            var maxOutdegree = 0;\n            for(var _i = 0; _i < numNodes; _i++){\n                var _node = nodes[_i];\n                var id = _node.id();\n                // add current node to the current options object and call degreeCentrality\n                options.root = _node;\n                var _currDegree = this.degreeCentrality(options);\n                if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n                if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n                indegrees[id] = _currDegree.indegree;\n                outdegrees[id] = _currDegree.outdegree;\n            }\n            return {\n                indegree: function indegree(node) {\n                    if (maxIndegree == 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return indegrees[node.id()] / maxIndegree;\n                },\n                outdegree: function outdegree(node) {\n                    if (maxOutdegree === 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return outdegrees[node.id()] / maxOutdegree;\n                }\n            };\n        }\n    },\n    // degreeCentralityNormalized\n    // Implemented from the algorithm in Opsahl's paper\n    // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n    // check the heading 2 \"Degree\"\n    degreeCentrality: function degreeCentrality(options) {\n        options = defaults$f(options);\n        var cy = this.cy();\n        var callingEles = this;\n        var _options = options, root = _options.root, weight = _options.weight, directed = _options.directed, alpha = _options.alpha;\n        root = cy.collection(root)[0];\n        if (!directed) {\n            var connEdges = root.connectedEdges().intersection(callingEles);\n            var k = connEdges.length;\n            var s = 0;\n            // Now, sum edge weights\n            for(var i = 0; i < connEdges.length; i++){\n                s += weight(connEdges[i]);\n            }\n            return {\n                degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n            };\n        } else {\n            var edges = root.connectedEdges();\n            var incoming = edges.filter(function(edge) {\n                return edge.target().same(root) && callingEles.has(edge);\n            });\n            var outgoing = edges.filter(function(edge) {\n                return edge.source().same(root) && callingEles.has(edge);\n            });\n            var k_in = incoming.length;\n            var k_out = outgoing.length;\n            var s_in = 0;\n            var s_out = 0;\n            // Now, sum incoming edge weights\n            for(var _i2 = 0; _i2 < incoming.length; _i2++){\n                s_in += weight(incoming[_i2]);\n            }\n            // Now, sum outgoing edge weights\n            for(var _i3 = 0; _i3 < outgoing.length; _i3++){\n                s_out += weight(outgoing[_i3]);\n            }\n            return {\n                indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n                outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n            };\n        }\n    } // degreeCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$n.dc = elesfn$n.degreeCentrality;\nelesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\nvar defaults$e = defaults$g({\n    harmonic: true,\n    weight: function weight() {\n        return 1;\n    },\n    directed: false,\n    root: null\n});\nvar elesfn$m = {\n    closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n        var _defaults = defaults$e(options), harmonic = _defaults.harmonic, weight = _defaults.weight, directed = _defaults.directed;\n        var cy = this.cy();\n        var closenesses = {};\n        var maxCloseness = 0;\n        var nodes = this.nodes();\n        var fw = this.floydWarshall({\n            weight: weight,\n            directed: directed\n        });\n        // Compute closeness for every node and find the maximum closeness\n        for(var i = 0; i < nodes.length; i++){\n            var currCloseness = 0;\n            var node_i = nodes[i];\n            for(var j = 0; j < nodes.length; j++){\n                if (i !== j) {\n                    var d = fw.distance(node_i, nodes[j]);\n                    if (harmonic) {\n                        currCloseness += 1 / d;\n                    } else {\n                        currCloseness += d;\n                    }\n                }\n            }\n            if (!harmonic) {\n                currCloseness = 1 / currCloseness;\n            }\n            if (maxCloseness < currCloseness) {\n                maxCloseness = currCloseness;\n            }\n            closenesses[node_i.id()] = currCloseness;\n        }\n        return {\n            closeness: function closeness(node) {\n                if (maxCloseness == 0) {\n                    return 0;\n                }\n                if (string(node)) {\n                    // from is a selector string\n                    node = cy.filter(node)[0].id();\n                } else {\n                    // from is a node\n                    node = node.id();\n                }\n                return closenesses[node] / maxCloseness;\n            }\n        };\n    },\n    // Implemented from pseudocode from wikipedia\n    closenessCentrality: function closenessCentrality(options) {\n        var _defaults2 = defaults$e(options), root = _defaults2.root, weight = _defaults2.weight, directed = _defaults2.directed, harmonic = _defaults2.harmonic;\n        root = this.filter(root)[0];\n        // we need distance from this node to every other node\n        var dijkstra = this.dijkstra({\n            root: root,\n            weight: weight,\n            directed: directed\n        });\n        var totalDistance = 0;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            var n = nodes[i];\n            if (!n.same(root)) {\n                var d = dijkstra.distanceTo(n);\n                if (harmonic) {\n                    totalDistance += 1 / d;\n                } else {\n                    totalDistance += d;\n                }\n            }\n        }\n        return harmonic ? totalDistance : 1 / totalDistance;\n    } // closenessCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$m.cc = elesfn$m.closenessCentrality;\nelesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\nvar defaults$d = defaults$g({\n    weight: null,\n    directed: false\n});\nvar elesfn$l = {\n    // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n    betweennessCentrality: function betweennessCentrality(options) {\n        var _defaults = defaults$d(options), directed = _defaults.directed, weight = _defaults.weight;\n        var weighted = weight != null;\n        var cy = this.cy();\n        // starting\n        var V = this.nodes();\n        var A = {};\n        var _C = {};\n        var max = 0;\n        var C = {\n            set: function set(key, val) {\n                _C[key] = val;\n                if (val > max) {\n                    max = val;\n                }\n            },\n            get: function get(key) {\n                return _C[key];\n            }\n        };\n        // A contains the neighborhoods of every node\n        for(var i = 0; i < V.length; i++){\n            var v = V[i];\n            var vid = v.id();\n            if (directed) {\n                A[vid] = v.outgoers().nodes(); // get outgoers of every node\n            } else {\n                A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n            }\n            C.set(vid, 0);\n        }\n        var _loop = function _loop() {\n            var sid = V[s].id();\n            var S = []; // stack\n            var P = {};\n            var g = {};\n            var d = {};\n            var Q = new Heap(function(a, b) {\n                return d[a] - d[b];\n            }); // queue\n            // init dictionaries\n            for(var _i = 0; _i < V.length; _i++){\n                var _vid = V[_i].id();\n                P[_vid] = [];\n                g[_vid] = 0;\n                d[_vid] = Infinity;\n            }\n            g[sid] = 1; // sigma\n            d[sid] = 0; // distance to s\n            Q.push(sid);\n            while(!Q.empty()){\n                var _v = Q.pop();\n                S.push(_v);\n                if (weighted) {\n                    for(var j = 0; j < A[_v].length; j++){\n                        var w = A[_v][j];\n                        var vEle = cy.getElementById(_v);\n                        var edge = undefined;\n                        if (vEle.edgesTo(w).length > 0) {\n                            edge = vEle.edgesTo(w)[0];\n                        } else {\n                            edge = w.edgesTo(vEle)[0];\n                        }\n                        var edgeWeight = weight(edge);\n                        w = w.id();\n                        if (d[w] > d[_v] + edgeWeight) {\n                            d[w] = d[_v] + edgeWeight;\n                            if (Q.nodes.indexOf(w) < 0) {\n                                //if w is not in Q\n                                Q.push(w);\n                            } else {\n                                // update position if w is in Q\n                                Q.updateItem(w);\n                            }\n                            g[w] = 0;\n                            P[w] = [];\n                        }\n                        if (d[w] == d[_v] + edgeWeight) {\n                            g[w] = g[w] + g[_v];\n                            P[w].push(_v);\n                        }\n                    }\n                } else {\n                    for(var _j = 0; _j < A[_v].length; _j++){\n                        var _w = A[_v][_j].id();\n                        if (d[_w] == Infinity) {\n                            Q.push(_w);\n                            d[_w] = d[_v] + 1;\n                        }\n                        if (d[_w] == d[_v] + 1) {\n                            g[_w] = g[_w] + g[_v];\n                            P[_w].push(_v);\n                        }\n                    }\n                }\n            }\n            var e = {};\n            for(var _i2 = 0; _i2 < V.length; _i2++){\n                e[V[_i2].id()] = 0;\n            }\n            while(S.length > 0){\n                var _w2 = S.pop();\n                for(var _j2 = 0; _j2 < P[_w2].length; _j2++){\n                    var _v2 = P[_w2][_j2];\n                    e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n                }\n                if (_w2 != V[s].id()) {\n                    C.set(_w2, C.get(_w2) + e[_w2]);\n                }\n            }\n        };\n        for(var s = 0; s < V.length; s++){\n            _loop();\n        }\n        var ret = {\n            betweenness: function betweenness(node) {\n                var id = cy.collection(node).id();\n                return C.get(id);\n            },\n            betweennessNormalized: function betweennessNormalized(node) {\n                if (max == 0) {\n                    return 0;\n                }\n                var id = cy.collection(node).id();\n                return C.get(id) / max;\n            }\n        };\n        // alias\n        ret.betweennessNormalised = ret.betweennessNormalized;\n        return ret;\n    } // betweennessCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$l.bc = elesfn$l.betweennessCentrality;\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-markov-cluster\n/* eslint-disable no-unused-vars */ var defaults$c = defaults$g({\n    expandFactor: 2,\n    // affects time of computation and cluster granularity to some extent: M * M\n    inflateFactor: 2,\n    // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n    multFactor: 1,\n    // optional self loops for each node. Use a neutral value to improve cluster computations.\n    maxIterations: 20,\n    // maximum number of iterations of the MCL algorithm in a single run\n    attributes: [\n        // attributes/features used to group nodes, ie. similarity values between nodes\n        function(edge) {\n            return 1;\n        }\n    ]\n});\n/* eslint-enable */ var setOptions$3 = function setOptions(options) {\n    return defaults$c(options);\n};\n/* eslint-enable */ var getSimilarity$1 = function getSimilarity(edge, attributes) {\n    var total = 0;\n    for(var i = 0; i < attributes.length; i++){\n        total += attributes[i](edge);\n    }\n    return total;\n};\nvar addLoops = function addLoops(M, n, val) {\n    for(var i = 0; i < n; i++){\n        M[i * n + i] = val;\n    }\n};\nvar normalize = function normalize(M, n) {\n    var sum;\n    for(var col = 0; col < n; col++){\n        sum = 0;\n        for(var row = 0; row < n; row++){\n            sum += M[row * n + col];\n        }\n        for(var _row = 0; _row < n; _row++){\n            M[_row * n + col] = M[_row * n + col] / sum;\n        }\n    }\n};\n// TODO: blocked matrix multiplication?\nvar mmult = function mmult(A, B, n) {\n    var C = new Array(n * n);\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j < n; j++){\n            C[i * n + j] = 0;\n        }\n        for(var k = 0; k < n; k++){\n            for(var _j = 0; _j < n; _j++){\n                C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n            }\n        }\n    }\n    return C;\n};\nvar expand = function expand(M, n, expandFactor /** power **/ ) {\n    var _M = M.slice(0);\n    for(var p = 1; p < expandFactor; p++){\n        M = mmult(M, _M, n);\n    }\n    return M;\n};\nvar inflate = function inflate(M, n, inflateFactor /** r **/ ) {\n    var _M = new Array(n * n);\n    // M(i,j) ^ inflatePower\n    for(var i = 0; i < n * n; i++){\n        _M[i] = Math.pow(M[i], inflateFactor);\n    }\n    normalize(_M, n);\n    return _M;\n};\nvar hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n    // Check that both matrices have the same elements (i,j)\n    for(var i = 0; i < n2; i++){\n        var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n        var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n        if (v1 !== v2) {\n            return false;\n        }\n    }\n    return true;\n};\nvar assign$2 = function assign(M, n, nodes, cy) {\n    var clusters = [];\n    for(var i = 0; i < n; i++){\n        var cluster = [];\n        for(var j = 0; j < n; j++){\n            // Row-wise attractors and elements that they attract belong in same cluster\n            if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n                cluster.push(nodes[j]);\n            }\n        }\n        if (cluster.length !== 0) {\n            clusters.push(cy.collection(cluster));\n        }\n    }\n    return clusters;\n};\nvar isDuplicate = function isDuplicate(c1, c2) {\n    for(var i = 0; i < c1.length; i++){\n        if (!c2[i] || c1[i].id() !== c2[i].id()) {\n            return false;\n        }\n    }\n    return true;\n};\nvar removeDuplicates = function removeDuplicates(clusters) {\n    for(var i = 0; i < clusters.length; i++){\n        for(var j = 0; j < clusters.length; j++){\n            if (i != j && isDuplicate(clusters[i], clusters[j])) {\n                clusters.splice(j, 1);\n            }\n        }\n    }\n    return clusters;\n};\nvar markovClustering = function markovClustering(options) {\n    var nodes = this.nodes();\n    var edges = this.edges();\n    var cy = this.cy();\n    // Set parameters of algorithm:\n    var opts = setOptions$3(options);\n    // Map each node to its position in node array\n    var id2position = {};\n    for(var i = 0; i < nodes.length; i++){\n        id2position[nodes[i].id()] = i;\n    }\n    // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n    var n = nodes.length, n2 = n * n;\n    var M = new Array(n2), _M;\n    for(var _i = 0; _i < n2; _i++){\n        M[_i] = 0;\n    }\n    for(var e = 0; e < edges.length; e++){\n        var edge = edges[e];\n        var _i2 = id2position[edge.source().id()];\n        var j = id2position[edge.target().id()];\n        var sim = getSimilarity$1(edge, opts.attributes);\n        M[_i2 * n + j] += sim; // G should be symmetric and undirected\n        M[j * n + _i2] += sim;\n    }\n    // Begin Markov cluster algorithm\n    // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n    addLoops(M, n, opts.multFactor);\n    // Step 2: M = normalize( M );\n    normalize(M, n);\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        isStillMoving = false;\n        // Step 3:\n        _M = expand(M, n, opts.expandFactor);\n        // Step 4:\n        M = inflate(_M, n, opts.inflateFactor);\n        // Step 5: check to see if ~steady state has been reached\n        if (!hasConverged(M, _M, n2, 4)) {\n            isStillMoving = true;\n        }\n        iterations++;\n    }\n    // Build clusters from matrix\n    var clusters = assign$2(M, n, nodes, cy);\n    // Remove duplicate clusters due to symmetry of graph and M matrix\n    clusters = removeDuplicates(clusters);\n    return clusters;\n};\nvar markovClustering$1 = {\n    markovClustering: markovClustering,\n    mcl: markovClustering\n};\n// Common distance metrics for clustering algorithms\n// https://en.wikipedia.org/wiki/Hierarchical_clustering#Metric\nvar identity$1 = function identity(x) {\n    return x;\n};\nvar absDiff = function absDiff(p, q) {\n    return Math.abs(q - p);\n};\nvar addAbsDiff = function addAbsDiff(total, p, q) {\n    return total + absDiff(p, q);\n};\nvar addSquaredDiff = function addSquaredDiff(total, p, q) {\n    return total + Math.pow(q - p, 2);\n};\nvar sqrt = function sqrt(x) {\n    return Math.sqrt(x);\n};\nvar maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n    return Math.max(currentMax, absDiff(p, q));\n};\nvar getDistance = function getDistance(length, getP, getQ, init, visit) {\n    var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity$1;\n    var ret = init;\n    var p, q;\n    for(var dim = 0; dim < length; dim++){\n        p = getP(dim);\n        q = getQ(dim);\n        ret = visit(ret, p, q);\n    }\n    return post(ret);\n};\nvar distances = {\n    euclidean: function euclidean(length, getP, getQ) {\n        if (length >= 2) {\n            return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n        } else {\n            // for single attr case, more efficient to avoid sqrt\n            return getDistance(length, getP, getQ, 0, addAbsDiff);\n        }\n    },\n    squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n        return getDistance(length, getP, getQ, 0, addSquaredDiff);\n    },\n    manhattan: function manhattan(length, getP, getQ) {\n        return getDistance(length, getP, getQ, 0, addAbsDiff);\n    },\n    max: function max(length, getP, getQ) {\n        return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n    }\n};\n// in case the user accidentally doesn't use camel case\ndistances['squared-euclidean'] = distances['squaredEuclidean'];\ndistances['squaredeuclidean'] = distances['squaredEuclidean'];\nfunction clusteringDistance(method, length, getP, getQ, nodeP, nodeQ) {\n    var impl;\n    if (fn$6(method)) {\n        impl = method;\n    } else {\n        impl = distances[method] || distances.euclidean;\n    }\n    if (length === 0 && fn$6(method)) {\n        return impl(nodeP, nodeQ);\n    } else {\n        return impl(length, getP, getQ, nodeP, nodeQ);\n    }\n}\nvar defaults$b = defaults$g({\n    k: 2,\n    m: 2,\n    sensitivityThreshold: 0.0001,\n    distance: 'euclidean',\n    maxIterations: 10,\n    attributes: [],\n    testMode: false,\n    testCentroids: null\n});\nvar setOptions$2 = function setOptions(options) {\n    return defaults$b(options);\n};\nvar getDist = function getDist(type, node, centroid, attributes, mode) {\n    var noNodeP = mode !== 'kMedoids';\n    var getP = noNodeP ? function(i) {\n        return centroid[i];\n    } : function(i) {\n        return attributes[i](centroid);\n    };\n    var getQ = function getQ(i) {\n        return attributes[i](node);\n    };\n    var nodeP = centroid;\n    var nodeQ = node;\n    return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n};\nvar randomCentroids = function randomCentroids(nodes, k, attributes) {\n    var ndim = attributes.length;\n    var min = new Array(ndim);\n    var max = new Array(ndim);\n    var centroids = new Array(k);\n    var centroid = null;\n    // Find min, max values for each attribute dimension\n    for(var i = 0; i < ndim; i++){\n        min[i] = nodes.min(attributes[i]).value;\n        max[i] = nodes.max(attributes[i]).value;\n    }\n    // Build k centroids, each represented as an n-dim feature vector\n    for(var c = 0; c < k; c++){\n        centroid = [];\n        for(var _i = 0; _i < ndim; _i++){\n            centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n        }\n        centroids[c] = centroid;\n    }\n    return centroids;\n};\nvar classify = function classify(node, centroids, distance, attributes, type) {\n    var min = Infinity;\n    var index = 0;\n    for(var i = 0; i < centroids.length; i++){\n        var dist = getDist(distance, node, centroids[i], attributes, type);\n        if (dist < min) {\n            min = dist;\n            index = i;\n        }\n    }\n    return index;\n};\nvar buildCluster = function buildCluster(centroid, nodes, assignment) {\n    var cluster = [];\n    var node = null;\n    for(var n = 0; n < nodes.length; n++){\n        node = nodes[n];\n        if (assignment[node.id()] === centroid) {\n            //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n            cluster.push(node);\n        }\n    }\n    return cluster;\n};\nvar haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n    return Math.abs(v2 - v1) <= sensitivityThreshold;\n};\nvar haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n    for(var i = 0; i < v1.length; i++){\n        for(var j = 0; j < v1[i].length; j++){\n            var diff = Math.abs(v1[i][j] - v2[i][j]);\n            if (diff > sensitivityThreshold) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nvar seenBefore = function seenBefore(node, medoids, n) {\n    for(var i = 0; i < n; i++){\n        if (node === medoids[i]) return true;\n    }\n    return false;\n};\nvar randomMedoids = function randomMedoids(nodes, k) {\n    var medoids = new Array(k);\n    // For small data sets, the probability of medoid conflict is greater,\n    // so we need to check to see if we've already seen or chose this node before.\n    if (nodes.length < 50) {\n        // Randomly select k medoids from the n nodes\n        for(var i = 0; i < k; i++){\n            var node = nodes[Math.floor(Math.random() * nodes.length)];\n            // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n            // Instead choose a different random node.\n            while(seenBefore(node, medoids, i)){\n                node = nodes[Math.floor(Math.random() * nodes.length)];\n            }\n            medoids[i] = node;\n        }\n    } else {\n        // Relatively large data set, so pretty safe to not check and just select random nodes\n        for(var _i2 = 0; _i2 < k; _i2++){\n            medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n        }\n    }\n    return medoids;\n};\nvar findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n    var cost = 0;\n    for(var n = 0; n < cluster.length; n++){\n        cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');\n    }\n    return cost;\n};\nvar kMeans = function kMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    // Set parameters of algorithm: # of clusters, distance metric, etc.\n    var opts = setOptions$2(options);\n    // Begin k-means algorithm\n    var clusters = new Array(opts.k);\n    var assignment = {};\n    var centroids;\n    // Step 1: Initialize centroid positions\n    if (opts.testMode) {\n        if (typeof opts.testCentroids === 'number') {\n            // TODO: implement a seeded random number generator.\n            opts.testCentroids;\n            centroids = randomCentroids(nodes, opts.k, opts.attributes);\n        } else if (_typeof(opts.testCentroids) === 'object') {\n            centroids = opts.testCentroids;\n        } else {\n            centroids = randomCentroids(nodes, opts.k, opts.attributes);\n        }\n    } else {\n        centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    }\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        // Step 2: Assign nodes to the nearest centroid\n        for(var n = 0; n < nodes.length; n++){\n            node = nodes[n];\n            // Determine which cluster this node belongs to: node id => cluster #\n            assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');\n        }\n        // Step 3: For each of the k clusters, update its centroid\n        isStillMoving = false;\n        for(var c = 0; c < opts.k; c++){\n            // Get all nodes that belong to this cluster\n            var cluster = buildCluster(c, nodes, assignment);\n            if (cluster.length === 0) {\n                continue;\n            }\n            // Update centroids by calculating avg of all nodes within the cluster.\n            var ndim = opts.attributes.length;\n            var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n            var newCentroid = new Array(ndim);\n            var sum = new Array(ndim);\n            for(var d = 0; d < ndim; d++){\n                sum[d] = 0.0;\n                for(var i = 0; i < cluster.length; i++){\n                    node = cluster[i];\n                    sum[d] += opts.attributes[d](node);\n                }\n                newCentroid[d] = sum[d] / cluster.length;\n                // Check to see if algorithm has converged, i.e. when centroids no longer change\n                if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n                    isStillMoving = true;\n                }\n            }\n            centroids[c] = newCentroid;\n            clusters[c] = cy.collection(cluster);\n        }\n        iterations++;\n    }\n    return clusters;\n};\nvar kMedoids = function kMedoids(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    var opts = setOptions$2(options);\n    // Begin k-medoids algorithm\n    var clusters = new Array(opts.k);\n    var medoids;\n    var assignment = {};\n    var curCost;\n    var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n    // Step 1: Initialize k medoids\n    if (opts.testMode) {\n        if (typeof opts.testCentroids === 'number') ;\n        else if (_typeof(opts.testCentroids) === 'object') {\n            medoids = opts.testCentroids;\n        } else {\n            medoids = randomMedoids(nodes, opts.k);\n        }\n    } else {\n        medoids = randomMedoids(nodes, opts.k);\n    }\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        // Step 2: Assign nodes to the nearest medoid\n        for(var n = 0; n < nodes.length; n++){\n            node = nodes[n];\n            // Determine which cluster this node belongs to: node id => cluster #\n            assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');\n        }\n        isStillMoving = false;\n        // Step 3: For each medoid m, and for each node associated with mediod m,\n        // select the node with the lowest configuration cost as new medoid.\n        for(var m1 = 0; m1 < medoids.length; m1++){\n            // Get all nodes that belong to this medoid\n            var cluster = buildCluster(m1, nodes, assignment);\n            if (cluster.length === 0) {\n                continue;\n            }\n            minCosts[m1] = findCost(medoids[m1], cluster, opts.attributes); // original cost\n            // Select different medoid if its configuration has the lowest cost\n            for(var _n = 0; _n < cluster.length; _n++){\n                curCost = findCost(cluster[_n], cluster, opts.attributes);\n                if (curCost < minCosts[m1]) {\n                    minCosts[m1] = curCost;\n                    medoids[m1] = cluster[_n];\n                    isStillMoving = true;\n                }\n            }\n            clusters[m1] = cy.collection(cluster);\n        }\n        iterations++;\n    }\n    return clusters;\n};\nvar updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n    var numerator, denominator;\n    for(var n = 0; n < nodes.length; n++){\n        for(var c = 0; c < centroids.length; c++){\n            weight[n][c] = Math.pow(U[n][c], opts.m);\n        }\n    }\n    for(var _c = 0; _c < centroids.length; _c++){\n        for(var dim = 0; dim < opts.attributes.length; dim++){\n            numerator = 0;\n            denominator = 0;\n            for(var _n2 = 0; _n2 < nodes.length; _n2++){\n                numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n                denominator += weight[_n2][_c];\n            }\n            centroids[_c][dim] = numerator / denominator;\n        }\n    }\n};\nvar updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n    // Save previous step\n    for(var i = 0; i < U.length; i++){\n        _U[i] = U[i].slice();\n    }\n    var sum, numerator, denominator;\n    var pow = 2 / (opts.m - 1);\n    for(var c = 0; c < centroids.length; c++){\n        for(var n = 0; n < nodes.length; n++){\n            sum = 0;\n            for(var k = 0; k < centroids.length; k++){\n                // against all other centroids\n                numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');\n                denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');\n                sum += Math.pow(numerator / denominator, pow);\n            }\n            U[n][c] = 1 / sum;\n        }\n    }\n};\nvar assign$1 = function assign(nodes, U, opts, cy) {\n    var clusters = new Array(opts.k);\n    for(var c = 0; c < clusters.length; c++){\n        clusters[c] = [];\n    }\n    var max;\n    var index;\n    for(var n = 0; n < U.length; n++){\n        // for each node (U is N x C matrix)\n        max = -Infinity;\n        index = -1;\n        // Determine which cluster the node is most likely to belong in\n        for(var _c2 = 0; _c2 < U[0].length; _c2++){\n            if (U[n][_c2] > max) {\n                max = U[n][_c2];\n                index = _c2;\n            }\n        }\n        clusters[index].push(nodes[n]);\n    }\n    // Turn every array into a collection of nodes\n    for(var _c3 = 0; _c3 < clusters.length; _c3++){\n        clusters[_c3] = cy.collection(clusters[_c3]);\n    }\n    return clusters;\n};\nvar fuzzyCMeans = function fuzzyCMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions$2(options);\n    // Begin fuzzy c-means algorithm\n    var clusters;\n    var centroids;\n    var U;\n    var _U;\n    var weight;\n    // Step 1: Initialize letiables.\n    _U = new Array(nodes.length);\n    for(var i = 0; i < nodes.length; i++){\n        // N x C matrix\n        _U[i] = new Array(opts.k);\n    }\n    U = new Array(nodes.length);\n    for(var _i3 = 0; _i3 < nodes.length; _i3++){\n        // N x C matrix\n        U[_i3] = new Array(opts.k);\n    }\n    for(var _i4 = 0; _i4 < nodes.length; _i4++){\n        var total = 0;\n        for(var j = 0; j < opts.k; j++){\n            U[_i4][j] = Math.random();\n            total += U[_i4][j];\n        }\n        for(var _j = 0; _j < opts.k; _j++){\n            U[_i4][_j] = U[_i4][_j] / total;\n        }\n    }\n    centroids = new Array(opts.k);\n    for(var _i5 = 0; _i5 < opts.k; _i5++){\n        centroids[_i5] = new Array(opts.attributes.length);\n    }\n    weight = new Array(nodes.length);\n    for(var _i6 = 0; _i6 < nodes.length; _i6++){\n        // N x C matrix\n        weight[_i6] = new Array(opts.k);\n    }\n    // end init FCM\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        isStillMoving = false;\n        // Step 2: Calculate the centroids for each step.\n        updateCentroids(centroids, nodes, U, weight, opts);\n        // Step 3: Update the partition matrix U.\n        updateMembership(U, _U, centroids, nodes, opts);\n        // Step 4: Check for convergence.\n        if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n            isStillMoving = true;\n        }\n        iterations++;\n    }\n    // Assign nodes to clusters with highest probability.\n    clusters = assign$1(nodes, U, opts, cy);\n    return {\n        clusters: clusters,\n        degreeOfMembership: U\n    };\n};\nvar kClustering = {\n    kMeans: kMeans,\n    kMedoids: kMedoids,\n    fuzzyCMeans: fuzzyCMeans,\n    fcm: fuzzyCMeans\n};\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-hierarchical\nvar defaults$a = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare nodes\n    linkage: 'min',\n    // linkage criterion : how to determine the distance between clusters of nodes\n    mode: 'threshold',\n    // mode:'threshold' => clusters must be threshold distance apart\n    threshold: Infinity,\n    // the distance threshold\n    // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n    addDendrogram: false,\n    // whether to add the dendrogram to the graph for viz\n    dendrogramDepth: 0,\n    // depth at which dendrogram branches are merged into the returned clusters\n    attributes: [] // array of attr functions\n});\nvar linkageAliases = {\n    'single': 'min',\n    'complete': 'max'\n};\nvar setOptions$1 = function setOptions(options) {\n    var opts = defaults$a(options);\n    var preferredAlias = linkageAliases[opts.linkage];\n    if (preferredAlias != null) {\n        opts.linkage = preferredAlias;\n    }\n    return opts;\n};\nvar mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n    // Find two closest clusters from cached mins\n    var minKey = 0;\n    var min = Infinity;\n    var dist;\n    var attrs = opts.attributes;\n    var getDist = function getDist(n1, n2) {\n        return clusteringDistance(opts.distance, attrs.length, function(i) {\n            return attrs[i](n1);\n        }, function(i) {\n            return attrs[i](n2);\n        }, n1, n2);\n    };\n    for(var i = 0; i < clusters.length; i++){\n        var key = clusters[i].key;\n        var _dist = dists[key][mins[key]];\n        if (_dist < min) {\n            minKey = key;\n            min = _dist;\n        }\n    }\n    if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {\n        return false;\n    }\n    var c1 = index[minKey];\n    var c2 = index[mins[minKey]];\n    var merged;\n    // Merge two closest clusters\n    if (opts.mode === 'dendrogram') {\n        merged = {\n            left: c1,\n            right: c2,\n            key: c1.key\n        };\n    } else {\n        merged = {\n            value: c1.value.concat(c2.value),\n            key: c1.key\n        };\n    }\n    clusters[c1.index] = merged;\n    clusters.splice(c2.index, 1);\n    index[c1.key] = merged;\n    // Update distances with new merged cluster\n    for(var _i = 0; _i < clusters.length; _i++){\n        var cur = clusters[_i];\n        if (c1.key === cur.key) {\n            dist = Infinity;\n        } else if (opts.linkage === 'min') {\n            dist = dists[c1.key][cur.key];\n            if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n                dist = dists[c2.key][cur.key];\n            }\n        } else if (opts.linkage === 'max') {\n            dist = dists[c1.key][cur.key];\n            if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n                dist = dists[c2.key][cur.key];\n            }\n        } else if (opts.linkage === 'mean') {\n            dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n        } else {\n            if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);\n            else dist = getDist(cur.value[0], c1.value[0]);\n        }\n        dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n    }\n    // Update cached mins\n    for(var _i2 = 0; _i2 < clusters.length; _i2++){\n        var key1 = clusters[_i2].key;\n        if (mins[key1] === c1.key || mins[key1] === c2.key) {\n            var _min = key1;\n            for(var j = 0; j < clusters.length; j++){\n                var key2 = clusters[j].key;\n                if (dists[key1][key2] < dists[key1][_min]) {\n                    _min = key2;\n                }\n            }\n            mins[key1] = _min;\n        }\n        clusters[_i2].index = _i2;\n    }\n    // Clean up meta data used for clustering\n    c1.key = c2.key = c1.index = c2.index = null;\n    return true;\n};\nvar _getAllChildren = function getAllChildren(root, arr, cy) {\n    if (!root) return;\n    if (root.value) {\n        arr.push(root.value);\n    } else {\n        if (root.left) _getAllChildren(root.left, arr);\n        if (root.right) _getAllChildren(root.right, arr);\n    }\n};\nvar _buildDendrogram = function buildDendrogram(root, cy) {\n    if (!root) return '';\n    if (root.left && root.right) {\n        var leftStr = _buildDendrogram(root.left, cy);\n        var rightStr = _buildDendrogram(root.right, cy);\n        var node = cy.add({\n            group: 'nodes',\n            data: {\n                id: leftStr + ',' + rightStr\n            }\n        });\n        cy.add({\n            group: 'edges',\n            data: {\n                source: leftStr,\n                target: node.id()\n            }\n        });\n        cy.add({\n            group: 'edges',\n            data: {\n                source: rightStr,\n                target: node.id()\n            }\n        });\n        return node.id();\n    } else if (root.value) {\n        return root.value.id();\n    }\n};\nvar _buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n    if (!root) return [];\n    var left = [], right = [], leaves = [];\n    if (k === 0) {\n        // don't cut tree, simply return all nodes as 1 single cluster\n        if (root.left) _getAllChildren(root.left, left);\n        if (root.right) _getAllChildren(root.right, right);\n        leaves = left.concat(right);\n        return [\n            cy.collection(leaves)\n        ];\n    } else if (k === 1) {\n        // cut at root\n        if (root.value) {\n            // leaf node\n            return [\n                cy.collection(root.value)\n            ];\n        } else {\n            if (root.left) _getAllChildren(root.left, left);\n            if (root.right) _getAllChildren(root.right, right);\n            return [\n                cy.collection(left),\n                cy.collection(right)\n            ];\n        }\n    } else {\n        if (root.value) {\n            return [\n                cy.collection(root.value)\n            ];\n        } else {\n            if (root.left) left = _buildClustersFromTree(root.left, k - 1, cy);\n            if (root.right) right = _buildClustersFromTree(root.right, k - 1, cy);\n            return left.concat(right);\n        }\n    }\n};\nvar hierarchicalClustering = function hierarchicalClustering(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    // Set parameters of algorithm: linkage type, distance metric, etc.\n    var opts = setOptions$1(options);\n    var attrs = opts.attributes;\n    var getDist = function getDist(n1, n2) {\n        return clusteringDistance(opts.distance, attrs.length, function(i) {\n            return attrs[i](n1);\n        }, function(i) {\n            return attrs[i](n2);\n        }, n1, n2);\n    };\n    // Begin hierarchical algorithm\n    var clusters = [];\n    var dists = []; // distances between each pair of clusters\n    var mins = []; // closest cluster for each cluster\n    var index = []; // hash of all clusters by key\n    // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n    for(var n = 0; n < nodes.length; n++){\n        var cluster = {\n            value: opts.mode === 'dendrogram' ? nodes[n] : [\n                nodes[n]\n            ],\n            key: n,\n            index: n\n        };\n        clusters[n] = cluster;\n        index[n] = cluster;\n        dists[n] = [];\n        mins[n] = 0;\n    }\n    // Calculate the distance between each pair of clusters\n    for(var i = 0; i < clusters.length; i++){\n        for(var j = 0; j <= i; j++){\n            var dist = undefined;\n            if (opts.mode === 'dendrogram') {\n                // modes store cluster values differently\n                dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n            } else {\n                dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n            }\n            dists[i][j] = dist;\n            dists[j][i] = dist;\n            if (dist < dists[i][mins[i]]) {\n                mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n            }\n        }\n    }\n    // Find the closest pair of clusters and merge them into a single cluster.\n    // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n    var merged = mergeClosest(clusters, index, dists, mins, opts);\n    while(merged){\n        merged = mergeClosest(clusters, index, dists, mins, opts);\n    }\n    var retClusters;\n    // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n    // in addition to returning the clusters.\n    if (opts.mode === 'dendrogram') {\n        retClusters = _buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n        if (opts.addDendrogram) _buildDendrogram(clusters[0], cy);\n    } else {\n        // Regular mode simply returns the clusters\n        retClusters = new Array(clusters.length);\n        clusters.forEach(function(cluster, i) {\n            // Clean up meta data used for clustering\n            cluster.key = cluster.index = null;\n            retClusters[i] = cy.collection(cluster.value);\n        });\n    }\n    return retClusters;\n};\nvar hierarchicalClustering$1 = {\n    hierarchicalClustering: hierarchicalClustering,\n    hca: hierarchicalClustering\n};\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-affinity-propagation\nvar defaults$9 = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare attributes between two nodes\n    preference: 'median',\n    // suitability of a data point to serve as an exemplar\n    damping: 0.8,\n    // damping factor between [0.5, 1)\n    maxIterations: 1000,\n    // max number of iterations to run\n    minIterations: 100,\n    // min number of iterations to run in order for clustering to stop\n    attributes: []\n});\nvar setOptions = function setOptions(options) {\n    var dmp = options.damping;\n    var pref = options.preference;\n    if (!(0.5 <= dmp && dmp < 1)) {\n        error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n    }\n    var validPrefs = [\n        'median',\n        'mean',\n        'min',\n        'max'\n    ];\n    if (!(validPrefs.some(function(v) {\n        return v === pref;\n    }) || number$1(pref))) {\n        error(\"Preference must be one of [\".concat(validPrefs.map(function(p) {\n            return \"'\".concat(p, \"'\");\n        }).join(', '), \"] or a number.  Got: \").concat(pref));\n    }\n    return defaults$9(options);\n};\nvar getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n    var attr = function attr(n, i) {\n        return attributes[i](n);\n    };\n    // nb negative because similarity should have an inverse relationship to distance\n    return -clusteringDistance(type, attributes.length, function(i) {\n        return attr(n1, i);\n    }, function(i) {\n        return attr(n2, i);\n    }, n1, n2);\n};\nvar getPreference = function getPreference(S, preference) {\n    // larger preference = greater # of clusters\n    var p = null;\n    if (preference === 'median') {\n        p = median(S);\n    } else if (preference === 'mean') {\n        p = mean(S);\n    } else if (preference === 'min') {\n        p = min(S);\n    } else if (preference === 'max') {\n        p = max(S);\n    } else {\n        // Custom preference number, as set by user\n        p = preference;\n    }\n    return p;\n};\nvar findExemplars = function findExemplars(n, R, A) {\n    var indices = [];\n    for(var i = 0; i < n; i++){\n        if (R[i * n + i] + A[i * n + i] > 0) {\n            indices.push(i);\n        }\n    }\n    return indices;\n};\nvar assignClusters = function assignClusters(n, S, exemplars) {\n    var clusters = [];\n    for(var i = 0; i < n; i++){\n        var index = -1;\n        var max = -Infinity;\n        for(var ei = 0; ei < exemplars.length; ei++){\n            var e = exemplars[ei];\n            if (S[i * n + e] > max) {\n                index = e;\n                max = S[i * n + e];\n            }\n        }\n        if (index > 0) {\n            clusters.push(index);\n        }\n    }\n    for(var _ei = 0; _ei < exemplars.length; _ei++){\n        clusters[exemplars[_ei]] = exemplars[_ei];\n    }\n    return clusters;\n};\nvar assign = function assign(n, S, exemplars) {\n    var clusters = assignClusters(n, S, exemplars);\n    for(var ei = 0; ei < exemplars.length; ei++){\n        var ii = [];\n        for(var c = 0; c < clusters.length; c++){\n            if (clusters[c] === exemplars[ei]) {\n                ii.push(c);\n            }\n        }\n        var maxI = -1;\n        var maxSum = -Infinity;\n        for(var i = 0; i < ii.length; i++){\n            var sum = 0;\n            for(var j = 0; j < ii.length; j++){\n                sum += S[ii[j] * n + ii[i]];\n            }\n            if (sum > maxSum) {\n                maxI = i;\n                maxSum = sum;\n            }\n        }\n        exemplars[ei] = ii[maxI];\n    }\n    clusters = assignClusters(n, S, exemplars);\n    return clusters;\n};\nvar affinityPropagation = function affinityPropagation(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions(options);\n    // Map each node to its position in node array\n    var id2position = {};\n    for(var i = 0; i < nodes.length; i++){\n        id2position[nodes[i].id()] = i;\n    }\n    // Begin affinity propagation algorithm\n    var n; // number of data points\n    var n2; // size of matrices\n    var S; // similarity matrix (1D array)\n    var p; // preference/suitability of a data point to serve as an exemplar\n    var R; // responsibility matrix (1D array)\n    var A; // availability matrix (1D array)\n    n = nodes.length;\n    n2 = n * n;\n    // Initialize and build S similarity matrix\n    S = new Array(n2);\n    for(var _i = 0; _i < n2; _i++){\n        S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n    }\n    for(var _i2 = 0; _i2 < n; _i2++){\n        for(var j = 0; j < n; j++){\n            if (_i2 !== j) {\n                S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n            }\n        }\n    }\n    // Place preferences on the diagonal of S\n    p = getPreference(S, opts.preference);\n    for(var _i3 = 0; _i3 < n; _i3++){\n        S[_i3 * n + _i3] = p;\n    }\n    // Initialize R responsibility matrix\n    R = new Array(n2);\n    for(var _i4 = 0; _i4 < n2; _i4++){\n        R[_i4] = 0.0;\n    }\n    // Initialize A availability matrix\n    A = new Array(n2);\n    for(var _i5 = 0; _i5 < n2; _i5++){\n        A[_i5] = 0.0;\n    }\n    var old = new Array(n);\n    var Rp = new Array(n);\n    var se = new Array(n);\n    for(var _i6 = 0; _i6 < n; _i6++){\n        old[_i6] = 0.0;\n        Rp[_i6] = 0.0;\n        se[_i6] = 0;\n    }\n    var e = new Array(n * opts.minIterations);\n    for(var _i7 = 0; _i7 < e.length; _i7++){\n        e[_i7] = 0;\n    }\n    var iter;\n    for(iter = 0; iter < opts.maxIterations; iter++){\n        // main algorithmic loop\n        // Update R responsibility matrix\n        for(var _i8 = 0; _i8 < n; _i8++){\n            var max = -Infinity, max2 = -Infinity, maxI = -1, AS = 0.0;\n            for(var _j = 0; _j < n; _j++){\n                old[_j] = R[_i8 * n + _j];\n                AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n                if (AS >= max) {\n                    max2 = max;\n                    max = AS;\n                    maxI = _j;\n                } else if (AS > max2) {\n                    max2 = AS;\n                }\n            }\n            for(var _j2 = 0; _j2 < n; _j2++){\n                R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n            }\n            R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n        }\n        // Update A availability matrix\n        for(var _i9 = 0; _i9 < n; _i9++){\n            var sum = 0;\n            for(var _j3 = 0; _j3 < n; _j3++){\n                old[_j3] = A[_j3 * n + _i9];\n                Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n                sum += Rp[_j3];\n            }\n            sum -= Rp[_i9];\n            Rp[_i9] = R[_i9 * n + _i9];\n            sum += Rp[_i9];\n            for(var _j4 = 0; _j4 < n; _j4++){\n                A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n            }\n            A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n        }\n        // Check for convergence\n        var K = 0;\n        for(var _i10 = 0; _i10 < n; _i10++){\n            var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n            e[iter % opts.minIterations * n + _i10] = E;\n            K += E;\n        }\n        if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n            var _sum = 0;\n            for(var _i11 = 0; _i11 < n; _i11++){\n                se[_i11] = 0;\n                for(var _j5 = 0; _j5 < opts.minIterations; _j5++){\n                    se[_i11] += e[_j5 * n + _i11];\n                }\n                if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n                    _sum++;\n                }\n            }\n            if (_sum === n) {\n                break;\n            }\n        }\n    }\n    // Identify exemplars (cluster centers)\n    var exemplarsIndices = findExemplars(n, R, A);\n    // Assign nodes to clusters\n    var clusterIndices = assign(n, S, exemplarsIndices);\n    var clusters = {};\n    for(var c = 0; c < exemplarsIndices.length; c++){\n        clusters[exemplarsIndices[c]] = [];\n    }\n    for(var _i12 = 0; _i12 < nodes.length; _i12++){\n        var pos = id2position[nodes[_i12].id()];\n        var clusterIndex = clusterIndices[pos];\n        if (clusterIndex != null) {\n            // the node may have not been assigned a cluster if no valid attributes were specified\n            clusters[clusterIndex].push(nodes[_i12]);\n        }\n    }\n    var retClusters = new Array(exemplarsIndices.length);\n    for(var _c = 0; _c < exemplarsIndices.length; _c++){\n        retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n    }\n    return retClusters;\n};\nvar affinityPropagation$1 = {\n    affinityPropagation: affinityPropagation,\n    ap: affinityPropagation\n};\nvar hierholzerDefaults = defaults$g({\n    root: undefined,\n    directed: false\n});\nvar elesfn$k = {\n    hierholzer: function hierholzer(options) {\n        if (!plainObject(options)) {\n            var args = arguments;\n            options = {\n                root: args[0],\n                directed: args[1]\n            };\n        }\n        var _hierholzerDefaults = hierholzerDefaults(options), root = _hierholzerDefaults.root, directed = _hierholzerDefaults.directed;\n        var eles = this;\n        var dflag = false;\n        var oddIn;\n        var oddOut;\n        var startVertex;\n        if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n        var nodes = {};\n        var edges = {};\n        if (directed) {\n            eles.forEach(function(ele) {\n                var id = ele.id();\n                if (ele.isNode()) {\n                    var ind = ele.indegree(true);\n                    var outd = ele.outdegree(true);\n                    var d1 = ind - outd;\n                    var d2 = outd - ind;\n                    if (d1 == 1) {\n                        if (oddIn) dflag = true;\n                        else oddIn = id;\n                    } else if (d2 == 1) {\n                        if (oddOut) dflag = true;\n                        else oddOut = id;\n                    } else if (d2 > 1 || d1 > 1) {\n                        dflag = true;\n                    }\n                    nodes[id] = [];\n                    ele.outgoers().forEach(function(e) {\n                        if (e.isEdge()) nodes[id].push(e.id());\n                    });\n                } else {\n                    edges[id] = [\n                        undefined,\n                        ele.target().id()\n                    ];\n                }\n            });\n        } else {\n            eles.forEach(function(ele) {\n                var id = ele.id();\n                if (ele.isNode()) {\n                    var d = ele.degree(true);\n                    if (d % 2) {\n                        if (!oddIn) oddIn = id;\n                        else if (!oddOut) oddOut = id;\n                        else dflag = true;\n                    }\n                    nodes[id] = [];\n                    ele.connectedEdges().forEach(function(e) {\n                        return nodes[id].push(e.id());\n                    });\n                } else {\n                    edges[id] = [\n                        ele.source().id(),\n                        ele.target().id()\n                    ];\n                }\n            });\n        }\n        var result = {\n            found: false,\n            trail: undefined\n        };\n        if (dflag) return result;\n        else if (oddOut && oddIn) {\n            if (directed) {\n                if (startVertex && oddOut != startVertex) {\n                    return result;\n                }\n                startVertex = oddOut;\n            } else {\n                if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n                    return result;\n                } else if (!startVertex) {\n                    startVertex = oddOut;\n                }\n            }\n        } else {\n            if (!startVertex) startVertex = eles[0].id();\n        }\n        var walk = function walk(v) {\n            var currentNode = v;\n            var subtour = [\n                v\n            ];\n            var adj, adjTail, adjHead;\n            while(nodes[currentNode].length){\n                adj = nodes[currentNode].shift();\n                adjTail = edges[adj][0];\n                adjHead = edges[adj][1];\n                if (currentNode != adjHead) {\n                    nodes[adjHead] = nodes[adjHead].filter(function(e) {\n                        return e != adj;\n                    });\n                    currentNode = adjHead;\n                } else if (!directed && currentNode != adjTail) {\n                    nodes[adjTail] = nodes[adjTail].filter(function(e) {\n                        return e != adj;\n                    });\n                    currentNode = adjTail;\n                }\n                subtour.unshift(adj);\n                subtour.unshift(currentNode);\n            }\n            return subtour;\n        };\n        var trail = [];\n        var subtour = [];\n        subtour = walk(startVertex);\n        while(subtour.length != 1){\n            if (nodes[subtour[0]].length == 0) {\n                trail.unshift(eles.getElementById(subtour.shift()));\n                trail.unshift(eles.getElementById(subtour.shift()));\n            } else {\n                subtour = walk(subtour.shift()).concat(subtour);\n            }\n        }\n        trail.unshift(eles.getElementById(subtour.shift())); // final node\n        for(var d in nodes){\n            if (nodes[d].length) {\n                return result;\n            }\n        }\n        result.found = true;\n        result.trail = this.spawn(trail, true);\n        return result;\n    }\n};\nvar hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n    var eles = this;\n    var nodes = {};\n    var id = 0;\n    var edgeCount = 0;\n    var components = [];\n    var stack = [];\n    var visitedEdges = {};\n    var buildComponent = function buildComponent(x, y) {\n        var i = stack.length - 1;\n        var cutset = [];\n        var component = eles.spawn();\n        while(stack[i].x != x || stack[i].y != y){\n            cutset.push(stack.pop().edge);\n            i--;\n        }\n        cutset.push(stack.pop().edge);\n        cutset.forEach(function(edge) {\n            var connectedNodes = edge.connectedNodes().intersection(eles);\n            component.merge(edge);\n            connectedNodes.forEach(function(node) {\n                var nodeId = node.id();\n                var connectedEdges = node.connectedEdges().intersection(eles);\n                component.merge(node);\n                if (!nodes[nodeId].cutVertex) {\n                    component.merge(connectedEdges);\n                } else {\n                    component.merge(connectedEdges.filter(function(edge) {\n                        return edge.isLoop();\n                    }));\n                }\n            });\n        });\n        components.push(component);\n    };\n    var _biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n        if (root === parent) edgeCount += 1;\n        nodes[currentNode] = {\n            id: id,\n            low: id++,\n            cutVertex: false\n        };\n        var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n        if (edges.size() === 0) {\n            components.push(eles.spawn(eles.getElementById(currentNode)));\n        } else {\n            var sourceId, targetId, otherNodeId, edgeId;\n            edges.forEach(function(edge) {\n                sourceId = edge.source().id();\n                targetId = edge.target().id();\n                otherNodeId = sourceId === currentNode ? targetId : sourceId;\n                if (otherNodeId !== parent) {\n                    edgeId = edge.id();\n                    if (!visitedEdges[edgeId]) {\n                        visitedEdges[edgeId] = true;\n                        stack.push({\n                            x: currentNode,\n                            y: otherNodeId,\n                            edge: edge\n                        });\n                    }\n                    if (!(otherNodeId in nodes)) {\n                        _biconnectedSearch(root, otherNodeId, currentNode);\n                        nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n                        if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n                            nodes[currentNode].cutVertex = true;\n                            buildComponent(currentNode, otherNodeId);\n                        }\n                    } else {\n                        nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n                    }\n                }\n            });\n        }\n    };\n    eles.forEach(function(ele) {\n        if (ele.isNode()) {\n            var nodeId = ele.id();\n            if (!(nodeId in nodes)) {\n                edgeCount = 0;\n                _biconnectedSearch(nodeId, nodeId);\n                nodes[nodeId].cutVertex = edgeCount > 1;\n            }\n        }\n    });\n    var cutVertices = Object.keys(nodes).filter(function(id) {\n        return nodes[id].cutVertex;\n    }).map(function(id) {\n        return eles.getElementById(id);\n    });\n    return {\n        cut: eles.spawn(cutVertices),\n        components: components\n    };\n};\nvar hopcroftTarjanBiconnected$1 = {\n    hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n    htbc: hopcroftTarjanBiconnected,\n    htb: hopcroftTarjanBiconnected,\n    hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n};\nvar tarjanStronglyConnected = function tarjanStronglyConnected() {\n    var eles = this;\n    var nodes = {};\n    var index = 0;\n    var components = [];\n    var stack = [];\n    var cut = eles.spawn(eles);\n    var _stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n        stack.push(sourceNodeId);\n        nodes[sourceNodeId] = {\n            index: index,\n            low: index++,\n            explored: false\n        };\n        var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n        connectedEdges.forEach(function(edge) {\n            var targetNodeId = edge.target().id();\n            if (targetNodeId !== sourceNodeId) {\n                if (!(targetNodeId in nodes)) {\n                    _stronglyConnectedSearch(targetNodeId);\n                }\n                if (!nodes[targetNodeId].explored) {\n                    nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n                }\n            }\n        });\n        if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n            var componentNodes = eles.spawn();\n            for(;;){\n                var nodeId = stack.pop();\n                componentNodes.merge(eles.getElementById(nodeId));\n                nodes[nodeId].low = nodes[sourceNodeId].index;\n                nodes[nodeId].explored = true;\n                if (nodeId === sourceNodeId) {\n                    break;\n                }\n            }\n            var componentEdges = componentNodes.edgesWith(componentNodes);\n            var component = componentNodes.merge(componentEdges);\n            components.push(component);\n            cut = cut.difference(component);\n        }\n    };\n    eles.forEach(function(ele) {\n        if (ele.isNode()) {\n            var nodeId = ele.id();\n            if (!(nodeId in nodes)) {\n                _stronglyConnectedSearch(nodeId);\n            }\n        }\n    });\n    return {\n        cut: cut,\n        components: components\n    };\n};\nvar tarjanStronglyConnected$1 = {\n    tarjanStronglyConnected: tarjanStronglyConnected,\n    tsc: tarjanStronglyConnected,\n    tscc: tarjanStronglyConnected,\n    tarjanStronglyConnectedComponents: tarjanStronglyConnected\n};\nvar elesfn$j = {};\n[\n    elesfn$v,\n    elesfn$u,\n    elesfn$t,\n    elesfn$s,\n    elesfn$r,\n    elesfn$q,\n    elesfn$p,\n    elesfn$o,\n    elesfn$n,\n    elesfn$m,\n    elesfn$l,\n    markovClustering$1,\n    kClustering,\n    hierarchicalClustering$1,\n    affinityPropagation$1,\n    elesfn$k,\n    hopcroftTarjanBiconnected$1,\n    tarjanStronglyConnected$1\n].forEach(function(props) {\n    extend(elesfn$j, props);\n});\n/*!\nEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\nCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\nLicensed under The MIT License (http://opensource.org/licenses/MIT)\n*/ /*  promise states [Promises/A+ 2.1]  */ var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */ \nvar STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */ \nvar STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */ \n/*  promise object constructor  */ var _api = function api(executor) {\n    /*  optionally support non-constructor/plain-function call  */ if (!(this instanceof _api)) return new _api(executor);\n    /*  initialize object  */ this.id = 'Thenable/1.0.7';\n    this.state = STATE_PENDING; /*  initial state  */ \n    this.fulfillValue = undefined; /*  initial value  */  /*  [Promises/A+ 1.3, 2.1.2.2]  */ \n    this.rejectReason = undefined; /*  initial reason */  /*  [Promises/A+ 1.5, 2.1.3.2]  */ \n    this.onFulfilled = []; /*  initial handlers  */ \n    this.onRejected = []; /*  initial handlers  */ \n    /*  provide optional information-hiding proxy  */ this.proxy = {\n        then: this.then.bind(this)\n    };\n    /*  support optional executor function  */ if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n};\n/*  promise API methods  */ _api.prototype = {\n    /*  promise resolving methods  */ fulfill: function fulfill(value) {\n        return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n    },\n    reject: function reject(value) {\n        return deliver(this, STATE_REJECTED, 'rejectReason', value);\n    },\n    /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */ then: function then(onFulfilled, onRejected) {\n        var curr = this;\n        var next = new _api(); /*  [Promises/A+ 2.2.7]  */ \n        curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */ \n        curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */ \n        execute(curr);\n        return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */ \n    }\n};\n/*  deliver an action  */ var deliver = function deliver(curr, state, name, value) {\n    if (curr.state === STATE_PENDING) {\n        curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */ \n        curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */ \n        execute(curr);\n    }\n    return curr;\n};\n/*  execute all handlers  */ var execute = function execute(curr) {\n    if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);\n    else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n};\n/*  execute particular set of handlers  */ var execute_handlers = function execute_handlers(curr, name, value) {\n    /* global setImmediate: true */ /* global setTimeout: true */ /*  short-circuit processing  */ if (curr[name].length === 0) return;\n    /*  iterate over all handlers, exactly once  */ var handlers = curr[name];\n    curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */ \n    var func = function func() {\n        for(var i = 0; i < handlers.length; i++)handlers[i](value); /*  [Promises/A+ 2.2.5]  */ \n    };\n    /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */ if (typeof setImmediate === 'function') setImmediate(func);\n    else setTimeout(func, 0);\n};\n/*  generate a resolver function  */ var resolver = function resolver(cb, next, method) {\n    return function(value) {\n        if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */ next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */ \n        else {\n            var result;\n            try {\n                result = cb(value);\n            } catch (e) {\n                next.reject(e); /*  [Promises/A+ 2.2.7.2]  */ \n                return;\n            }\n            _resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */ \n        }\n    };\n};\n/*  \"Promise Resolution Procedure\"  */ /*  [Promises/A+ 2.3]  */ var _resolve = function resolve(promise, x) {\n    /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */ if (promise === x || promise.proxy === x) {\n        promise.reject(new TypeError('cannot resolve promise with itself'));\n        return;\n    }\n    /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */ var then;\n    if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {\n        try {\n            then = x.then;\n        } catch (e) {\n            promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */ \n            return;\n        }\n    }\n    /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */ if (typeof then === 'function') {\n        var resolved = false;\n        try {\n            /*  call retrieved \"then\" method */ /*  [Promises/A+ 2.3.3.3]  */ then.call(x, /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */ function(y) {\n                if (resolved) return;\n                resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */ \n                if (y === x) /*  [Promises/A+ 3.6]  */ promise.reject(new TypeError('circular thenable chain'));\n                else _resolve(promise, y);\n            }, /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */ function(r) {\n                if (resolved) return;\n                resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */ \n                promise.reject(r);\n            });\n        } catch (e) {\n            if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */ promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */ \n        }\n        return;\n    }\n    /*  handle other values  */ promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */ \n};\n// so we always have Promise.all()\n_api.all = function(ps) {\n    return new _api(function(resolveAll, rejectAll) {\n        var vals = new Array(ps.length);\n        var doneCount = 0;\n        var fulfill = function fulfill(i, val) {\n            vals[i] = val;\n            doneCount++;\n            if (doneCount === ps.length) {\n                resolveAll(vals);\n            }\n        };\n        for(var i = 0; i < ps.length; i++){\n            (function(i) {\n                var p = ps[i];\n                var isPromise = p != null && p.then != null;\n                if (isPromise) {\n                    p.then(function(val) {\n                        fulfill(i, val);\n                    }, function(err) {\n                        rejectAll(err);\n                    });\n                } else {\n                    var val = p;\n                    fulfill(i, val);\n                }\n            })(i);\n        }\n    });\n};\n_api.resolve = function(val) {\n    return new _api(function(resolve, reject) {\n        resolve(val);\n    });\n};\n_api.reject = function(val) {\n    return new _api(function(resolve, reject) {\n        reject(val);\n    });\n};\nvar Promise$1 = typeof Promise !== 'undefined' ? Promise : _api; // eslint-disable-line no-undef\nvar Animation = function Animation(target, opts, opts2) {\n    var isCore = core(target);\n    var isEle = !isCore;\n    var _p = this._private = extend({\n        duration: 1000\n    }, opts, opts2);\n    _p.target = target;\n    _p.style = _p.style || _p.css;\n    _p.started = false;\n    _p.playing = false;\n    _p.hooked = false;\n    _p.applying = false;\n    _p.progress = 0;\n    _p.completes = [];\n    _p.frames = [];\n    if (_p.complete && fn$6(_p.complete)) {\n        _p.completes.push(_p.complete);\n    }\n    if (isEle) {\n        var pos = target.position();\n        _p.startPosition = _p.startPosition || {\n            x: pos.x,\n            y: pos.y\n        };\n        _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n    }\n    if (isCore) {\n        var pan = target.pan();\n        _p.startPan = {\n            x: pan.x,\n            y: pan.y\n        };\n        _p.startZoom = target.zoom();\n    }\n    // for future timeline/animations impl\n    this.length = 1;\n    this[0] = this;\n};\nvar anifn = Animation.prototype;\nextend(anifn, {\n    instanceString: function instanceString() {\n        return 'animation';\n    },\n    hook: function hook() {\n        var _p = this._private;\n        if (!_p.hooked) {\n            // add to target's animation queue\n            var q;\n            var tAni = _p.target._private.animation;\n            if (_p.queue) {\n                q = tAni.queue;\n            } else {\n                q = tAni.current;\n            }\n            q.push(this);\n            // add to the animation loop pool\n            if (elementOrCollection(_p.target)) {\n                _p.target.cy().addToAnimationPool(_p.target);\n            }\n            _p.hooked = true;\n        }\n        return this;\n    },\n    play: function play() {\n        var _p = this._private;\n        // autorewind\n        if (_p.progress === 1) {\n            _p.progress = 0;\n        }\n        _p.playing = true;\n        _p.started = false; // needs to be started by animation loop\n        _p.stopped = false;\n        this.hook();\n        // the animation loop will start the animation...\n        return this;\n    },\n    playing: function playing() {\n        return this._private.playing;\n    },\n    apply: function apply() {\n        var _p = this._private;\n        _p.applying = true;\n        _p.started = false; // needs to be started by animation loop\n        _p.stopped = false;\n        this.hook();\n        // the animation loop will apply the animation at this progress\n        return this;\n    },\n    applying: function applying() {\n        return this._private.applying;\n    },\n    pause: function pause() {\n        var _p = this._private;\n        _p.playing = false;\n        _p.started = false;\n        return this;\n    },\n    stop: function stop() {\n        var _p = this._private;\n        _p.playing = false;\n        _p.started = false;\n        _p.stopped = true; // to be removed from animation queues\n        return this;\n    },\n    rewind: function rewind() {\n        return this.progress(0);\n    },\n    fastforward: function fastforward() {\n        return this.progress(1);\n    },\n    time: function time(t) {\n        var _p = this._private;\n        if (t === undefined) {\n            return _p.progress * _p.duration;\n        } else {\n            return this.progress(t / _p.duration);\n        }\n    },\n    progress: function progress(p) {\n        var _p = this._private;\n        var wasPlaying = _p.playing;\n        if (p === undefined) {\n            return _p.progress;\n        } else {\n            if (wasPlaying) {\n                this.pause();\n            }\n            _p.progress = p;\n            _p.started = false;\n            if (wasPlaying) {\n                this.play();\n            }\n        }\n        return this;\n    },\n    completed: function completed() {\n        return this._private.progress === 1;\n    },\n    reverse: function reverse() {\n        var _p = this._private;\n        var wasPlaying = _p.playing;\n        if (wasPlaying) {\n            this.pause();\n        }\n        _p.progress = 1 - _p.progress;\n        _p.started = false;\n        var swap = function swap(a, b) {\n            var _pa = _p[a];\n            if (_pa == null) {\n                return;\n            }\n            _p[a] = _p[b];\n            _p[b] = _pa;\n        };\n        swap('zoom', 'startZoom');\n        swap('pan', 'startPan');\n        swap('position', 'startPosition');\n        // swap styles\n        if (_p.style) {\n            for(var i = 0; i < _p.style.length; i++){\n                var prop = _p.style[i];\n                var name = prop.name;\n                var startStyleProp = _p.startStyle[name];\n                _p.startStyle[name] = prop;\n                _p.style[i] = startStyleProp;\n            }\n        }\n        if (wasPlaying) {\n            this.play();\n        }\n        return this;\n    },\n    promise: function promise(type) {\n        var _p = this._private;\n        var arr;\n        switch(type){\n            case 'frame':\n                arr = _p.frames;\n                break;\n            default:\n            case 'complete':\n            case 'completed':\n                arr = _p.completes;\n        }\n        return new Promise$1(function(resolve, reject) {\n            arr.push(function() {\n                resolve();\n            });\n        });\n    }\n});\nanifn.complete = anifn.completed;\nanifn.run = anifn.play;\nanifn.running = anifn.playing;\nvar define$3 = {\n    animated: function animated() {\n        return function animatedImpl() {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return false;\n            }\n            var ele = all[0];\n            if (ele) {\n                return ele._private.animation.current.length > 0;\n            }\n        };\n    },\n    // animated\n    clearQueue: function clearQueue() {\n        return function clearQueueImpl() {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                ele._private.animation.queue = [];\n            }\n            return this;\n        };\n    },\n    // clearQueue\n    delay: function delay() {\n        return function delayImpl(time, complete) {\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            return this.animate({\n                delay: time,\n                duration: time,\n                complete: complete\n            });\n        };\n    },\n    // delay\n    delayAnimation: function delayAnimation() {\n        return function delayAnimationImpl(time, complete) {\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            return this.animation({\n                delay: time,\n                duration: time,\n                complete: complete\n            });\n        };\n    },\n    // delay\n    animation: function animation() {\n        return function animationImpl(properties, params) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            var isCore = !selfIsArrayLike;\n            var isEles = !isCore;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            var style = cy.style();\n            properties = extend({}, properties, params);\n            var propertiesEmpty = Object.keys(properties).length === 0;\n            if (propertiesEmpty) {\n                return new Animation(all[0], properties); // nothing to animate\n            }\n            if (properties.duration === undefined) {\n                properties.duration = 400;\n            }\n            switch(properties.duration){\n                case 'slow':\n                    properties.duration = 600;\n                    break;\n                case 'fast':\n                    properties.duration = 200;\n                    break;\n            }\n            if (isEles) {\n                properties.style = style.getPropsList(properties.style || properties.css);\n                properties.css = undefined;\n            }\n            if (isEles && properties.renderedPosition != null) {\n                var rpos = properties.renderedPosition;\n                var pan = cy.pan();\n                var zoom = cy.zoom();\n                properties.position = renderedToModelPosition(rpos, zoom, pan);\n            }\n            // override pan w/ panBy if set\n            if (isCore && properties.panBy != null) {\n                var panBy = properties.panBy;\n                var cyPan = cy.pan();\n                properties.pan = {\n                    x: cyPan.x + panBy.x,\n                    y: cyPan.y + panBy.y\n                };\n            }\n            // override pan w/ center if set\n            var center = properties.center || properties.centre;\n            if (isCore && center != null) {\n                var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n                if (centerPan != null) {\n                    properties.pan = centerPan;\n                }\n            }\n            // override pan & zoom w/ fit if set\n            if (isCore && properties.fit != null) {\n                var fit = properties.fit;\n                var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n                if (fitVp != null) {\n                    properties.pan = fitVp.pan;\n                    properties.zoom = fitVp.zoom;\n                }\n            }\n            // override zoom (& potentially pan) w/ zoom obj if set\n            if (isCore && plainObject(properties.zoom)) {\n                var vp = cy.getZoomedViewport(properties.zoom);\n                if (vp != null) {\n                    if (vp.zoomed) {\n                        properties.zoom = vp.zoom;\n                    }\n                    if (vp.panned) {\n                        properties.pan = vp.pan;\n                    }\n                } else {\n                    properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n                }\n            }\n            return new Animation(all[0], properties);\n        };\n    },\n    // animate\n    animate: function animate() {\n        return function animateImpl(properties, params) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            if (params) {\n                properties = extend({}, properties, params);\n            }\n            // manually hook and run the animation\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n                var ani = ele.animation(properties, queue ? {\n                    queue: true\n                } : undefined);\n                ani.play();\n            }\n            return this; // chaining\n        };\n    },\n    // animate\n    stop: function stop() {\n        return function stopImpl(clearQueue, jumpToEnd) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                var _p = ele._private;\n                var anis = _p.animation.current;\n                for(var j = 0; j < anis.length; j++){\n                    var ani = anis[j];\n                    var ani_p = ani._private;\n                    if (jumpToEnd) {\n                        // next iteration of the animation loop, the animation\n                        // will go straight to the end and be removed\n                        ani_p.duration = 0;\n                    }\n                }\n                // clear the queue of future animations\n                if (clearQueue) {\n                    _p.animation.queue = [];\n                }\n                if (!jumpToEnd) {\n                    _p.animation.current = [];\n                }\n            }\n            // we have to notify (the animation loop doesn't do it for us on `stop`)\n            cy.notify('draw');\n            return this;\n        };\n    } // stop\n}; // define\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */ var isArray_1;\nvar hasRequiredIsArray;\nfunction requireIsArray() {\n    if (hasRequiredIsArray) return isArray_1;\n    hasRequiredIsArray = 1;\n    var isArray = Array.isArray;\n    isArray_1 = isArray;\n    return isArray_1;\n}\nvar _isKey;\nvar hasRequired_isKey;\nfunction require_isKey() {\n    if (hasRequired_isKey) return _isKey;\n    hasRequired_isKey = 1;\n    var isArray = requireIsArray(), isSymbol = requireIsSymbol();\n    /** Used to match property names within property paths. */ var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/;\n    /**\n\t * Checks if `value` is a property name and not a property path.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t */ function isKey(value, object) {\n        if (isArray(value)) {\n            return false;\n        }\n        var type = typeof value;\n        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n            return true;\n        }\n        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    }\n    _isKey = isKey;\n    return _isKey;\n}\nvar isFunction_1;\nvar hasRequiredIsFunction;\nfunction requireIsFunction() {\n    if (hasRequiredIsFunction) return isFunction_1;\n    hasRequiredIsFunction = 1;\n    var baseGetTag = require_baseGetTag(), isObject = requireIsObject();\n    /** `Object#toString` result references. */ var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';\n    /**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */ function isFunction(value) {\n        if (!isObject(value)) {\n            return false;\n        }\n        // The use of `Object#toString` avoids issues with the `typeof` operator\n        // in Safari 9 which returns 'object' for typed arrays and other constructors.\n        var tag = baseGetTag(value);\n        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n    isFunction_1 = isFunction;\n    return isFunction_1;\n}\nvar _coreJsData;\nvar hasRequired_coreJsData;\nfunction require_coreJsData() {\n    if (hasRequired_coreJsData) return _coreJsData;\n    hasRequired_coreJsData = 1;\n    var root = require_root();\n    /** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];\n    _coreJsData = coreJsData;\n    return _coreJsData;\n}\nvar _isMasked;\nvar hasRequired_isMasked;\nfunction require_isMasked() {\n    if (hasRequired_isMasked) return _isMasked;\n    hasRequired_isMasked = 1;\n    var coreJsData = require_coreJsData();\n    /** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n        return uid ? 'Symbol(src)_1.' + uid : '';\n    }();\n    /**\n\t * Checks if `func` has its source masked.\n\t *\n\t * @private\n\t * @param {Function} func The function to check.\n\t * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t */ function isMasked(func) {\n        return !!maskSrcKey && maskSrcKey in func;\n    }\n    _isMasked = isMasked;\n    return _isMasked;\n}\n/** Used for built-in method references. */ var _toSource;\nvar hasRequired_toSource;\nfunction require_toSource() {\n    if (hasRequired_toSource) return _toSource;\n    hasRequired_toSource = 1;\n    var funcProto = Function.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n    /**\n\t * Converts `func` to its source code.\n\t *\n\t * @private\n\t * @param {Function} func The function to convert.\n\t * @returns {string} Returns the source code.\n\t */ function toSource(func) {\n        if (func != null) {\n            try {\n                return funcToString.call(func);\n            } catch (e) {}\n            try {\n                return func + '';\n            } catch (e) {}\n        }\n        return '';\n    }\n    _toSource = toSource;\n    return _toSource;\n}\nvar _baseIsNative;\nvar hasRequired_baseIsNative;\nfunction require_baseIsNative() {\n    if (hasRequired_baseIsNative) return _baseIsNative;\n    hasRequired_baseIsNative = 1;\n    var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();\n    /**\n\t * Used to match `RegExp`\n\t * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n    /**\n\t * The base implementation of `_.isNative` without bad shim checks.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function,\n\t *  else `false`.\n\t */ function baseIsNative(value) {\n        if (!isObject(value) || isMasked(value)) {\n            return false;\n        }\n        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n        return pattern.test(toSource(value));\n    }\n    _baseIsNative = baseIsNative;\n    return _baseIsNative;\n}\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ var _getValue;\nvar hasRequired_getValue;\nfunction require_getValue() {\n    if (hasRequired_getValue) return _getValue;\n    hasRequired_getValue = 1;\n    function getValue(object, key) {\n        return object == null ? undefined : object[key];\n    }\n    _getValue = getValue;\n    return _getValue;\n}\nvar _getNative;\nvar hasRequired_getNative;\nfunction require_getNative() {\n    if (hasRequired_getNative) return _getNative;\n    hasRequired_getNative = 1;\n    var baseIsNative = require_baseIsNative(), getValue = require_getValue();\n    /**\n\t * Gets the native function at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {string} key The key of the method to get.\n\t * @returns {*} Returns the function if it's native, else `undefined`.\n\t */ function getNative(object, key) {\n        var value = getValue(object, key);\n        return baseIsNative(value) ? value : undefined;\n    }\n    _getNative = getNative;\n    return _getNative;\n}\nvar _nativeCreate;\nvar hasRequired_nativeCreate;\nfunction require_nativeCreate() {\n    if (hasRequired_nativeCreate) return _nativeCreate;\n    hasRequired_nativeCreate = 1;\n    var getNative = require_getNative();\n    /* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, 'create');\n    _nativeCreate = nativeCreate;\n    return _nativeCreate;\n}\nvar _hashClear;\nvar hasRequired_hashClear;\nfunction require_hashClear() {\n    if (hasRequired_hashClear) return _hashClear;\n    hasRequired_hashClear = 1;\n    var nativeCreate = require_nativeCreate();\n    /**\n\t * Removes all key-value entries from the hash.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Hash\n\t */ function hashClear() {\n        this.__data__ = nativeCreate ? nativeCreate(null) : {};\n        this.size = 0;\n    }\n    _hashClear = hashClear;\n    return _hashClear;\n}\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ var _hashDelete;\nvar hasRequired_hashDelete;\nfunction require_hashDelete() {\n    if (hasRequired_hashDelete) return _hashDelete;\n    hasRequired_hashDelete = 1;\n    function hashDelete(key) {\n        var result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    _hashDelete = hashDelete;\n    return _hashDelete;\n}\nvar _hashGet;\nvar hasRequired_hashGet;\nfunction require_hashGet() {\n    if (hasRequired_hashGet) return _hashGet;\n    hasRequired_hashGet = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Gets the hash value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function hashGet(key) {\n        var data = this.__data__;\n        if (nativeCreate) {\n            var result = data[key];\n            return result === HASH_UNDEFINED ? undefined : result;\n        }\n        return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n    _hashGet = hashGet;\n    return _hashGet;\n}\nvar _hashHas;\nvar hasRequired_hashHas;\nfunction require_hashHas() {\n    if (hasRequired_hashHas) return _hashHas;\n    hasRequired_hashHas = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Checks if a hash value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Hash\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function hashHas(key) {\n        var data = this.__data__;\n        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n    }\n    _hashHas = hashHas;\n    return _hashHas;\n}\nvar _hashSet;\nvar hasRequired_hashSet;\nfunction require_hashSet() {\n    if (hasRequired_hashSet) return _hashSet;\n    hasRequired_hashSet = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';\n    /**\n\t * Sets the hash `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the hash instance.\n\t */ function hashSet(key, value) {\n        var data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n    _hashSet = hashSet;\n    return _hashSet;\n}\nvar _Hash;\nvar hasRequired_Hash;\nfunction require_Hash() {\n    if (hasRequired_Hash) return _Hash;\n    hasRequired_Hash = 1;\n    var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();\n    /**\n\t * Creates a hash object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function Hash(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    _Hash = Hash;\n    return _Hash;\n}\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */ var _listCacheClear;\nvar hasRequired_listCacheClear;\nfunction require_listCacheClear() {\n    if (hasRequired_listCacheClear) return _listCacheClear;\n    hasRequired_listCacheClear = 1;\n    function listCacheClear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n    _listCacheClear = listCacheClear;\n    return _listCacheClear;\n}\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */ var eq_1;\nvar hasRequiredEq;\nfunction requireEq() {\n    if (hasRequiredEq) return eq_1;\n    hasRequiredEq = 1;\n    function eq(value, other) {\n        return value === other || value !== value && other !== other;\n    }\n    eq_1 = eq;\n    return eq_1;\n}\nvar _assocIndexOf;\nvar hasRequired_assocIndexOf;\nfunction require_assocIndexOf() {\n    if (hasRequired_assocIndexOf) return _assocIndexOf;\n    hasRequired_assocIndexOf = 1;\n    var eq = requireEq();\n    /**\n\t * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} key The key to search for.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */ function assocIndexOf(array, key) {\n        var length = array.length;\n        while(length--){\n            if (eq(array[length][0], key)) {\n                return length;\n            }\n        }\n        return -1;\n    }\n    _assocIndexOf = assocIndexOf;\n    return _assocIndexOf;\n}\nvar _listCacheDelete;\nvar hasRequired_listCacheDelete;\nfunction require_listCacheDelete() {\n    if (hasRequired_listCacheDelete) return _listCacheDelete;\n    hasRequired_listCacheDelete = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /** Used for built-in method references. */ var arrayProto = Array.prototype;\n    /** Built-in value references. */ var splice = arrayProto.splice;\n    /**\n\t * Removes `key` and its value from the list cache.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */ function listCacheDelete(key) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        if (index < 0) {\n            return false;\n        }\n        var lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            splice.call(data, index, 1);\n        }\n        --this.size;\n        return true;\n    }\n    _listCacheDelete = listCacheDelete;\n    return _listCacheDelete;\n}\nvar _listCacheGet;\nvar hasRequired_listCacheGet;\nfunction require_listCacheGet() {\n    if (hasRequired_listCacheGet) return _listCacheGet;\n    hasRequired_listCacheGet = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Gets the list cache value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function listCacheGet(key) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n    _listCacheGet = listCacheGet;\n    return _listCacheGet;\n}\nvar _listCacheHas;\nvar hasRequired_listCacheHas;\nfunction require_listCacheHas() {\n    if (hasRequired_listCacheHas) return _listCacheHas;\n    hasRequired_listCacheHas = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Checks if a list cache value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf ListCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function listCacheHas(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    }\n    _listCacheHas = listCacheHas;\n    return _listCacheHas;\n}\nvar _listCacheSet;\nvar hasRequired_listCacheSet;\nfunction require_listCacheSet() {\n    if (hasRequired_listCacheSet) return _listCacheSet;\n    hasRequired_listCacheSet = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Sets the list cache `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the list cache instance.\n\t */ function listCacheSet(key, value) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        if (index < 0) {\n            ++this.size;\n            data.push([\n                key,\n                value\n            ]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n    _listCacheSet = listCacheSet;\n    return _listCacheSet;\n}\nvar _ListCache;\nvar hasRequired_ListCache;\nfunction require_ListCache() {\n    if (hasRequired_ListCache) return _ListCache;\n    hasRequired_ListCache = 1;\n    var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();\n    /**\n\t * Creates an list cache object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function ListCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    _ListCache = ListCache;\n    return _ListCache;\n}\nvar _Map;\nvar hasRequired_Map;\nfunction require_Map() {\n    if (hasRequired_Map) return _Map;\n    hasRequired_Map = 1;\n    var getNative = require_getNative(), root = require_root();\n    /* Built-in method references that are verified to be native. */ var Map1 = getNative(root, 'Map');\n    _Map = Map1;\n    return _Map;\n}\nvar _mapCacheClear;\nvar hasRequired_mapCacheClear;\nfunction require_mapCacheClear() {\n    if (hasRequired_mapCacheClear) return _mapCacheClear;\n    hasRequired_mapCacheClear = 1;\n    var Hash = require_Hash(), ListCache = require_ListCache(), Map1 = require_Map();\n    /**\n\t * Removes all key-value entries from the map.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf MapCache\n\t */ function mapCacheClear() {\n        this.size = 0;\n        this.__data__ = {\n            'hash': new Hash,\n            'map': new (Map1 || ListCache),\n            'string': new Hash\n        };\n    }\n    _mapCacheClear = mapCacheClear;\n    return _mapCacheClear;\n}\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */ var _isKeyable;\nvar hasRequired_isKeyable;\nfunction require_isKeyable() {\n    if (hasRequired_isKeyable) return _isKeyable;\n    hasRequired_isKeyable = 1;\n    function isKeyable(value) {\n        var type = typeof value;\n        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n    }\n    _isKeyable = isKeyable;\n    return _isKeyable;\n}\nvar _getMapData;\nvar hasRequired_getMapData;\nfunction require_getMapData() {\n    if (hasRequired_getMapData) return _getMapData;\n    hasRequired_getMapData = 1;\n    var isKeyable = require_isKeyable();\n    /**\n\t * Gets the data for `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to query.\n\t * @param {string} key The reference key.\n\t * @returns {*} Returns the map data.\n\t */ function getMapData(map, key) {\n        var data = map.__data__;\n        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n    }\n    _getMapData = getMapData;\n    return _getMapData;\n}\nvar _mapCacheDelete;\nvar hasRequired_mapCacheDelete;\nfunction require_mapCacheDelete() {\n    if (hasRequired_mapCacheDelete) return _mapCacheDelete;\n    hasRequired_mapCacheDelete = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Removes `key` and its value from the map.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */ function mapCacheDelete(key) {\n        var result = getMapData(this, key)['delete'](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    _mapCacheDelete = mapCacheDelete;\n    return _mapCacheDelete;\n}\nvar _mapCacheGet;\nvar hasRequired_mapCacheGet;\nfunction require_mapCacheGet() {\n    if (hasRequired_mapCacheGet) return _mapCacheGet;\n    hasRequired_mapCacheGet = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Gets the map value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function mapCacheGet(key) {\n        return getMapData(this, key).get(key);\n    }\n    _mapCacheGet = mapCacheGet;\n    return _mapCacheGet;\n}\nvar _mapCacheHas;\nvar hasRequired_mapCacheHas;\nfunction require_mapCacheHas() {\n    if (hasRequired_mapCacheHas) return _mapCacheHas;\n    hasRequired_mapCacheHas = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Checks if a map value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf MapCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function mapCacheHas(key) {\n        return getMapData(this, key).has(key);\n    }\n    _mapCacheHas = mapCacheHas;\n    return _mapCacheHas;\n}\nvar _mapCacheSet;\nvar hasRequired_mapCacheSet;\nfunction require_mapCacheSet() {\n    if (hasRequired_mapCacheSet) return _mapCacheSet;\n    hasRequired_mapCacheSet = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Sets the map `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the map cache instance.\n\t */ function mapCacheSet(key, value) {\n        var data = getMapData(this, key), size = data.size;\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n    _mapCacheSet = mapCacheSet;\n    return _mapCacheSet;\n}\nvar _MapCache;\nvar hasRequired_MapCache;\nfunction require_MapCache() {\n    if (hasRequired_MapCache) return _MapCache;\n    hasRequired_MapCache = 1;\n    var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();\n    /**\n\t * Creates a map cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function MapCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    _MapCache = MapCache;\n    return _MapCache;\n}\nvar memoize_1;\nvar hasRequiredMemoize;\nfunction requireMemoize() {\n    if (hasRequiredMemoize) return memoize_1;\n    hasRequiredMemoize = 1;\n    var MapCache = require_MapCache();\n    /** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';\n    /**\n\t * Creates a function that memoizes the result of `func`. If `resolver` is\n\t * provided, it determines the cache key for storing the result based on the\n\t * arguments provided to the memoized function. By default, the first argument\n\t * provided to the memoized function is used as the map cache key. The `func`\n\t * is invoked with the `this` binding of the memoized function.\n\t *\n\t * **Note:** The cache is exposed as the `cache` property on the memoized\n\t * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t * constructor with one whose instances implement the\n\t * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n\t * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to have its output memoized.\n\t * @param {Function} [resolver] The function to resolve the cache key.\n\t * @returns {Function} Returns the new memoized function.\n\t * @example\n\t *\n\t * var object = { 'a': 1, 'b': 2 };\n\t * var other = { 'c': 3, 'd': 4 };\n\t *\n\t * var values = _.memoize(_.values);\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * values(other);\n\t * // => [3, 4]\n\t *\n\t * object.a = 2;\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * // Modify the result cache.\n\t * values.cache.set(object, ['a', 'b']);\n\t * values(object);\n\t * // => ['a', 'b']\n\t *\n\t * // Replace `_.memoize.Cache`.\n\t * _.memoize.Cache = WeakMap;\n\t */ function memoize(func, resolver) {\n        if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        var memoized = function() {\n            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n            if (cache.has(key)) {\n                return cache.get(key);\n            }\n            var result = func.apply(this, args);\n            memoized.cache = cache.set(key, result) || cache;\n            return result;\n        };\n        memoized.cache = new (memoize.Cache || MapCache);\n        return memoized;\n    }\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n    memoize_1 = memoize;\n    return memoize_1;\n}\nvar _memoizeCapped;\nvar hasRequired_memoizeCapped;\nfunction require_memoizeCapped() {\n    if (hasRequired_memoizeCapped) return _memoizeCapped;\n    hasRequired_memoizeCapped = 1;\n    var memoize = requireMemoize();\n    /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n    /**\n\t * A specialized version of `_.memoize` which clears the memoized function's\n\t * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n\t *\n\t * @private\n\t * @param {Function} func The function to have its output memoized.\n\t * @returns {Function} Returns the new memoized function.\n\t */ function memoizeCapped(func) {\n        var result = memoize(func, function(key) {\n            if (cache.size === MAX_MEMOIZE_SIZE) {\n                cache.clear();\n            }\n            return key;\n        });\n        var cache = result.cache;\n        return result;\n    }\n    _memoizeCapped = memoizeCapped;\n    return _memoizeCapped;\n}\nvar _stringToPath;\nvar hasRequired_stringToPath;\nfunction require_stringToPath() {\n    if (hasRequired_stringToPath) return _stringToPath;\n    hasRequired_stringToPath = 1;\n    var memoizeCapped = require_memoizeCapped();\n    /** Used to match property names within property paths. */ var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    /** Used to match backslashes in property paths. */ var reEscapeChar = /\\\\(\\\\)?/g;\n    /**\n\t * Converts `string` to a property path array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the property path array.\n\t */ var stringToPath = memoizeCapped(function(string) {\n        var result = [];\n        if (string.charCodeAt(0) === 46 /* . */ ) {\n            result.push('');\n        }\n        string.replace(rePropName, function(match, number, quote, subString) {\n            result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);\n        });\n        return result;\n    });\n    _stringToPath = stringToPath;\n    return _stringToPath;\n}\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ var _arrayMap;\nvar hasRequired_arrayMap;\nfunction require_arrayMap() {\n    if (hasRequired_arrayMap) return _arrayMap;\n    hasRequired_arrayMap = 1;\n    function arrayMap(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n        while(++index < length){\n            result[index] = iteratee(array[index], index, array);\n        }\n        return result;\n    }\n    _arrayMap = arrayMap;\n    return _arrayMap;\n}\nvar _baseToString;\nvar hasRequired_baseToString;\nfunction require_baseToString() {\n    if (hasRequired_baseToString) return _baseToString;\n    hasRequired_baseToString = 1;\n    var Symbol1 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();\n    /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol1 ? Symbol1.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n    /**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */ function baseToString(value) {\n        // Exit early for strings to avoid a performance hit in some environments.\n        if (typeof value == 'string') {\n            return value;\n        }\n        if (isArray(value)) {\n            // Recursively convert values (susceptible to call stack limits).\n            return arrayMap(value, baseToString) + '';\n        }\n        if (isSymbol(value)) {\n            return symbolToString ? symbolToString.call(value) : '';\n        }\n        var result = value + '';\n        return result == '0' && 1 / value == -Infinity ? '-0' : result;\n    }\n    _baseToString = baseToString;\n    return _baseToString;\n}\nvar toString_1;\nvar hasRequiredToString;\nfunction requireToString() {\n    if (hasRequiredToString) return toString_1;\n    hasRequiredToString = 1;\n    var baseToString = require_baseToString();\n    /**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */ function toString(value) {\n        return value == null ? '' : baseToString(value);\n    }\n    toString_1 = toString;\n    return toString_1;\n}\nvar _castPath;\nvar hasRequired_castPath;\nfunction require_castPath() {\n    if (hasRequired_castPath) return _castPath;\n    hasRequired_castPath = 1;\n    var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();\n    /**\n\t * Casts `value` to a path array if it's not one.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {Array} Returns the cast property path array.\n\t */ function castPath(value, object) {\n        if (isArray(value)) {\n            return value;\n        }\n        return isKey(value, object) ? [\n            value\n        ] : stringToPath(toString(value));\n    }\n    _castPath = castPath;\n    return _castPath;\n}\nvar _toKey;\nvar hasRequired_toKey;\nfunction require_toKey() {\n    if (hasRequired_toKey) return _toKey;\n    hasRequired_toKey = 1;\n    var isSymbol = requireIsSymbol();\n    /**\n\t * Converts `value` to a string key if it's not a string or symbol.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @returns {string|symbol} Returns the key.\n\t */ function toKey(value) {\n        if (typeof value == 'string' || isSymbol(value)) {\n            return value;\n        }\n        var result = value + '';\n        return result == '0' && 1 / value == -Infinity ? '-0' : result;\n    }\n    _toKey = toKey;\n    return _toKey;\n}\nvar _baseGet;\nvar hasRequired_baseGet;\nfunction require_baseGet() {\n    if (hasRequired_baseGet) return _baseGet;\n    hasRequired_baseGet = 1;\n    var castPath = require_castPath(), toKey = require_toKey();\n    /**\n\t * The base implementation of `_.get` without support for default values.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {*} Returns the resolved value.\n\t */ function baseGet(object, path) {\n        path = castPath(path, object);\n        var index = 0, length = path.length;\n        while(object != null && index < length){\n            object = object[toKey(path[index++])];\n        }\n        return index && index == length ? object : undefined;\n    }\n    _baseGet = baseGet;\n    return _baseGet;\n}\nvar get_1;\nvar hasRequiredGet;\nfunction requireGet() {\n    if (hasRequiredGet) return get_1;\n    hasRequiredGet = 1;\n    var baseGet = require_baseGet();\n    /**\n\t * Gets the value at `path` of `object`. If the resolved value is\n\t * `undefined`, the `defaultValue` is returned in its place.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n\t * @returns {*} Returns the resolved value.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.get(object, 'a[0].b.c');\n\t * // => 3\n\t *\n\t * _.get(object, ['a', '0', 'b', 'c']);\n\t * // => 3\n\t *\n\t * _.get(object, 'a.b.c', 'default');\n\t * // => 'default'\n\t */ function get(object, path, defaultValue) {\n        var result = object == null ? undefined : baseGet(object, path);\n        return result === undefined ? defaultValue : result;\n    }\n    get_1 = get;\n    return get_1;\n}\nvar getExports = requireGet();\nvar get = /*@__PURE__*/ getDefaultExportFromCjs(getExports);\nvar _defineProperty;\nvar hasRequired_defineProperty;\nfunction require_defineProperty() {\n    if (hasRequired_defineProperty) return _defineProperty;\n    hasRequired_defineProperty = 1;\n    var getNative = require_getNative();\n    var defineProperty = function() {\n        try {\n            var func = getNative(Object, 'defineProperty');\n            func({}, '', {});\n            return func;\n        } catch (e) {}\n    }();\n    _defineProperty = defineProperty;\n    return _defineProperty;\n}\nvar _baseAssignValue;\nvar hasRequired_baseAssignValue;\nfunction require_baseAssignValue() {\n    if (hasRequired_baseAssignValue) return _baseAssignValue;\n    hasRequired_baseAssignValue = 1;\n    var defineProperty = require_defineProperty();\n    /**\n\t * The base implementation of `assignValue` and `assignMergeValue` without\n\t * value checks.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */ function baseAssignValue(object, key, value) {\n        if (key == '__proto__' && defineProperty) {\n            defineProperty(object, key, {\n                'configurable': true,\n                'enumerable': true,\n                'value': value,\n                'writable': true\n            });\n        } else {\n            object[key] = value;\n        }\n    }\n    _baseAssignValue = baseAssignValue;\n    return _baseAssignValue;\n}\nvar _assignValue;\nvar hasRequired_assignValue;\nfunction require_assignValue() {\n    if (hasRequired_assignValue) return _assignValue;\n    hasRequired_assignValue = 1;\n    var baseAssignValue = require_baseAssignValue(), eq = requireEq();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * for equality comparisons.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */ function assignValue(object, key, value) {\n        var objValue = object[key];\n        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n            baseAssignValue(object, key, value);\n        }\n    }\n    _assignValue = assignValue;\n    return _assignValue;\n}\n/** Used as references for various `Number` constants. */ var _isIndex;\nvar hasRequired_isIndex;\nfunction require_isIndex() {\n    if (hasRequired_isIndex) return _isIndex;\n    hasRequired_isIndex = 1;\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    /**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */ function isIndex(value, length) {\n        var type = typeof value;\n        length = length == null ? MAX_SAFE_INTEGER : length;\n        return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n    _isIndex = isIndex;\n    return _isIndex;\n}\nvar _baseSet;\nvar hasRequired_baseSet;\nfunction require_baseSet() {\n    if (hasRequired_baseSet) return _baseSet;\n    hasRequired_baseSet = 1;\n    var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject = requireIsObject(), toKey = require_toKey();\n    /**\n\t * The base implementation of `_.set`.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @param {Function} [customizer] The function to customize path creation.\n\t * @returns {Object} Returns `object`.\n\t */ function baseSet(object, path, value, customizer) {\n        if (!isObject(object)) {\n            return object;\n        }\n        path = castPath(path, object);\n        var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n        while(nested != null && ++index < length){\n            var key = toKey(path[index]), newValue = value;\n            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n                return object;\n            }\n            if (index != lastIndex) {\n                var objValue = nested[key];\n                newValue = customizer ? customizer(objValue, key, nested) : undefined;\n                if (newValue === undefined) {\n                    newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n                }\n            }\n            assignValue(nested, key, newValue);\n            nested = nested[key];\n        }\n        return object;\n    }\n    _baseSet = baseSet;\n    return _baseSet;\n}\nvar set_1;\nvar hasRequiredSet;\nfunction requireSet() {\n    if (hasRequiredSet) return set_1;\n    hasRequiredSet = 1;\n    var baseSet = require_baseSet();\n    /**\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n\t * it's created. Arrays are created for missing index properties while objects\n\t * are created for all other missing properties. Use `_.setWith` to customize\n\t * `path` creation.\n\t *\n\t * **Note:** This method mutates `object`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns `object`.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.set(object, 'a[0].b.c', 4);\n\t * console.log(object.a[0].b.c);\n\t * // => 4\n\t *\n\t * _.set(object, ['x', '0', 'y', 'z'], 5);\n\t * console.log(object.x[0].y.z);\n\t * // => 5\n\t */ function set(object, path, value) {\n        return object == null ? object : baseSet(object, path, value);\n    }\n    set_1 = set;\n    return set_1;\n}\nvar setExports = requireSet();\nvar set = /*@__PURE__*/ getDefaultExportFromCjs(setExports);\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */ var _copyArray;\nvar hasRequired_copyArray;\nfunction require_copyArray() {\n    if (hasRequired_copyArray) return _copyArray;\n    hasRequired_copyArray = 1;\n    function copyArray(source, array) {\n        var index = -1, length = source.length;\n        array || (array = Array(length));\n        while(++index < length){\n            array[index] = source[index];\n        }\n        return array;\n    }\n    _copyArray = copyArray;\n    return _copyArray;\n}\nvar toPath_1;\nvar hasRequiredToPath;\nfunction requireToPath() {\n    if (hasRequiredToPath) return toPath_1;\n    hasRequiredToPath = 1;\n    var arrayMap = require_arrayMap(), copyArray = require_copyArray(), isArray = requireIsArray(), isSymbol = requireIsSymbol(), stringToPath = require_stringToPath(), toKey = require_toKey(), toString = requireToString();\n    /**\n\t * Converts `value` to a property path array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Util\n\t * @param {*} value The value to convert.\n\t * @returns {Array} Returns the new property path array.\n\t * @example\n\t *\n\t * _.toPath('a.b.c');\n\t * // => ['a', 'b', 'c']\n\t *\n\t * _.toPath('a[0].b.c');\n\t * // => ['a', '0', 'b', 'c']\n\t */ function toPath(value) {\n        if (isArray(value)) {\n            return arrayMap(value, toKey);\n        }\n        return isSymbol(value) ? [\n            value\n        ] : copyArray(stringToPath(toString(value)));\n    }\n    toPath_1 = toPath;\n    return toPath_1;\n}\nvar toPathExports = requireToPath();\nvar toPath = /*@__PURE__*/ getDefaultExportFromCjs(toPathExports);\nvar define$2 = {\n    // access data field\n    data: function data(params) {\n        var defaults = {\n            field: 'data',\n            bindingEvent: 'data',\n            allowBinding: false,\n            allowSetting: false,\n            allowGetting: false,\n            settingEvent: 'data',\n            settingTriggersEvent: false,\n            triggerFnName: 'trigger',\n            immutableKeys: {},\n            // key => true if immutable\n            updateStyle: false,\n            beforeGet: function beforeGet(self1) {},\n            beforeSet: function beforeSet(self1, obj) {},\n            onSet: function onSet(self1) {},\n            canSet: function canSet(self1) {\n                return true;\n            }\n        };\n        params = extend({}, defaults, params);\n        return function dataImpl(name, value) {\n            var p = params;\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var single = selfIsArrayLike ? self1[0] : self1;\n            // .data('foo', ...)\n            if (string(name)) {\n                // set or get property\n                var isPathLike = name.indexOf('.') !== -1; // there might be a normal field with a dot \n                var path = isPathLike && toPath(name);\n                // .data('foo')\n                if (p.allowGetting && value === undefined) {\n                    // get\n                    var ret;\n                    if (single) {\n                        p.beforeGet(single);\n                        // check if it's path and a field with the same name doesn't exist\n                        if (path && single._private[p.field][name] === undefined) {\n                            ret = get(single._private[p.field], path);\n                        } else {\n                            ret = single._private[p.field][name];\n                        }\n                    }\n                    return ret;\n                // .data('foo', 'bar')\n                } else if (p.allowSetting && value !== undefined) {\n                    // set\n                    var valid = !p.immutableKeys[name];\n                    if (valid) {\n                        var change = _defineProperty$1({}, name, value);\n                        p.beforeSet(self1, change);\n                        for(var i = 0, l = all.length; i < l; i++){\n                            var ele = all[i];\n                            if (p.canSet(ele)) {\n                                if (path && single._private[p.field][name] === undefined) {\n                                    set(ele._private[p.field], path, value);\n                                } else {\n                                    ele._private[p.field][name] = value;\n                                }\n                            }\n                        }\n                        // update mappers if asked\n                        if (p.updateStyle) {\n                            self1.updateStyle();\n                        }\n                        // call onSet callback\n                        p.onSet(self1);\n                        if (p.settingTriggersEvent) {\n                            self1[p.triggerFnName](p.settingEvent);\n                        }\n                    }\n                }\n            // .data({ 'foo': 'bar' })\n            } else if (p.allowSetting && plainObject(name)) {\n                // extend\n                var obj = name;\n                var k, v;\n                var keys = Object.keys(obj);\n                p.beforeSet(self1, obj);\n                for(var _i = 0; _i < keys.length; _i++){\n                    k = keys[_i];\n                    v = obj[k];\n                    var _valid = !p.immutableKeys[k];\n                    if (_valid) {\n                        for(var j = 0; j < all.length; j++){\n                            var _ele = all[j];\n                            if (p.canSet(_ele)) {\n                                _ele._private[p.field][k] = v;\n                            }\n                        }\n                    }\n                }\n                // update mappers if asked\n                if (p.updateStyle) {\n                    self1.updateStyle();\n                }\n                // call onSet callback\n                p.onSet(self1);\n                if (p.settingTriggersEvent) {\n                    self1[p.triggerFnName](p.settingEvent);\n                }\n            // .data(function(){ ... })\n            } else if (p.allowBinding && fn$6(name)) {\n                // bind to event\n                var fn = name;\n                self1.on(p.bindingEvent, fn);\n            // .data()\n            } else if (p.allowGetting && name === undefined) {\n                // get whole object\n                var _ret;\n                if (single) {\n                    p.beforeGet(single);\n                    _ret = single._private[p.field];\n                }\n                return _ret;\n            }\n            return self1; // maintain chainability\n        }; // function\n    },\n    // data\n    // remove data field\n    removeData: function removeData(params) {\n        var defaults = {\n            field: 'data',\n            event: 'data',\n            triggerFnName: 'trigger',\n            triggerEvent: false,\n            immutableKeys: {} // key => true if immutable\n        };\n        params = extend({}, defaults, params);\n        return function removeDataImpl(names) {\n            var p = params;\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            // .removeData('foo bar')\n            if (string(names)) {\n                // then get the list of keys, and delete them\n                var keys = names.split(/\\s+/);\n                var l = keys.length;\n                for(var i = 0; i < l; i++){\n                    // delete each non-empty key\n                    var key = keys[i];\n                    if (emptyString(key)) {\n                        continue;\n                    }\n                    var valid = !p.immutableKeys[key]; // not valid if immutable\n                    if (valid) {\n                        for(var i_a = 0, l_a = all.length; i_a < l_a; i_a++){\n                            all[i_a]._private[p.field][key] = undefined;\n                        }\n                    }\n                }\n                if (p.triggerEvent) {\n                    self1[p.triggerFnName](p.event);\n                }\n            // .removeData()\n            } else if (names === undefined) {\n                // then delete all keys\n                for(var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++){\n                    var _privateFields = all[_i_a]._private[p.field];\n                    var _keys = Object.keys(_privateFields);\n                    for(var _i2 = 0; _i2 < _keys.length; _i2++){\n                        var _key = _keys[_i2];\n                        var validKeyToDelete = !p.immutableKeys[_key];\n                        if (validKeyToDelete) {\n                            _privateFields[_key] = undefined;\n                        }\n                    }\n                }\n                if (p.triggerEvent) {\n                    self1[p.triggerFnName](p.event);\n                }\n            }\n            return self1; // maintain chaining\n        }; // function\n    } // removeData\n}; // define\nvar define$1 = {\n    eventAliasesOn: function eventAliasesOn(proto) {\n        var p = proto;\n        p.addListener = p.listen = p.bind = p.on;\n        p.unlisten = p.unbind = p.off = p.removeListener;\n        p.trigger = p.emit;\n        // this is just a wrapper alias of .on()\n        p.pon = p.promiseOn = function(events, selector) {\n            var self1 = this;\n            var args = Array.prototype.slice.call(arguments, 0);\n            return new Promise$1(function(resolve, reject) {\n                var callback = function callback(e) {\n                    self1.off.apply(self1, offArgs);\n                    resolve(e);\n                };\n                var onArgs = args.concat([\n                    callback\n                ]);\n                var offArgs = onArgs.concat([]);\n                self1.on.apply(self1, onArgs);\n            });\n        };\n    }\n}; // define\n// use this module to cherry pick functions into your prototype\n// (useful for functions shared between the core and collections, for example)\nvar define = {};\n[\n    define$3,\n    define$2,\n    define$1\n].forEach(function(m1) {\n    extend(define, m1);\n});\nvar elesfn$i = {\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop()\n};\nvar elesfn$h = {\n    classes: function classes(_classes) {\n        var self1 = this;\n        if (_classes === undefined) {\n            var ret = [];\n            self1[0]._private.classes.forEach(function(cls) {\n                return ret.push(cls);\n            });\n            return ret;\n        } else if (!array(_classes)) {\n            // extract classes from string\n            _classes = (_classes || '').match(/\\S+/g) || [];\n        }\n        var changed = [];\n        var classesSet = new Set$1(_classes);\n        // check and update each ele\n        for(var j = 0; j < self1.length; j++){\n            var ele = self1[j];\n            var _p = ele._private;\n            var eleClasses = _p.classes;\n            var changedEle = false;\n            // check if ele has all of the passed classes\n            for(var i = 0; i < _classes.length; i++){\n                var cls = _classes[i];\n                var eleHasClass = eleClasses.has(cls);\n                if (!eleHasClass) {\n                    changedEle = true;\n                    break;\n                }\n            }\n            // check if ele has classes outside of those passed\n            if (!changedEle) {\n                changedEle = eleClasses.size !== _classes.length;\n            }\n            if (changedEle) {\n                _p.classes = classesSet;\n                changed.push(ele);\n            }\n        }\n        // trigger update style on those eles that had class changes\n        if (changed.length > 0) {\n            this.spawn(changed).updateStyle().emit('class');\n        }\n        return self1;\n    },\n    addClass: function addClass(classes) {\n        return this.toggleClass(classes, true);\n    },\n    hasClass: function hasClass(className) {\n        var ele = this[0];\n        return ele != null && ele._private.classes.has(className);\n    },\n    toggleClass: function toggleClass(classes, toggle) {\n        if (!array(classes)) {\n            // extract classes from string\n            classes = classes.match(/\\S+/g) || [];\n        }\n        var self1 = this;\n        var toggleUndefd = toggle === undefined;\n        var changed = []; // eles who had classes changed\n        for(var i = 0, il = self1.length; i < il; i++){\n            var ele = self1[i];\n            var eleClasses = ele._private.classes;\n            var changedEle = false;\n            for(var j = 0; j < classes.length; j++){\n                var cls = classes[j];\n                var hasClass = eleClasses.has(cls);\n                var changedNow = false;\n                if (toggle || toggleUndefd && !hasClass) {\n                    eleClasses.add(cls);\n                    changedNow = true;\n                } else if (!toggle || toggleUndefd && hasClass) {\n                    eleClasses[\"delete\"](cls);\n                    changedNow = true;\n                }\n                if (!changedEle && changedNow) {\n                    changed.push(ele);\n                    changedEle = true;\n                }\n            } // for j classes\n        } // for i eles\n        // trigger update style on those eles that had class changes\n        if (changed.length > 0) {\n            this.spawn(changed).updateStyle().emit('class');\n        }\n        return self1;\n    },\n    removeClass: function removeClass(classes) {\n        return this.toggleClass(classes, false);\n    },\n    flashClass: function flashClass(classes, duration) {\n        var self1 = this;\n        if (duration == null) {\n            duration = 250;\n        } else if (duration === 0) {\n            return self1; // nothing to do really\n        }\n        self1.addClass(classes);\n        setTimeout(function() {\n            self1.removeClass(classes);\n        }, duration);\n        return self1;\n    }\n};\nelesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n// tokens in the query language\nvar tokens = {\n    metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]',\n    // chars we need to escape in let names, etc\n    comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=',\n    // binary comparison op (used in data selectors)\n    boolOp: '\\\\?|\\\\!|\\\\^',\n    // boolean (unary) operators (used in data selectors)\n    string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\",\n    // string literals (used in data selectors) -- doublequotes | singlequotes\n    number: number,\n    // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n    meta: 'degree|indegree|outdegree',\n    // allowed metadata fields (i.e. allowed functions to use from Collection)\n    separator: '\\\\s*,\\\\s*',\n    // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n    descendant: '\\\\s+',\n    child: '\\\\s+>\\\\s+',\n    subject: '\\\\$',\n    group: 'node|edge|\\\\*',\n    directedEdge: '\\\\s+->\\\\s+',\n    undirectedEdge: '\\\\s+<->\\\\s+'\n};\ntokens.variable = '(?:[\\\\w-.]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name can have letters, numbers, dashes, and periods\ntokens.className = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a class name has the same rules as a variable except it can't have a '.' in the name\ntokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\ntokens.id = tokens.variable; // an element id (follows variable conventions)\n(function() {\n    var ops, op, i;\n    // add @ variants to comparatorOp\n    ops = tokens.comparatorOp.split('|');\n    for(i = 0; i < ops.length; i++){\n        op = ops[i];\n        tokens.comparatorOp += '|@' + op;\n    }\n    // add ! variants to comparatorOp\n    ops = tokens.comparatorOp.split('|');\n    for(i = 0; i < ops.length; i++){\n        op = ops[i];\n        if (op.indexOf('!') >= 0) {\n            continue;\n        } // skip ops that explicitly contain !\n        if (op === '=') {\n            continue;\n        } // skip = b/c != is explicitly defined\n        tokens.comparatorOp += '|\\\\!' + op;\n    }\n})();\n/**\n * Make a new query object\n *\n * @prop type {Type} The type enum (int) of the query\n * @prop checks List of checks to make against an ele to test for a match\n */ var newQuery = function newQuery() {\n    return {\n        checks: []\n    };\n};\n/**\n * A check type enum-like object.  Uses integer values for fast match() lookup.\n * The ordering does not matter as long as the ints are unique.\n */ var Type = {\n    /** E.g. node */ GROUP: 0,\n    /** A collection of elements */ COLLECTION: 1,\n    /** A filter(ele) function */ FILTER: 2,\n    /** E.g. [foo > 1] */ DATA_COMPARE: 3,\n    /** E.g. [foo] */ DATA_EXIST: 4,\n    /** E.g. [?foo] */ DATA_BOOL: 5,\n    /** E.g. [[degree > 2]] */ META_COMPARE: 6,\n    /** E.g. :selected */ STATE: 7,\n    /** E.g. #foo */ ID: 8,\n    /** E.g. .foo */ CLASS: 9,\n    /** E.g. #foo <-> #bar */ UNDIRECTED_EDGE: 10,\n    /** E.g. #foo -> #bar */ DIRECTED_EDGE: 11,\n    /** E.g. $#foo -> #bar */ NODE_SOURCE: 12,\n    /** E.g. #foo -> $#bar */ NODE_TARGET: 13,\n    /** E.g. $#foo <-> #bar */ NODE_NEIGHBOR: 14,\n    /** E.g. #foo > #bar */ CHILD: 15,\n    /** E.g. #foo #bar */ DESCENDANT: 16,\n    /** E.g. $#foo > #bar */ PARENT: 17,\n    /** E.g. $#foo #bar */ ANCESTOR: 18,\n    /** E.g. #foo > $bar > #baz */ COMPOUND_SPLIT: 19,\n    /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */ TRUE: 20\n};\nvar stateSelectors = [\n    {\n        selector: ':selected',\n        matches: function matches(ele) {\n            return ele.selected();\n        }\n    },\n    {\n        selector: ':unselected',\n        matches: function matches(ele) {\n            return !ele.selected();\n        }\n    },\n    {\n        selector: ':selectable',\n        matches: function matches(ele) {\n            return ele.selectable();\n        }\n    },\n    {\n        selector: ':unselectable',\n        matches: function matches(ele) {\n            return !ele.selectable();\n        }\n    },\n    {\n        selector: ':locked',\n        matches: function matches(ele) {\n            return ele.locked();\n        }\n    },\n    {\n        selector: ':unlocked',\n        matches: function matches(ele) {\n            return !ele.locked();\n        }\n    },\n    {\n        selector: ':visible',\n        matches: function matches(ele) {\n            return ele.visible();\n        }\n    },\n    {\n        selector: ':hidden',\n        matches: function matches(ele) {\n            return !ele.visible();\n        }\n    },\n    {\n        selector: ':transparent',\n        matches: function matches(ele) {\n            return ele.transparent();\n        }\n    },\n    {\n        selector: ':grabbed',\n        matches: function matches(ele) {\n            return ele.grabbed();\n        }\n    },\n    {\n        selector: ':free',\n        matches: function matches(ele) {\n            return !ele.grabbed();\n        }\n    },\n    {\n        selector: ':removed',\n        matches: function matches(ele) {\n            return ele.removed();\n        }\n    },\n    {\n        selector: ':inside',\n        matches: function matches(ele) {\n            return !ele.removed();\n        }\n    },\n    {\n        selector: ':grabbable',\n        matches: function matches(ele) {\n            return ele.grabbable();\n        }\n    },\n    {\n        selector: ':ungrabbable',\n        matches: function matches(ele) {\n            return !ele.grabbable();\n        }\n    },\n    {\n        selector: ':animated',\n        matches: function matches(ele) {\n            return ele.animated();\n        }\n    },\n    {\n        selector: ':unanimated',\n        matches: function matches(ele) {\n            return !ele.animated();\n        }\n    },\n    {\n        selector: ':parent',\n        matches: function matches(ele) {\n            return ele.isParent();\n        }\n    },\n    {\n        selector: ':childless',\n        matches: function matches(ele) {\n            return ele.isChildless();\n        }\n    },\n    {\n        selector: ':child',\n        matches: function matches(ele) {\n            return ele.isChild();\n        }\n    },\n    {\n        selector: ':orphan',\n        matches: function matches(ele) {\n            return ele.isOrphan();\n        }\n    },\n    {\n        selector: ':nonorphan',\n        matches: function matches(ele) {\n            return ele.isChild();\n        }\n    },\n    {\n        selector: ':compound',\n        matches: function matches(ele) {\n            if (ele.isNode()) {\n                return ele.isParent();\n            } else {\n                return ele.source().isParent() || ele.target().isParent();\n            }\n        }\n    },\n    {\n        selector: ':loop',\n        matches: function matches(ele) {\n            return ele.isLoop();\n        }\n    },\n    {\n        selector: ':simple',\n        matches: function matches(ele) {\n            return ele.isSimple();\n        }\n    },\n    {\n        selector: ':active',\n        matches: function matches(ele) {\n            return ele.active();\n        }\n    },\n    {\n        selector: ':inactive',\n        matches: function matches(ele) {\n            return !ele.active();\n        }\n    },\n    {\n        selector: ':backgrounding',\n        matches: function matches(ele) {\n            return ele.backgrounding();\n        }\n    },\n    {\n        selector: ':nonbackgrounding',\n        matches: function matches(ele) {\n            return !ele.backgrounding();\n        }\n    }\n].sort(function(a, b) {\n    // n.b. selectors that are starting substrings of others must have the longer ones first\n    return descending(a.selector, b.selector);\n});\nvar lookup = function() {\n    var selToFn = {};\n    var s;\n    for(var i = 0; i < stateSelectors.length; i++){\n        s = stateSelectors[i];\n        selToFn[s.selector] = s.matches;\n    }\n    return selToFn;\n}();\nvar stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n    return lookup[sel](ele);\n};\nvar stateSelectorRegex = '(' + stateSelectors.map(function(s) {\n    return s.selector;\n}).join('|') + ')';\n// when a token like a variable has escaped meta characters, we need to clean the backslashes out\n// so that values get compared properly in Selector.filter()\nvar cleanMetaChars = function cleanMetaChars(str) {\n    return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1) {\n        return $1;\n    });\n};\nvar replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n    selector[selector.length - 1] = replacementQuery;\n};\n// NOTE: add new expression syntax here to have it recognised by the parser;\n// - a query contains all adjacent (i.e. no separator in between) expressions;\n// - the current query is stored in selector[i]\n// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\nvar exprs = [\n    {\n        name: 'group',\n        // just used for identifying when debugging\n        query: true,\n        regex: '(' + tokens.group + ')',\n        populate: function populate(selector, query, _ref) {\n            var _ref2 = _slicedToArray(_ref, 1), group = _ref2[0];\n            query.checks.push({\n                type: Type.GROUP,\n                value: group === '*' ? group : group + 's'\n            });\n        }\n    },\n    {\n        name: 'state',\n        query: true,\n        regex: stateSelectorRegex,\n        populate: function populate(selector, query, _ref3) {\n            var _ref4 = _slicedToArray(_ref3, 1), state = _ref4[0];\n            query.checks.push({\n                type: Type.STATE,\n                value: state\n            });\n        }\n    },\n    {\n        name: 'id',\n        query: true,\n        regex: '\\\\#(' + tokens.id + ')',\n        populate: function populate(selector, query, _ref5) {\n            var _ref6 = _slicedToArray(_ref5, 1), id = _ref6[0];\n            query.checks.push({\n                type: Type.ID,\n                value: cleanMetaChars(id)\n            });\n        }\n    },\n    {\n        name: 'className',\n        query: true,\n        regex: '\\\\.(' + tokens.className + ')',\n        populate: function populate(selector, query, _ref7) {\n            var _ref8 = _slicedToArray(_ref7, 1), className = _ref8[0];\n            query.checks.push({\n                type: Type.CLASS,\n                value: cleanMetaChars(className)\n            });\n        }\n    },\n    {\n        name: 'dataExists',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n        populate: function populate(selector, query, _ref9) {\n            var _ref10 = _slicedToArray(_ref9, 1), variable = _ref10[0];\n            query.checks.push({\n                type: Type.DATA_EXIST,\n                field: cleanMetaChars(variable)\n            });\n        }\n    },\n    {\n        name: 'dataCompare',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n        populate: function populate(selector, query, _ref11) {\n            var _ref12 = _slicedToArray(_ref11, 3), variable = _ref12[0], comparatorOp = _ref12[1], value = _ref12[2];\n            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n            if (valueIsString) {\n                value = value.substring(1, value.length - 1);\n            } else {\n                value = parseFloat(value);\n            }\n            query.checks.push({\n                type: Type.DATA_COMPARE,\n                field: cleanMetaChars(variable),\n                operator: comparatorOp,\n                value: value\n            });\n        }\n    },\n    {\n        name: 'dataBool',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n        populate: function populate(selector, query, _ref13) {\n            var _ref14 = _slicedToArray(_ref13, 2), boolOp = _ref14[0], variable = _ref14[1];\n            query.checks.push({\n                type: Type.DATA_BOOL,\n                field: cleanMetaChars(variable),\n                operator: boolOp\n            });\n        }\n    },\n    {\n        name: 'metaCompare',\n        query: true,\n        regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n        populate: function populate(selector, query, _ref15) {\n            var _ref16 = _slicedToArray(_ref15, 3), meta = _ref16[0], comparatorOp = _ref16[1], number = _ref16[2];\n            query.checks.push({\n                type: Type.META_COMPARE,\n                field: cleanMetaChars(meta),\n                operator: comparatorOp,\n                value: parseFloat(number)\n            });\n        }\n    },\n    {\n        name: 'nextQuery',\n        separator: true,\n        regex: tokens.separator,\n        populate: function populate(selector, query) {\n            var currentSubject = selector.currentSubject;\n            var edgeCount = selector.edgeCount;\n            var compoundCount = selector.compoundCount;\n            var lastQ = selector[selector.length - 1];\n            if (currentSubject != null) {\n                lastQ.subject = currentSubject;\n                selector.currentSubject = null;\n            }\n            lastQ.edgeCount = edgeCount;\n            lastQ.compoundCount = compoundCount;\n            selector.edgeCount = 0;\n            selector.compoundCount = 0;\n            // go on to next query\n            var nextQuery = selector[selector.length++] = newQuery();\n            return nextQuery; // this is the new query to be filled by the following exprs\n        }\n    },\n    {\n        name: 'directedEdge',\n        separator: true,\n        regex: tokens.directedEdge,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // undirected edge\n                var edgeQuery = newQuery();\n                var source = query;\n                var target = newQuery();\n                edgeQuery.checks.push({\n                    type: Type.DIRECTED_EDGE,\n                    source: source,\n                    target: target\n                });\n                // the query in the selector should be the edge rather than the source\n                replaceLastQuery(selector, query, edgeQuery);\n                selector.edgeCount++;\n                // we're now populating the target query with expressions that follow\n                return target;\n            } else {\n                // source/target\n                var srcTgtQ = newQuery();\n                var _source = query;\n                var _target = newQuery();\n                srcTgtQ.checks.push({\n                    type: Type.NODE_SOURCE,\n                    source: _source,\n                    target: _target\n                });\n                // the query in the selector should be the neighbourhood rather than the node\n                replaceLastQuery(selector, query, srcTgtQ);\n                selector.edgeCount++;\n                return _target; // now populating the target with the following expressions\n            }\n        }\n    },\n    {\n        name: 'undirectedEdge',\n        separator: true,\n        regex: tokens.undirectedEdge,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // undirected edge\n                var edgeQuery = newQuery();\n                var source = query;\n                var target = newQuery();\n                edgeQuery.checks.push({\n                    type: Type.UNDIRECTED_EDGE,\n                    nodes: [\n                        source,\n                        target\n                    ]\n                });\n                // the query in the selector should be the edge rather than the source\n                replaceLastQuery(selector, query, edgeQuery);\n                selector.edgeCount++;\n                // we're now populating the target query with expressions that follow\n                return target;\n            } else {\n                // neighbourhood\n                var nhoodQ = newQuery();\n                var node = query;\n                var neighbor = newQuery();\n                nhoodQ.checks.push({\n                    type: Type.NODE_NEIGHBOR,\n                    node: node,\n                    neighbor: neighbor\n                });\n                // the query in the selector should be the neighbourhood rather than the node\n                replaceLastQuery(selector, query, nhoodQ);\n                return neighbor; // now populating the neighbor with following expressions\n            }\n        }\n    },\n    {\n        name: 'child',\n        separator: true,\n        regex: tokens.child,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // default: child query\n                var parentChildQuery = newQuery();\n                var child = newQuery();\n                var parent = selector[selector.length - 1];\n                parentChildQuery.checks.push({\n                    type: Type.CHILD,\n                    parent: parent,\n                    child: child\n                });\n                // the query in the selector should be the '>' itself\n                replaceLastQuery(selector, query, parentChildQuery);\n                selector.compoundCount++;\n                // we're now populating the child query with expressions that follow\n                return child;\n            } else if (selector.currentSubject === query) {\n                // compound split query\n                var compound = newQuery();\n                var left = selector[selector.length - 1];\n                var right = newQuery();\n                var subject = newQuery();\n                var _child = newQuery();\n                var _parent = newQuery();\n                // set up the root compound q\n                compound.checks.push({\n                    type: Type.COMPOUND_SPLIT,\n                    left: left,\n                    right: right,\n                    subject: subject\n                });\n                // populate the subject and replace the q at the old spot (within left) with TRUE\n                subject.checks = query.checks; // take the checks from the left\n                query.checks = [\n                    {\n                        type: Type.TRUE\n                    }\n                ]; // checks under left refs the subject implicitly\n                // set up the right q\n                _parent.checks.push({\n                    type: Type.TRUE\n                }); // parent implicitly refs the subject\n                right.checks.push({\n                    type: Type.PARENT,\n                    // type is swapped on right side queries\n                    parent: _parent,\n                    child: _child // empty for now\n                });\n                replaceLastQuery(selector, left, compound);\n                // update the ref since we moved things around for `query`\n                selector.currentSubject = subject;\n                selector.compoundCount++;\n                return _child; // now populating the right side's child\n            } else {\n                // parent query\n                // info for parent query\n                var _parent2 = newQuery();\n                var _child2 = newQuery();\n                var pcQChecks = [\n                    {\n                        type: Type.PARENT,\n                        parent: _parent2,\n                        child: _child2\n                    }\n                ];\n                // the parent-child query takes the place of the query previously being populated\n                _parent2.checks = query.checks; // the previous query contains the checks for the parent\n                query.checks = pcQChecks; // pc query takes over\n                selector.compoundCount++;\n                return _child2; // we're now populating the child\n            }\n        }\n    },\n    {\n        name: 'descendant',\n        separator: true,\n        regex: tokens.descendant,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // default: descendant query\n                var ancChQuery = newQuery();\n                var descendant = newQuery();\n                var ancestor = selector[selector.length - 1];\n                ancChQuery.checks.push({\n                    type: Type.DESCENDANT,\n                    ancestor: ancestor,\n                    descendant: descendant\n                });\n                // the query in the selector should be the '>' itself\n                replaceLastQuery(selector, query, ancChQuery);\n                selector.compoundCount++;\n                // we're now populating the descendant query with expressions that follow\n                return descendant;\n            } else if (selector.currentSubject === query) {\n                // compound split query\n                var compound = newQuery();\n                var left = selector[selector.length - 1];\n                var right = newQuery();\n                var subject = newQuery();\n                var _descendant = newQuery();\n                var _ancestor = newQuery();\n                // set up the root compound q\n                compound.checks.push({\n                    type: Type.COMPOUND_SPLIT,\n                    left: left,\n                    right: right,\n                    subject: subject\n                });\n                // populate the subject and replace the q at the old spot (within left) with TRUE\n                subject.checks = query.checks; // take the checks from the left\n                query.checks = [\n                    {\n                        type: Type.TRUE\n                    }\n                ]; // checks under left refs the subject implicitly\n                // set up the right q\n                _ancestor.checks.push({\n                    type: Type.TRUE\n                }); // ancestor implicitly refs the subject\n                right.checks.push({\n                    type: Type.ANCESTOR,\n                    // type is swapped on right side queries\n                    ancestor: _ancestor,\n                    descendant: _descendant // empty for now\n                });\n                replaceLastQuery(selector, left, compound);\n                // update the ref since we moved things around for `query`\n                selector.currentSubject = subject;\n                selector.compoundCount++;\n                return _descendant; // now populating the right side's descendant\n            } else {\n                // ancestor query\n                // info for parent query\n                var _ancestor2 = newQuery();\n                var _descendant2 = newQuery();\n                var adQChecks = [\n                    {\n                        type: Type.ANCESTOR,\n                        ancestor: _ancestor2,\n                        descendant: _descendant2\n                    }\n                ];\n                // the parent-child query takes the place of the query previously being populated\n                _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n                query.checks = adQChecks; // pc query takes over\n                selector.compoundCount++;\n                return _descendant2; // we're now populating the child\n            }\n        }\n    },\n    {\n        name: 'subject',\n        modifier: true,\n        regex: tokens.subject,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject != null && selector.currentSubject !== query) {\n                warn('Redefinition of subject in selector `' + selector.toString() + '`');\n                return false;\n            }\n            selector.currentSubject = query;\n            var topQ = selector[selector.length - 1];\n            var topChk = topQ.checks[0];\n            var topType = topChk == null ? null : topChk.type;\n            if (topType === Type.DIRECTED_EDGE) {\n                // directed edge with subject on the target\n                // change to target node check\n                topChk.type = Type.NODE_TARGET;\n            } else if (topType === Type.UNDIRECTED_EDGE) {\n                // undirected edge with subject on the second node\n                // change to neighbor check\n                topChk.type = Type.NODE_NEIGHBOR;\n                topChk.node = topChk.nodes[1]; // second node is subject\n                topChk.neighbor = topChk.nodes[0];\n                // clean up unused fields for new type\n                topChk.nodes = null;\n            }\n        }\n    }\n];\nexprs.forEach(function(e) {\n    return e.regexObj = new RegExp('^' + e.regex);\n});\n/**\n * Of all the expressions, find the first match in the remaining text.\n * @param {string} remaining The remaining text to parse\n * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n */ var consumeExpr = function consumeExpr(remaining) {\n    var expr;\n    var match;\n    var name;\n    for(var j = 0; j < exprs.length; j++){\n        var e = exprs[j];\n        var n = e.name;\n        var m1 = remaining.match(e.regexObj);\n        if (m1 != null) {\n            match = m1;\n            expr = e;\n            name = n;\n            var consumed = m1[0];\n            remaining = remaining.substring(consumed.length);\n            break; // we've consumed one expr, so we can return now\n        }\n    }\n    return {\n        expr: expr,\n        match: match,\n        name: name,\n        remaining: remaining\n    };\n};\n/**\n * Consume all the leading whitespace\n * @param {string} remaining The text to consume\n * @returns The text with the leading whitespace removed\n */ var consumeWhitespace = function consumeWhitespace(remaining) {\n    var match = remaining.match(/^\\s+/);\n    if (match) {\n        var consumed = match[0];\n        remaining = remaining.substring(consumed.length);\n    }\n    return remaining;\n};\n/**\n * Parse the string and store the parsed representation in the Selector.\n * @param {string} selector The selector string\n * @returns `true` if the selector was successfully parsed, `false` otherwise\n */ var parse = function parse(selector) {\n    var self1 = this;\n    var remaining = self1.inputText = selector;\n    var currentQuery = self1[0] = newQuery();\n    self1.length = 1;\n    remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n    for(;;){\n        var exprInfo = consumeExpr(remaining);\n        if (exprInfo.expr == null) {\n            warn('The selector `' + selector + '`is invalid');\n            return false;\n        } else {\n            var args = exprInfo.match.slice(1);\n            // let the token populate the selector object in currentQuery\n            var ret = exprInfo.expr.populate(self1, currentQuery, args);\n            if (ret === false) {\n                return false; // exit if population failed\n            } else if (ret != null) {\n                currentQuery = ret; // change the current query to be filled if the expr specifies\n            }\n        }\n        remaining = exprInfo.remaining;\n        // we're done when there's nothing left to parse\n        if (remaining.match(/^\\s*$/)) {\n            break;\n        }\n    }\n    var lastQ = self1[self1.length - 1];\n    if (self1.currentSubject != null) {\n        lastQ.subject = self1.currentSubject;\n    }\n    lastQ.edgeCount = self1.edgeCount;\n    lastQ.compoundCount = self1.compoundCount;\n    for(var i = 0; i < self1.length; i++){\n        var q = self1[i];\n        // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n        if (q.compoundCount > 0 && q.edgeCount > 0) {\n            warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');\n            return false;\n        }\n        if (q.edgeCount > 1) {\n            warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');\n            return false;\n        } else if (q.edgeCount === 1) {\n            warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');\n        }\n    }\n    return true; // success\n};\n/**\n * Get the selector represented as a string.  This value uses default formatting,\n * so things like spacing may differ from the input text passed to the constructor.\n * @returns {string} The selector string\n */ var toString = function toString() {\n    if (this.toStringCache != null) {\n        return this.toStringCache;\n    }\n    var clean = function clean(obj) {\n        if (obj == null) {\n            return '';\n        } else {\n            return obj;\n        }\n    };\n    var cleanVal = function cleanVal(val) {\n        if (string(val)) {\n            return '\"' + val + '\"';\n        } else {\n            return clean(val);\n        }\n    };\n    var space = function space(val) {\n        return ' ' + val + ' ';\n    };\n    var checkToString = function checkToString(check, subject) {\n        var type = check.type, value = check.value;\n        switch(type){\n            case Type.GROUP:\n                {\n                    var group = clean(value);\n                    return group.substring(0, group.length - 1);\n                }\n            case Type.DATA_COMPARE:\n                {\n                    var field = check.field, operator = check.operator;\n                    return '[' + field + space(clean(operator)) + cleanVal(value) + ']';\n                }\n            case Type.DATA_BOOL:\n                {\n                    var _operator = check.operator, _field = check.field;\n                    return '[' + clean(_operator) + _field + ']';\n                }\n            case Type.DATA_EXIST:\n                {\n                    var _field2 = check.field;\n                    return '[' + _field2 + ']';\n                }\n            case Type.META_COMPARE:\n                {\n                    var _operator2 = check.operator, _field3 = check.field;\n                    return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';\n                }\n            case Type.STATE:\n                {\n                    return value;\n                }\n            case Type.ID:\n                {\n                    return '#' + value;\n                }\n            case Type.CLASS:\n                {\n                    return '.' + value;\n                }\n            case Type.PARENT:\n            case Type.CHILD:\n                {\n                    return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);\n                }\n            case Type.ANCESTOR:\n            case Type.DESCENDANT:\n                {\n                    return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);\n                }\n            case Type.COMPOUND_SPLIT:\n                {\n                    var lhs = queryToString(check.left, subject);\n                    var sub = queryToString(check.subject, subject);\n                    var rhs = queryToString(check.right, subject);\n                    return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;\n                }\n            case Type.TRUE:\n                {\n                    return '';\n                }\n        }\n    };\n    var queryToString = function queryToString(query, subject) {\n        return query.checks.reduce(function(str, chk, i) {\n            return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);\n        }, '');\n    };\n    var str = '';\n    for(var i = 0; i < this.length; i++){\n        var query = this[i];\n        str += queryToString(query, query.subject);\n        if (this.length > 1 && i < this.length - 1) {\n            str += ', ';\n        }\n    }\n    this.toStringCache = str;\n    return str;\n};\nvar parse$1 = {\n    parse: parse,\n    toString: toString\n};\nvar valCmp = function valCmp(fieldVal, operator, value) {\n    var matches;\n    var isFieldStr = string(fieldVal);\n    var isFieldNum = number$1(fieldVal);\n    var isValStr = string(value);\n    var fieldStr, valStr;\n    var caseInsensitive = false;\n    var notExpr = false;\n    var isIneqCmp = false;\n    if (operator.indexOf('!') >= 0) {\n        operator = operator.replace('!', '');\n        notExpr = true;\n    }\n    if (operator.indexOf('@') >= 0) {\n        operator = operator.replace('@', '');\n        caseInsensitive = true;\n    }\n    if (isFieldStr || isValStr || caseInsensitive) {\n        fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;\n        valStr = '' + value;\n    }\n    // if we're doing a case insensitive comparison, then we're using a STRING comparison\n    // even if we're comparing numbers\n    if (caseInsensitive) {\n        fieldVal = fieldStr = fieldStr.toLowerCase();\n        value = valStr = valStr.toLowerCase();\n    }\n    switch(operator){\n        case '*=':\n            matches = fieldStr.indexOf(valStr) >= 0;\n            break;\n        case '$=':\n            matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n            break;\n        case '^=':\n            matches = fieldStr.indexOf(valStr) === 0;\n            break;\n        case '=':\n            matches = fieldVal === value;\n            break;\n        case '>':\n            isIneqCmp = true;\n            matches = fieldVal > value;\n            break;\n        case '>=':\n            isIneqCmp = true;\n            matches = fieldVal >= value;\n            break;\n        case '<':\n            isIneqCmp = true;\n            matches = fieldVal < value;\n            break;\n        case '<=':\n            isIneqCmp = true;\n            matches = fieldVal <= value;\n            break;\n        default:\n            matches = false;\n            break;\n    }\n    // apply the not op, but null vals for inequalities should always stay non-matching\n    if (notExpr && (fieldVal != null || !isIneqCmp)) {\n        matches = !matches;\n    }\n    return matches;\n};\nvar boolCmp = function boolCmp(fieldVal, operator) {\n    switch(operator){\n        case '?':\n            return fieldVal ? true : false;\n        case '!':\n            return fieldVal ? false : true;\n        case '^':\n            return fieldVal === undefined;\n    }\n};\nvar existCmp = function existCmp(fieldVal) {\n    return fieldVal !== undefined;\n};\nvar data$1 = function data(ele, field) {\n    return ele.data(field);\n};\nvar meta = function meta(ele, field) {\n    return ele[field]();\n};\n/** A lookup of `match(check, ele)` functions by `Type` int */ var match = [];\n/**\n * Returns whether the query matches for the element\n * @param query The `{ type, value, ... }` query object\n * @param ele The element to compare against\n*/ var matches$1 = function matches(query, ele) {\n    return query.checks.every(function(chk) {\n        return match[chk.type](chk, ele);\n    });\n};\nmatch[Type.GROUP] = function(check, ele) {\n    var group = check.value;\n    return group === '*' || group === ele.group();\n};\nmatch[Type.STATE] = function(check, ele) {\n    var stateSelector = check.value;\n    return stateSelectorMatches(stateSelector, ele);\n};\nmatch[Type.ID] = function(check, ele) {\n    var id = check.value;\n    return ele.id() === id;\n};\nmatch[Type.CLASS] = function(check, ele) {\n    var cls = check.value;\n    return ele.hasClass(cls);\n};\nmatch[Type.META_COMPARE] = function(check, ele) {\n    var field = check.field, operator = check.operator, value = check.value;\n    return valCmp(meta(ele, field), operator, value);\n};\nmatch[Type.DATA_COMPARE] = function(check, ele) {\n    var field = check.field, operator = check.operator, value = check.value;\n    return valCmp(data$1(ele, field), operator, value);\n};\nmatch[Type.DATA_BOOL] = function(check, ele) {\n    var field = check.field, operator = check.operator;\n    return boolCmp(data$1(ele, field), operator);\n};\nmatch[Type.DATA_EXIST] = function(check, ele) {\n    var field = check.field;\n    check.operator;\n    return existCmp(data$1(ele, field));\n};\nmatch[Type.UNDIRECTED_EDGE] = function(check, ele) {\n    var qA = check.nodes[0];\n    var qB = check.nodes[1];\n    var src = ele.source();\n    var tgt = ele.target();\n    return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n};\nmatch[Type.NODE_NEIGHBOR] = function(check, ele) {\n    return matches$1(check.node, ele) && ele.neighborhood().some(function(n) {\n        return n.isNode() && matches$1(check.neighbor, n);\n    });\n};\nmatch[Type.DIRECTED_EDGE] = function(check, ele) {\n    return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n};\nmatch[Type.NODE_SOURCE] = function(check, ele) {\n    return matches$1(check.source, ele) && ele.outgoers().some(function(n) {\n        return n.isNode() && matches$1(check.target, n);\n    });\n};\nmatch[Type.NODE_TARGET] = function(check, ele) {\n    return matches$1(check.target, ele) && ele.incomers().some(function(n) {\n        return n.isNode() && matches$1(check.source, n);\n    });\n};\nmatch[Type.CHILD] = function(check, ele) {\n    return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n};\nmatch[Type.PARENT] = function(check, ele) {\n    return matches$1(check.parent, ele) && ele.children().some(function(c) {\n        return matches$1(check.child, c);\n    });\n};\nmatch[Type.DESCENDANT] = function(check, ele) {\n    return matches$1(check.descendant, ele) && ele.ancestors().some(function(a) {\n        return matches$1(check.ancestor, a);\n    });\n};\nmatch[Type.ANCESTOR] = function(check, ele) {\n    return matches$1(check.ancestor, ele) && ele.descendants().some(function(d) {\n        return matches$1(check.descendant, d);\n    });\n};\nmatch[Type.COMPOUND_SPLIT] = function(check, ele) {\n    return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n};\nmatch[Type.TRUE] = function() {\n    return true;\n};\nmatch[Type.COLLECTION] = function(check, ele) {\n    var collection = check.value;\n    return collection.has(ele);\n};\nmatch[Type.FILTER] = function(check, ele) {\n    var filter = check.value;\n    return filter(ele);\n};\n// filter an existing collection\nvar filter = function filter(collection) {\n    var self1 = this;\n    // for 1 id #foo queries, just get the element\n    if (self1.length === 1 && self1[0].checks.length === 1 && self1[0].checks[0].type === Type.ID) {\n        return collection.getElementById(self1[0].checks[0].value).collection();\n    }\n    var selectorFunction = function selectorFunction(element) {\n        for(var j = 0; j < self1.length; j++){\n            var query = self1[j];\n            if (matches$1(query, element)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (self1.text() == null) {\n        selectorFunction = function selectorFunction() {\n            return true;\n        };\n    }\n    return collection.filter(selectorFunction);\n}; // filter\n// does selector match a single element?\nvar matches = function matches(ele) {\n    var self1 = this;\n    for(var j = 0; j < self1.length; j++){\n        var query = self1[j];\n        if (matches$1(query, ele)) {\n            return true;\n        }\n    }\n    return false;\n}; // matches\nvar matching = {\n    matches: matches,\n    filter: filter\n};\nvar Selector = function Selector(selector) {\n    this.inputText = selector;\n    this.currentSubject = null;\n    this.compoundCount = 0;\n    this.edgeCount = 0;\n    this.length = 0;\n    if (selector == null || string(selector) && selector.match(/^\\s*$/)) ;\n    else if (elementOrCollection(selector)) {\n        this.addQuery({\n            checks: [\n                {\n                    type: Type.COLLECTION,\n                    value: selector.collection()\n                }\n            ]\n        });\n    } else if (fn$6(selector)) {\n        this.addQuery({\n            checks: [\n                {\n                    type: Type.FILTER,\n                    value: selector\n                }\n            ]\n        });\n    } else if (string(selector)) {\n        if (!this.parse(selector)) {\n            this.invalid = true;\n        }\n    } else {\n        error('A selector must be created from a string; found ');\n    }\n};\nvar selfn = Selector.prototype;\n[\n    parse$1,\n    matching\n].forEach(function(p) {\n    return extend(selfn, p);\n});\nselfn.text = function() {\n    return this.inputText;\n};\nselfn.size = function() {\n    return this.length;\n};\nselfn.eq = function(i) {\n    return this[i];\n};\nselfn.sameText = function(otherSel) {\n    return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n};\nselfn.addQuery = function(q) {\n    this[this.length++] = q;\n};\nselfn.selector = selfn.toString;\nvar elesfn$g = {\n    allAre: function allAre(selector) {\n        var selObj = new Selector(selector);\n        return this.every(function(ele) {\n            return selObj.matches(ele);\n        });\n    },\n    is: function is(selector) {\n        var selObj = new Selector(selector);\n        return this.some(function(ele) {\n            return selObj.matches(ele);\n        });\n    },\n    some: function some(fn, thisArg) {\n        for(var i = 0; i < this.length; i++){\n            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                this[i],\n                i,\n                this\n            ]);\n            if (ret) {\n                return true;\n            }\n        }\n        return false;\n    },\n    every: function every(fn, thisArg) {\n        for(var i = 0; i < this.length; i++){\n            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                this[i],\n                i,\n                this\n            ]);\n            if (!ret) {\n                return false;\n            }\n        }\n        return true;\n    },\n    same: function same(collection) {\n        // cheap collection ref check\n        if (this === collection) {\n            return true;\n        }\n        collection = this.cy().collection(collection);\n        var thisLength = this.length;\n        var collectionLength = collection.length;\n        // cheap length check\n        if (thisLength !== collectionLength) {\n            return false;\n        }\n        // cheap element ref check\n        if (thisLength === 1) {\n            return this[0] === collection[0];\n        }\n        return this.every(function(ele) {\n            return collection.hasElementWithId(ele.id());\n        });\n    },\n    anySame: function anySame(collection) {\n        collection = this.cy().collection(collection);\n        return this.some(function(ele) {\n            return collection.hasElementWithId(ele.id());\n        });\n    },\n    allAreNeighbors: function allAreNeighbors(collection) {\n        collection = this.cy().collection(collection);\n        var nhood = this.neighborhood();\n        return collection.every(function(ele) {\n            return nhood.hasElementWithId(ele.id());\n        });\n    },\n    contains: function contains(collection) {\n        collection = this.cy().collection(collection);\n        var self1 = this;\n        return collection.every(function(ele) {\n            return self1.hasElementWithId(ele.id());\n        });\n    }\n};\nelesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\nelesfn$g.has = elesfn$g.contains;\nelesfn$g.equal = elesfn$g.equals = elesfn$g.same;\nvar cache = function cache(fn, name) {\n    return function traversalCache(arg1, arg2, arg3, arg4) {\n        var selectorOrEles = arg1;\n        var eles = this;\n        var key;\n        if (selectorOrEles == null) {\n            key = '';\n        } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n            key = selectorOrEles.id();\n        }\n        if (eles.length === 1 && key) {\n            var _p = eles[0]._private;\n            var tch = _p.traversalCache = _p.traversalCache || {};\n            var ch = tch[name] = tch[name] || [];\n            var hash = hashString(key);\n            var cacheHit = ch[hash];\n            if (cacheHit) {\n                return cacheHit;\n            } else {\n                return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n            }\n        } else {\n            return fn.call(eles, arg1, arg2, arg3, arg4);\n        }\n    };\n};\nvar elesfn$f = {\n    parent: function parent(selector) {\n        var parents = [];\n        // optimisation for single ele call\n        if (this.length === 1) {\n            var parent = this[0]._private.parent;\n            if (parent) {\n                return parent;\n            }\n        }\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var _parent = ele._private.parent;\n            if (_parent) {\n                parents.push(_parent);\n            }\n        }\n        return this.spawn(parents, true).filter(selector);\n    },\n    parents: function parents(selector) {\n        var parents = [];\n        var eles = this.parent();\n        while(eles.nonempty()){\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                parents.push(ele);\n            }\n            eles = eles.parent();\n        }\n        return this.spawn(parents, true).filter(selector);\n    },\n    commonAncestors: function commonAncestors(selector) {\n        var ancestors;\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var parents = ele.parents();\n            ancestors = ancestors || parents;\n            ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n        }\n        return ancestors.filter(selector);\n    },\n    orphans: function orphans(selector) {\n        return this.stdFilter(function(ele) {\n            return ele.isOrphan();\n        }).filter(selector);\n    },\n    nonorphans: function nonorphans(selector) {\n        return this.stdFilter(function(ele) {\n            return ele.isChild();\n        }).filter(selector);\n    },\n    children: cache(function(selector) {\n        var children = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var eleChildren = ele._private.children;\n            for(var j = 0; j < eleChildren.length; j++){\n                children.push(eleChildren[j]);\n            }\n        }\n        return this.spawn(children, true).filter(selector);\n    }, 'children'),\n    siblings: function siblings(selector) {\n        return this.parent().children().not(this).filter(selector);\n    },\n    isParent: function isParent() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.children.length !== 0;\n        }\n    },\n    isChildless: function isChildless() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.children.length === 0;\n        }\n    },\n    isChild: function isChild() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.parent != null;\n        }\n    },\n    isOrphan: function isOrphan() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.parent == null;\n        }\n    },\n    descendants: function descendants(selector) {\n        var elements = [];\n        function add(eles) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                elements.push(ele);\n                if (ele.children().nonempty()) {\n                    add(ele.children());\n                }\n            }\n        }\n        add(this.children());\n        return this.spawn(elements, true).filter(selector);\n    }\n};\nfunction forEachCompound(eles, fn, includeSelf, recursiveStep) {\n    var q = [];\n    var did = new Set$1();\n    var cy = eles.cy();\n    var hasCompounds = cy.hasCompoundNodes();\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (includeSelf) {\n            q.push(ele);\n        } else if (hasCompounds) {\n            recursiveStep(q, did, ele);\n        }\n    }\n    while(q.length > 0){\n        var _ele = q.shift();\n        fn(_ele);\n        did.add(_ele.id());\n        if (hasCompounds) {\n            recursiveStep(q, did, _ele);\n        }\n    }\n    return eles;\n}\nfunction addChildren(q, did, ele) {\n    if (ele.isParent()) {\n        var children = ele._private.children;\n        for(var i = 0; i < children.length; i++){\n            var child = children[i];\n            if (!did.has(child.id())) {\n                q.push(child);\n            }\n        }\n    }\n}\n// very efficient version of eles.add( eles.descendants() ).forEach()\n// for internal use\nelesfn$f.forEachDown = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addChildren);\n};\nfunction addParent(q, did, ele) {\n    if (ele.isChild()) {\n        var parent = ele._private.parent;\n        if (!did.has(parent.id())) {\n            q.push(parent);\n        }\n    }\n}\nelesfn$f.forEachUp = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParent);\n};\nfunction addParentAndChildren(q, did, ele) {\n    addParent(q, did, ele);\n    addChildren(q, did, ele);\n}\nelesfn$f.forEachUpAndDown = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n};\n// aliases\nelesfn$f.ancestors = elesfn$f.parents;\nvar fn$5, elesfn$e;\nfn$5 = elesfn$e = {\n    data: define.data({\n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'data',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        immutableKeys: {\n            'id': true,\n            'source': true,\n            'target': true,\n            'parent': true\n        },\n        updateStyle: true\n    }),\n    removeData: define.removeData({\n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        immutableKeys: {\n            'id': true,\n            'source': true,\n            'target': true,\n            'parent': true\n        },\n        updateStyle: true\n    }),\n    scratch: define.data({\n        field: 'scratch',\n        bindingEvent: 'scratch',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'scratch',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeScratch: define.removeData({\n        field: 'scratch',\n        event: 'scratch',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        updateStyle: true\n    }),\n    rscratch: define.data({\n        field: 'rscratch',\n        allowBinding: false,\n        allowSetting: true,\n        settingTriggersEvent: false,\n        allowGetting: true\n    }),\n    removeRscratch: define.removeData({\n        field: 'rscratch',\n        triggerEvent: false\n    }),\n    id: function id() {\n        var ele = this[0];\n        if (ele) {\n            return ele._private.data.id;\n        }\n    }\n};\n// aliases\nfn$5.attr = fn$5.data;\nfn$5.removeAttr = fn$5.removeData;\nvar data = elesfn$e;\nvar elesfn$d = {};\nfunction defineDegreeFunction(callback) {\n    return function(includeLoops) {\n        var self1 = this;\n        if (includeLoops === undefined) {\n            includeLoops = true;\n        }\n        if (self1.length === 0) {\n            return;\n        }\n        if (self1.isNode() && !self1.removed()) {\n            var degree = 0;\n            var node = self1[0];\n            var connectedEdges = node._private.edges;\n            for(var i = 0; i < connectedEdges.length; i++){\n                var edge = connectedEdges[i];\n                if (!includeLoops && edge.isLoop()) {\n                    continue;\n                }\n                degree += callback(node, edge);\n            }\n            return degree;\n        } else {\n            return;\n        }\n    };\n}\nextend(elesfn$d, {\n    degree: defineDegreeFunction(function(node, edge) {\n        if (edge.source().same(edge.target())) {\n            return 2;\n        } else {\n            return 1;\n        }\n    }),\n    indegree: defineDegreeFunction(function(node, edge) {\n        if (edge.target().same(node)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }),\n    outdegree: defineDegreeFunction(function(node, edge) {\n        if (edge.source().same(node)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    })\n});\nfunction defineDegreeBoundsFunction(degreeFn, callback) {\n    return function(includeLoops) {\n        var ret;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            var ele = nodes[i];\n            var degree = ele[degreeFn](includeLoops);\n            if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n                ret = degree;\n            }\n        }\n        return ret;\n    };\n}\nextend(elesfn$d, {\n    minDegree: defineDegreeBoundsFunction('degree', function(degree, min) {\n        return degree < min;\n    }),\n    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max) {\n        return degree > max;\n    }),\n    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min) {\n        return degree < min;\n    }),\n    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max) {\n        return degree > max;\n    }),\n    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min) {\n        return degree < min;\n    }),\n    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max) {\n        return degree > max;\n    })\n});\nextend(elesfn$d, {\n    totalDegree: function totalDegree(includeLoops) {\n        var total = 0;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            total += nodes[i].degree(includeLoops);\n        }\n        return total;\n    }\n});\nvar fn$4, elesfn$c;\nvar beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (!ele.locked()) {\n            var oldPos = ele._private.position;\n            var delta = {\n                x: newPos.x != null ? newPos.x - oldPos.x : 0,\n                y: newPos.y != null ? newPos.y - oldPos.y : 0\n            };\n            if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n                ele.children().shift(delta, silent);\n            }\n            ele.dirtyBoundingBoxCache();\n        }\n    }\n};\nvar positionDef = {\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: true,\n    triggerFnName: 'emitAndNotify',\n    allowGetting: true,\n    validKeys: [\n        'x',\n        'y'\n    ],\n    beforeGet: function beforeGet(ele) {\n        ele.updateCompoundBounds();\n    },\n    beforeSet: function beforeSet(eles, newPos) {\n        beforePositionSet(eles, newPos, false);\n    },\n    onSet: function onSet(eles) {\n        eles.dirtyCompoundBoundsCache();\n    },\n    canSet: function canSet(ele) {\n        return !ele.locked();\n    }\n};\nfn$4 = elesfn$c = {\n    position: define.data(positionDef),\n    // position but no notification to renderer\n    silentPosition: define.data(extend({}, positionDef, {\n        allowBinding: false,\n        allowSetting: true,\n        settingTriggersEvent: false,\n        allowGetting: false,\n        beforeSet: function beforeSet(eles, newPos) {\n            beforePositionSet(eles, newPos, true);\n        },\n        onSet: function onSet(eles) {\n            eles.dirtyCompoundBoundsCache();\n        }\n    })),\n    positions: function positions(pos, silent) {\n        if (plainObject(pos)) {\n            if (silent) {\n                this.silentPosition(pos);\n            } else {\n                this.position(pos);\n            }\n        } else if (fn$6(pos)) {\n            var _fn = pos;\n            var cy = this.cy();\n            cy.startBatch();\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var _pos = undefined;\n                if (_pos = _fn(ele, i)) {\n                    if (silent) {\n                        ele.silentPosition(_pos);\n                    } else {\n                        ele.position(_pos);\n                    }\n                }\n            }\n            cy.endBatch();\n        }\n        return this; // chaining\n    },\n    silentPositions: function silentPositions(pos) {\n        return this.positions(pos, true);\n    },\n    shift: function shift(dim, val, silent) {\n        var delta;\n        if (plainObject(dim)) {\n            delta = {\n                x: number$1(dim.x) ? dim.x : 0,\n                y: number$1(dim.y) ? dim.y : 0\n            };\n            silent = val;\n        } else if (string(dim) && number$1(val)) {\n            delta = {\n                x: 0,\n                y: 0\n            };\n            delta[dim] = val;\n        }\n        if (delta != null) {\n            var cy = this.cy();\n            cy.startBatch();\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                // exclude any node that is a descendant of the calling collection\n                if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n                    continue;\n                }\n                var pos = ele.position();\n                var newPos = {\n                    x: pos.x + delta.x,\n                    y: pos.y + delta.y\n                };\n                if (silent) {\n                    ele.silentPosition(newPos);\n                } else {\n                    ele.position(newPos);\n                }\n            }\n            cy.endBatch();\n        }\n        return this;\n    },\n    silentShift: function silentShift(dim, val) {\n        if (plainObject(dim)) {\n            this.shift(dim, true);\n        } else if (string(dim) && number$1(val)) {\n            this.shift(dim, val, true);\n        }\n        return this;\n    },\n    // get/set the rendered (i.e. on screen) positon of the element\n    renderedPosition: function renderedPosition(dim, val) {\n        var ele = this[0];\n        var cy = this.cy();\n        var zoom = cy.zoom();\n        var pan = cy.pan();\n        var rpos = plainObject(dim) ? dim : undefined;\n        var setting = rpos !== undefined || val !== undefined && string(dim);\n        if (ele && ele.isNode()) {\n            // must have an element and must be a node to return position\n            if (setting) {\n                for(var i = 0; i < this.length; i++){\n                    var _ele = this[i];\n                    if (val !== undefined) {\n                        // set one dimension\n                        _ele.position(dim, (val - pan[dim]) / zoom);\n                    } else if (rpos !== undefined) {\n                        // set whole position\n                        _ele.position(renderedToModelPosition(rpos, zoom, pan));\n                    }\n                }\n            } else {\n                // getting\n                var pos = ele.position();\n                rpos = modelToRenderedPosition$1(pos, zoom, pan);\n                if (dim === undefined) {\n                    // then return the whole rendered position\n                    return rpos;\n                } else {\n                    // then return the specified dimension\n                    return rpos[dim];\n                }\n            }\n        } else if (!setting) {\n            return undefined; // for empty collection case\n        }\n        return this; // chaining\n    },\n    // get/set the position relative to the parent\n    relativePosition: function relativePosition(dim, val) {\n        var ele = this[0];\n        var cy = this.cy();\n        var ppos = plainObject(dim) ? dim : undefined;\n        var setting = ppos !== undefined || val !== undefined && string(dim);\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        if (ele && ele.isNode()) {\n            // must have an element and must be a node to return position\n            if (setting) {\n                for(var i = 0; i < this.length; i++){\n                    var _ele2 = this[i];\n                    var parent = hasCompoundNodes ? _ele2.parent() : null;\n                    var hasParent = parent && parent.length > 0;\n                    var relativeToParent = hasParent;\n                    if (hasParent) {\n                        parent = parent[0];\n                    }\n                    var origin = relativeToParent ? parent.position() : {\n                        x: 0,\n                        y: 0\n                    };\n                    if (val !== undefined) {\n                        // set one dimension\n                        _ele2.position(dim, val + origin[dim]);\n                    } else if (ppos !== undefined) {\n                        // set whole position\n                        _ele2.position({\n                            x: ppos.x + origin.x,\n                            y: ppos.y + origin.y\n                        });\n                    }\n                }\n            } else {\n                // getting\n                var pos = ele.position();\n                var _parent = hasCompoundNodes ? ele.parent() : null;\n                var _hasParent = _parent && _parent.length > 0;\n                var _relativeToParent = _hasParent;\n                if (_hasParent) {\n                    _parent = _parent[0];\n                }\n                var _origin = _relativeToParent ? _parent.position() : {\n                    x: 0,\n                    y: 0\n                };\n                ppos = {\n                    x: pos.x - _origin.x,\n                    y: pos.y - _origin.y\n                };\n                if (dim === undefined) {\n                    // then return the whole rendered position\n                    return ppos;\n                } else {\n                    // then return the specified dimension\n                    return ppos[dim];\n                }\n            }\n        } else if (!setting) {\n            return undefined; // for empty collection case\n        }\n        return this; // chaining\n    }\n};\n// aliases\nfn$4.modelPosition = fn$4.point = fn$4.position;\nfn$4.modelPositions = fn$4.points = fn$4.positions;\nfn$4.renderedPoint = fn$4.renderedPosition;\nfn$4.relativePoint = fn$4.relativePosition;\nvar position = elesfn$c;\nvar fn$3, elesfn$b;\nfn$3 = elesfn$b = {};\nelesfn$b.renderedBoundingBox = function(options) {\n    var bb = this.boundingBox(options);\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var x1 = bb.x1 * zoom + pan.x;\n    var x2 = bb.x2 * zoom + pan.x;\n    var y1 = bb.y1 * zoom + pan.y;\n    var y2 = bb.y2 * zoom + pan.y;\n    return {\n        x1: x1,\n        x2: x2,\n        y1: y1,\n        y2: y2,\n        w: x2 - x1,\n        h: y2 - y1\n    };\n};\nelesfn$b.dirtyCompoundBoundsCache = function() {\n    var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n        return this;\n    }\n    this.forEachUp(function(ele) {\n        if (ele.isParent()) {\n            var _p = ele._private;\n            _p.compoundBoundsClean = false;\n            _p.bbCache = null;\n            if (!silent) {\n                ele.emitAndNotify('bounds');\n            }\n        }\n    });\n    return this;\n};\nelesfn$b.updateCompoundBounds = function() {\n    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n    // not possible to do on non-compound graphs or with the style disabled\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n        return this;\n    }\n    // save cycles when batching -- but bounds will be stale (or not exist yet)\n    if (!force && cy.batching()) {\n        return this;\n    }\n    function update(parent) {\n        if (!parent.isParent()) {\n            return;\n        }\n        var _p = parent._private;\n        var children = parent.children();\n        var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n        var min = {\n            width: {\n                val: parent.pstyle('min-width').pfValue,\n                left: parent.pstyle('min-width-bias-left'),\n                right: parent.pstyle('min-width-bias-right')\n            },\n            height: {\n                val: parent.pstyle('min-height').pfValue,\n                top: parent.pstyle('min-height-bias-top'),\n                bottom: parent.pstyle('min-height-bias-bottom')\n            }\n        };\n        var bb = children.boundingBox({\n            includeLabels: includeLabels,\n            includeOverlays: false,\n            // updating the compound bounds happens outside of the regular\n            // cache cycle (i.e. before fired events)\n            useCache: false\n        });\n        var pos = _p.position;\n        // if children take up zero area then keep position and fall back on stylesheet w/h\n        if (bb.w === 0 || bb.h === 0) {\n            bb = {\n                w: parent.pstyle('width').pfValue,\n                h: parent.pstyle('height').pfValue\n            };\n            bb.x1 = pos.x - bb.w / 2;\n            bb.x2 = pos.x + bb.w / 2;\n            bb.y1 = pos.y - bb.h / 2;\n            bb.y2 = pos.y + bb.h / 2;\n        }\n        function computeBiasValues(propDiff, propBias, propBiasComplement) {\n            var biasDiff = 0;\n            var biasComplementDiff = 0;\n            var biasTotal = propBias + propBiasComplement;\n            if (propDiff > 0 && biasTotal > 0) {\n                biasDiff = propBias / biasTotal * propDiff;\n                biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n            }\n            return {\n                biasDiff: biasDiff,\n                biasComplementDiff: biasComplementDiff\n            };\n        }\n        function computePaddingValues(width, height, paddingObject, relativeTo) {\n            // Assuming percentage is number from 0 to 1\n            if (paddingObject.units === '%') {\n                switch(relativeTo){\n                    case 'width':\n                        return width > 0 ? paddingObject.pfValue * width : 0;\n                    case 'height':\n                        return height > 0 ? paddingObject.pfValue * height : 0;\n                    case 'average':\n                        return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n                    case 'min':\n                        return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n                    case 'max':\n                        return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n                    default:\n                        return 0;\n                }\n            } else if (paddingObject.units === 'px') {\n                return paddingObject.pfValue;\n            } else {\n                return 0;\n            }\n        }\n        var leftVal = min.width.left.value;\n        if (min.width.left.units === 'px' && min.width.val > 0) {\n            leftVal = leftVal * 100 / min.width.val;\n        }\n        var rightVal = min.width.right.value;\n        if (min.width.right.units === 'px' && min.width.val > 0) {\n            rightVal = rightVal * 100 / min.width.val;\n        }\n        var topVal = min.height.top.value;\n        if (min.height.top.units === 'px' && min.height.val > 0) {\n            topVal = topVal * 100 / min.height.val;\n        }\n        var bottomVal = min.height.bottom.value;\n        if (min.height.bottom.units === 'px' && min.height.val > 0) {\n            bottomVal = bottomVal * 100 / min.height.val;\n        }\n        var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n        var diffLeft = widthBiasDiffs.biasDiff;\n        var diffRight = widthBiasDiffs.biasComplementDiff;\n        var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n        var diffTop = heightBiasDiffs.biasDiff;\n        var diffBottom = heightBiasDiffs.biasComplementDiff;\n        _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n        _p.autoWidth = Math.max(bb.w, min.width.val);\n        pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n        _p.autoHeight = Math.max(bb.h, min.height.val);\n        pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n    }\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var _p = ele._private;\n        if (!_p.compoundBoundsClean || force) {\n            update(ele);\n            if (!cy.batching()) {\n                _p.compoundBoundsClean = true;\n            }\n        }\n    }\n    return this;\n};\nvar noninf = function noninf(x) {\n    if (x === Infinity || x === -Infinity) {\n        return 0;\n    }\n    return x;\n};\nvar updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n    // don't update with zero area boxes\n    if (x2 - x1 === 0 || y2 - y1 === 0) {\n        return;\n    }\n    // don't update with null dim\n    if (x1 == null || y1 == null || x2 == null || y2 == null) {\n        return;\n    }\n    b.x1 = x1 < b.x1 ? x1 : b.x1;\n    b.x2 = x2 > b.x2 ? x2 : b.x2;\n    b.y1 = y1 < b.y1 ? y1 : b.y1;\n    b.y2 = y2 > b.y2 ? y2 : b.y2;\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n};\nvar updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n    if (b2 == null) {\n        return b;\n    }\n    return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n};\nvar prefixedProperty = function prefixedProperty(obj, field, prefix) {\n    return getPrefixedProperty(obj, field, prefix);\n};\nvar updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var halfArW = rstyle.arrowWidth / 2;\n    var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n    var x;\n    var y;\n    if (arrowType !== 'none') {\n        if (prefix === 'source') {\n            x = rstyle.srcX;\n            y = rstyle.srcY;\n        } else if (prefix === 'target') {\n            x = rstyle.tgtX;\n            y = rstyle.tgtY;\n        } else {\n            x = rstyle.midX;\n            y = rstyle.midY;\n        }\n        // always store the individual arrow bounds\n        var bbs = _p.arrowBounds = _p.arrowBounds || {};\n        var bb = bbs[prefix] = bbs[prefix] || {};\n        bb.x1 = x - halfArW;\n        bb.y1 = y - halfArW;\n        bb.x2 = x + halfArW;\n        bb.y2 = y + halfArW;\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n        expandBoundingBox(bb, 1);\n        updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n    }\n};\nvar updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var prefixDash;\n    if (prefix) {\n        prefixDash = prefix + '-';\n    } else {\n        prefixDash = '';\n    }\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var label = ele.pstyle(prefixDash + 'label').strValue;\n    if (label) {\n        var halign = ele.pstyle('text-halign');\n        var valign = ele.pstyle('text-valign');\n        var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n        var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n        var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n        var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n        var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n        var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n        var isEdge = ele.isEdge();\n        var rotation = ele.pstyle(prefixDash + 'text-rotation');\n        var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n        var borderWidth = ele.pstyle('text-border-width').pfValue;\n        var halfBorderWidth = borderWidth / 2;\n        var padding = ele.pstyle('text-background-padding').pfValue;\n        var marginOfError = 2; // expand to work around browser dimension inaccuracies\n        var lh = labelHeight;\n        var lw = labelWidth;\n        var lw_2 = lw / 2;\n        var lh_2 = lh / 2;\n        var lx1, lx2, ly1, ly2;\n        if (isEdge) {\n            lx1 = labelX - lw_2;\n            lx2 = labelX + lw_2;\n            ly1 = labelY - lh_2;\n            ly2 = labelY + lh_2;\n        } else {\n            switch(halign.value){\n                case 'left':\n                    lx1 = labelX - lw;\n                    lx2 = labelX;\n                    break;\n                case 'center':\n                    lx1 = labelX - lw_2;\n                    lx2 = labelX + lw_2;\n                    break;\n                case 'right':\n                    lx1 = labelX;\n                    lx2 = labelX + lw;\n                    break;\n            }\n            switch(valign.value){\n                case 'top':\n                    ly1 = labelY - lh;\n                    ly2 = labelY;\n                    break;\n                case 'center':\n                    ly1 = labelY - lh_2;\n                    ly2 = labelY + lh_2;\n                    break;\n                case 'bottom':\n                    ly1 = labelY;\n                    ly2 = labelY + lh;\n                    break;\n            }\n        }\n        // shift by margin and expand by outline and border\n        var leftPad = marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n        var rightPad = marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n        var topPad = marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n        var botPad = marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n        lx1 += leftPad;\n        lx2 += rightPad;\n        ly1 += topPad;\n        ly2 += botPad;\n        // always store the unrotated label bounds separately\n        var bbPrefix = prefix || 'main';\n        var bbs = _p.labelBounds;\n        var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n        bb.x1 = lx1;\n        bb.y1 = ly1;\n        bb.x2 = lx2;\n        bb.y2 = ly2;\n        bb.w = lx2 - lx1;\n        bb.h = ly2 - ly1;\n        bb.leftPad = leftPad;\n        bb.rightPad = rightPad;\n        bb.topPad = topPad;\n        bb.botPad = botPad;\n        var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n        var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n        if (isAutorotate || isPfValue) {\n            var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            // rotation point (default value for center-center)\n            var xo = (lx1 + lx2) / 2;\n            var yo = (ly1 + ly2) / 2;\n            if (!isEdge) {\n                switch(halign.value){\n                    case 'left':\n                        xo = lx2;\n                        break;\n                    case 'right':\n                        xo = lx1;\n                        break;\n                }\n                switch(valign.value){\n                    case 'top':\n                        yo = ly2;\n                        break;\n                    case 'bottom':\n                        yo = ly1;\n                        break;\n                }\n            }\n            var rotate = function rotate(x, y) {\n                x = x - xo;\n                y = y - yo;\n                return {\n                    x: x * cos - y * sin + xo,\n                    y: x * sin + y * cos + yo\n                };\n            };\n            var px1y1 = rotate(lx1, ly1);\n            var px1y2 = rotate(lx1, ly2);\n            var px2y1 = rotate(lx2, ly1);\n            var px2y2 = rotate(lx2, ly2);\n            lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n            lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n            ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n            ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n        }\n        var bbPrefixRot = bbPrefix + 'Rot';\n        var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n        bbRot.x1 = lx1;\n        bbRot.y1 = ly1;\n        bbRot.x2 = lx2;\n        bbRot.y2 = ly2;\n        bbRot.w = lx2 - lx1;\n        bbRot.h = ly2 - ly1;\n        updateBounds(bounds, lx1, ly1, lx2, ly2);\n        updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n    }\n    return bounds;\n};\nvar updateBoundsFromOutline = function updateBoundsFromOutline(bounds, ele) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var outlineOpacity = ele.pstyle('outline-opacity').value;\n    var outlineWidth = ele.pstyle('outline-width').value;\n    var outlineOffset = ele.pstyle('outline-offset').value;\n    var expansion = outlineWidth + outlineOffset;\n    updateBoundsFromMiter(bounds, ele, outlineOpacity, expansion, 'outside', expansion / 2);\n};\nvar updateBoundsFromMiter = function updateBoundsFromMiter(bounds, ele, opacity, expansionSize, expansionPosition, useFallbackValue) {\n    if (opacity === 0 || expansionSize <= 0 || expansionPosition === 'inside') {\n        return;\n    }\n    var cy = ele.cy();\n    var shape = ele.pstyle('shape').value;\n    var rshape = cy.renderer().nodeShapes[shape];\n    var _ele$position = ele.position(), x = _ele$position.x, y = _ele$position.y;\n    var w = ele.width();\n    var h = ele.height();\n    if (rshape.hasMiterBounds) {\n        if (expansionPosition === 'center') {\n            expansionSize /= 2;\n        }\n        var mbb = rshape.miterBounds(x, y, w, h, expansionSize);\n        updateBoundsFromBox(bounds, mbb);\n    } else if (useFallbackValue != null && useFallbackValue > 0) {\n        expandBoundingBoxSides(bounds, [\n            useFallbackValue,\n            useFallbackValue,\n            useFallbackValue,\n            useFallbackValue\n        ]);\n    }\n};\nvar updateBoundsFromMiterBorder = function updateBoundsFromMiterBorder(bounds, ele) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var borderOpacity = ele.pstyle('border-opacity').value;\n    var borderWidth = ele.pstyle('border-width').pfValue;\n    var borderPosition = ele.pstyle('border-position').value;\n    updateBoundsFromMiter(bounds, ele, borderOpacity, borderWidth, borderPosition);\n};\n// get the bounding box of the elements (in raw model position)\nvar boundingBoxImpl = function boundingBoxImpl(ele, options) {\n    var cy = ele._private.cy;\n    var styleEnabled = cy.styleEnabled();\n    var headless = cy.headless();\n    var bounds = makeBoundingBox();\n    var _p = ele._private;\n    var isNode = ele.isNode();\n    var isEdge = ele.isEdge();\n    var ex1, ex2, ey1, ey2; // extrema of body / lines\n    var x, y; // node pos\n    var rstyle = _p.rstyle;\n    var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [\n        0\n    ];\n    // must use `display` prop only, as reading `compound.width()` causes recursion\n    // (other factors like width values will be considered later in this function anyway)\n    var isDisplayed = function isDisplayed(ele) {\n        return ele.pstyle('display').value !== 'none';\n    };\n    var displayed = !styleEnabled || isDisplayed(ele) && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n    if (displayed) {\n        // displayed suffices, since we will find zero area eles anyway\n        var overlayOpacity = 0;\n        var overlayPadding = 0;\n        if (styleEnabled && options.includeOverlays) {\n            overlayOpacity = ele.pstyle('overlay-opacity').value;\n            if (overlayOpacity !== 0) {\n                overlayPadding = ele.pstyle('overlay-padding').value;\n            }\n        }\n        var underlayOpacity = 0;\n        var underlayPadding = 0;\n        if (styleEnabled && options.includeUnderlays) {\n            underlayOpacity = ele.pstyle('underlay-opacity').value;\n            if (underlayOpacity !== 0) {\n                underlayPadding = ele.pstyle('underlay-padding').value;\n            }\n        }\n        var padding = Math.max(overlayPadding, underlayPadding);\n        var w = 0;\n        var wHalf = 0;\n        if (styleEnabled) {\n            w = ele.pstyle('width').pfValue;\n            wHalf = w / 2;\n        }\n        if (isNode && options.includeNodes) {\n            var pos = ele.position();\n            x = pos.x;\n            y = pos.y;\n            var _w = ele.outerWidth();\n            var halfW = _w / 2;\n            var h = ele.outerHeight();\n            var halfH = h / 2;\n            // handle node dimensions\n            /////////////////////////\n            ex1 = x - halfW;\n            ex2 = x + halfW;\n            ey1 = y - halfH;\n            ey2 = y + halfH;\n            updateBounds(bounds, ex1, ey1, ex2, ey2);\n            if (styleEnabled) {\n                updateBoundsFromOutline(bounds, ele);\n            }\n            if (styleEnabled && options.includeOutlines && !headless) {\n                updateBoundsFromOutline(bounds, ele);\n            }\n            if (styleEnabled) {\n                updateBoundsFromMiterBorder(bounds, ele);\n            }\n        } else if (isEdge && options.includeEdges) {\n            if (styleEnabled && !headless) {\n                var curveStyle = ele.pstyle('curve-style').strValue;\n                // handle edge dimensions (rough box estimate)\n                //////////////////////////////////////////////\n                ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n                ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n                // take into account edge width\n                ex1 -= wHalf;\n                ex2 += wHalf;\n                ey1 -= wHalf;\n                ey2 += wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n                // precise edges\n                ////////////////\n                if (curveStyle === 'haystack') {\n                    var hpts = rstyle.haystackPts;\n                    if (hpts && hpts.length === 2) {\n                        ex1 = hpts[0].x;\n                        ey1 = hpts[0].y;\n                        ex2 = hpts[1].x;\n                        ey2 = hpts[1].y;\n                        if (ex1 > ex2) {\n                            var temp = ex1;\n                            ex1 = ex2;\n                            ex2 = temp;\n                        }\n                        if (ey1 > ey2) {\n                            var _temp = ey1;\n                            ey1 = ey2;\n                            ey2 = _temp;\n                        }\n                        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n                    }\n                } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || endsWith(curveStyle, 'segments') || endsWith(curveStyle, 'taxi')) {\n                    var pts;\n                    switch(curveStyle){\n                        case 'bezier':\n                        case 'unbundled-bezier':\n                            pts = rstyle.bezierPts;\n                            break;\n                        case 'segments':\n                        case 'taxi':\n                        case 'round-segments':\n                        case 'round-taxi':\n                            pts = rstyle.linePts;\n                            break;\n                    }\n                    if (pts != null) {\n                        for(var j = 0; j < pts.length; j++){\n                            var pt = pts[j];\n                            ex1 = pt.x - wHalf;\n                            ex2 = pt.x + wHalf;\n                            ey1 = pt.y - wHalf;\n                            ey2 = pt.y + wHalf;\n                            updateBounds(bounds, ex1, ey1, ex2, ey2);\n                        }\n                    }\n                } // bezier-like or segment-like edge\n            } else {\n                // headless or style disabled\n                // fallback on source and target positions\n                //////////////////////////////////////////\n                var n1 = ele.source();\n                var n1pos = n1.position();\n                var n2 = ele.target();\n                var n2pos = n2.position();\n                ex1 = n1pos.x;\n                ex2 = n2pos.x;\n                ey1 = n1pos.y;\n                ey2 = n2pos.y;\n                if (ex1 > ex2) {\n                    var _temp2 = ex1;\n                    ex1 = ex2;\n                    ex2 = _temp2;\n                }\n                if (ey1 > ey2) {\n                    var _temp3 = ey1;\n                    ey1 = ey2;\n                    ey2 = _temp3;\n                }\n                // take into account edge width\n                ex1 -= wHalf;\n                ex2 += wHalf;\n                ey1 -= wHalf;\n                ey2 += wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n            } // headless or style disabled\n        } // edges\n        // handle edge arrow size\n        /////////////////////////\n        if (styleEnabled && options.includeEdges && isEdge) {\n            updateBoundsFromArrow(bounds, ele, 'mid-source');\n            updateBoundsFromArrow(bounds, ele, 'mid-target');\n            updateBoundsFromArrow(bounds, ele, 'source');\n            updateBoundsFromArrow(bounds, ele, 'target');\n        }\n        // ghost\n        ////////\n        if (styleEnabled) {\n            var ghost = ele.pstyle('ghost').value === 'yes';\n            if (ghost) {\n                var gx = ele.pstyle('ghost-offset-x').pfValue;\n                var gy = ele.pstyle('ghost-offset-y').pfValue;\n                updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n            }\n        }\n        // always store the body bounds separately from the labels\n        var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n        assignBoundingBox(bbBody, bounds);\n        expandBoundingBoxSides(bbBody, manualExpansion);\n        expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n        // overlay\n        //////////\n        if (styleEnabled) {\n            ex1 = bounds.x1;\n            ex2 = bounds.x2;\n            ey1 = bounds.y1;\n            ey2 = bounds.y2;\n            updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n        }\n        // always store the body bounds separately from the labels\n        var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n        assignBoundingBox(bbOverlay, bounds);\n        expandBoundingBoxSides(bbOverlay, manualExpansion);\n        expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n        // handle label dimensions\n        //////////////////////////\n        var bbLabels = _p.labelBounds = _p.labelBounds || {};\n        if (bbLabels.all != null) {\n            clearBoundingBox(bbLabels.all);\n        } else {\n            bbLabels.all = makeBoundingBox();\n        }\n        if (styleEnabled && options.includeLabels) {\n            if (options.includeMainLabels) {\n                updateBoundsFromLabel(bounds, ele, null);\n            }\n            if (isEdge) {\n                if (options.includeSourceLabels) {\n                    updateBoundsFromLabel(bounds, ele, 'source');\n                }\n                if (options.includeTargetLabels) {\n                    updateBoundsFromLabel(bounds, ele, 'target');\n                }\n            }\n        } // style enabled for labels\n    } // if displayed\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    if (bounds.w > 0 && bounds.h > 0 && displayed) {\n        expandBoundingBoxSides(bounds, manualExpansion);\n        // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n        expandBoundingBox(bounds, 1);\n    }\n    return bounds;\n};\nvar getKey = function getKey(opts) {\n    var i = 0;\n    var tf = function tf(val) {\n        return (val ? 1 : 0) << i++;\n    };\n    var key = 0;\n    key += tf(opts.incudeNodes);\n    key += tf(opts.includeEdges);\n    key += tf(opts.includeLabels);\n    key += tf(opts.includeMainLabels);\n    key += tf(opts.includeSourceLabels);\n    key += tf(opts.includeTargetLabels);\n    key += tf(opts.includeOverlays);\n    key += tf(opts.includeOutlines);\n    return key;\n};\nvar getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n    var r = function r(x) {\n        return Math.round(x);\n    };\n    if (ele.isEdge()) {\n        var p1 = ele.source().position();\n        var p2 = ele.target().position();\n        return hashIntsArray([\n            r(p1.x),\n            r(p1.y),\n            r(p2.x),\n            r(p2.y)\n        ]);\n    } else {\n        var p = ele.position();\n        return hashIntsArray([\n            r(p.x),\n            r(p.y)\n        ]);\n    }\n};\nvar cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n    var _p = ele._private;\n    var bb;\n    var isEdge = ele.isEdge();\n    var key = opts == null ? defBbOptsKey : getKey(opts);\n    var usingDefOpts = key === defBbOptsKey;\n    if (_p.bbCache == null) {\n        bb = boundingBoxImpl(ele, defBbOpts);\n        _p.bbCache = bb;\n        _p.bbCachePosKey = getBoundingBoxPosKey(ele);\n    } else {\n        bb = _p.bbCache;\n    }\n    // not using def opts => need to build up bb from combination of sub bbs\n    if (!usingDefOpts) {\n        var isNode = ele.isNode();\n        bb = makeBoundingBox();\n        if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n            if (opts.includeOverlays) {\n                updateBoundsFromBox(bb, _p.overlayBounds);\n            } else {\n                updateBoundsFromBox(bb, _p.bodyBounds);\n            }\n        }\n        if (opts.includeLabels) {\n            if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n                updateBoundsFromBox(bb, _p.labelBounds.all);\n            } else {\n                if (opts.includeMainLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n                }\n                if (opts.includeSourceLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n                }\n                if (opts.includeTargetLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n                }\n            }\n        }\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n    }\n    return bb;\n};\nvar defBbOpts = {\n    includeNodes: true,\n    includeEdges: true,\n    includeLabels: true,\n    includeMainLabels: true,\n    includeSourceLabels: true,\n    includeTargetLabels: true,\n    includeOverlays: true,\n    includeUnderlays: true,\n    includeOutlines: true,\n    useCache: true\n};\nvar defBbOptsKey = getKey(defBbOpts);\nvar filledBbOpts = defaults$g(defBbOpts);\nelesfn$b.boundingBox = function(options) {\n    var bounds;\n    var useCache = options === undefined || options.useCache === undefined || options.useCache === true;\n    var isDirty = memoize(function(ele) {\n        var _p = ele._private;\n        return _p.bbCache == null || _p.styleDirty || _p.bbCachePosKey !== getBoundingBoxPosKey(ele);\n    }, function(ele) {\n        return ele.id();\n    });\n    // the main usecase is ele.boundingBox() for a single element with no/def options\n    // specified s.t. the cache is used, so check for this case to make it faster by\n    // avoiding the overhead of the rest of the function\n    if (useCache && this.length === 1 && !isDirty(this[0])) {\n        if (options === undefined) {\n            options = defBbOpts;\n        } else {\n            options = filledBbOpts(options);\n        }\n        bounds = cachedBoundingBoxImpl(this[0], options);\n    } else {\n        bounds = makeBoundingBox();\n        options = options || defBbOpts;\n        var opts = filledBbOpts(options);\n        var eles = this;\n        var cy = eles.cy();\n        var styleEnabled = cy.styleEnabled();\n        // cache the isDirty state for all eles, edges first since they depend on node state\n        this.edges().forEach(isDirty);\n        this.nodes().forEach(isDirty);\n        if (styleEnabled) {\n            this.recalculateRenderedStyle(useCache);\n        }\n        this.updateCompoundBounds(!useCache);\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (isDirty(ele)) {\n                ele.dirtyBoundingBoxCache();\n            }\n            updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));\n        }\n    }\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    return bounds;\n};\nelesfn$b.dirtyBoundingBoxCache = function() {\n    for(var i = 0; i < this.length; i++){\n        var _p = this[i]._private;\n        _p.bbCache = null;\n        _p.bbCachePosKey = null;\n        _p.bodyBounds = null;\n        _p.overlayBounds = null;\n        _p.labelBounds.all = null;\n        _p.labelBounds.source = null;\n        _p.labelBounds.target = null;\n        _p.labelBounds.main = null;\n        _p.labelBounds.sourceRot = null;\n        _p.labelBounds.targetRot = null;\n        _p.labelBounds.mainRot = null;\n        _p.arrowBounds.source = null;\n        _p.arrowBounds.target = null;\n        _p.arrowBounds['mid-source'] = null;\n        _p.arrowBounds['mid-target'] = null;\n    }\n    this.emitAndNotify('bounds');\n    return this;\n};\n// private helper to get bounding box for custom node positions\n// - good for perf in certain cases but currently requires dirtying the rendered style\n// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n// - try to use for only things like discrete layouts where the node position would change anyway\nelesfn$b.boundingBoxAt = function(fn) {\n    var nodes = this.nodes();\n    var cy = this.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var parents = cy.collection();\n    if (hasCompoundNodes) {\n        parents = nodes.filter(function(node) {\n            return node.isParent();\n        });\n        nodes = nodes.not(parents);\n    }\n    if (plainObject(fn)) {\n        var obj = fn;\n        fn = function fn() {\n            return obj;\n        };\n    }\n    var storeOldPos = function storeOldPos(node, i) {\n        return node._private.bbAtOldPos = fn(node, i);\n    };\n    var getOldPos = function getOldPos(node) {\n        return node._private.bbAtOldPos;\n    };\n    cy.startBatch();\n    nodes.forEach(storeOldPos).silentPositions(fn);\n    if (hasCompoundNodes) {\n        parents.dirtyCompoundBoundsCache();\n        parents.dirtyBoundingBoxCache();\n        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n    var bb = copyBoundingBox(this.boundingBox({\n        useCache: false\n    }));\n    nodes.silentPositions(getOldPos);\n    if (hasCompoundNodes) {\n        parents.dirtyCompoundBoundsCache();\n        parents.dirtyBoundingBoxCache();\n        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n    cy.endBatch();\n    return bb;\n};\nfn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\nfn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\nvar bounds = elesfn$b;\nvar fn$2, elesfn$a;\nfn$2 = elesfn$a = {};\nvar defineDimFns = function defineDimFns(opts) {\n    opts.uppercaseName = capitalize(opts.name);\n    opts.autoName = 'auto' + opts.uppercaseName;\n    opts.labelName = 'label' + opts.uppercaseName;\n    opts.outerName = 'outer' + opts.uppercaseName;\n    opts.uppercaseOuterName = capitalize(opts.outerName);\n    fn$2[opts.name] = function dimImpl() {\n        var ele = this[0];\n        var _p = ele._private;\n        var cy = _p.cy;\n        var styleEnabled = cy._private.styleEnabled;\n        if (ele) {\n            if (styleEnabled) {\n                if (ele.isParent()) {\n                    ele.updateCompoundBounds();\n                    return _p[opts.autoName] || 0;\n                }\n                var d = ele.pstyle(opts.name);\n                switch(d.strValue){\n                    case 'label':\n                        ele.recalculateRenderedStyle();\n                        return _p.rstyle[opts.labelName] || 0;\n                    default:\n                        return d.pfValue;\n                }\n            } else {\n                return 1;\n            }\n        }\n    };\n    fn$2['outer' + opts.uppercaseName] = function outerDimImpl() {\n        var ele = this[0];\n        var _p = ele._private;\n        var cy = _p.cy;\n        var styleEnabled = cy._private.styleEnabled;\n        if (ele) {\n            if (styleEnabled) {\n                var dim = ele[opts.name]();\n                var borderPos = ele.pstyle('border-position').value;\n                var border;\n                if (borderPos === 'center') {\n                    border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n                } else if (borderPos === 'outside') {\n                    border = 2 * ele.pstyle('border-width').pfValue;\n                } else {\n                    // 'inside'\n                    border = 0;\n                }\n                var padding = 2 * ele.padding();\n                return dim + border + padding;\n            } else {\n                return 1;\n            }\n        }\n    };\n    fn$2['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n        var ele = this[0];\n        if (ele) {\n            var d = ele[opts.name]();\n            return d * this.cy().zoom();\n        }\n    };\n    fn$2['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n        var ele = this[0];\n        if (ele) {\n            var od = ele[opts.outerName]();\n            return od * this.cy().zoom();\n        }\n    };\n};\ndefineDimFns({\n    name: 'width'\n});\ndefineDimFns({\n    name: 'height'\n});\nelesfn$a.padding = function() {\n    var ele = this[0];\n    var _p = ele._private;\n    if (ele.isParent()) {\n        ele.updateCompoundBounds();\n        if (_p.autoPadding !== undefined) {\n            return _p.autoPadding;\n        } else {\n            return ele.pstyle('padding').pfValue;\n        }\n    } else {\n        return ele.pstyle('padding').pfValue;\n    }\n};\nelesfn$a.paddedHeight = function() {\n    var ele = this[0];\n    return ele.height() + 2 * ele.padding();\n};\nelesfn$a.paddedWidth = function() {\n    var ele = this[0];\n    return ele.width() + 2 * ele.padding();\n};\nvar widthHeight = elesfn$a;\nvar ifEdge = function ifEdge(ele, getValue) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        return getValue(ele);\n    }\n};\nvar ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        var cy = ele.cy();\n        return modelToRenderedPosition$1(getPoint(ele), cy.zoom(), cy.pan());\n    }\n};\nvar ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        var cy = ele.cy();\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        return getPoints(ele).map(function(p) {\n            return modelToRenderedPosition$1(p, zoom, pan);\n        });\n    }\n};\nvar controlPoints = function controlPoints(ele) {\n    return ele.renderer().getControlPoints(ele);\n};\nvar segmentPoints = function segmentPoints(ele) {\n    return ele.renderer().getSegmentPoints(ele);\n};\nvar sourceEndpoint = function sourceEndpoint(ele) {\n    return ele.renderer().getSourceEndpoint(ele);\n};\nvar targetEndpoint = function targetEndpoint(ele) {\n    return ele.renderer().getTargetEndpoint(ele);\n};\nvar midpoint = function midpoint(ele) {\n    return ele.renderer().getEdgeMidpoint(ele);\n};\nvar pts = {\n    controlPoints: {\n        get: controlPoints,\n        mult: true\n    },\n    segmentPoints: {\n        get: segmentPoints,\n        mult: true\n    },\n    sourceEndpoint: {\n        get: sourceEndpoint\n    },\n    targetEndpoint: {\n        get: targetEndpoint\n    },\n    midpoint: {\n        get: midpoint\n    }\n};\nvar renderedName = function renderedName(name) {\n    return 'rendered' + name[0].toUpperCase() + name.substr(1);\n};\nvar edgePoints = Object.keys(pts).reduce(function(obj, name) {\n    var spec = pts[name];\n    var rName = renderedName(name);\n    obj[name] = function() {\n        return ifEdge(this, spec.get);\n    };\n    if (spec.mult) {\n        obj[rName] = function() {\n            return ifEdgeRenderedPositions(this, spec.get);\n        };\n    } else {\n        obj[rName] = function() {\n            return ifEdgeRenderedPosition(this, spec.get);\n        };\n    }\n    return obj;\n}, {});\nvar dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n/*!\nEvent object based on jQuery events, MIT license\n\nhttps://jquery.org/license/\nhttps://tldrlegal.com/license/mit-license\nhttps://github.com/jquery/jquery/blob/master/src/event.js\n*/ var Event = function Event(src, props) {\n    this.recycle(src, props);\n};\nfunction returnFalse() {\n    return false;\n}\nfunction returnTrue() {\n    return true;\n}\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n    instanceString: function instanceString() {\n        return 'event';\n    },\n    recycle: function recycle(src, props) {\n        this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n        if (src != null && src.preventDefault) {\n            // Browser Event object\n            this.type = src.type;\n            // Events bubbling up the document may have been marked as prevented\n            // by a handler lower down the tree; reflect the correct value.\n            this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n        } else if (src != null && src.type) {\n            // Plain object containing all event details\n            props = src;\n        } else {\n            // Event string\n            this.type = src;\n        }\n        // Put explicitly provided properties onto the event object\n        if (props != null) {\n            // more efficient to manually copy fields we use\n            this.originalEvent = props.originalEvent;\n            this.type = props.type != null ? props.type : this.type;\n            this.cy = props.cy;\n            this.target = props.target;\n            this.position = props.position;\n            this.renderedPosition = props.renderedPosition;\n            this.namespace = props.namespace;\n            this.layout = props.layout;\n        }\n        if (this.cy != null && this.position != null && this.renderedPosition == null) {\n            // create a rendered position based on the passed position\n            var pos = this.position;\n            var zoom = this.cy.zoom();\n            var pan = this.cy.pan();\n            this.renderedPosition = {\n                x: pos.x * zoom + pan.x,\n                y: pos.y * zoom + pan.y\n            };\n        }\n        // Create a timestamp if incoming event doesn't have one\n        this.timeStamp = src && src.timeStamp || Date.now();\n    },\n    preventDefault: function preventDefault() {\n        this.isDefaultPrevented = returnTrue;\n        var e = this.originalEvent;\n        if (!e) {\n            return;\n        }\n        // if preventDefault exists run it on the original event\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n    },\n    stopPropagation: function stopPropagation() {\n        this.isPropagationStopped = returnTrue;\n        var e = this.originalEvent;\n        if (!e) {\n            return;\n        }\n        // if stopPropagation exists run it on the original event\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n        this.isImmediatePropagationStopped = returnTrue;\n        this.stopPropagation();\n    },\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse\n};\nvar eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\nvar universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\nvar defaults$8 = {\n    qualifierCompare: function qualifierCompare(q1, q2) {\n        return q1 === q2;\n    },\n    eventMatches: function eventMatches() {\n        return true;\n    },\n    addEventFields: function addEventFields() {},\n    callbackContext: function callbackContext(context /*, listener, eventObj*/ ) {\n        return context;\n    },\n    beforeEmit: function beforeEmit() {},\n    afterEmit: function afterEmit() {},\n    bubble: function bubble() {\n        return false;\n    },\n    parent: function parent() {\n        return null;\n    },\n    context: null\n};\nvar defaultsKeys = Object.keys(defaults$8);\nvar emptyOpts = {};\nfunction Emitter() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n    var context = arguments.length > 1 ? arguments[1] : undefined;\n    // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n    for(var i = 0; i < defaultsKeys.length; i++){\n        var key = defaultsKeys[i];\n        this[key] = opts[key] || defaults$8[key];\n    }\n    this.context = context || this.context;\n    this.listeners = [];\n    this.emitting = 0;\n}\nvar p = Emitter.prototype;\nvar forEachEvent = function forEachEvent(self1, handler, events, qualifier, callback, conf, confOverrides) {\n    if (fn$6(qualifier)) {\n        callback = qualifier;\n        qualifier = null;\n    }\n    if (confOverrides) {\n        if (conf == null) {\n            conf = confOverrides;\n        } else {\n            conf = extend({}, conf, confOverrides);\n        }\n    }\n    var eventList = array(events) ? events : events.split(/\\s+/);\n    for(var i = 0; i < eventList.length; i++){\n        var evt = eventList[i];\n        if (emptyString(evt)) {\n            continue;\n        }\n        var match = evt.match(eventRegex); // type[.namespace]\n        if (match) {\n            var type = match[1];\n            var namespace = match[2] ? match[2] : null;\n            var ret = handler(self1, evt, type, namespace, qualifier, callback, conf);\n            if (ret === false) {\n                break;\n            } // allow exiting early\n        }\n    }\n};\nvar makeEventObj = function makeEventObj(self1, obj) {\n    self1.addEventFields(self1.context, obj);\n    return new Event(obj.type, obj);\n};\nvar forEachEventObj = function forEachEventObj(self1, handler, events) {\n    if (event(events)) {\n        handler(self1, events);\n        return;\n    } else if (plainObject(events)) {\n        handler(self1, makeEventObj(self1, events));\n        return;\n    }\n    var eventList = array(events) ? events : events.split(/\\s+/);\n    for(var i = 0; i < eventList.length; i++){\n        var evt = eventList[i];\n        if (emptyString(evt)) {\n            continue;\n        }\n        var match = evt.match(eventRegex); // type[.namespace]\n        if (match) {\n            var type = match[1];\n            var namespace = match[2] ? match[2] : null;\n            var eventObj = makeEventObj(self1, {\n                type: type,\n                namespace: namespace,\n                target: self1.context\n            });\n            handler(self1, eventObj);\n        }\n    }\n};\np.on = p.addListener = function(events, qualifier, callback, conf, confOverrides) {\n    forEachEvent(this, function(self1, event, type, namespace, qualifier, callback, conf) {\n        if (fn$6(callback)) {\n            self1.listeners.push({\n                event: event,\n                // full event string\n                callback: callback,\n                // callback to run\n                type: type,\n                // the event type (e.g. 'click')\n                namespace: namespace,\n                // the event namespace (e.g. \".foo\")\n                qualifier: qualifier,\n                // a restriction on whether to match this emitter\n                conf: conf // additional configuration\n            });\n        }\n    }, events, qualifier, callback, conf, confOverrides);\n    return this;\n};\np.one = function(events, qualifier, callback, conf) {\n    return this.on(events, qualifier, callback, conf, {\n        one: true\n    });\n};\np.removeListener = p.off = function(events, qualifier, callback, conf) {\n    var _this = this;\n    if (this.emitting !== 0) {\n        this.listeners = copyArray(this.listeners);\n    }\n    var listeners = this.listeners;\n    var _loop = function _loop(i) {\n        var listener = listeners[i];\n        forEachEvent(_this, function(self1, event, type, namespace, qualifier, callback /*, conf*/ ) {\n            if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self1.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n                listeners.splice(i, 1);\n                return false;\n            }\n        }, events, qualifier, callback, conf);\n    };\n    for(var i = listeners.length - 1; i >= 0; i--){\n        _loop(i);\n    }\n    return this;\n};\np.removeAllListeners = function() {\n    return this.removeListener('*');\n};\np.emit = p.trigger = function(events, extraParams, manualCallback) {\n    var listeners = this.listeners;\n    var numListenersBeforeEmit = listeners.length;\n    this.emitting++;\n    if (!array(extraParams)) {\n        extraParams = [\n            extraParams\n        ];\n    }\n    forEachEventObj(this, function(self1, eventObj) {\n        if (manualCallback != null) {\n            listeners = [\n                {\n                    event: eventObj.event,\n                    type: eventObj.type,\n                    namespace: eventObj.namespace,\n                    callback: manualCallback\n                }\n            ];\n            numListenersBeforeEmit = listeners.length;\n        }\n        var _loop2 = function _loop2() {\n            var listener = listeners[i];\n            if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self1.eventMatches(self1.context, listener, eventObj)) {\n                var args = [\n                    eventObj\n                ];\n                if (extraParams != null) {\n                    push(args, extraParams);\n                }\n                self1.beforeEmit(self1.context, listener, eventObj);\n                if (listener.conf && listener.conf.one) {\n                    self1.listeners = self1.listeners.filter(function(l) {\n                        return l !== listener;\n                    });\n                }\n                var context = self1.callbackContext(self1.context, listener, eventObj);\n                var ret = listener.callback.apply(context, args);\n                self1.afterEmit(self1.context, listener, eventObj);\n                if (ret === false) {\n                    eventObj.stopPropagation();\n                    eventObj.preventDefault();\n                }\n            } // if listener matches\n        };\n        for(var i = 0; i < numListenersBeforeEmit; i++){\n            _loop2();\n        } // for listener\n        if (self1.bubble(self1.context) && !eventObj.isPropagationStopped()) {\n            self1.parent(self1.context).emit(eventObj, extraParams);\n        }\n    }, events);\n    this.emitting--;\n    return this;\n};\nvar emitterOptions$1 = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n        if (selector1 == null || selector2 == null) {\n            return selector1 == null && selector2 == null;\n        } else {\n            return selector1.sameText(selector2);\n        }\n    },\n    eventMatches: function eventMatches(ele, listener, eventObj) {\n        var selector = listener.qualifier;\n        if (selector != null) {\n            return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n        }\n        return true;\n    },\n    addEventFields: function addEventFields(ele, evt) {\n        evt.cy = ele.cy();\n        evt.target = ele;\n    },\n    callbackContext: function callbackContext(ele, listener, eventObj) {\n        return listener.qualifier != null ? eventObj.target : ele;\n    },\n    beforeEmit: function beforeEmit(context, listener /*, eventObj*/ ) {\n        if (listener.conf && listener.conf.once) {\n            listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n        }\n    },\n    bubble: function bubble() {\n        return true;\n    },\n    parent: function parent(ele) {\n        return ele.isChild() ? ele.parent() : ele.cy();\n    }\n};\nvar argSelector$1 = function argSelector(arg) {\n    if (string(arg)) {\n        return new Selector(arg);\n    } else {\n        return arg;\n    }\n};\nvar elesfn$9 = {\n    createEmitter: function createEmitter() {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var _p = ele._private;\n            if (!_p.emitter) {\n                _p.emitter = new Emitter(emitterOptions$1, ele);\n            }\n        }\n        return this;\n    },\n    emitter: function emitter() {\n        return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().on(events, argSel, callback);\n        }\n        return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().removeListener(events, argSel, callback);\n        }\n        return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().removeAllListeners();\n        }\n        return this;\n    },\n    one: function one(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().one(events, argSel, callback);\n        }\n        return this;\n    },\n    once: function once(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().on(events, argSel, callback, {\n                once: true,\n                onceCollection: this\n            });\n        }\n    },\n    emit: function emit(events, extraParams) {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().emit(events, extraParams);\n        }\n        return this;\n    },\n    emitAndNotify: function emitAndNotify(event, extraParams) {\n        // for internal use only\n        if (this.length === 0) {\n            return;\n        } // empty collections don't need to notify anything\n        // notify renderer\n        this.cy().notify(event, this);\n        this.emit(event, extraParams);\n        return this;\n    }\n};\ndefine.eventAliasesOn(elesfn$9);\nvar elesfn$8 = {\n    nodes: function nodes(selector) {\n        return this.filter(function(ele) {\n            return ele.isNode();\n        }).filter(selector);\n    },\n    edges: function edges(selector) {\n        return this.filter(function(ele) {\n            return ele.isEdge();\n        }).filter(selector);\n    },\n    // internal helper to get nodes and edges as separate collections with single iteration over elements\n    byGroup: function byGroup() {\n        var nodes = this.spawn();\n        var edges = this.spawn();\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            if (ele.isNode()) {\n                nodes.push(ele);\n            } else {\n                edges.push(ele);\n            }\n        }\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    },\n    filter: function filter(_filter, thisArg) {\n        if (_filter === undefined) {\n            // check this first b/c it's the most common/performant case\n            return this;\n        } else if (string(_filter) || elementOrCollection(_filter)) {\n            return new Selector(_filter).filter(this);\n        } else if (fn$6(_filter)) {\n            var filterEles = this.spawn();\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var include = thisArg ? _filter.apply(thisArg, [\n                    ele,\n                    i,\n                    eles\n                ]) : _filter(ele, i, eles);\n                if (include) {\n                    filterEles.push(ele);\n                }\n            }\n            return filterEles;\n        }\n        return this.spawn(); // if not handled by above, give 'em an empty collection\n    },\n    not: function not(toRemove) {\n        if (!toRemove) {\n            return this;\n        } else {\n            if (string(toRemove)) {\n                toRemove = this.filter(toRemove);\n            }\n            var elements = this.spawn();\n            for(var i = 0; i < this.length; i++){\n                var element = this[i];\n                var remove = toRemove.has(element);\n                if (!remove) {\n                    elements.push(element);\n                }\n            }\n            return elements;\n        }\n    },\n    absoluteComplement: function absoluteComplement() {\n        var cy = this.cy();\n        return cy.mutableElements().not(this);\n    },\n    intersect: function intersect(other) {\n        // if a selector is specified, then filter by it instead\n        if (string(other)) {\n            var selector = other;\n            return this.filter(selector);\n        }\n        var elements = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var col1Smaller = this.length < other.length;\n        var colS = col1Smaller ? col1 : col2;\n        var colL = col1Smaller ? col2 : col1;\n        for(var i = 0; i < colS.length; i++){\n            var ele = colS[i];\n            if (colL.has(ele)) {\n                elements.push(ele);\n            }\n        }\n        return elements;\n    },\n    xor: function xor(other) {\n        var cy = this._private.cy;\n        if (string(other)) {\n            other = cy.$(other);\n        }\n        var elements = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var add = function add(col, other) {\n            for(var i = 0; i < col.length; i++){\n                var ele = col[i];\n                var id = ele._private.data.id;\n                var inOther = other.hasElementWithId(id);\n                if (!inOther) {\n                    elements.push(ele);\n                }\n            }\n        };\n        add(col1, col2);\n        add(col2, col1);\n        return elements;\n    },\n    diff: function diff(other) {\n        var cy = this._private.cy;\n        if (string(other)) {\n            other = cy.$(other);\n        }\n        var left = this.spawn();\n        var right = this.spawn();\n        var both = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var add = function add(col, other, retEles) {\n            for(var i = 0; i < col.length; i++){\n                var ele = col[i];\n                var id = ele._private.data.id;\n                var inOther = other.hasElementWithId(id);\n                if (inOther) {\n                    both.merge(ele);\n                } else {\n                    retEles.push(ele);\n                }\n            }\n        };\n        add(col1, col2, left);\n        add(col2, col1, right);\n        return {\n            left: left,\n            right: right,\n            both: both\n        };\n    },\n    add: function add(toAdd) {\n        var cy = this._private.cy;\n        if (!toAdd) {\n            return this;\n        }\n        if (string(toAdd)) {\n            var selector = toAdd;\n            toAdd = cy.mutableElements().filter(selector);\n        }\n        var elements = this.spawnSelf();\n        for(var i = 0; i < toAdd.length; i++){\n            var ele = toAdd[i];\n            var add = !this.has(ele);\n            if (add) {\n                elements.push(ele);\n            }\n        }\n        return elements;\n    },\n    // in place merge on calling collection\n    merge: function merge(toAdd) {\n        var _p = this._private;\n        var cy = _p.cy;\n        if (!toAdd) {\n            return this;\n        }\n        if (toAdd && string(toAdd)) {\n            var selector = toAdd;\n            toAdd = cy.mutableElements().filter(selector);\n        }\n        var map = _p.map;\n        for(var i = 0; i < toAdd.length; i++){\n            var toAddEle = toAdd[i];\n            var id = toAddEle._private.data.id;\n            var add = !map.has(id);\n            if (add) {\n                var index = this.length++;\n                this[index] = toAddEle;\n                map.set(id, {\n                    ele: toAddEle,\n                    index: index\n                });\n            }\n        }\n        return this; // chaining\n    },\n    unmergeAt: function unmergeAt(i) {\n        var ele = this[i];\n        var id = ele.id();\n        var _p = this._private;\n        var map = _p.map;\n        // remove ele\n        this[i] = undefined;\n        map[\"delete\"](id);\n        var unmergedLastEle = i === this.length - 1;\n        // replace empty spot with last ele in collection\n        if (this.length > 1 && !unmergedLastEle) {\n            var lastEleI = this.length - 1;\n            var lastEle = this[lastEleI];\n            var lastEleId = lastEle._private.data.id;\n            this[lastEleI] = undefined;\n            this[i] = lastEle;\n            map.set(lastEleId, {\n                ele: lastEle,\n                index: i\n            });\n        }\n        // the collection is now 1 ele smaller\n        this.length--;\n        return this;\n    },\n    // remove single ele in place in calling collection\n    unmergeOne: function unmergeOne(ele) {\n        ele = ele[0];\n        var _p = this._private;\n        var id = ele._private.data.id;\n        var map = _p.map;\n        var entry = map.get(id);\n        if (!entry) {\n            return this; // no need to remove\n        }\n        var i = entry.index;\n        this.unmergeAt(i);\n        return this;\n    },\n    // remove eles in place on calling collection\n    unmerge: function unmerge(toRemove) {\n        var cy = this._private.cy;\n        if (!toRemove) {\n            return this;\n        }\n        if (toRemove && string(toRemove)) {\n            var selector = toRemove;\n            toRemove = cy.mutableElements().filter(selector);\n        }\n        for(var i = 0; i < toRemove.length; i++){\n            this.unmergeOne(toRemove[i]);\n        }\n        return this; // chaining\n    },\n    unmergeBy: function unmergeBy(toRmFn) {\n        for(var i = this.length - 1; i >= 0; i--){\n            var ele = this[i];\n            if (toRmFn(ele)) {\n                this.unmergeAt(i);\n            }\n        }\n        return this;\n    },\n    map: function map(mapFn, thisArg) {\n        var arr = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var ret = thisArg ? mapFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : mapFn(ele, i, eles);\n            arr.push(ret);\n        }\n        return arr;\n    },\n    reduce: function reduce(fn, initialValue) {\n        var val = initialValue;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            val = fn(val, eles[i], i, eles);\n        }\n        return val;\n    },\n    max: function max(valFn, thisArg) {\n        var max = -Infinity;\n        var maxEle;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var val = thisArg ? valFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : valFn(ele, i, eles);\n            if (val > max) {\n                max = val;\n                maxEle = ele;\n            }\n        }\n        return {\n            value: max,\n            ele: maxEle\n        };\n    },\n    min: function min(valFn, thisArg) {\n        var min = Infinity;\n        var minEle;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var val = thisArg ? valFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : valFn(ele, i, eles);\n            if (val < min) {\n                min = val;\n                minEle = ele;\n            }\n        }\n        return {\n            value: min,\n            ele: minEle\n        };\n    }\n};\n// aliases\nvar fn$1 = elesfn$8;\nfn$1['u'] = fn$1['|'] = fn$1['+'] = fn$1.union = fn$1.or = fn$1.add;\nfn$1['\\\\'] = fn$1['!'] = fn$1['-'] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\nfn$1['n'] = fn$1['&'] = fn$1['.'] = fn$1.and = fn$1.intersection = fn$1.intersect;\nfn$1['^'] = fn$1['(+)'] = fn$1['(-)'] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\nfn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\nfn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\nvar elesfn$7 = {\n    isNode: function isNode() {\n        return this.group() === 'nodes';\n    },\n    isEdge: function isEdge() {\n        return this.group() === 'edges';\n    },\n    isLoop: function isLoop() {\n        return this.isEdge() && this.source()[0] === this.target()[0];\n    },\n    isSimple: function isSimple() {\n        return this.isEdge() && this.source()[0] !== this.target()[0];\n    },\n    group: function group() {\n        var ele = this[0];\n        if (ele) {\n            return ele._private.group;\n        }\n    }\n};\n/**\n *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n *  and z-index (low to high).  These styles affect how this applies:\n *\n *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n *      root to leaves of the compound graph.  The last drawn is `top`.\n *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n *      `manual` ignores this convention and draws based on the `z-index` value setting.\n *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n *      `z-index` will be drawn on top of an element with a lower `z-index`.\n */ var zIndexSort = function zIndexSort(a, b) {\n    var cy = a.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    function getDepth(ele) {\n        var style = ele.pstyle('z-compound-depth');\n        if (style.value === 'auto') {\n            return hasCompoundNodes ? ele.zDepth() : 0;\n        } else if (style.value === 'bottom') {\n            return -1;\n        } else if (style.value === 'top') {\n            return MAX_INT$1;\n        }\n        // 'orphan'\n        return 0;\n    }\n    var depthDiff = getDepth(a) - getDepth(b);\n    if (depthDiff !== 0) {\n        return depthDiff;\n    }\n    function getEleDepth(ele) {\n        var style = ele.pstyle('z-index-compare');\n        if (style.value === 'auto') {\n            return ele.isNode() ? 1 : 0;\n        }\n        // 'manual'\n        return 0;\n    }\n    var eleDiff = getEleDepth(a) - getEleDepth(b);\n    if (eleDiff !== 0) {\n        return eleDiff;\n    }\n    var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n    if (zDiff !== 0) {\n        return zDiff;\n    }\n    // compare indices in the core (order added to graph w/ last on top)\n    return a.poolIndex() - b.poolIndex();\n};\nvar elesfn$6 = {\n    forEach: function forEach(fn, thisArg) {\n        if (fn$6(fn)) {\n            var N = this.length;\n            for(var i = 0; i < N; i++){\n                var ele = this[i];\n                var ret = thisArg ? fn.apply(thisArg, [\n                    ele,\n                    i,\n                    this\n                ]) : fn(ele, i, this);\n                if (ret === false) {\n                    break;\n                } // exit each early on return false\n            }\n        }\n        return this;\n    },\n    toArray: function toArray() {\n        var array = [];\n        for(var i = 0; i < this.length; i++){\n            array.push(this[i]);\n        }\n        return array;\n    },\n    slice: function slice(start, end) {\n        var array = [];\n        var thisSize = this.length;\n        if (end == null) {\n            end = thisSize;\n        }\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start = thisSize + start;\n        }\n        if (end < 0) {\n            end = thisSize + end;\n        }\n        for(var i = start; i >= 0 && i < end && i < thisSize; i++){\n            array.push(this[i]);\n        }\n        return this.spawn(array);\n    },\n    size: function size() {\n        return this.length;\n    },\n    eq: function eq(i) {\n        return this[i] || this.spawn();\n    },\n    first: function first() {\n        return this[0] || this.spawn();\n    },\n    last: function last() {\n        return this[this.length - 1] || this.spawn();\n    },\n    empty: function empty() {\n        return this.length === 0;\n    },\n    nonempty: function nonempty() {\n        return !this.empty();\n    },\n    sort: function sort(sortFn) {\n        if (!fn$6(sortFn)) {\n            return this;\n        }\n        var sorted = this.toArray().sort(sortFn);\n        return this.spawn(sorted);\n    },\n    sortByZIndex: function sortByZIndex() {\n        return this.sort(zIndexSort);\n    },\n    zDepth: function zDepth() {\n        var ele = this[0];\n        if (!ele) {\n            return undefined;\n        }\n        // let cy = ele.cy();\n        var _p = ele._private;\n        var group = _p.group;\n        if (group === 'nodes') {\n            var depth = _p.data.parent ? ele.parents().size() : 0;\n            if (!ele.isParent()) {\n                return MAX_INT$1 - 1; // childless nodes always on top\n            }\n            return depth;\n        } else {\n            var src = _p.source;\n            var tgt = _p.target;\n            var srcDepth = src.zDepth();\n            var tgtDepth = tgt.zDepth();\n            return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n        }\n    }\n};\nelesfn$6.each = elesfn$6.forEach;\nvar defineSymbolIterator = function defineSymbolIterator() {\n    var typeofUndef = \"undefined\";\n    var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef;\n    if (isIteratorSupported) {\n        elesfn$6[Symbol.iterator] = function() {\n            var _this = this;\n            var entry = {\n                value: undefined,\n                done: false\n            };\n            var i = 0;\n            var length = this.length;\n            return _defineProperty$1({\n                next: function next() {\n                    if (i < length) {\n                        entry.value = _this[i++];\n                    } else {\n                        entry.value = undefined;\n                        entry.done = true;\n                    }\n                    return entry;\n                }\n            }, Symbol.iterator, function() {\n                return this;\n            });\n        };\n    }\n};\ndefineSymbolIterator();\nvar getLayoutDimensionOptions = defaults$g({\n    nodeDimensionsIncludeLabels: false\n});\nvar elesfn$5 = {\n    // Calculates and returns node dimensions { x, y } based on options given\n    layoutDimensions: function layoutDimensions(options) {\n        options = getLayoutDimensionOptions(options);\n        var dims;\n        if (!this.takesUpSpace()) {\n            dims = {\n                w: 0,\n                h: 0\n            };\n        } else if (options.nodeDimensionsIncludeLabels) {\n            var bbDim = this.boundingBox();\n            dims = {\n                w: bbDim.w,\n                h: bbDim.h\n            };\n        } else {\n            dims = {\n                w: this.outerWidth(),\n                h: this.outerHeight()\n            };\n        }\n        // sanitise the dimensions for external layouts (avoid division by zero)\n        if (dims.w === 0 || dims.h === 0) {\n            dims.w = dims.h = 1;\n        }\n        return dims;\n    },\n    // using standard layout options, apply position function (w/ or w/o animation)\n    layoutPositions: function layoutPositions(layout, options, fn) {\n        var nodes = this.nodes().filter(function(n) {\n            return !n.isParent();\n        });\n        var cy = this.cy();\n        var layoutEles = options.eles; // nodes & edges\n        var getMemoizeKey = function getMemoizeKey(node) {\n            return node.id();\n        };\n        var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function\n        layout.emit({\n            type: 'layoutstart',\n            layout: layout\n        });\n        layout.animations = [];\n        var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n            var center = {\n                x: nodesBb.x1 + nodesBb.w / 2,\n                y: nodesBb.y1 + nodesBb.h / 2\n            };\n            var spacingVector = {\n                // scale from center of bounding box (not necessarily 0,0)\n                x: (pos.x - center.x) * spacing,\n                y: (pos.y - center.y) * spacing\n            };\n            return {\n                x: center.x + spacingVector.x,\n                y: center.y + spacingVector.y\n            };\n        };\n        var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n        var spacingBb = function spacingBb() {\n            if (!useSpacingFactor) {\n                return null;\n            }\n            var bb = makeBoundingBox();\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var pos = fnMem(node, i);\n                expandBoundingBoxByPoint(bb, pos.x, pos.y);\n            }\n            return bb;\n        };\n        var bb = spacingBb();\n        var getFinalPos = memoize(function(node, i) {\n            var newPos = fnMem(node, i);\n            if (useSpacingFactor) {\n                var spacing = Math.abs(options.spacingFactor);\n                newPos = calculateSpacing(spacing, bb, newPos);\n            }\n            if (options.transform != null) {\n                newPos = options.transform(node, newPos);\n            }\n            return newPos;\n        }, getMemoizeKey);\n        if (options.animate) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var newPos = getFinalPos(node, i);\n                var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n                if (animateNode) {\n                    var ani = node.animation({\n                        position: newPos,\n                        duration: options.animationDuration,\n                        easing: options.animationEasing\n                    });\n                    layout.animations.push(ani);\n                } else {\n                    node.position(newPos);\n                }\n            }\n            if (options.fit) {\n                var fitAni = cy.animation({\n                    fit: {\n                        boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n                        padding: options.padding\n                    },\n                    duration: options.animationDuration,\n                    easing: options.animationEasing\n                });\n                layout.animations.push(fitAni);\n            } else if (options.zoom !== undefined && options.pan !== undefined) {\n                var zoomPanAni = cy.animation({\n                    zoom: options.zoom,\n                    pan: options.pan,\n                    duration: options.animationDuration,\n                    easing: options.animationEasing\n                });\n                layout.animations.push(zoomPanAni);\n            }\n            layout.animations.forEach(function(ani) {\n                return ani.play();\n            });\n            layout.one('layoutready', options.ready);\n            layout.emit({\n                type: 'layoutready',\n                layout: layout\n            });\n            Promise$1.all(layout.animations.map(function(ani) {\n                return ani.promise();\n            })).then(function() {\n                layout.one('layoutstop', options.stop);\n                layout.emit({\n                    type: 'layoutstop',\n                    layout: layout\n                });\n            });\n        } else {\n            nodes.positions(getFinalPos);\n            if (options.fit) {\n                cy.fit(options.eles, options.padding);\n            }\n            if (options.zoom != null) {\n                cy.zoom(options.zoom);\n            }\n            if (options.pan) {\n                cy.pan(options.pan);\n            }\n            layout.one('layoutready', options.ready);\n            layout.emit({\n                type: 'layoutready',\n                layout: layout\n            });\n            layout.one('layoutstop', options.stop);\n            layout.emit({\n                type: 'layoutstop',\n                layout: layout\n            });\n        }\n        return this; // chaining\n    },\n    layout: function layout(options) {\n        var cy = this.cy();\n        return cy.makeLayout(extend({}, options, {\n            eles: this\n        }));\n    }\n};\n// aliases:\nelesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\nfunction styleCache(key, fn, ele) {\n    var _p = ele._private;\n    var cache = _p.styleCache = _p.styleCache || [];\n    var val;\n    if ((val = cache[key]) != null) {\n        return val;\n    } else {\n        val = cache[key] = fn(ele);\n        return val;\n    }\n}\nfunction cacheStyleFunction(key, fn) {\n    key = hashString(key);\n    return function cachedStyleFunction(ele) {\n        return styleCache(key, fn, ele);\n    };\n}\nfunction cachePrototypeStyleFunction(key, fn) {\n    key = hashString(key);\n    var selfFn = function selfFn(ele) {\n        return fn.call(ele);\n    };\n    return function cachedPrototypeStyleFunction() {\n        var ele = this[0];\n        if (ele) {\n            return styleCache(key, selfFn, ele);\n        }\n    };\n}\nvar elesfn$4 = {\n    recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n        var cy = this.cy();\n        var renderer = cy.renderer();\n        var styleEnabled = cy.styleEnabled();\n        if (renderer && styleEnabled) {\n            renderer.recalculateRenderedStyle(this, useCache);\n        }\n        return this;\n    },\n    dirtyStyleCache: function dirtyStyleCache() {\n        var cy = this.cy();\n        var dirty = function dirty(ele) {\n            return ele._private.styleCache = null;\n        };\n        if (cy.hasCompoundNodes()) {\n            var eles;\n            eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n            eles.merge(eles.connectedEdges());\n            eles.forEach(dirty);\n        } else {\n            this.forEach(function(ele) {\n                dirty(ele);\n                ele.connectedEdges().forEach(dirty);\n            });\n        }\n        return this;\n    },\n    // fully updates (recalculates) the style for the elements\n    updateStyle: function updateStyle(notifyRenderer) {\n        var cy = this._private.cy;\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        if (cy.batching()) {\n            var bEles = cy._private.batchStyleEles;\n            bEles.merge(this);\n            return this; // chaining and exit early when batching\n        }\n        var hasCompounds = cy.hasCompoundNodes();\n        var updatedEles = this;\n        notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n        if (hasCompounds) {\n            // then add everything up and down for compound selector checks\n            updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n        }\n        // let changedEles = style.apply( updatedEles );\n        var changedEles = updatedEles;\n        if (notifyRenderer) {\n            changedEles.emitAndNotify('style'); // let renderer know we changed style\n        } else {\n            changedEles.emit('style'); // just fire the event\n        }\n        updatedEles.forEach(function(ele) {\n            return ele._private.styleDirty = true;\n        });\n        return this; // chaining\n    },\n    // private: clears dirty flag and recalculates style\n    cleanStyle: function cleanStyle() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return;\n        }\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            if (ele._private.styleDirty) {\n                // n.b. this flag should be set before apply() to avoid potential infinite recursion\n                ele._private.styleDirty = false;\n                cy.style().apply(ele);\n            }\n        }\n    },\n    // get the internal parsed style object for the specified property\n    parsedStyle: function parsedStyle(property) {\n        var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var ele = this[0];\n        var cy = ele.cy();\n        if (!cy.styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            // this.cleanStyle();\n            // Inline the important part of cleanStyle(), for raw performance\n            if (ele._private.styleDirty) {\n                // n.b. this flag should be set before apply() to avoid potential infinite recursion\n                ele._private.styleDirty = false;\n                cy.style().apply(ele);\n            }\n            var overriddenStyle = ele._private.style[property];\n            if (overriddenStyle != null) {\n                return overriddenStyle;\n            } else if (includeNonDefault) {\n                return cy.style().getDefaultProperty(property);\n            } else {\n                return null;\n            }\n        }\n    },\n    numericStyle: function numericStyle(property) {\n        var ele = this[0];\n        if (!ele.cy().styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            var pstyle = ele.pstyle(property);\n            return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n        }\n    },\n    numericStyleUnits: function numericStyleUnits(property) {\n        var ele = this[0];\n        if (!ele.cy().styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            return ele.pstyle(property).units;\n        }\n    },\n    // get the specified css property as a rendered value (i.e. on-screen value)\n    // or get the whole rendered style if no property specified (NB doesn't allow setting)\n    renderedStyle: function renderedStyle(property) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var ele = this[0];\n        if (ele) {\n            return cy.style().getRenderedStyle(ele, property);\n        }\n    },\n    // read the calculated css style of the element or override the style (via a bypass)\n    style: function style(name, value) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var updateTransitions = false;\n        var style = cy.style();\n        if (plainObject(name)) {\n            // then extend the bypass\n            var props = name;\n            style.applyBypass(this, props, updateTransitions);\n            this.emitAndNotify('style'); // let the renderer know we've updated style\n        } else if (string(name)) {\n            if (value === undefined) {\n                // then get the property from the style\n                var ele = this[0];\n                if (ele) {\n                    return style.getStylePropertyValue(ele, name);\n                } else {\n                    // empty collection => can't get any value\n                    return;\n                }\n            } else {\n                // then set the bypass with the property value\n                style.applyBypass(this, name, value, updateTransitions);\n                this.emitAndNotify('style'); // let the renderer know we've updated style\n            }\n        } else if (name === undefined) {\n            var _ele = this[0];\n            if (_ele) {\n                return style.getRawStyle(_ele);\n            } else {\n                // empty collection => can't get any value\n                return;\n            }\n        }\n        return this; // chaining\n    },\n    removeStyle: function removeStyle(names) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var updateTransitions = false;\n        var style = cy.style();\n        var eles = this;\n        if (names === undefined) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                style.removeAllBypasses(ele, updateTransitions);\n            }\n        } else {\n            names = names.split(/\\s+/);\n            for(var _i = 0; _i < eles.length; _i++){\n                var _ele2 = eles[_i];\n                style.removeBypasses(_ele2, names, updateTransitions);\n            }\n        }\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n        return this; // chaining\n    },\n    show: function show() {\n        this.css('display', 'element');\n        return this; // chaining\n    },\n    hide: function hide() {\n        this.css('display', 'none');\n        return this; // chaining\n    },\n    effectiveOpacity: function effectiveOpacity() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return 1;\n        }\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        var ele = this[0];\n        if (ele) {\n            var _p = ele._private;\n            var parentOpacity = ele.pstyle('opacity').value;\n            if (!hasCompoundNodes) {\n                return parentOpacity;\n            }\n            var parents = !_p.data.parent ? null : ele.parents();\n            if (parents) {\n                for(var i = 0; i < parents.length; i++){\n                    var parent = parents[i];\n                    var opacity = parent.pstyle('opacity').value;\n                    parentOpacity = opacity * parentOpacity;\n                }\n            }\n            return parentOpacity;\n        }\n    },\n    transparent: function transparent() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return false;\n        }\n        var ele = this[0];\n        var hasCompoundNodes = ele.cy().hasCompoundNodes();\n        if (ele) {\n            if (!hasCompoundNodes) {\n                return ele.pstyle('opacity').value === 0;\n            } else {\n                return ele.effectiveOpacity() === 0;\n            }\n        }\n    },\n    backgrounding: function backgrounding() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return false;\n        }\n        var ele = this[0];\n        return ele._private.backgrounding ? true : false;\n    }\n};\nfunction checkCompound(ele, parentOk) {\n    var _p = ele._private;\n    var parents = _p.data.parent ? ele.parents() : null;\n    if (parents) {\n        for(var i = 0; i < parents.length; i++){\n            var parent = parents[i];\n            if (!parentOk(parent)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction defineDerivedStateFunction(specs) {\n    var ok = specs.ok;\n    var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n    var parentOk = specs.parentOk || specs.ok;\n    return function() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return true;\n        }\n        var ele = this[0];\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        if (ele) {\n            var _p = ele._private;\n            if (!ok(ele)) {\n                return false;\n            }\n            if (ele.isNode()) {\n                return !hasCompoundNodes || checkCompound(ele, parentOk);\n            } else {\n                var src = _p.source;\n                var tgt = _p.target;\n                return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n            }\n        }\n    };\n}\nvar eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function(ele) {\n    return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n});\nelesfn$4.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n    ok: eleTakesUpSpace\n}));\nvar eleInteractive = cacheStyleFunction('eleInteractive', function(ele) {\n    return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n});\nvar parentInteractive = cacheStyleFunction('parentInteractive', function(parent) {\n    return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n});\nelesfn$4.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n    ok: eleInteractive,\n    parentOk: parentInteractive,\n    edgeOkViaNode: eleTakesUpSpace\n}));\nelesfn$4.noninteractive = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele.interactive();\n    }\n};\nvar eleVisible = cacheStyleFunction('eleVisible', function(ele) {\n    return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n});\nvar edgeVisibleViaNode = eleTakesUpSpace;\nelesfn$4.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n    ok: eleVisible,\n    edgeOkViaNode: edgeVisibleViaNode\n}));\nelesfn$4.hidden = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele.visible();\n    }\n};\nelesfn$4.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function() {\n    if (!this.cy().styleEnabled()) {\n        return false;\n    }\n    return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();\n});\nelesfn$4.bypass = elesfn$4.css = elesfn$4.style;\nelesfn$4.renderedCss = elesfn$4.renderedStyle;\nelesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\nelesfn$4.pstyle = elesfn$4.parsedStyle;\nvar elesfn$3 = {};\nfunction defineSwitchFunction(params) {\n    return function() {\n        var args = arguments;\n        var changedEles = [];\n        // e.g. cy.nodes().select( data, handler )\n        if (args.length === 2) {\n            var data = args[0];\n            var handler = args[1];\n            this.on(params.event, data, handler);\n        } else if (args.length === 1 && fn$6(args[0])) {\n            var _handler = args[0];\n            this.on(params.event, _handler);\n        } else if (args.length === 0 || args.length === 1 && array(args[0])) {\n            var addlEvents = args.length === 1 ? args[0] : null;\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var able = !params.ableField || ele._private[params.ableField];\n                var changed = ele._private[params.field] != params.value;\n                if (params.overrideAble) {\n                    var overrideAble = params.overrideAble(ele);\n                    if (overrideAble !== undefined) {\n                        able = overrideAble;\n                        if (!overrideAble) {\n                            return this;\n                        } // to save cycles assume not able for all on override\n                    }\n                }\n                if (able) {\n                    ele._private[params.field] = params.value;\n                    if (changed) {\n                        changedEles.push(ele);\n                    }\n                }\n            }\n            var changedColl = this.spawn(changedEles);\n            changedColl.updateStyle(); // change of state => possible change of style\n            changedColl.emit(params.event);\n            if (addlEvents) {\n                changedColl.emit(addlEvents);\n            }\n        }\n        return this;\n    };\n}\nfunction defineSwitchSet(params) {\n    elesfn$3[params.field] = function() {\n        var ele = this[0];\n        if (ele) {\n            if (params.overrideField) {\n                var val = params.overrideField(ele);\n                if (val !== undefined) {\n                    return val;\n                }\n            }\n            return ele._private[params.field];\n        }\n    };\n    elesfn$3[params.on] = defineSwitchFunction({\n        event: params.on,\n        field: params.field,\n        ableField: params.ableField,\n        overrideAble: params.overrideAble,\n        value: true\n    });\n    elesfn$3[params.off] = defineSwitchFunction({\n        event: params.off,\n        field: params.field,\n        ableField: params.ableField,\n        overrideAble: params.overrideAble,\n        value: false\n    });\n}\ndefineSwitchSet({\n    field: 'locked',\n    overrideField: function overrideField(ele) {\n        return ele.cy().autolock() ? true : undefined;\n    },\n    on: 'lock',\n    off: 'unlock'\n});\ndefineSwitchSet({\n    field: 'grabbable',\n    overrideField: function overrideField(ele) {\n        return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n    },\n    on: 'grabify',\n    off: 'ungrabify'\n});\ndefineSwitchSet({\n    field: 'selected',\n    ableField: 'selectable',\n    overrideAble: function overrideAble(ele) {\n        return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'select',\n    off: 'unselect'\n});\ndefineSwitchSet({\n    field: 'selectable',\n    overrideField: function overrideField(ele) {\n        return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'selectify',\n    off: 'unselectify'\n});\nelesfn$3.deselect = elesfn$3.unselect;\nelesfn$3.grabbed = function() {\n    var ele = this[0];\n    if (ele) {\n        return ele._private.grabbed;\n    }\n};\ndefineSwitchSet({\n    field: 'active',\n    on: 'activate',\n    off: 'unactivate'\n});\ndefineSwitchSet({\n    field: 'pannable',\n    on: 'panify',\n    off: 'unpanify'\n});\nelesfn$3.inactive = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele._private.active;\n    }\n};\nvar elesfn$2 = {};\n// DAG functions\n////////////////\nvar defineDagExtremity = function defineDagExtremity(params) {\n    return function dagExtremityImpl(selector) {\n        var eles = this;\n        var ret = [];\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.isNode()) {\n                continue;\n            }\n            var disqualified = false;\n            var edges = ele.connectedEdges();\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n                    disqualified = true;\n                    break;\n                }\n            }\n            if (!disqualified) {\n                ret.push(ele);\n            }\n        }\n        return this.spawn(ret, true).filter(selector);\n    };\n};\nvar defineDagOneHop = function defineDagOneHop(params) {\n    return function(selector) {\n        var eles = this;\n        var oEles = [];\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.isNode()) {\n                continue;\n            }\n            var edges = ele.connectedEdges();\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                if (params.outgoing && src === ele) {\n                    oEles.push(edge);\n                    oEles.push(tgt);\n                } else if (params.incoming && tgt === ele) {\n                    oEles.push(edge);\n                    oEles.push(src);\n                }\n            }\n        }\n        return this.spawn(oEles, true).filter(selector);\n    };\n};\nvar defineDagAllHops = function defineDagAllHops(params) {\n    return function(selector) {\n        var eles = this;\n        var sEles = [];\n        var sElesIds = {};\n        for(;;){\n            var next = params.outgoing ? eles.outgoers() : eles.incomers();\n            if (next.length === 0) {\n                break;\n            } // done if none left\n            var newNext = false;\n            for(var i = 0; i < next.length; i++){\n                var n = next[i];\n                var nid = n.id();\n                if (!sElesIds[nid]) {\n                    sElesIds[nid] = true;\n                    sEles.push(n);\n                    newNext = true;\n                }\n            }\n            if (!newNext) {\n                break;\n            } // done if touched all outgoers already\n            eles = next;\n        }\n        return this.spawn(sEles, true).filter(selector);\n    };\n};\nelesfn$2.clearTraversalCache = function() {\n    for(var i = 0; i < this.length; i++){\n        this[i]._private.traversalCache = null;\n    }\n};\nextend(elesfn$2, {\n    // get the root nodes in the DAG\n    roots: defineDagExtremity({\n        noIncomingEdges: true\n    }),\n    // get the leaf nodes in the DAG\n    leaves: defineDagExtremity({\n        noOutgoingEdges: true\n    }),\n    // normally called children in graph theory\n    // these nodes =edges=> outgoing nodes\n    outgoers: cache(defineDagOneHop({\n        outgoing: true\n    }), 'outgoers'),\n    // aka DAG descendants\n    successors: defineDagAllHops({\n        outgoing: true\n    }),\n    // normally called parents in graph theory\n    // these nodes <=edges= incoming nodes\n    incomers: cache(defineDagOneHop({\n        incoming: true\n    }), 'incomers'),\n    // aka DAG ancestors\n    predecessors: defineDagAllHops({})\n});\n// Neighbourhood functions\n//////////////////////////\nextend(elesfn$2, {\n    neighborhood: cache(function(selector) {\n        var elements = [];\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            // for all nodes\n            var node = nodes[i];\n            var connectedEdges = node.connectedEdges();\n            // for each connected edge, add the edge and the other node\n            for(var j = 0; j < connectedEdges.length; j++){\n                var edge = connectedEdges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                var otherNode = node === src ? tgt : src;\n                // need check in case of loop\n                if (otherNode.length > 0) {\n                    elements.push(otherNode[0]); // add node 1 hop away\n                }\n                // add connected edge\n                elements.push(edge[0]);\n            }\n        }\n        return this.spawn(elements, true).filter(selector);\n    }, 'neighborhood'),\n    closedNeighborhood: function closedNeighborhood(selector) {\n        return this.neighborhood().add(this).filter(selector);\n    },\n    openNeighborhood: function openNeighborhood(selector) {\n        return this.neighborhood(selector);\n    }\n});\n// aliases\nelesfn$2.neighbourhood = elesfn$2.neighborhood;\nelesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\nelesfn$2.openNeighbourhood = elesfn$2.openNeighborhood;\n// Edge functions\n/////////////////\nextend(elesfn$2, {\n    source: cache(function sourceImpl(selector) {\n        var ele = this[0];\n        var src;\n        if (ele) {\n            src = ele._private.source || ele.cy().collection();\n        }\n        return src && selector ? src.filter(selector) : src;\n    }, 'source'),\n    target: cache(function targetImpl(selector) {\n        var ele = this[0];\n        var tgt;\n        if (ele) {\n            tgt = ele._private.target || ele.cy().collection();\n        }\n        return tgt && selector ? tgt.filter(selector) : tgt;\n    }, 'target'),\n    sources: defineSourceFunction({\n        attr: 'source'\n    }),\n    targets: defineSourceFunction({\n        attr: 'target'\n    })\n});\nfunction defineSourceFunction(params) {\n    return function sourceImpl(selector) {\n        var sources = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var src = ele._private[params.attr];\n            if (src) {\n                sources.push(src);\n            }\n        }\n        return this.spawn(sources, true).filter(selector);\n    };\n}\nextend(elesfn$2, {\n    edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n    edgesTo: cache(defineEdgesWithFunction({\n        thisIsSrc: true\n    }), 'edgesTo')\n});\nfunction defineEdgesWithFunction(params) {\n    return function edgesWithImpl(otherNodes) {\n        var elements = [];\n        var cy = this._private.cy;\n        var p = params || {};\n        // get elements if a selector is specified\n        if (string(otherNodes)) {\n            otherNodes = cy.$(otherNodes);\n        }\n        for(var h = 0; h < otherNodes.length; h++){\n            var edges = otherNodes[h]._private.edges;\n            for(var i = 0; i < edges.length; i++){\n                var edge = edges[i];\n                var edgeData = edge._private.data;\n                var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n                var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n                var edgeConnectsThisAndOther = thisToOther || otherToThis;\n                if (!edgeConnectsThisAndOther) {\n                    continue;\n                }\n                if (p.thisIsSrc || p.thisIsTgt) {\n                    if (p.thisIsSrc && !thisToOther) {\n                        continue;\n                    }\n                    if (p.thisIsTgt && !otherToThis) {\n                        continue;\n                    }\n                }\n                elements.push(edge);\n            }\n        }\n        return this.spawn(elements, true);\n    };\n}\nextend(elesfn$2, {\n    connectedEdges: cache(function(selector) {\n        var retEles = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var node = eles[i];\n            if (!node.isNode()) {\n                continue;\n            }\n            var edges = node._private.edges;\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                retEles.push(edge);\n            }\n        }\n        return this.spawn(retEles, true).filter(selector);\n    }, 'connectedEdges'),\n    connectedNodes: cache(function(selector) {\n        var retEles = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var edge = eles[i];\n            if (!edge.isEdge()) {\n                continue;\n            }\n            retEles.push(edge.source()[0]);\n            retEles.push(edge.target()[0]);\n        }\n        return this.spawn(retEles, true).filter(selector);\n    }, 'connectedNodes'),\n    parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n    codirectedEdges: cache(defineParallelEdgesFunction({\n        codirected: true\n    }), 'codirectedEdges')\n});\nfunction defineParallelEdgesFunction(params) {\n    var defaults = {\n        codirected: false\n    };\n    params = extend({}, defaults, params);\n    return function parallelEdgesImpl(selector) {\n        // micro-optimised for renderer\n        var elements = [];\n        var edges = this.edges();\n        var p = params;\n        // look at all the edges in the collection\n        for(var i = 0; i < edges.length; i++){\n            var edge1 = edges[i];\n            var edge1_p = edge1._private;\n            var src1 = edge1_p.source;\n            var srcid1 = src1._private.data.id;\n            var tgtid1 = edge1_p.data.target;\n            var srcEdges1 = src1._private.edges;\n            // look at edges connected to the src node of this edge\n            for(var j = 0; j < srcEdges1.length; j++){\n                var edge2 = srcEdges1[j];\n                var edge2data = edge2._private.data;\n                var tgtid2 = edge2data.target;\n                var srcid2 = edge2data.source;\n                var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n                var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n                if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n                    elements.push(edge2);\n                }\n            }\n        }\n        return this.spawn(elements, true).filter(selector);\n    };\n}\n// Misc functions\n/////////////////\nextend(elesfn$2, {\n    components: function components(root) {\n        var self1 = this;\n        var cy = self1.cy();\n        var visited = cy.collection();\n        var unvisited = root == null ? self1.nodes() : root.nodes();\n        var components = [];\n        if (root != null && unvisited.empty()) {\n            // root may contain only edges\n            unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n        }\n        var visitInComponent = function visitInComponent(node, component) {\n            visited.merge(node);\n            unvisited.unmerge(node);\n            component.merge(node);\n        };\n        if (unvisited.empty()) {\n            return self1.spawn();\n        }\n        var _loop = function _loop() {\n            // each iteration yields a component\n            var cmpt = cy.collection();\n            components.push(cmpt);\n            var root = unvisited[0];\n            visitInComponent(root, cmpt);\n            self1.bfs({\n                directed: false,\n                roots: root,\n                visit: function visit(v) {\n                    return visitInComponent(v, cmpt);\n                }\n            });\n            cmpt.forEach(function(node) {\n                node.connectedEdges().forEach(function(e) {\n                    // connectedEdges() usually cached\n                    if (self1.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n                        // has() is cheap\n                        cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n                    }\n                });\n            });\n        };\n        do {\n            _loop();\n        }while (unvisited.length > 0);\n        return components;\n    },\n    component: function component() {\n        var ele = this[0];\n        return ele.cy().mutableElements().components(ele)[0];\n    }\n});\nelesfn$2.componentsOf = elesfn$2.components;\n// represents a set of nodes, edges, or both together\nvar Collection = function Collection(cy, elements) {\n    var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (cy === undefined) {\n        error('A collection must have a reference to the core');\n        return;\n    }\n    var map = new Map$1();\n    var createdElements = false;\n    if (!elements) {\n        elements = [];\n    } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n        createdElements = true;\n        // make elements from json and restore all at once later\n        var eles = [];\n        var elesIds = new Set$1();\n        for(var i = 0, l = elements.length; i < l; i++){\n            var json = elements[i];\n            if (json.data == null) {\n                json.data = {};\n            }\n            var _data = json.data;\n            // make sure newly created elements have valid ids\n            if (_data.id == null) {\n                _data.id = uuid();\n            } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n                continue; // can't create element if prior id already exists\n            }\n            var ele = new Element(cy, json, false);\n            eles.push(ele);\n            elesIds.add(_data.id);\n        }\n        elements = eles;\n    }\n    this.length = 0;\n    for(var _i = 0, _l = elements.length; _i < _l; _i++){\n        var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n        if (element$1 == null) {\n            continue;\n        }\n        var id = element$1._private.data.id;\n        if (!unique || !map.has(id)) {\n            if (unique) {\n                map.set(id, {\n                    index: this.length,\n                    ele: element$1\n                });\n            }\n            this[this.length] = element$1;\n            this.length++;\n        }\n    }\n    this._private = {\n        eles: this,\n        cy: cy,\n        get map () {\n            if (this.lazyMap == null) {\n                this.rebuildMap();\n            }\n            return this.lazyMap;\n        },\n        set map (m){\n            this.lazyMap = m;\n        },\n        rebuildMap: function rebuildMap() {\n            var m1 = this.lazyMap = new Map$1();\n            var eles = this.eles;\n            for(var _i2 = 0; _i2 < eles.length; _i2++){\n                var _ele = eles[_i2];\n                m1.set(_ele.id(), {\n                    index: _i2,\n                    ele: _ele\n                });\n            }\n        }\n    };\n    if (unique) {\n        this._private.map = map;\n    }\n    // restore the elements if we created them from json\n    if (createdElements && !removed) {\n        this.restore();\n    }\n};\n// Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\nvar elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\nelesfn$1.instanceString = function() {\n    return 'collection';\n};\nelesfn$1.spawn = function(eles, unique) {\n    return new Collection(this.cy(), eles, unique);\n};\nelesfn$1.spawnSelf = function() {\n    return this.spawn(this);\n};\nelesfn$1.cy = function() {\n    return this._private.cy;\n};\nelesfn$1.renderer = function() {\n    return this._private.cy.renderer();\n};\nelesfn$1.element = function() {\n    return this[0];\n};\nelesfn$1.collection = function() {\n    if (collection(this)) {\n        return this;\n    } else {\n        // an element\n        return new Collection(this._private.cy, [\n            this\n        ]);\n    }\n};\nelesfn$1.unique = function() {\n    return new Collection(this._private.cy, this, true);\n};\nelesfn$1.hasElementWithId = function(id) {\n    id = '' + id; // id must be string\n    return this._private.map.has(id);\n};\nelesfn$1.getElementById = function(id) {\n    id = '' + id; // id must be string\n    var cy = this._private.cy;\n    var entry = this._private.map.get(id);\n    return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n};\nelesfn$1.$id = elesfn$1.getElementById;\nelesfn$1.poolIndex = function() {\n    var cy = this._private.cy;\n    var eles = cy._private.elements;\n    var id = this[0]._private.data.id;\n    return eles._private.map.get(id).index;\n};\nelesfn$1.indexOf = function(ele) {\n    var id = ele[0]._private.data.id;\n    return this._private.map.get(id).index;\n};\nelesfn$1.indexOfId = function(id) {\n    id = '' + id; // id must be string\n    return this._private.map.get(id).index;\n};\nelesfn$1.json = function(obj) {\n    var ele = this.element();\n    var cy = this.cy();\n    if (ele == null && obj) {\n        return this;\n    } // can't set to no eles\n    if (ele == null) {\n        return undefined;\n    } // can't get from no eles\n    var p = ele._private;\n    if (plainObject(obj)) {\n        // set\n        cy.startBatch();\n        if (obj.data) {\n            ele.data(obj.data);\n            var _data2 = p.data;\n            if (ele.isEdge()) {\n                // source and target are immutable via data()\n                var move = false;\n                var spec = {};\n                var src = obj.data.source;\n                var tgt = obj.data.target;\n                if (src != null && src != _data2.source) {\n                    spec.source = '' + src; // id must be string\n                    move = true;\n                }\n                if (tgt != null && tgt != _data2.target) {\n                    spec.target = '' + tgt; // id must be string\n                    move = true;\n                }\n                if (move) {\n                    ele = ele.move(spec);\n                }\n            } else {\n                // parent is immutable via data()\n                var newParentValSpecd = 'parent' in obj.data;\n                var parent = obj.data.parent;\n                if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n                    if (parent === undefined) {\n                        // can't set undefined imperatively, so use null\n                        parent = null;\n                    }\n                    if (parent != null) {\n                        parent = '' + parent; // id must be string\n                    }\n                    ele = ele.move({\n                        parent: parent\n                    });\n                }\n            }\n        }\n        if (obj.position) {\n            ele.position(obj.position);\n        }\n        // ignore group -- immutable\n        var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n            var obj_k = obj[k];\n            if (obj_k != null && obj_k !== p[k]) {\n                if (obj_k) {\n                    ele[trueFnName]();\n                } else {\n                    ele[falseFnName]();\n                }\n            }\n        };\n        checkSwitch('removed', 'remove', 'restore');\n        checkSwitch('selected', 'select', 'unselect');\n        checkSwitch('selectable', 'selectify', 'unselectify');\n        checkSwitch('locked', 'lock', 'unlock');\n        checkSwitch('grabbable', 'grabify', 'ungrabify');\n        checkSwitch('pannable', 'panify', 'unpanify');\n        if (obj.classes != null) {\n            ele.classes(obj.classes);\n        }\n        cy.endBatch();\n        return this;\n    } else if (obj === undefined) {\n        // get\n        var json = {\n            data: copy(p.data),\n            position: copy(p.position),\n            group: p.group,\n            removed: p.removed,\n            selected: p.selected,\n            selectable: p.selectable,\n            locked: p.locked,\n            grabbable: p.grabbable,\n            pannable: p.pannable,\n            classes: null\n        };\n        json.classes = '';\n        var i = 0;\n        p.classes.forEach(function(cls) {\n            return json.classes += i++ === 0 ? cls : ' ' + cls;\n        });\n        return json;\n    }\n};\nelesfn$1.jsons = function() {\n    var jsons = [];\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var json = ele.json();\n        jsons.push(json);\n    }\n    return jsons;\n};\nelesfn$1.clone = function() {\n    var cy = this.cy();\n    var elesArr = [];\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var json = ele.json();\n        var clone = new Element(cy, json, false); // NB no restore\n        elesArr.push(clone);\n    }\n    return new Collection(cy, elesArr);\n};\nelesfn$1.copy = elesfn$1.clone;\nelesfn$1.restore = function() {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self1 = this;\n    var cy = self1.cy();\n    var cy_p = cy._private;\n    // create arrays of nodes and edges, since we need to\n    // restore the nodes first\n    var nodes = [];\n    var edges = [];\n    var elements;\n    for(var _i3 = 0, l = self1.length; _i3 < l; _i3++){\n        var ele = self1[_i3];\n        if (addToPool && !ele.removed()) {\n            continue;\n        }\n        // keep nodes first in the array and edges after\n        if (ele.isNode()) {\n            // put to front of array if node\n            nodes.push(ele);\n        } else {\n            // put to end of array if edge\n            edges.push(ele);\n        }\n    }\n    elements = nodes.concat(edges);\n    var i;\n    var removeFromElements = function removeFromElements() {\n        elements.splice(i, 1);\n        i--;\n    };\n    // now, restore each element\n    for(i = 0; i < elements.length; i++){\n        var _ele2 = elements[i];\n        var _private = _ele2._private;\n        var _data3 = _private.data;\n        // the traversal cache should start fresh when ele is added\n        _ele2.clearTraversalCache();\n        // set id and validate\n        if (!addToPool && !_private.removed) ;\n        else if (_data3.id === undefined) {\n            _data3.id = uuid();\n        } else if (number$1(_data3.id)) {\n            _data3.id = '' + _data3.id; // now it's a string\n        } else if (emptyString(_data3.id) || !string(_data3.id)) {\n            error('Can not create element with invalid string ID `' + _data3.id + '`');\n            // can't create element if it has empty string as id or non-string id\n            removeFromElements();\n            continue;\n        } else if (cy.hasElementWithId(_data3.id)) {\n            error('Can not create second element with ID `' + _data3.id + '`');\n            // can't create element if one already has that id\n            removeFromElements();\n            continue;\n        }\n        var id = _data3.id; // id is finalised, now let's keep a ref\n        if (_ele2.isNode()) {\n            // extra checks for nodes\n            var pos = _private.position;\n            // make sure the nodes have a defined position\n            if (pos.x == null) {\n                pos.x = 0;\n            }\n            if (pos.y == null) {\n                pos.y = 0;\n            }\n        }\n        if (_ele2.isEdge()) {\n            // extra checks for edges\n            var edge = _ele2;\n            var fields = [\n                'source',\n                'target'\n            ];\n            var fieldsLength = fields.length;\n            var badSourceOrTarget = false;\n            for(var j = 0; j < fieldsLength; j++){\n                var field = fields[j];\n                var val = _data3[field];\n                if (number$1(val)) {\n                    val = _data3[field] = '' + _data3[field]; // now string\n                }\n                if (val == null || val === '') {\n                    // can't create if source or target is not defined properly\n                    error('Can not create edge `' + id + '` with unspecified ' + field);\n                    badSourceOrTarget = true;\n                } else if (!cy.hasElementWithId(val)) {\n                    // can't create edge if one of its nodes doesn't exist\n                    error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n                    badSourceOrTarget = true;\n                }\n            }\n            if (badSourceOrTarget) {\n                removeFromElements();\n                continue;\n            } // can't create this\n            var src = cy.getElementById(_data3.source);\n            var tgt = cy.getElementById(_data3.target);\n            // only one edge in node if loop\n            if (src.same(tgt)) {\n                src._private.edges.push(edge);\n            } else {\n                src._private.edges.push(edge);\n                tgt._private.edges.push(edge);\n            }\n            edge._private.source = src;\n            edge._private.target = tgt;\n        } // if is edge\n        // create mock ids / indexes maps for element so it can be used like collections\n        _private.map = new Map$1();\n        _private.map.set(id, {\n            ele: _ele2,\n            index: 0\n        });\n        _private.removed = false;\n        if (addToPool) {\n            cy.addToPool(_ele2);\n        }\n    } // for each element\n    // do compound node sanity checks\n    for(var _i4 = 0; _i4 < nodes.length; _i4++){\n        // each node\n        var node = nodes[_i4];\n        var _data4 = node._private.data;\n        if (number$1(_data4.parent)) {\n            // then automake string\n            _data4.parent = '' + _data4.parent;\n        }\n        var parentId = _data4.parent;\n        var specifiedParent = parentId != null;\n        if (specifiedParent || node._private.parent) {\n            var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n            if (parent.empty()) {\n                // non-existant parent; just remove it\n                _data4.parent = undefined;\n            } else if (parent[0].removed()) {\n                warn('Node added with missing parent, reference to parent removed');\n                _data4.parent = undefined;\n                node._private.parent = null;\n            } else {\n                var selfAsParent = false;\n                var ancestor = parent;\n                while(!ancestor.empty()){\n                    if (node.same(ancestor)) {\n                        // mark self as parent and remove from data\n                        selfAsParent = true;\n                        _data4.parent = undefined; // remove parent reference\n                        break;\n                    }\n                    ancestor = ancestor.parent();\n                }\n                if (!selfAsParent) {\n                    // connect with children\n                    parent[0]._private.children.push(node);\n                    node._private.parent = parent[0];\n                    // let the core know we have a compound graph\n                    cy_p.hasCompoundNodes = true;\n                }\n            } // else\n        } // if specified parent\n    } // for each node\n    if (elements.length > 0) {\n        var restored = elements.length === self1.length ? self1 : new Collection(cy, elements);\n        for(var _i5 = 0; _i5 < restored.length; _i5++){\n            var _ele3 = restored[_i5];\n            if (_ele3.isNode()) {\n                continue;\n            }\n            // adding an edge invalidates the traversal caches for the parallel edges\n            _ele3.parallelEdges().clearTraversalCache();\n            // adding an edge invalidates the traversal cache for the connected nodes\n            _ele3.source().clearTraversalCache();\n            _ele3.target().clearTraversalCache();\n        }\n        var toUpdateStyle;\n        if (cy_p.hasCompoundNodes) {\n            toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n        } else {\n            toUpdateStyle = restored;\n        }\n        toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n        if (notifyRenderer) {\n            restored.emitAndNotify('add');\n        } else if (addToPool) {\n            restored.emit('add');\n        }\n    }\n    return self1; // chainability\n};\nelesfn$1.removed = function() {\n    var ele = this[0];\n    return ele && ele._private.removed;\n};\nelesfn$1.inside = function() {\n    var ele = this[0];\n    return ele && !ele._private.removed;\n};\nelesfn$1.remove = function() {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self1 = this;\n    var elesToRemove = [];\n    var elesToRemoveIds = {};\n    var cy = self1._private.cy;\n    // add connected edges\n    function addConnectedEdges(node) {\n        var edges = node._private.edges;\n        for(var i = 0; i < edges.length; i++){\n            add(edges[i]);\n        }\n    }\n    // add descendant nodes\n    function addChildren(node) {\n        var children = node._private.children;\n        for(var i = 0; i < children.length; i++){\n            add(children[i]);\n        }\n    }\n    function add(ele) {\n        var alreadyAdded = elesToRemoveIds[ele.id()];\n        if (removeFromPool && ele.removed() || alreadyAdded) {\n            return;\n        } else {\n            elesToRemoveIds[ele.id()] = true;\n        }\n        if (ele.isNode()) {\n            elesToRemove.push(ele); // nodes are removed last\n            addConnectedEdges(ele);\n            addChildren(ele);\n        } else {\n            elesToRemove.unshift(ele); // edges are removed first\n        }\n    }\n    // make the list of elements to remove\n    // (may be removing more than specified due to connected edges etc)\n    for(var i = 0, l = self1.length; i < l; i++){\n        var ele = self1[i];\n        add(ele);\n    }\n    function removeEdgeRef(node, edge) {\n        var connectedEdges = node._private.edges;\n        removeFromArray(connectedEdges, edge);\n        // removing an edges invalidates the traversal cache for its nodes\n        node.clearTraversalCache();\n    }\n    function removeParallelRef(pllEdge) {\n        // removing an edge invalidates the traversal caches for the parallel edges\n        pllEdge.clearTraversalCache();\n    }\n    var alteredParents = [];\n    alteredParents.ids = {};\n    function removeChildRef(parent, ele) {\n        ele = ele[0];\n        parent = parent[0];\n        var children = parent._private.children;\n        var pid = parent.id();\n        removeFromArray(children, ele); // remove parent => child ref\n        ele._private.parent = null; // remove child => parent ref\n        if (!alteredParents.ids[pid]) {\n            alteredParents.ids[pid] = true;\n            alteredParents.push(parent);\n        }\n    }\n    self1.dirtyCompoundBoundsCache();\n    if (removeFromPool) {\n        cy.removeFromPool(elesToRemove); // remove from core pool\n    }\n    for(var _i6 = 0; _i6 < elesToRemove.length; _i6++){\n        var _ele4 = elesToRemove[_i6];\n        if (_ele4.isEdge()) {\n            // remove references to this edge in its connected nodes\n            var src = _ele4.source()[0];\n            var tgt = _ele4.target()[0];\n            removeEdgeRef(src, _ele4);\n            removeEdgeRef(tgt, _ele4);\n            var pllEdges = _ele4.parallelEdges();\n            for(var j = 0; j < pllEdges.length; j++){\n                var pllEdge = pllEdges[j];\n                removeParallelRef(pllEdge);\n                if (pllEdge.isBundledBezier()) {\n                    pllEdge.dirtyBoundingBoxCache();\n                }\n            }\n        } else {\n            // remove reference to parent\n            var parent = _ele4.parent();\n            if (parent.length !== 0) {\n                removeChildRef(parent, _ele4);\n            }\n        }\n        if (removeFromPool) {\n            // mark as removed\n            _ele4._private.removed = true;\n        }\n    }\n    // check to see if we have a compound graph or not\n    var elesStillInside = cy._private.elements;\n    cy._private.hasCompoundNodes = false;\n    for(var _i7 = 0; _i7 < elesStillInside.length; _i7++){\n        var _ele5 = elesStillInside[_i7];\n        if (_ele5.isParent()) {\n            cy._private.hasCompoundNodes = true;\n            break;\n        }\n    }\n    var removedElements = new Collection(this.cy(), elesToRemove);\n    if (removedElements.size() > 0) {\n        // must manually notify since trigger won't do this automatically once removed\n        if (notifyRenderer) {\n            removedElements.emitAndNotify('remove');\n        } else if (removeFromPool) {\n            removedElements.emit('remove');\n        }\n    }\n    // the parents who were modified by the removal need their style updated\n    for(var _i8 = 0; _i8 < alteredParents.length; _i8++){\n        var _ele6 = alteredParents[_i8];\n        if (!removeFromPool || !_ele6.removed()) {\n            _ele6.updateStyle();\n        }\n    }\n    return removedElements;\n};\nelesfn$1.move = function(struct) {\n    var cy = this._private.cy;\n    var eles = this;\n    // just clean up refs, caches, etc. in the same way as when removing and then restoring\n    // (our calls to remove/restore do not remove from the graph or make events)\n    var notifyRenderer = false;\n    var modifyPool = false;\n    var toString = function toString(id) {\n        return id == null ? id : '' + id;\n    }; // id must be string\n    if (struct.source !== undefined || struct.target !== undefined) {\n        var srcId = toString(struct.source);\n        var tgtId = toString(struct.target);\n        var srcExists = srcId != null && cy.hasElementWithId(srcId);\n        var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n        if (srcExists || tgtExists) {\n            cy.batch(function() {\n                // avoid duplicate style updates\n                eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                eles.emitAndNotify('moveout');\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _data5 = ele._private.data;\n                    if (ele.isEdge()) {\n                        if (srcExists) {\n                            _data5.source = srcId;\n                        }\n                        if (tgtExists) {\n                            _data5.target = tgtId;\n                        }\n                    }\n                }\n                eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n            });\n            eles.emitAndNotify('move');\n        }\n    } else if (struct.parent !== undefined) {\n        // move node to new parent\n        var parentId = toString(struct.parent);\n        var parentExists = parentId === null || cy.hasElementWithId(parentId);\n        if (parentExists) {\n            var pidToAssign = parentId === null ? undefined : parentId;\n            cy.batch(function() {\n                // avoid duplicate style updates\n                var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                updated.emitAndNotify('moveout');\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _data6 = ele._private.data;\n                    if (ele.isNode()) {\n                        _data6.parent = pidToAssign;\n                    }\n                }\n                updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n            });\n            eles.emitAndNotify('move');\n        }\n    }\n    return this;\n};\n[\n    elesfn$j,\n    elesfn$i,\n    elesfn$h,\n    elesfn$g,\n    elesfn$f,\n    data,\n    elesfn$d,\n    dimensions,\n    elesfn$9,\n    elesfn$8,\n    elesfn$7,\n    elesfn$6,\n    elesfn$5,\n    elesfn$4,\n    elesfn$3,\n    elesfn$2\n].forEach(function(props) {\n    extend(elesfn$1, props);\n});\nvar corefn$9 = {\n    add: function add(opts) {\n        var elements;\n        var cy = this;\n        // add the elements\n        if (elementOrCollection(opts)) {\n            var eles = opts;\n            if (eles._private.cy === cy) {\n                // same instance => just restore\n                elements = eles.restore();\n            } else {\n                // otherwise, copy from json\n                var jsons = [];\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    jsons.push(ele.json());\n                }\n                elements = new Collection(cy, jsons);\n            }\n        } else if (array(opts)) {\n            var _jsons = opts;\n            elements = new Collection(cy, _jsons);\n        } else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n            var elesByGroup = opts;\n            var _jsons2 = [];\n            var grs = [\n                'nodes',\n                'edges'\n            ];\n            for(var _i = 0, il = grs.length; _i < il; _i++){\n                var group = grs[_i];\n                var elesArray = elesByGroup[group];\n                if (array(elesArray)) {\n                    for(var j = 0, jl = elesArray.length; j < jl; j++){\n                        var json = extend({\n                            group: group\n                        }, elesArray[j]);\n                        _jsons2.push(json);\n                    }\n                }\n            }\n            elements = new Collection(cy, _jsons2);\n        } else {\n            var _json = opts;\n            elements = new Element(cy, _json).collection();\n        }\n        return elements;\n    },\n    remove: function remove(collection) {\n        if (elementOrCollection(collection)) ;\n        else if (string(collection)) {\n            var selector = collection;\n            collection = this.$(selector);\n        }\n        return collection.remove();\n    }\n};\n/* global Float32Array */ /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */ function generateCubicBezier(mX1, mY1, mX2, mY2) {\n    var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 0.001, SUBDIVISION_PRECISION = 0.0000001, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1.0 / (kSplineTableSize - 1.0), float32ArraySupported = typeof Float32Array !== 'undefined';\n    /* Must contain four arguments. */ if (arguments.length !== 4) {\n        return false;\n    }\n    /* Arguments must be numbers. */ for(var i = 0; i < 4; ++i){\n        if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n            return false;\n        }\n    }\n    /* X values must be in the [0, 1] range. */ mX1 = Math.min(mX1, 1);\n    mX2 = Math.min(mX2, 1);\n    mX1 = Math.max(mX1, 0);\n    mX2 = Math.max(mX2, 0);\n    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    function A(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n    function B(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n    }\n    function C(aA1) {\n        return 3.0 * aA1;\n    }\n    function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n    function getSlope(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n    function newtonRaphsonIterate(aX, aGuessT) {\n        for(var _i = 0; _i < NEWTON_ITERATIONS; ++_i){\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function calcSampleValues() {\n        for(var _i2 = 0; _i2 < kSplineTableSize; ++_i2){\n            mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function binarySubdivide(aX, aA, aB) {\n        var currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n    }\n    function getTForX(aX) {\n        var intervalStart = 0.0, currentSample = 1, lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n        }\n    }\n    var _precomputed = false;\n    function precompute() {\n        _precomputed = true;\n        if (mX1 !== mY1 || mX2 !== mY2) {\n            calcSampleValues();\n        }\n    }\n    var f = function f(aX) {\n        if (!_precomputed) {\n            precompute();\n        }\n        if (mX1 === mY1 && mX2 === mY2) {\n            return aX;\n        }\n        if (aX === 0) {\n            return 0;\n        }\n        if (aX === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(aX), mY1, mY2);\n    };\n    f.getControlPoints = function() {\n        return [\n            {\n                x: mX1,\n                y: mY1\n            },\n            {\n                x: mX2,\n                y: mY2\n            }\n        ];\n    };\n    var str = \"generateBezier(\" + [\n        mX1,\n        mY1,\n        mX2,\n        mY2\n    ] + \")\";\n    f.toString = function() {\n        return str;\n    };\n    return f;\n}\n/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */ /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */ var generateSpringRK4 = function() {\n    function springAccelerationForState(state) {\n        return -state.tension * state.x - state.friction * state.v;\n    }\n    function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n        var state = {\n            x: initialState.x + derivative.dx * dt,\n            v: initialState.v + derivative.dv * dt,\n            tension: initialState.tension,\n            friction: initialState.friction\n        };\n        return {\n            dx: state.v,\n            dv: springAccelerationForState(state)\n        };\n    }\n    function springIntegrateState(state, dt) {\n        var a = {\n            dx: state.v,\n            dv: springAccelerationForState(state)\n        }, b = springEvaluateStateWithDerivative(state, dt * 0.5, a), c = springEvaluateStateWithDerivative(state, dt * 0.5, b), d = springEvaluateStateWithDerivative(state, dt, c), dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx), dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n        state.x = state.x + dxdt * dt;\n        state.v = state.v + dvdt * dt;\n        return state;\n    }\n    return function springRK4Factory(tension, friction, duration) {\n        var initState = {\n            x: -1,\n            v: 0,\n            tension: null,\n            friction: null\n        }, path = [\n            0\n        ], time_lapsed = 0, tolerance = 1 / 10000, DT = 16 / 1000, have_duration, dt, last_state;\n        tension = parseFloat(tension) || 500;\n        friction = parseFloat(friction) || 20;\n        duration = duration || null;\n        initState.tension = tension;\n        initState.friction = friction;\n        have_duration = duration !== null;\n        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */ if (have_duration) {\n            /* Run the simulation without a duration. */ time_lapsed = springRK4Factory(tension, friction);\n            /* Compute the adjusted time delta. */ dt = time_lapsed / duration * DT;\n        } else {\n            dt = DT;\n        }\n        for(;;){\n            /* Next/step function .*/ last_state = springIntegrateState(last_state || initState, dt);\n            /* Store the position. */ path.push(1 + last_state.x);\n            time_lapsed += 16;\n            /* If the change threshold is reached, break. */ if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n                break;\n            }\n        }\n        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n       computed path and returns a snapshot of the position according to a given percentComplete. */ return !have_duration ? time_lapsed : function(percentComplete) {\n            return path[percentComplete * (path.length - 1) | 0];\n        };\n    };\n}();\nvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n    var bezier = generateCubicBezier(t1, p1, t2, p2);\n    return function(start, end, percent) {\n        return start + (end - start) * bezier(percent);\n    };\n};\nvar easings = {\n    'linear': function linear(start, end, percent) {\n        return start + (end - start) * percent;\n    },\n    // default easings\n    'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n    'ease-in': cubicBezier(0.42, 0, 1, 1),\n    'ease-out': cubicBezier(0, 0, 0.58, 1),\n    'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n    // sine\n    'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n    'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n    'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n    // quad\n    'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n    'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n    'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n    // cubic\n    'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n    'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n    'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n    // quart\n    'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n    'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n    'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n    // quint\n    'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n    'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n    'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n    // expo\n    'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n    'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n    'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n    // circ\n    'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n    'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n    'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n    // user param easings...\n    'spring': function spring(tension, friction, duration) {\n        if (duration === 0) {\n            // can't get a spring w/ duration 0\n            return easings.linear; // duration 0 => jump to end so impl doesn't matter\n        }\n        var spring = generateSpringRK4(tension, friction, duration);\n        return function(start, end, percent) {\n            return start + (end - start) * spring(percent);\n        };\n    },\n    'cubic-bezier': cubicBezier\n};\nfunction getEasedValue(type, start, end, percent, easingFn) {\n    if (percent === 1) {\n        return end;\n    }\n    if (start === end) {\n        return end;\n    }\n    var val = easingFn(start, end, percent);\n    if (type == null) {\n        return val;\n    }\n    if (type.roundValue || type.color) {\n        val = Math.round(val);\n    }\n    if (type.min !== undefined) {\n        val = Math.max(val, type.min);\n    }\n    if (type.max !== undefined) {\n        val = Math.min(val, type.max);\n    }\n    return val;\n}\nfunction getValue(prop, spec) {\n    if (prop.pfValue != null || prop.value != null) {\n        if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {\n            return prop.pfValue;\n        } else {\n            return prop.value;\n        }\n    } else {\n        return prop;\n    }\n}\nfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n    var type = propSpec != null ? propSpec.type : null;\n    if (percent < 0) {\n        percent = 0;\n    } else if (percent > 1) {\n        percent = 1;\n    }\n    var start = getValue(startProp, propSpec);\n    var end = getValue(endProp, propSpec);\n    if (number$1(start) && number$1(end)) {\n        return getEasedValue(type, start, end, percent, easingFn);\n    } else if (array(start) && array(end)) {\n        var easedArr = [];\n        for(var i = 0; i < end.length; i++){\n            var si = start[i];\n            var ei = end[i];\n            if (si != null && ei != null) {\n                var val = getEasedValue(type, si, ei, percent, easingFn);\n                easedArr.push(val);\n            } else {\n                easedArr.push(ei);\n            }\n        }\n        return easedArr;\n    }\n    return undefined;\n}\nfunction step$1(self1, ani, now, isCore) {\n    var isEles = !isCore;\n    var _p = self1._private;\n    var ani_p = ani._private;\n    var pEasing = ani_p.easing;\n    var startTime = ani_p.startTime;\n    var cy = isCore ? self1 : self1.cy();\n    var style = cy.style();\n    if (!ani_p.easingImpl) {\n        if (pEasing == null) {\n            // use default\n            ani_p.easingImpl = easings['linear'];\n        } else {\n            // then define w/ name\n            var easingVals;\n            if (string(pEasing)) {\n                var easingProp = style.parse('transition-timing-function', pEasing);\n                easingVals = easingProp.value;\n            } else {\n                // then assume preparsed array\n                easingVals = pEasing;\n            }\n            var name, args;\n            if (string(easingVals)) {\n                name = easingVals;\n                args = [];\n            } else {\n                name = easingVals[1];\n                args = easingVals.slice(2).map(function(n) {\n                    return +n;\n                });\n            }\n            if (args.length > 0) {\n                // create with args\n                if (name === 'spring') {\n                    args.push(ani_p.duration); // need duration to generate spring\n                }\n                ani_p.easingImpl = easings[name].apply(null, args);\n            } else {\n                // static impl by name\n                ani_p.easingImpl = easings[name];\n            }\n        }\n    }\n    var easing = ani_p.easingImpl;\n    var percent;\n    if (ani_p.duration === 0) {\n        percent = 1;\n    } else {\n        percent = (now - startTime) / ani_p.duration;\n    }\n    if (ani_p.applying) {\n        percent = ani_p.progress;\n    }\n    if (percent < 0) {\n        percent = 0;\n    } else if (percent > 1) {\n        percent = 1;\n    }\n    if (ani_p.delay == null) {\n        // then update\n        var startPos = ani_p.startPosition;\n        var endPos = ani_p.position;\n        if (endPos && isEles && !self1.locked()) {\n            var newPos = {};\n            if (valid(startPos.x, endPos.x)) {\n                newPos.x = ease(startPos.x, endPos.x, percent, easing);\n            }\n            if (valid(startPos.y, endPos.y)) {\n                newPos.y = ease(startPos.y, endPos.y, percent, easing);\n            }\n            self1.position(newPos);\n        }\n        var startPan = ani_p.startPan;\n        var endPan = ani_p.pan;\n        var pan = _p.pan;\n        var animatingPan = endPan != null && isCore;\n        if (animatingPan) {\n            if (valid(startPan.x, endPan.x)) {\n                pan.x = ease(startPan.x, endPan.x, percent, easing);\n            }\n            if (valid(startPan.y, endPan.y)) {\n                pan.y = ease(startPan.y, endPan.y, percent, easing);\n            }\n            self1.emit('pan');\n        }\n        var startZoom = ani_p.startZoom;\n        var endZoom = ani_p.zoom;\n        var animatingZoom = endZoom != null && isCore;\n        if (animatingZoom) {\n            if (valid(startZoom, endZoom)) {\n                _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n            }\n            self1.emit('zoom');\n        }\n        if (animatingPan || animatingZoom) {\n            self1.emit('viewport');\n        }\n        var props = ani_p.style;\n        if (props && props.length > 0 && isEles) {\n            for(var i = 0; i < props.length; i++){\n                var prop = props[i];\n                var _name = prop.name;\n                var end = prop;\n                var start = ani_p.startStyle[_name];\n                var propSpec = style.properties[start.name];\n                var easedVal = ease(start, end, percent, easing, propSpec);\n                style.overrideBypass(self1, _name, easedVal);\n            } // for props\n            self1.emit('style');\n        } // if\n    }\n    ani_p.progress = percent;\n    return percent;\n}\nfunction valid(start, end) {\n    if (start == null || end == null) {\n        return false;\n    }\n    if (number$1(start) && number$1(end)) {\n        return true;\n    } else if (start && end) {\n        return true;\n    }\n    return false;\n}\nfunction startAnimation(self1, ani, now, isCore) {\n    var ani_p = ani._private;\n    ani_p.started = true;\n    ani_p.startTime = now - ani_p.progress * ani_p.duration;\n}\nfunction stepAll(now, cy) {\n    var eles = cy._private.aniEles;\n    var doneEles = [];\n    function stepOne(ele, isCore) {\n        var _p = ele._private;\n        var current = _p.animation.current;\n        var queue = _p.animation.queue;\n        var ranAnis = false;\n        // if nothing currently animating, get something from the queue\n        if (current.length === 0) {\n            var next = queue.shift();\n            if (next) {\n                current.push(next);\n            }\n        }\n        var callbacks = function callbacks(_callbacks) {\n            for(var j = _callbacks.length - 1; j >= 0; j--){\n                var cb = _callbacks[j];\n                cb();\n            }\n            _callbacks.splice(0, _callbacks.length);\n        };\n        // step and remove if done\n        for(var i = current.length - 1; i >= 0; i--){\n            var ani = current[i];\n            var ani_p = ani._private;\n            if (ani_p.stopped) {\n                current.splice(i, 1);\n                ani_p.hooked = false;\n                ani_p.playing = false;\n                ani_p.started = false;\n                callbacks(ani_p.frames);\n                continue;\n            }\n            if (!ani_p.playing && !ani_p.applying) {\n                continue;\n            }\n            // an apply() while playing shouldn't do anything\n            if (ani_p.playing && ani_p.applying) {\n                ani_p.applying = false;\n            }\n            if (!ani_p.started) {\n                startAnimation(ele, ani, now);\n            }\n            step$1(ele, ani, now, isCore);\n            if (ani_p.applying) {\n                ani_p.applying = false;\n            }\n            callbacks(ani_p.frames);\n            if (ani_p.step != null) {\n                ani_p.step(now);\n            }\n            if (ani.completed()) {\n                current.splice(i, 1);\n                ani_p.hooked = false;\n                ani_p.playing = false;\n                ani_p.started = false;\n                callbacks(ani_p.completes);\n            }\n            ranAnis = true;\n        }\n        if (!isCore && current.length === 0 && queue.length === 0) {\n            doneEles.push(ele);\n        }\n        return ranAnis;\n    } // stepElement\n    // handle all eles\n    var ranEleAni = false;\n    for(var e = 0; e < eles.length; e++){\n        var ele = eles[e];\n        var handledThisEle = stepOne(ele);\n        ranEleAni = ranEleAni || handledThisEle;\n    } // each element\n    var ranCoreAni = stepOne(cy, true);\n    // notify renderer\n    if (ranEleAni || ranCoreAni) {\n        if (eles.length > 0) {\n            cy.notify('draw', eles);\n        } else {\n            cy.notify('draw');\n        }\n    }\n    // remove elements from list of currently animating if its queues are empty\n    eles.unmerge(doneEles);\n    cy.emit('step');\n} // stepAll\nvar corefn$8 = {\n    // pull in animation functions\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop(),\n    addToAnimationPool: function addToAnimationPool(eles) {\n        var cy = this;\n        if (!cy.styleEnabled()) {\n            return;\n        } // save cycles when no style used\n        cy._private.aniEles.merge(eles);\n    },\n    stopAnimationLoop: function stopAnimationLoop() {\n        this._private.animationsRunning = false;\n    },\n    startAnimationLoop: function startAnimationLoop() {\n        var cy = this;\n        cy._private.animationsRunning = true;\n        if (!cy.styleEnabled()) {\n            return;\n        } // save cycles when no style used\n        // NB the animation loop will exec in headless environments if style enabled\n        // and explicit cy.destroy() is necessary to stop the loop\n        function headlessStep() {\n            if (!cy._private.animationsRunning) {\n                return;\n            }\n            requestAnimationFrame(function animationStep(now) {\n                stepAll(now, cy);\n                headlessStep();\n            });\n        }\n        var renderer = cy.renderer();\n        if (renderer && renderer.beforeRender) {\n            // let the renderer schedule animations\n            renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n                stepAll(now, cy);\n            }, renderer.beforeRenderPriorities.animations);\n        } else {\n            // manage the animation loop ourselves\n            headlessStep(); // first call\n        }\n    }\n};\nvar emitterOptions = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n        if (selector1 == null || selector2 == null) {\n            return selector1 == null && selector2 == null;\n        } else {\n            return selector1.sameText(selector2);\n        }\n    },\n    eventMatches: function eventMatches(cy, listener, eventObj) {\n        var selector = listener.qualifier;\n        if (selector != null) {\n            return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n        }\n        return true;\n    },\n    addEventFields: function addEventFields(cy, evt) {\n        evt.cy = cy;\n        evt.target = cy;\n    },\n    callbackContext: function callbackContext(cy, listener, eventObj) {\n        return listener.qualifier != null ? eventObj.target : cy;\n    }\n};\nvar argSelector = function argSelector(arg) {\n    if (string(arg)) {\n        return new Selector(arg);\n    } else {\n        return arg;\n    }\n};\nvar elesfn = {\n    createEmitter: function createEmitter() {\n        var _p = this._private;\n        if (!_p.emitter) {\n            _p.emitter = new Emitter(emitterOptions, this);\n        }\n        return this;\n    },\n    emitter: function emitter() {\n        return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n        this.emitter().on(events, argSelector(selector), callback);\n        return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n        this.emitter().removeListener(events, argSelector(selector), callback);\n        return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n        this.emitter().removeAllListeners();\n        return this;\n    },\n    one: function one(events, selector, callback) {\n        this.emitter().one(events, argSelector(selector), callback);\n        return this;\n    },\n    once: function once(events, selector, callback) {\n        this.emitter().one(events, argSelector(selector), callback);\n        return this;\n    },\n    emit: function emit(events, extraParams) {\n        this.emitter().emit(events, extraParams);\n        return this;\n    },\n    emitAndNotify: function emitAndNotify(event, eles) {\n        this.emit(event);\n        this.notify(event, eles);\n        return this;\n    }\n};\ndefine.eventAliasesOn(elesfn);\nvar corefn$7 = {\n    png: function png(options) {\n        var renderer = this._private.renderer;\n        options = options || {};\n        return renderer.png(options);\n    },\n    jpg: function jpg(options) {\n        var renderer = this._private.renderer;\n        options = options || {};\n        options.bg = options.bg || '#fff';\n        return renderer.jpg(options);\n    }\n};\ncorefn$7.jpeg = corefn$7.jpg;\nvar corefn$6 = {\n    layout: function layout(options) {\n        var cy = this;\n        if (options == null) {\n            error('Layout options must be specified to make a layout');\n            return;\n        }\n        if (options.name == null) {\n            error('A `name` must be specified to make a layout');\n            return;\n        }\n        var name = options.name;\n        var Layout = cy.extension('layout', name);\n        if (Layout == null) {\n            error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');\n            return;\n        }\n        var eles;\n        if (string(options.eles)) {\n            eles = cy.$(options.eles);\n        } else {\n            eles = options.eles != null ? options.eles : cy.$();\n        }\n        var layout = new Layout(extend({}, options, {\n            cy: cy,\n            eles: eles\n        }));\n        return layout;\n    }\n};\ncorefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\nvar corefn$5 = {\n    notify: function notify(eventName, eventEles) {\n        var _p = this._private;\n        if (this.batching()) {\n            _p.batchNotifications = _p.batchNotifications || {};\n            var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n            if (eventEles != null) {\n                eles.merge(eventEles);\n            }\n            return; // notifications are disabled during batching\n        }\n        if (!_p.notificationsEnabled) {\n            return;\n        } // exit on disabled\n        var renderer = this.renderer();\n        // exit if destroy() called on core or renderer in between frames #1499 #1528\n        if (this.destroyed() || !renderer) {\n            return;\n        }\n        renderer.notify(eventName, eventEles);\n    },\n    notifications: function notifications(bool) {\n        var p = this._private;\n        if (bool === undefined) {\n            return p.notificationsEnabled;\n        } else {\n            p.notificationsEnabled = bool ? true : false;\n        }\n        return this;\n    },\n    noNotifications: function noNotifications(callback) {\n        this.notifications(false);\n        callback();\n        this.notifications(true);\n    },\n    batching: function batching() {\n        return this._private.batchCount > 0;\n    },\n    startBatch: function startBatch() {\n        var _p = this._private;\n        if (_p.batchCount == null) {\n            _p.batchCount = 0;\n        }\n        if (_p.batchCount === 0) {\n            _p.batchStyleEles = this.collection();\n            _p.batchNotifications = {};\n        }\n        _p.batchCount++;\n        return this;\n    },\n    endBatch: function endBatch() {\n        var _p = this._private;\n        if (_p.batchCount === 0) {\n            return this;\n        }\n        _p.batchCount--;\n        if (_p.batchCount === 0) {\n            // update style for dirty eles\n            _p.batchStyleEles.updateStyle();\n            var renderer = this.renderer();\n            // notify the renderer of queued eles and event types\n            Object.keys(_p.batchNotifications).forEach(function(eventName) {\n                var eles = _p.batchNotifications[eventName];\n                if (eles.empty()) {\n                    renderer.notify(eventName);\n                } else {\n                    renderer.notify(eventName, eles);\n                }\n            });\n        }\n        return this;\n    },\n    batch: function batch(callback) {\n        this.startBatch();\n        callback();\n        this.endBatch();\n        return this;\n    },\n    // for backwards compatibility\n    batchData: function batchData(map) {\n        var cy = this;\n        return this.batch(function() {\n            var ids = Object.keys(map);\n            for(var i = 0; i < ids.length; i++){\n                var id = ids[i];\n                var data = map[id];\n                var ele = cy.getElementById(id);\n                ele.data(data);\n            }\n        });\n    }\n};\nvar rendererDefaults = defaults$g({\n    hideEdgesOnViewport: false,\n    textureOnViewport: false,\n    motionBlur: false,\n    motionBlurOpacity: 0.05,\n    pixelRatio: undefined,\n    desktopTapThreshold: 4,\n    touchTapThreshold: 8,\n    wheelSensitivity: 1,\n    debug: false,\n    showFps: false,\n    // webgl options\n    webgl: false,\n    webglDebug: false,\n    webglDebugShowAtlases: false,\n    // defaults good for mobile\n    webglTexSize: 2048,\n    webglTexRows: 36,\n    webglTexRowsNodes: 18,\n    webglBatchSize: 2048,\n    webglTexPerBatch: 14,\n    webglBgColor: [\n        255,\n        255,\n        255\n    ]\n});\nvar corefn$4 = {\n    renderTo: function renderTo(context, zoom, pan, pxRatio) {\n        var r = this._private.renderer;\n        r.renderTo(context, zoom, pan, pxRatio);\n        return this;\n    },\n    renderer: function renderer() {\n        return this._private.renderer;\n    },\n    forceRender: function forceRender() {\n        this.notify('draw');\n        return this;\n    },\n    resize: function resize() {\n        this.invalidateSize();\n        this.emitAndNotify('resize');\n        return this;\n    },\n    initRenderer: function initRenderer(options) {\n        var cy = this;\n        var RendererProto = cy.extension('renderer', options.name);\n        if (RendererProto == null) {\n            error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n            return;\n        }\n        if (options.wheelSensitivity !== undefined) {\n            warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n        }\n        var rOpts = rendererDefaults(options);\n        rOpts.cy = cy;\n        cy._private.renderer = new RendererProto(rOpts);\n        this.notify('init');\n    },\n    destroyRenderer: function destroyRenderer() {\n        var cy = this;\n        cy.notify('destroy'); // destroy the renderer\n        var domEle = cy.container();\n        if (domEle) {\n            domEle._cyreg = null;\n            while(domEle.childNodes.length > 0){\n                domEle.removeChild(domEle.childNodes[0]);\n            }\n        }\n        cy._private.renderer = null; // to be extra safe, remove the ref\n        cy.mutableElements().forEach(function(ele) {\n            var _p = ele._private;\n            _p.rscratch = {};\n            _p.rstyle = {};\n            _p.animation.current = [];\n            _p.animation.queue = [];\n        });\n    },\n    onRender: function onRender(fn) {\n        return this.on('render', fn);\n    },\n    offRender: function offRender(fn) {\n        return this.off('render', fn);\n    }\n};\ncorefn$4.invalidateDimensions = corefn$4.resize;\nvar corefn$3 = {\n    // get a collection\n    // - empty collection on no args\n    // - collection of elements in the graph on selector arg\n    // - guarantee a returned collection when elements or collection specified\n    collection: function collection(eles, opts) {\n        if (string(eles)) {\n            return this.$(eles);\n        } else if (elementOrCollection(eles)) {\n            return eles.collection();\n        } else if (array(eles)) {\n            if (!opts) {\n                opts = {};\n            }\n            return new Collection(this, eles, opts.unique, opts.removed);\n        }\n        return new Collection(this);\n    },\n    nodes: function nodes(selector) {\n        var nodes = this.$(function(ele) {\n            return ele.isNode();\n        });\n        if (selector) {\n            return nodes.filter(selector);\n        }\n        return nodes;\n    },\n    edges: function edges(selector) {\n        var edges = this.$(function(ele) {\n            return ele.isEdge();\n        });\n        if (selector) {\n            return edges.filter(selector);\n        }\n        return edges;\n    },\n    // search the graph like jQuery\n    $: function $(selector) {\n        var eles = this._private.elements;\n        if (selector) {\n            return eles.filter(selector);\n        } else {\n            return eles.spawnSelf();\n        }\n    },\n    mutableElements: function mutableElements() {\n        return this._private.elements;\n    }\n};\n// aliases\ncorefn$3.elements = corefn$3.filter = corefn$3.$;\nvar styfn$8 = {};\n// keys for style blocks, e.g. ttfftt\nvar TRUE = 't';\nvar FALSE = 'f';\n// (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\nstyfn$8.apply = function(eles) {\n    var self1 = this;\n    var _p = self1._private;\n    var cy = _p.cy;\n    var updatedEles = cy.collection();\n    for(var ie = 0; ie < eles.length; ie++){\n        var ele = eles[ie];\n        var cxtMeta = self1.getContextMeta(ele);\n        if (cxtMeta.empty) {\n            continue;\n        }\n        var cxtStyle = self1.getContextStyle(cxtMeta);\n        var app = self1.applyContextStyle(cxtMeta, cxtStyle, ele);\n        if (ele._private.appliedInitStyle) {\n            self1.updateTransitions(ele, app.diffProps);\n        } else {\n            ele._private.appliedInitStyle = true;\n        }\n        var hintsDiff = self1.updateStyleHints(ele);\n        if (hintsDiff) {\n            updatedEles.push(ele);\n        }\n    } // for elements\n    return updatedEles;\n};\nstyfn$8.getPropertiesDiff = function(oldCxtKey, newCxtKey) {\n    var self1 = this;\n    var cache = self1._private.propDiffs = self1._private.propDiffs || {};\n    var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n    var cachedVal = cache[dualCxtKey];\n    if (cachedVal) {\n        return cachedVal;\n    }\n    var diffProps = [];\n    var addedProp = {};\n    for(var i = 0; i < self1.length; i++){\n        var cxt = self1[i];\n        var oldHasCxt = oldCxtKey[i] === TRUE;\n        var newHasCxt = newCxtKey[i] === TRUE;\n        var cxtHasDiffed = oldHasCxt !== newHasCxt;\n        var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n        if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n            var props = undefined;\n            if (cxtHasDiffed && cxtHasMappedProps) {\n                props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n            } else if (cxtHasDiffed) {\n                props = cxt.properties; // need to check them all\n            } else if (cxtHasMappedProps) {\n                props = cxt.mappedProperties; // only need to check mapped\n            }\n            for(var j = 0; j < props.length; j++){\n                var prop = props[j];\n                var name = prop.name;\n                // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n                // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n                // is cached)\n                var laterCxtOverrides = false;\n                for(var k = i + 1; k < self1.length; k++){\n                    var laterCxt = self1[k];\n                    var hasLaterCxt = newCxtKey[k] === TRUE;\n                    if (!hasLaterCxt) {\n                        continue;\n                    } // can't override unless the context is active\n                    laterCxtOverrides = laterCxt.properties[prop.name] != null;\n                    if (laterCxtOverrides) {\n                        break;\n                    } // exit early as long as one later context overrides\n                }\n                if (!addedProp[name] && !laterCxtOverrides) {\n                    addedProp[name] = true;\n                    diffProps.push(name);\n                }\n            } // for props\n        } // if\n    } // for contexts\n    cache[dualCxtKey] = diffProps;\n    return diffProps;\n};\nstyfn$8.getContextMeta = function(ele) {\n    var self1 = this;\n    var cxtKey = '';\n    var diffProps;\n    var prevKey = ele._private.styleCxtKey || '';\n    // get the cxt key\n    for(var i = 0; i < self1.length; i++){\n        var context = self1[i];\n        var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n        if (contextSelectorMatches) {\n            cxtKey += TRUE;\n        } else {\n            cxtKey += FALSE;\n        }\n    } // for context\n    diffProps = self1.getPropertiesDiff(prevKey, cxtKey);\n    ele._private.styleCxtKey = cxtKey;\n    return {\n        key: cxtKey,\n        diffPropNames: diffProps,\n        empty: diffProps.length === 0\n    };\n};\n// gets a computed ele style object based on matched contexts\nstyfn$8.getContextStyle = function(cxtMeta) {\n    var cxtKey = cxtMeta.key;\n    var self1 = this;\n    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n    // if already computed style, returned cached copy\n    if (cxtStyles[cxtKey]) {\n        return cxtStyles[cxtKey];\n    }\n    var style = {\n        _private: {\n            key: cxtKey\n        }\n    };\n    for(var i = 0; i < self1.length; i++){\n        var cxt = self1[i];\n        var hasCxt = cxtKey[i] === TRUE;\n        if (!hasCxt) {\n            continue;\n        }\n        for(var j = 0; j < cxt.properties.length; j++){\n            var prop = cxt.properties[j];\n            style[prop.name] = prop;\n        }\n    }\n    cxtStyles[cxtKey] = style;\n    return style;\n};\nstyfn$8.applyContextStyle = function(cxtMeta, cxtStyle, ele) {\n    var self1 = this;\n    var diffProps = cxtMeta.diffPropNames;\n    var retDiffProps = {};\n    var types = self1.types;\n    for(var i = 0; i < diffProps.length; i++){\n        var diffPropName = diffProps[i];\n        var cxtProp = cxtStyle[diffPropName];\n        var eleProp = ele.pstyle(diffPropName);\n        if (!cxtProp) {\n            // no context prop means delete\n            if (!eleProp) {\n                continue; // no existing prop means nothing needs to be removed\n            // nb affects initial application on mapped values like control-point-distances\n            } else if (eleProp.bypass) {\n                cxtProp = {\n                    name: diffPropName,\n                    deleteBypassed: true\n                };\n            } else {\n                cxtProp = {\n                    name: diffPropName,\n                    \"delete\": true\n                };\n            }\n        }\n        // save cycles when the context prop doesn't need to be applied\n        if (eleProp === cxtProp) {\n            continue;\n        }\n        // save cycles when a mapped context prop doesn't need to be applied\n        if (cxtProp.mapped === types.fn // context prop is function mapper\n         && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n         && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n         && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n        ) {\n            // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n            var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n            var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n            if (fnValue === mapping.prevFnValue) {\n                continue;\n            }\n        }\n        var retDiffProp = retDiffProps[diffPropName] = {\n            prev: eleProp\n        };\n        self1.applyParsedProperty(ele, cxtProp);\n        retDiffProp.next = ele.pstyle(diffPropName);\n        if (retDiffProp.next && retDiffProp.next.bypass) {\n            retDiffProp.next = retDiffProp.next.bypassed;\n        }\n    }\n    return {\n        diffProps: retDiffProps\n    };\n};\nstyfn$8.updateStyleHints = function(ele) {\n    var _p = ele._private;\n    var self1 = this;\n    var propNames = self1.propertyGroupNames;\n    var propGrKeys = self1.propertyGroupKeys;\n    var propHash = function propHash(ele, propNames, seedKey) {\n        return self1.getPropertiesHash(ele, propNames, seedKey);\n    };\n    var oldStyleKey = _p.styleKey;\n    if (ele.removed()) {\n        return false;\n    }\n    var isNode = _p.group === 'nodes';\n    // get the style key hashes per prop group\n    // but lazily -- only use non-default prop values to reduce the number of hashes\n    //\n    var overriddenStyles = ele._private.style;\n    propNames = Object.keys(overriddenStyles);\n    for(var i = 0; i < propGrKeys.length; i++){\n        var grKey = propGrKeys[i];\n        _p.styleKeys[grKey] = [\n            DEFAULT_HASH_SEED,\n            DEFAULT_HASH_SEED_ALT\n        ];\n    }\n    var updateGrKey1 = function updateGrKey1(val, grKey) {\n        return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n    };\n    var updateGrKey2 = function updateGrKey2(val, grKey) {\n        return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n    };\n    var updateGrKey = function updateGrKey(val, grKey) {\n        updateGrKey1(val, grKey);\n        updateGrKey2(val, grKey);\n    };\n    var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n        for(var j = 0; j < strVal.length; j++){\n            var ch = strVal.charCodeAt(j);\n            updateGrKey1(ch, grKey);\n            updateGrKey2(ch, grKey);\n        }\n    };\n    // - hashing works on 32 bit ints b/c we use bitwise ops\n    // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n    // - raise up small numbers so more significant digits are seen by hashing\n    // - make small numbers larger than a normal value to avoid collisions\n    // - works in practice and it's relatively cheap\n    var N = 2000000000;\n    var cleanNum = function cleanNum(val) {\n        return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n    };\n    for(var _i = 0; _i < propNames.length; _i++){\n        var name = propNames[_i];\n        var parsedProp = overriddenStyles[name];\n        if (parsedProp == null) {\n            continue;\n        }\n        var propInfo = this.properties[name];\n        var type = propInfo.type;\n        var _grKey = propInfo.groupKey;\n        var normalizedNumberVal = undefined;\n        if (propInfo.hashOverride != null) {\n            normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n        } else if (parsedProp.pfValue != null) {\n            normalizedNumberVal = parsedProp.pfValue;\n        }\n        // might not be a number if it allows enums\n        var numberVal = propInfo.enums == null ? parsedProp.value : null;\n        var haveNormNum = normalizedNumberVal != null;\n        var haveUnitedNum = numberVal != null;\n        var haveNum = haveNormNum || haveUnitedNum;\n        var units = parsedProp.units;\n        // numbers are cheaper to hash than strings\n        // 1 hash op vs n hash ops (for length n string)\n        if (type.number && haveNum && !type.multiple) {\n            var v = haveNormNum ? normalizedNumberVal : numberVal;\n            updateGrKey(cleanNum(v), _grKey);\n            if (!haveNormNum && units != null) {\n                updateGrKeyWStr(units, _grKey);\n            }\n        } else {\n            updateGrKeyWStr(parsedProp.strValue, _grKey);\n        }\n    }\n    // overall style key\n    //\n    var hash = [\n        DEFAULT_HASH_SEED,\n        DEFAULT_HASH_SEED_ALT\n    ];\n    for(var _i2 = 0; _i2 < propGrKeys.length; _i2++){\n        var _grKey2 = propGrKeys[_i2];\n        var grHash = _p.styleKeys[_grKey2];\n        hash[0] = hashInt(grHash[0], hash[0]);\n        hash[1] = hashIntAlt(grHash[1], hash[1]);\n    }\n    _p.styleKey = combineHashes(hash[0], hash[1]);\n    // label dims\n    //\n    var sk = _p.styleKeys;\n    _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n    var labelKeys = propHash(ele, [\n        'label'\n    ], sk.labelDimensions);\n    _p.labelKey = combineHashesArray(labelKeys);\n    _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n    if (!isNode) {\n        var sourceLabelKeys = propHash(ele, [\n            'source-label'\n        ], sk.labelDimensions);\n        _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n        _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n        var targetLabelKeys = propHash(ele, [\n            'target-label'\n        ], sk.labelDimensions);\n        _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n        _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n    }\n    // node\n    //\n    if (isNode) {\n        var _p$styleKeys = _p.styleKeys, nodeBody = _p$styleKeys.nodeBody, nodeBorder = _p$styleKeys.nodeBorder, nodeOutline = _p$styleKeys.nodeOutline, backgroundImage = _p$styleKeys.backgroundImage, compound = _p$styleKeys.compound, pie = _p$styleKeys.pie, stripe = _p$styleKeys.stripe;\n        var nodeKeys = [\n            nodeBody,\n            nodeBorder,\n            nodeOutline,\n            backgroundImage,\n            compound,\n            pie,\n            stripe\n        ].filter(function(k) {\n            return k != null;\n        }).reduce(hashArrays, [\n            DEFAULT_HASH_SEED,\n            DEFAULT_HASH_SEED_ALT\n        ]);\n        _p.nodeKey = combineHashesArray(nodeKeys);\n        _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n        _p.hasStripe = stripe != null && stripe[0] !== DEFAULT_HASH_SEED && stripe[1] !== DEFAULT_HASH_SEED_ALT;\n    }\n    return oldStyleKey !== _p.styleKey;\n};\nstyfn$8.clearStyleHints = function(ele) {\n    var _p = ele._private;\n    _p.styleCxtKey = '';\n    _p.styleKeys = {};\n    _p.styleKey = null;\n    _p.labelKey = null;\n    _p.labelStyleKey = null;\n    _p.sourceLabelKey = null;\n    _p.sourceLabelStyleKey = null;\n    _p.targetLabelKey = null;\n    _p.targetLabelStyleKey = null;\n    _p.nodeKey = null;\n    _p.hasPie = null;\n    _p.hasStripe = null;\n};\n// apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\nstyfn$8.applyParsedProperty = function(ele, parsedProp) {\n    var self1 = this;\n    var prop = parsedProp;\n    var style = ele._private.style;\n    var flatProp;\n    var types = self1.types;\n    var type = self1.properties[prop.name].type;\n    var propIsBypass = prop.bypass;\n    var origProp = style[prop.name];\n    var origPropIsBypass = origProp && origProp.bypass;\n    var _p = ele._private;\n    var flatPropMapping = 'mapping';\n    var getVal = function getVal(p) {\n        if (p == null) {\n            return null;\n        } else if (p.pfValue != null) {\n            return p.pfValue;\n        } else {\n            return p.value;\n        }\n    };\n    var checkTriggers = function checkTriggers() {\n        var fromVal = getVal(origProp);\n        var toVal = getVal(prop);\n        self1.checkTriggers(ele, prop.name, fromVal, toVal);\n    };\n    // edge sanity checks to prevent the client from making serious mistakes\n    if (parsedProp.name === 'curve-style' && ele.isEdge() && // loops must be bundled beziers\n    (parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n    parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {\n        prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n    }\n    if (prop[\"delete\"]) {\n        // delete the property and use the default value on falsey value\n        style[prop.name] = undefined;\n        checkTriggers();\n        return true;\n    }\n    if (prop.deleteBypassed) {\n        // delete the property that the\n        if (!origProp) {\n            checkTriggers();\n            return true; // can't delete if no prop\n        } else if (origProp.bypass) {\n            // delete bypassed\n            origProp.bypassed = undefined;\n            checkTriggers();\n            return true;\n        } else {\n            return false; // we're unsuccessful deleting the bypassed\n        }\n    }\n    // check if we need to delete the current bypass\n    if (prop.deleteBypass) {\n        // then this property is just here to indicate we need to delete\n        if (!origProp) {\n            checkTriggers();\n            return true; // property is already not defined\n        } else if (origProp.bypass) {\n            // then replace the bypass property with the original\n            // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n            style[prop.name] = origProp.bypassed;\n            checkTriggers();\n            return true;\n        } else {\n            return false; // we're unsuccessful deleting the bypass\n        }\n    }\n    var printMappingErr = function printMappingErr() {\n        warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n    };\n    // put the property in the style objects\n    switch(prop.mapped){\n        // flatten the property if mapped\n        case types.mapData:\n            {\n                // flatten the field (e.g. data.foo.bar)\n                var fields = prop.field.split('.');\n                var fieldVal = _p.data;\n                for(var i = 0; i < fields.length && fieldVal; i++){\n                    var field = fields[i];\n                    fieldVal = fieldVal[field];\n                }\n                if (fieldVal == null) {\n                    printMappingErr();\n                    return false;\n                }\n                var percent;\n                if (!number$1(fieldVal)) {\n                    // then don't apply and fall back on the existing style\n                    warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');\n                    return false;\n                } else {\n                    var fieldWidth = prop.fieldMax - prop.fieldMin;\n                    if (fieldWidth === 0) {\n                        // safety check -- not strictly necessary as no props of zero range should be passed here\n                        percent = 0;\n                    } else {\n                        percent = (fieldVal - prop.fieldMin) / fieldWidth;\n                    }\n                }\n                // make sure to bound percent value\n                if (percent < 0) {\n                    percent = 0;\n                } else if (percent > 1) {\n                    percent = 1;\n                }\n                if (type.color) {\n                    var r1 = prop.valueMin[0];\n                    var r2 = prop.valueMax[0];\n                    var g1 = prop.valueMin[1];\n                    var g2 = prop.valueMax[1];\n                    var b1 = prop.valueMin[2];\n                    var b2 = prop.valueMax[2];\n                    var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n                    var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n                    var clr = [\n                        Math.round(r1 + (r2 - r1) * percent),\n                        Math.round(g1 + (g2 - g1) * percent),\n                        Math.round(b1 + (b2 - b1) * percent),\n                        Math.round(a1 + (a2 - a1) * percent)\n                    ];\n                    flatProp = {\n                        // colours are simple, so just create the flat property instead of expensive string parsing\n                        bypass: prop.bypass,\n                        // we're a bypass if the mapping property is a bypass\n                        name: prop.name,\n                        value: clr,\n                        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n                    };\n                } else if (type.number) {\n                    var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n                    flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n                } else {\n                    return false; // can only map to colours and numbers\n                }\n                if (!flatProp) {\n                    // if we can't flatten the property, then don't apply the property and fall back on the existing style\n                    printMappingErr();\n                    return false;\n                }\n                flatProp.mapping = prop; // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        // direct mapping\n        case types.data:\n            {\n                // flatten the field (e.g. data.foo.bar)\n                var _fields = prop.field.split('.');\n                var _fieldVal = _p.data;\n                for(var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++){\n                    var _field = _fields[_i3];\n                    _fieldVal = _fieldVal[_field];\n                }\n                if (_fieldVal != null) {\n                    flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n                }\n                if (!flatProp) {\n                    // if we can't flatten the property, then don't apply and fall back on the existing style\n                    printMappingErr();\n                    return false;\n                }\n                flatProp.mapping = prop; // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        case types.fn:\n            {\n                var fn = prop.value;\n                var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n                prop.prevFnValue = fnRetVal;\n                if (fnRetVal == null) {\n                    warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');\n                    return false;\n                }\n                flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n                if (!flatProp) {\n                    warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');\n                    return false;\n                }\n                flatProp.mapping = copy(prop); // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        case undefined:\n            break;\n        // just set the property\n        default:\n            return false;\n    }\n    // if the property is a bypass property, then link the resultant property to the original one\n    if (propIsBypass) {\n        if (origPropIsBypass) {\n            // then this bypass overrides the existing one\n            prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n        } else {\n            // then link the orig prop to the new bypass\n            prop.bypassed = origProp;\n        }\n        style[prop.name] = prop; // and set\n    } else {\n        // prop is not bypass\n        if (origPropIsBypass) {\n            // then keep the orig prop (since it's a bypass) and link to the new prop\n            origProp.bypassed = prop;\n        } else {\n            // then just replace the old prop with the new one\n            style[prop.name] = prop;\n        }\n    }\n    checkTriggers();\n    return true;\n};\nstyfn$8.cleanElements = function(eles, keepBypasses) {\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        this.clearStyleHints(ele);\n        ele.dirtyCompoundBoundsCache();\n        ele.dirtyBoundingBoxCache();\n        if (!keepBypasses) {\n            ele._private.style = {};\n        } else {\n            var style = ele._private.style;\n            var propNames = Object.keys(style);\n            for(var j = 0; j < propNames.length; j++){\n                var propName = propNames[j];\n                var eleProp = style[propName];\n                if (eleProp != null) {\n                    if (eleProp.bypass) {\n                        eleProp.bypassed = null;\n                    } else {\n                        style[propName] = null;\n                    }\n                }\n            }\n        }\n    }\n};\n// updates the visual style for all elements (useful for manual style modification after init)\nstyfn$8.update = function() {\n    var cy = this._private.cy;\n    var eles = cy.mutableElements();\n    eles.updateStyle();\n};\n// diffProps : { name => { prev, next } }\nstyfn$8.updateTransitions = function(ele, diffProps) {\n    var self1 = this;\n    var _p = ele._private;\n    var props = ele.pstyle('transition-property').value;\n    var duration = ele.pstyle('transition-duration').pfValue;\n    var delay = ele.pstyle('transition-delay').pfValue;\n    if (props.length > 0 && duration > 0) {\n        var style = {};\n        // build up the style to animate towards\n        var anyPrev = false;\n        for(var i = 0; i < props.length; i++){\n            var prop = props[i];\n            var styProp = ele.pstyle(prop);\n            var diffProp = diffProps[prop];\n            if (!diffProp) {\n                continue;\n            }\n            var prevProp = diffProp.prev;\n            var fromProp = prevProp;\n            var toProp = diffProp.next != null ? diffProp.next : styProp;\n            var diff = false;\n            var initVal = undefined;\n            var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n            if (!fromProp) {\n                continue;\n            }\n            // consider px values\n            if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n                diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n                initVal = fromProp.pfValue + initDt * diff;\n            // consider numerical values\n            } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n                diff = toProp.value - fromProp.value; // nonzero is truthy\n                initVal = fromProp.value + initDt * diff;\n            // consider colour values\n            } else if (array(fromProp.value) && array(toProp.value)) {\n                diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n                initVal = fromProp.strValue;\n            }\n            // the previous value is good for an animation only if it's different\n            if (diff) {\n                style[prop] = toProp.strValue; // to val\n                this.applyBypass(ele, prop, initVal); // from val\n                anyPrev = true;\n            }\n        } // end if props allow ani\n        // can't transition if there's nothing previous to transition from\n        if (!anyPrev) {\n            return;\n        }\n        _p.transitioning = true;\n        new Promise$1(function(resolve) {\n            if (delay > 0) {\n                ele.delayAnimation(delay).play().promise().then(resolve);\n            } else {\n                resolve();\n            }\n        }).then(function() {\n            return ele.animation({\n                style: style,\n                duration: duration,\n                easing: ele.pstyle('transition-timing-function').value,\n                queue: false\n            }).play().promise();\n        }).then(function() {\n            // if( !isBypass ){\n            self1.removeBypasses(ele, props);\n            ele.emitAndNotify('style');\n            // }\n            _p.transitioning = false;\n        });\n    } else if (_p.transitioning) {\n        this.removeBypasses(ele, props);\n        ele.emitAndNotify('style');\n        _p.transitioning = false;\n    }\n};\nstyfn$8.checkTrigger = function(ele, name, fromValue, toValue, getTrigger, onTrigger) {\n    var prop = this.properties[name];\n    var triggerCheck = getTrigger(prop);\n    if (ele.removed()) {\n        return;\n    }\n    if (triggerCheck != null && triggerCheck(fromValue, toValue, ele)) {\n        onTrigger(prop);\n    }\n};\nstyfn$8.checkZOrderTrigger = function(ele, name, fromValue, toValue) {\n    var _this = this;\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersZOrder;\n    }, function() {\n        _this._private.cy.notify('zorder', ele);\n    });\n};\nstyfn$8.checkBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBounds;\n    }, function(prop) {\n        ele.dirtyCompoundBoundsCache();\n        ele.dirtyBoundingBoxCache();\n    });\n};\nstyfn$8.checkConnectedEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBoundsOfConnectedEdges;\n    }, function(prop) {\n        ele.connectedEdges().forEach(function(edge) {\n            edge.dirtyBoundingBoxCache();\n        });\n    });\n};\nstyfn$8.checkParallelEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBoundsOfParallelEdges;\n    }, function(prop) {\n        ele.parallelEdges().forEach(function(pllEdge) {\n            pllEdge.dirtyBoundingBoxCache();\n        });\n    });\n};\nstyfn$8.checkTriggers = function(ele, name, fromValue, toValue) {\n    ele.dirtyStyleCache();\n    this.checkZOrderTrigger(ele, name, fromValue, toValue);\n    this.checkBoundsTrigger(ele, name, fromValue, toValue);\n    this.checkConnectedEdgesBoundsTrigger(ele, name, fromValue, toValue);\n    this.checkParallelEdgesBoundsTrigger(ele, name, fromValue, toValue);\n};\nvar styfn$7 = {};\n// bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\nstyfn$7.applyBypass = function(eles, name, value, updateTransitions) {\n    var self1 = this;\n    var props = [];\n    var isBypass = true;\n    // put all the properties (can specify one or many) in an array after parsing them\n    if (name === '*' || name === '**') {\n        // apply to all property names\n        if (value !== undefined) {\n            for(var i = 0; i < self1.properties.length; i++){\n                var prop = self1.properties[i];\n                var _name = prop.name;\n                var parsedProp = this.parse(_name, value, true);\n                if (parsedProp) {\n                    props.push(parsedProp);\n                }\n            }\n        }\n    } else if (string(name)) {\n        // then parse the single property\n        var _parsedProp = this.parse(name, value, true);\n        if (_parsedProp) {\n            props.push(_parsedProp);\n        }\n    } else if (plainObject(name)) {\n        // then parse each property\n        var specifiedProps = name;\n        updateTransitions = value;\n        var names = Object.keys(specifiedProps);\n        for(var _i = 0; _i < names.length; _i++){\n            var _name2 = names[_i];\n            var _value = specifiedProps[_name2];\n            if (_value === undefined) {\n                // try camel case name too\n                _value = specifiedProps[dash2camel(_name2)];\n            }\n            if (_value !== undefined) {\n                var _parsedProp2 = this.parse(_name2, _value, true);\n                if (_parsedProp2) {\n                    props.push(_parsedProp2);\n                }\n            }\n        }\n    } else {\n        // can't do anything without well defined properties\n        return false;\n    }\n    // we've failed if there are no valid properties\n    if (props.length === 0) {\n        return false;\n    }\n    // now, apply the bypass properties on the elements\n    var ret = false; // return true if at least one succesful bypass applied\n    for(var _i2 = 0; _i2 < eles.length; _i2++){\n        // for each ele\n        var ele = eles[_i2];\n        var diffProps = {};\n        var diffProp = undefined;\n        for(var j = 0; j < props.length; j++){\n            // for each prop\n            var _prop = props[j];\n            if (updateTransitions) {\n                var prevProp = ele.pstyle(_prop.name);\n                diffProp = diffProps[_prop.name] = {\n                    prev: prevProp\n                };\n            }\n            ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n            if (updateTransitions) {\n                diffProp.next = ele.pstyle(_prop.name);\n            }\n        } // for props\n        if (ret) {\n            this.updateStyleHints(ele);\n        }\n        if (updateTransitions) {\n            this.updateTransitions(ele, diffProps, isBypass);\n        }\n    } // for eles\n    return ret;\n};\n// only useful in specific cases like animation\nstyfn$7.overrideBypass = function(eles, name, value) {\n    name = camel2dash(name);\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var prop = ele._private.style[name];\n        var type = this.properties[name].type;\n        var isColor = type.color;\n        var isMulti = type.mutiple;\n        var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n        if (!prop || !prop.bypass) {\n            // need a bypass if one doesn't exist\n            this.applyBypass(ele, name, value);\n        } else {\n            prop.value = value;\n            if (prop.pfValue != null) {\n                prop.pfValue = value;\n            }\n            if (isColor) {\n                prop.strValue = 'rgb(' + value.join(',') + ')';\n            } else if (isMulti) {\n                prop.strValue = value.join(' ');\n            } else {\n                prop.strValue = '' + value;\n            }\n            this.updateStyleHints(ele);\n        }\n        this.checkTriggers(ele, name, oldValue, value);\n    }\n};\nstyfn$7.removeAllBypasses = function(eles, updateTransitions) {\n    return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n};\nstyfn$7.removeBypasses = function(eles, props, updateTransitions) {\n    var isBypass = true;\n    for(var j = 0; j < eles.length; j++){\n        var ele = eles[j];\n        var diffProps = {};\n        for(var i = 0; i < props.length; i++){\n            var name = props[i];\n            var prop = this.properties[name];\n            var prevProp = ele.pstyle(prop.name);\n            if (!prevProp || !prevProp.bypass) {\n                continue;\n            }\n            var value = ''; // empty => remove bypass\n            var parsedProp = this.parse(name, value, true);\n            var diffProp = diffProps[prop.name] = {\n                prev: prevProp\n            };\n            this.applyParsedProperty(ele, parsedProp);\n            diffProp.next = ele.pstyle(prop.name);\n        } // for props\n        this.updateStyleHints(ele);\n        if (updateTransitions) {\n            this.updateTransitions(ele, diffProps, isBypass);\n        }\n    } // for eles\n};\nvar styfn$6 = {};\n// gets what an em size corresponds to in pixels relative to a dom element\nstyfn$6.getEmSizeInPixels = function() {\n    var px = this.containerCss('font-size');\n    if (px != null) {\n        return parseFloat(px);\n    } else {\n        return 1; // for headless\n    }\n};\n// gets css property from the core container\nstyfn$6.containerCss = function(propName) {\n    var cy = this._private.cy;\n    var domElement = cy.container();\n    var containerWindow = cy.window();\n    if (containerWindow && domElement && containerWindow.getComputedStyle) {\n        return containerWindow.getComputedStyle(domElement).getPropertyValue(propName);\n    }\n};\nvar styfn$5 = {};\n// gets the rendered style for an element\nstyfn$5.getRenderedStyle = function(ele, prop) {\n    if (prop) {\n        return this.getStylePropertyValue(ele, prop, true);\n    } else {\n        return this.getRawStyle(ele, true);\n    }\n};\n// gets the raw style for an element\nstyfn$5.getRawStyle = function(ele, isRenderedVal) {\n    var self1 = this;\n    ele = ele[0]; // insure it's an element\n    if (ele) {\n        var rstyle = {};\n        for(var i = 0; i < self1.properties.length; i++){\n            var prop = self1.properties[i];\n            var val = self1.getStylePropertyValue(ele, prop.name, isRenderedVal);\n            if (val != null) {\n                rstyle[prop.name] = val;\n                rstyle[dash2camel(prop.name)] = val;\n            }\n        }\n        return rstyle;\n    }\n};\nstyfn$5.getIndexedStyle = function(ele, property, subproperty, index) {\n    var pstyle = ele.pstyle(property)[subproperty][index];\n    return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n};\nstyfn$5.getStylePropertyValue = function(ele, propName, isRenderedVal) {\n    var self1 = this;\n    ele = ele[0]; // insure it's an element\n    if (ele) {\n        var prop = self1.properties[propName];\n        if (prop.alias) {\n            prop = prop.pointsTo;\n        }\n        var type = prop.type;\n        var styleProp = ele.pstyle(prop.name);\n        if (styleProp) {\n            var value = styleProp.value, units = styleProp.units, strValue = styleProp.strValue;\n            if (isRenderedVal && type.number && value != null && number$1(value)) {\n                var zoom = ele.cy().zoom();\n                var getRenderedValue = function getRenderedValue(val) {\n                    return val * zoom;\n                };\n                var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n                    return getRenderedValue(val) + units;\n                };\n                var isArrayValue = array(value);\n                var haveUnits = isArrayValue ? units.every(function(u) {\n                    return u != null;\n                }) : units != null;\n                if (haveUnits) {\n                    if (isArrayValue) {\n                        return value.map(function(v, i) {\n                            return getValueStringWithUnits(v, units[i]);\n                        }).join(' ');\n                    } else {\n                        return getValueStringWithUnits(value, units);\n                    }\n                } else {\n                    if (isArrayValue) {\n                        return value.map(function(v) {\n                            return string(v) ? v : '' + getRenderedValue(v);\n                        }).join(' ');\n                    } else {\n                        return '' + getRenderedValue(value);\n                    }\n                }\n            } else if (strValue != null) {\n                return strValue;\n            }\n        }\n        return null;\n    }\n};\nstyfn$5.getAnimationStartStyle = function(ele, aniProps) {\n    var rstyle = {};\n    for(var i = 0; i < aniProps.length; i++){\n        var aniProp = aniProps[i];\n        var name = aniProp.name;\n        var styleProp = ele.pstyle(name);\n        if (styleProp !== undefined) {\n            // then make a prop of it\n            if (plainObject(styleProp)) {\n                styleProp = this.parse(name, styleProp.strValue);\n            } else {\n                styleProp = this.parse(name, styleProp);\n            }\n        }\n        if (styleProp) {\n            rstyle[name] = styleProp;\n        }\n    }\n    return rstyle;\n};\nstyfn$5.getPropsList = function(propsObj) {\n    var self1 = this;\n    var rstyle = [];\n    var style = propsObj;\n    var props = self1.properties;\n    if (style) {\n        var names = Object.keys(style);\n        for(var i = 0; i < names.length; i++){\n            var name = names[i];\n            var val = style[name];\n            var prop = props[name] || props[camel2dash(name)];\n            var styleProp = this.parse(prop.name, val);\n            if (styleProp) {\n                rstyle.push(styleProp);\n            }\n        }\n    }\n    return rstyle;\n};\nstyfn$5.getNonDefaultPropertiesHash = function(ele, propNames, seed) {\n    var hash = seed.slice();\n    var name, val, strVal, chVal;\n    var i, j;\n    for(i = 0; i < propNames.length; i++){\n        name = propNames[i];\n        val = ele.pstyle(name, false);\n        if (val == null) {\n            continue;\n        } else if (val.pfValue != null) {\n            hash[0] = hashInt(chVal, hash[0]);\n            hash[1] = hashIntAlt(chVal, hash[1]);\n        } else {\n            strVal = val.strValue;\n            for(j = 0; j < strVal.length; j++){\n                chVal = strVal.charCodeAt(j);\n                hash[0] = hashInt(chVal, hash[0]);\n                hash[1] = hashIntAlt(chVal, hash[1]);\n            }\n        }\n    }\n    return hash;\n};\nstyfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\nvar styfn$4 = {};\nstyfn$4.appendFromJson = function(json) {\n    var style = this;\n    for(var i = 0; i < json.length; i++){\n        var context = json[i];\n        var selector = context.selector;\n        var props = context.style || context.css;\n        var names = Object.keys(props);\n        style.selector(selector); // apply selector\n        for(var j = 0; j < names.length; j++){\n            var name = names[j];\n            var value = props[name];\n            style.css(name, value); // apply property\n        }\n    }\n    return style;\n};\n// accessible cy.style() function\nstyfn$4.fromJson = function(json) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromJson(json);\n    return style;\n};\n// get json from cy.style() api\nstyfn$4.json = function() {\n    var json = [];\n    for(var i = this.defaultLength; i < this.length; i++){\n        var cxt = this[i];\n        var selector = cxt.selector;\n        var props = cxt.properties;\n        var css = {};\n        for(var j = 0; j < props.length; j++){\n            var prop = props[j];\n            css[prop.name] = prop.strValue;\n        }\n        json.push({\n            selector: !selector ? 'core' : selector.toString(),\n            style: css\n        });\n    }\n    return json;\n};\nvar styfn$3 = {};\nstyfn$3.appendFromString = function(string) {\n    var self1 = this;\n    var style = this;\n    var remaining = '' + string;\n    var selAndBlockStr;\n    var blockRem;\n    var propAndValStr;\n    // remove comments from the style string\n    remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n    function removeSelAndBlockFromRemaining() {\n        // remove the parsed selector and block from the remaining text to parse\n        if (remaining.length > selAndBlockStr.length) {\n            remaining = remaining.substr(selAndBlockStr.length);\n        } else {\n            remaining = '';\n        }\n    }\n    function removePropAndValFromRem() {\n        // remove the parsed property and value from the remaining block text to parse\n        if (blockRem.length > propAndValStr.length) {\n            blockRem = blockRem.substr(propAndValStr.length);\n        } else {\n            blockRem = '';\n        }\n    }\n    for(;;){\n        var nothingLeftToParse = remaining.match(/^\\s*$/);\n        if (nothingLeftToParse) {\n            break;\n        }\n        var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n        if (!selAndBlock) {\n            warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n            break;\n        }\n        selAndBlockStr = selAndBlock[0];\n        // parse the selector\n        var selectorStr = selAndBlock[1];\n        if (selectorStr !== 'core') {\n            var selector = new Selector(selectorStr);\n            if (selector.invalid) {\n                warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);\n                // skip this selector and block\n                removeSelAndBlockFromRemaining();\n                continue;\n            }\n        }\n        // parse the block of properties and values\n        var blockStr = selAndBlock[2];\n        var invalidBlock = false;\n        blockRem = blockStr;\n        var props = [];\n        for(;;){\n            var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n            if (_nothingLeftToParse) {\n                break;\n            }\n            var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n            if (!propAndVal) {\n                warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n                invalidBlock = true;\n                break;\n            }\n            propAndValStr = propAndVal[0];\n            var propStr = propAndVal[1];\n            var valStr = propAndVal[2];\n            var prop = self1.properties[propStr];\n            if (!prop) {\n                warn('Skipping property: Invalid property name in: ' + propAndValStr);\n                // skip this property in the block\n                removePropAndValFromRem();\n                continue;\n            }\n            var parsedProp = style.parse(propStr, valStr);\n            if (!parsedProp) {\n                warn('Skipping property: Invalid property definition in: ' + propAndValStr);\n                // skip this property in the block\n                removePropAndValFromRem();\n                continue;\n            }\n            props.push({\n                name: propStr,\n                val: valStr\n            });\n            removePropAndValFromRem();\n        }\n        if (invalidBlock) {\n            removeSelAndBlockFromRemaining();\n            break;\n        }\n        // put the parsed block in the style\n        style.selector(selectorStr);\n        for(var i = 0; i < props.length; i++){\n            var _prop = props[i];\n            style.css(_prop.name, _prop.val);\n        }\n        removeSelAndBlockFromRemaining();\n    }\n    return style;\n};\nstyfn$3.fromString = function(string) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromString(string);\n    return style;\n};\nvar styfn$2 = {};\n(function() {\n    var number$1 = number;\n    var rgba = rgbaNoBackRefs;\n    var hsla = hslaNoBackRefs;\n    var hex3$1 = hex3;\n    var hex6$1 = hex6;\n    var data = function data(prefix) {\n        return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n    };\n    var mapData = function mapData(prefix) {\n        var mapArg = number$1 + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;\n        return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n    };\n    var urlRegexes = [\n        '^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$',\n        '^(none)$',\n        '^(.+)$'\n    ];\n    // each visual style property has a type and needs to be validated according to it\n    styfn$2.types = {\n        time: {\n            number: true,\n            min: 0,\n            units: 's|ms',\n            implicitUnits: 'ms'\n        },\n        percent: {\n            number: true,\n            min: 0,\n            max: 100,\n            units: '%',\n            implicitUnits: '%'\n        },\n        percentages: {\n            number: true,\n            min: 0,\n            max: 100,\n            units: '%',\n            implicitUnits: '%',\n            multiple: true\n        },\n        zeroOneNumber: {\n            number: true,\n            min: 0,\n            max: 1,\n            unitless: true\n        },\n        zeroOneNumbers: {\n            number: true,\n            min: 0,\n            max: 1,\n            unitless: true,\n            multiple: true\n        },\n        nOneOneNumber: {\n            number: true,\n            min: -1,\n            max: 1,\n            unitless: true\n        },\n        nonNegativeInt: {\n            number: true,\n            min: 0,\n            integer: true,\n            unitless: true\n        },\n        nonNegativeNumber: {\n            number: true,\n            min: 0,\n            unitless: true\n        },\n        position: {\n            enums: [\n                'parent',\n                'origin'\n            ]\n        },\n        nodeSize: {\n            number: true,\n            min: 0,\n            enums: [\n                'label'\n            ]\n        },\n        number: {\n            number: true,\n            unitless: true\n        },\n        numbers: {\n            number: true,\n            unitless: true,\n            multiple: true\n        },\n        positiveNumber: {\n            number: true,\n            unitless: true,\n            min: 0,\n            strictMin: true\n        },\n        size: {\n            number: true,\n            min: 0\n        },\n        bidirectionalSize: {\n            number: true\n        },\n        // allows negative\n        bidirectionalSizeMaybePercent: {\n            number: true,\n            allowPercent: true\n        },\n        // allows negative\n        bidirectionalSizes: {\n            number: true,\n            multiple: true\n        },\n        // allows negative\n        sizeMaybePercent: {\n            number: true,\n            min: 0,\n            allowPercent: true\n        },\n        axisDirection: {\n            enums: [\n                'horizontal',\n                'leftward',\n                'rightward',\n                'vertical',\n                'upward',\n                'downward',\n                'auto'\n            ]\n        },\n        axisDirectionExplicit: {\n            enums: [\n                'leftward',\n                'rightward',\n                'upward',\n                'downward'\n            ]\n        },\n        axisDirectionPrimary: {\n            enums: [\n                'horizontal',\n                'vertical'\n            ]\n        },\n        paddingRelativeTo: {\n            enums: [\n                'width',\n                'height',\n                'average',\n                'min',\n                'max'\n            ]\n        },\n        bgWH: {\n            number: true,\n            min: 0,\n            allowPercent: true,\n            enums: [\n                'auto'\n            ],\n            multiple: true\n        },\n        bgPos: {\n            number: true,\n            allowPercent: true,\n            multiple: true\n        },\n        bgRelativeTo: {\n            enums: [\n                'inner',\n                'include-padding'\n            ],\n            multiple: true\n        },\n        bgRepeat: {\n            enums: [\n                'repeat',\n                'repeat-x',\n                'repeat-y',\n                'no-repeat'\n            ],\n            multiple: true\n        },\n        bgFit: {\n            enums: [\n                'none',\n                'contain',\n                'cover'\n            ],\n            multiple: true\n        },\n        bgCrossOrigin: {\n            enums: [\n                'anonymous',\n                'use-credentials',\n                'null'\n            ],\n            multiple: true\n        },\n        bgClip: {\n            enums: [\n                'none',\n                'node'\n            ],\n            multiple: true\n        },\n        bgContainment: {\n            enums: [\n                'inside',\n                'over'\n            ],\n            multiple: true\n        },\n        boxSelection: {\n            enums: [\n                'contain',\n                'overlap',\n                'none'\n            ]\n        },\n        color: {\n            color: true\n        },\n        colors: {\n            color: true,\n            multiple: true\n        },\n        fill: {\n            enums: [\n                'solid',\n                'linear-gradient',\n                'radial-gradient'\n            ]\n        },\n        bool: {\n            enums: [\n                'yes',\n                'no'\n            ]\n        },\n        bools: {\n            enums: [\n                'yes',\n                'no'\n            ],\n            multiple: true\n        },\n        lineStyle: {\n            enums: [\n                'solid',\n                'dotted',\n                'dashed'\n            ]\n        },\n        lineCap: {\n            enums: [\n                'butt',\n                'round',\n                'square'\n            ]\n        },\n        linePosition: {\n            enums: [\n                'center',\n                'inside',\n                'outside'\n            ]\n        },\n        lineJoin: {\n            enums: [\n                'round',\n                'bevel',\n                'miter'\n            ]\n        },\n        borderStyle: {\n            enums: [\n                'solid',\n                'dotted',\n                'dashed',\n                'double'\n            ]\n        },\n        curveStyle: {\n            enums: [\n                'bezier',\n                'unbundled-bezier',\n                'haystack',\n                'segments',\n                'straight',\n                'straight-triangle',\n                'taxi',\n                'round-segments',\n                'round-taxi'\n            ]\n        },\n        radiusType: {\n            enums: [\n                'arc-radius',\n                'influence-radius'\n            ],\n            multiple: true\n        },\n        fontFamily: {\n            regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n        },\n        fontStyle: {\n            enums: [\n                'italic',\n                'normal',\n                'oblique'\n            ]\n        },\n        fontWeight: {\n            enums: [\n                'normal',\n                'bold',\n                'bolder',\n                'lighter',\n                '100',\n                '200',\n                '300',\n                '400',\n                '500',\n                '600',\n                '800',\n                '900',\n                100,\n                200,\n                300,\n                400,\n                500,\n                600,\n                700,\n                800,\n                900\n            ]\n        },\n        textDecoration: {\n            enums: [\n                'none',\n                'underline',\n                'overline',\n                'line-through'\n            ]\n        },\n        textTransform: {\n            enums: [\n                'none',\n                'uppercase',\n                'lowercase'\n            ]\n        },\n        textWrap: {\n            enums: [\n                'none',\n                'wrap',\n                'ellipsis'\n            ]\n        },\n        textOverflowWrap: {\n            enums: [\n                'whitespace',\n                'anywhere'\n            ]\n        },\n        textBackgroundShape: {\n            enums: [\n                'rectangle',\n                'roundrectangle',\n                'round-rectangle',\n                'circle'\n            ]\n        },\n        nodeShape: {\n            enums: [\n                'rectangle',\n                'roundrectangle',\n                'round-rectangle',\n                'cutrectangle',\n                'cut-rectangle',\n                'bottomroundrectangle',\n                'bottom-round-rectangle',\n                'barrel',\n                'ellipse',\n                'triangle',\n                'round-triangle',\n                'square',\n                'pentagon',\n                'round-pentagon',\n                'hexagon',\n                'round-hexagon',\n                'concavehexagon',\n                'concave-hexagon',\n                'heptagon',\n                'round-heptagon',\n                'octagon',\n                'round-octagon',\n                'tag',\n                'round-tag',\n                'star',\n                'diamond',\n                'round-diamond',\n                'vee',\n                'rhomboid',\n                'right-rhomboid',\n                'polygon'\n            ]\n        },\n        overlayShape: {\n            enums: [\n                'roundrectangle',\n                'round-rectangle',\n                'ellipse'\n            ]\n        },\n        cornerRadius: {\n            number: true,\n            min: 0,\n            units: 'px|em',\n            implicitUnits: 'px',\n            enums: [\n                'auto'\n            ]\n        },\n        compoundIncludeLabels: {\n            enums: [\n                'include',\n                'exclude'\n            ]\n        },\n        arrowShape: {\n            enums: [\n                'tee',\n                'triangle',\n                'triangle-tee',\n                'circle-triangle',\n                'triangle-cross',\n                'triangle-backcurve',\n                'vee',\n                'square',\n                'circle',\n                'diamond',\n                'chevron',\n                'none'\n            ]\n        },\n        arrowFill: {\n            enums: [\n                'filled',\n                'hollow'\n            ]\n        },\n        arrowWidth: {\n            number: true,\n            units: '%|px|em',\n            implicitUnits: 'px',\n            enums: [\n                'match-line'\n            ]\n        },\n        display: {\n            enums: [\n                'element',\n                'none'\n            ]\n        },\n        visibility: {\n            enums: [\n                'hidden',\n                'visible'\n            ]\n        },\n        zCompoundDepth: {\n            enums: [\n                'bottom',\n                'orphan',\n                'auto',\n                'top'\n            ]\n        },\n        zIndexCompare: {\n            enums: [\n                'auto',\n                'manual'\n            ]\n        },\n        valign: {\n            enums: [\n                'top',\n                'center',\n                'bottom'\n            ]\n        },\n        halign: {\n            enums: [\n                'left',\n                'center',\n                'right'\n            ]\n        },\n        justification: {\n            enums: [\n                'left',\n                'center',\n                'right',\n                'auto'\n            ]\n        },\n        text: {\n            string: true\n        },\n        data: {\n            mapping: true,\n            regex: data('data')\n        },\n        layoutData: {\n            mapping: true,\n            regex: data('layoutData')\n        },\n        scratch: {\n            mapping: true,\n            regex: data('scratch')\n        },\n        mapData: {\n            mapping: true,\n            regex: mapData('mapData')\n        },\n        mapLayoutData: {\n            mapping: true,\n            regex: mapData('mapLayoutData')\n        },\n        mapScratch: {\n            mapping: true,\n            regex: mapData('mapScratch')\n        },\n        fn: {\n            mapping: true,\n            fn: true\n        },\n        url: {\n            regexes: urlRegexes,\n            singleRegexMatchValue: true\n        },\n        urls: {\n            regexes: urlRegexes,\n            singleRegexMatchValue: true,\n            multiple: true\n        },\n        propList: {\n            propList: true\n        },\n        angle: {\n            number: true,\n            units: 'deg|rad',\n            implicitUnits: 'rad'\n        },\n        textRotation: {\n            number: true,\n            units: 'deg|rad',\n            implicitUnits: 'rad',\n            enums: [\n                'none',\n                'autorotate'\n            ]\n        },\n        polygonPointList: {\n            number: true,\n            multiple: true,\n            evenMultiple: true,\n            min: -1,\n            max: 1,\n            unitless: true\n        },\n        edgeDistances: {\n            enums: [\n                'intersection',\n                'node-position',\n                'endpoints'\n            ]\n        },\n        edgeEndpoint: {\n            number: true,\n            multiple: true,\n            units: '%|px|em|deg|rad',\n            implicitUnits: 'px',\n            enums: [\n                'inside-to-node',\n                'outside-to-node',\n                'outside-to-node-or-label',\n                'outside-to-line',\n                'outside-to-line-or-label'\n            ],\n            singleEnum: true,\n            validate: function validate(valArr, unitsArr) {\n                switch(valArr.length){\n                    case 2:\n                        // can be % or px only\n                        return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n                    case 1:\n                        // can be enum, deg, or rad only\n                        return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n                    default:\n                        return false;\n                }\n            }\n        },\n        easing: {\n            regexes: [\n                '^(spring)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$',\n                '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$'\n            ],\n            enums: [\n                'linear',\n                'ease',\n                'ease-in',\n                'ease-out',\n                'ease-in-out',\n                'ease-in-sine',\n                'ease-out-sine',\n                'ease-in-out-sine',\n                'ease-in-quad',\n                'ease-out-quad',\n                'ease-in-out-quad',\n                'ease-in-cubic',\n                'ease-out-cubic',\n                'ease-in-out-cubic',\n                'ease-in-quart',\n                'ease-out-quart',\n                'ease-in-out-quart',\n                'ease-in-quint',\n                'ease-out-quint',\n                'ease-in-out-quint',\n                'ease-in-expo',\n                'ease-out-expo',\n                'ease-in-out-expo',\n                'ease-in-circ',\n                'ease-out-circ',\n                'ease-in-out-circ'\n            ]\n        },\n        gradientDirection: {\n            enums: [\n                'to-bottom',\n                'to-top',\n                'to-left',\n                'to-right',\n                'to-bottom-right',\n                'to-bottom-left',\n                'to-top-right',\n                'to-top-left',\n                'to-right-bottom',\n                'to-left-bottom',\n                'to-right-top',\n                'to-left-top' // different order\n            ]\n        },\n        boundsExpansion: {\n            number: true,\n            multiple: true,\n            min: 0,\n            validate: function validate(valArr) {\n                var length = valArr.length;\n                return length === 1 || length === 2 || length === 4;\n            }\n        }\n    };\n    var diff = {\n        zeroNonZero: function zeroNonZero(val1, val2) {\n            if ((val1 == null || val2 == null) && val1 !== val2) {\n                return true; // null cases could represent any value\n            }\n            if (val1 == 0 && val2 != 0) {\n                return true;\n            } else if (val1 != 0 && val2 == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        },\n        any: function any(val1, val2) {\n            return val1 != val2;\n        },\n        emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n            var empty1 = emptyString(str1);\n            var empty2 = emptyString(str2);\n            return empty1 && !empty2 || !empty1 && empty2;\n        }\n    };\n    // define visual style properties\n    //\n    // - n.b. adding a new group of props may require updates to updateStyleHints()\n    // - adding new props to an existing group gets handled automatically\n    var t = styfn$2.types;\n    var mainLabel = [\n        {\n            name: 'label',\n            type: t.text,\n            triggersBounds: diff.any,\n            triggersZOrder: diff.emptyNonEmpty\n        },\n        {\n            name: 'text-rotation',\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-margin-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-margin-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        }\n    ];\n    var sourceLabel = [\n        {\n            name: 'source-label',\n            type: t.text,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-rotation',\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-margin-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-margin-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-offset',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var targetLabel = [\n        {\n            name: 'target-label',\n            type: t.text,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-rotation',\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-margin-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-margin-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-offset',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var labelDimensions = [\n        {\n            name: 'font-family',\n            type: t.fontFamily,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'font-style',\n            type: t.fontStyle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'font-weight',\n            type: t.fontWeight,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'font-size',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-transform',\n            type: t.textTransform,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-wrap',\n            type: t.textWrap,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-overflow-wrap',\n            type: t.textOverflowWrap,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-max-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-outline-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'line-height',\n            type: t.positiveNumber,\n            triggersBounds: diff.any\n        }\n    ];\n    var commonLabel = [\n        {\n            name: 'text-valign',\n            type: t.valign,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-halign',\n            type: t.halign,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'color',\n            type: t.color\n        },\n        {\n            name: 'text-outline-color',\n            type: t.color\n        },\n        {\n            name: 'text-outline-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'text-background-color',\n            type: t.color\n        },\n        {\n            name: 'text-background-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'text-background-padding',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-border-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'text-border-color',\n            type: t.color\n        },\n        {\n            name: 'text-border-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-border-style',\n            type: t.borderStyle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-background-shape',\n            type: t.textBackgroundShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-justification',\n            type: t.justification\n        },\n        {\n            name: 'box-select-labels',\n            type: t.bool,\n            triggersBounds: diff.any\n        }\n    ];\n    var behavior = [\n        {\n            name: 'events',\n            type: t.bool,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'text-events',\n            type: t.bool,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'box-selection',\n            type: t.boxSelection,\n            triggersZOrder: diff.any\n        }\n    ];\n    var visibility = [\n        {\n            name: 'display',\n            type: t.display,\n            triggersZOrder: diff.any,\n            triggersBounds: diff.any,\n            triggersBoundsOfConnectedEdges: diff.any,\n            triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue, ele) {\n                if (fromValue === toValue) {\n                    return false;\n                }\n                // only if edge is bundled bezier (so as not to affect performance of other edges)\n                return ele.pstyle('curve-style').value === 'bezier';\n            }\n        },\n        {\n            name: 'visibility',\n            type: t.visibility,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'opacity',\n            type: t.zeroOneNumber,\n            triggersZOrder: diff.zeroNonZero\n        },\n        {\n            name: 'text-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'min-zoomed-font-size',\n            type: t.size\n        },\n        {\n            name: 'z-compound-depth',\n            type: t.zCompoundDepth,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'z-index-compare',\n            type: t.zIndexCompare,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'z-index',\n            type: t.number,\n            triggersZOrder: diff.any\n        }\n    ];\n    var overlay = [\n        {\n            name: 'overlay-padding',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'overlay-color',\n            type: t.color\n        },\n        {\n            name: 'overlay-opacity',\n            type: t.zeroOneNumber,\n            triggersBounds: diff.zeroNonZero\n        },\n        {\n            name: 'overlay-shape',\n            type: t.overlayShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'overlay-corner-radius',\n            type: t.cornerRadius\n        }\n    ];\n    var underlay = [\n        {\n            name: 'underlay-padding',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'underlay-color',\n            type: t.color\n        },\n        {\n            name: 'underlay-opacity',\n            type: t.zeroOneNumber,\n            triggersBounds: diff.zeroNonZero\n        },\n        {\n            name: 'underlay-shape',\n            type: t.overlayShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'underlay-corner-radius',\n            type: t.cornerRadius\n        }\n    ];\n    var transition = [\n        {\n            name: 'transition-property',\n            type: t.propList\n        },\n        {\n            name: 'transition-duration',\n            type: t.time\n        },\n        {\n            name: 'transition-delay',\n            type: t.time\n        },\n        {\n            name: 'transition-timing-function',\n            type: t.easing\n        }\n    ];\n    var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n        if (parsedProp.value === 'label') {\n            return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n        } else {\n            return parsedProp.pfValue;\n        }\n    };\n    var nodeBody = [\n        {\n            name: 'height',\n            type: t.nodeSize,\n            triggersBounds: diff.any,\n            hashOverride: nodeSizeHashOverride\n        },\n        {\n            name: 'width',\n            type: t.nodeSize,\n            triggersBounds: diff.any,\n            hashOverride: nodeSizeHashOverride\n        },\n        {\n            name: 'shape',\n            type: t.nodeShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'shape-polygon-points',\n            type: t.polygonPointList,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'corner-radius',\n            type: t.cornerRadius\n        },\n        {\n            name: 'background-color',\n            type: t.color\n        },\n        {\n            name: 'background-fill',\n            type: t.fill\n        },\n        {\n            name: 'background-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'background-blacken',\n            type: t.nOneOneNumber\n        },\n        {\n            name: 'background-gradient-stop-colors',\n            type: t.colors\n        },\n        {\n            name: 'background-gradient-stop-positions',\n            type: t.percentages\n        },\n        {\n            name: 'background-gradient-direction',\n            type: t.gradientDirection\n        },\n        {\n            name: 'padding',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'padding-relative-to',\n            type: t.paddingRelativeTo,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'bounds-expansion',\n            type: t.boundsExpansion,\n            triggersBounds: diff.any\n        }\n    ];\n    var nodeBorder = [\n        {\n            name: 'border-color',\n            type: t.color\n        },\n        {\n            name: 'border-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'border-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'border-style',\n            type: t.borderStyle\n        },\n        {\n            name: 'border-cap',\n            type: t.lineCap\n        },\n        {\n            name: 'border-join',\n            type: t.lineJoin\n        },\n        {\n            name: 'border-dash-pattern',\n            type: t.numbers\n        },\n        {\n            name: 'border-dash-offset',\n            type: t.number\n        },\n        {\n            name: 'border-position',\n            type: t.linePosition\n        }\n    ];\n    var nodeOutline = [\n        {\n            name: 'outline-color',\n            type: t.color\n        },\n        {\n            name: 'outline-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'outline-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'outline-style',\n            type: t.borderStyle\n        },\n        {\n            name: 'outline-offset',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var backgroundImage = [\n        {\n            name: 'background-image',\n            type: t.urls\n        },\n        {\n            name: 'background-image-crossorigin',\n            type: t.bgCrossOrigin\n        },\n        {\n            name: 'background-image-opacity',\n            type: t.zeroOneNumbers\n        },\n        {\n            name: 'background-image-containment',\n            type: t.bgContainment\n        },\n        {\n            name: 'background-image-smoothing',\n            type: t.bools\n        },\n        {\n            name: 'background-position-x',\n            type: t.bgPos\n        },\n        {\n            name: 'background-position-y',\n            type: t.bgPos\n        },\n        {\n            name: 'background-width-relative-to',\n            type: t.bgRelativeTo\n        },\n        {\n            name: 'background-height-relative-to',\n            type: t.bgRelativeTo\n        },\n        {\n            name: 'background-repeat',\n            type: t.bgRepeat\n        },\n        {\n            name: 'background-fit',\n            type: t.bgFit\n        },\n        {\n            name: 'background-clip',\n            type: t.bgClip\n        },\n        {\n            name: 'background-width',\n            type: t.bgWH\n        },\n        {\n            name: 'background-height',\n            type: t.bgWH\n        },\n        {\n            name: 'background-offset-x',\n            type: t.bgPos\n        },\n        {\n            name: 'background-offset-y',\n            type: t.bgPos\n        }\n    ];\n    var compound = [\n        {\n            name: 'position',\n            type: t.position,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'compound-sizing-wrt-labels',\n            type: t.compoundIncludeLabels,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-width-bias-left',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-width-bias-right',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-height',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-height-bias-top',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-height-bias-bottom',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        }\n    ];\n    var edgeLine = [\n        {\n            name: 'line-style',\n            type: t.lineStyle\n        },\n        {\n            name: 'line-color',\n            type: t.color\n        },\n        {\n            name: 'line-fill',\n            type: t.fill\n        },\n        {\n            name: 'line-cap',\n            type: t.lineCap\n        },\n        {\n            name: 'line-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'line-dash-pattern',\n            type: t.numbers\n        },\n        {\n            name: 'line-dash-offset',\n            type: t.number\n        },\n        {\n            name: 'line-outline-width',\n            type: t.size\n        },\n        {\n            name: 'line-outline-color',\n            type: t.color\n        },\n        {\n            name: 'line-gradient-stop-colors',\n            type: t.colors\n        },\n        {\n            name: 'line-gradient-stop-positions',\n            type: t.percentages\n        },\n        {\n            name: 'curve-style',\n            type: t.curveStyle,\n            triggersBounds: diff.any,\n            triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue) {\n                if (fromValue === toValue) {\n                    return false;\n                } // must have diff\n                return fromValue === 'bezier' || // remove from bundle\n                toValue === 'bezier'; // add to bundle\n            }\n        },\n        {\n            name: 'haystack-radius',\n            type: t.zeroOneNumber,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-endpoint',\n            type: t.edgeEndpoint,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-endpoint',\n            type: t.edgeEndpoint,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'control-point-step-size',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'control-point-distances',\n            type: t.bidirectionalSizes,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'control-point-weights',\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'segment-distances',\n            type: t.bidirectionalSizes,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'segment-weights',\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'segment-radii',\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'radius-type',\n            type: t.radiusType,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-turn',\n            type: t.bidirectionalSizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-turn-min-distance',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-direction',\n            type: t.axisDirection,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-radius',\n            type: t.number,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'edge-distances',\n            type: t.edgeDistances,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'arrow-scale',\n            type: t.positiveNumber,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'loop-direction',\n            type: t.angle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'loop-sweep',\n            type: t.angle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-distance-from-node',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-distance-from-node',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var ghost = [\n        {\n            name: 'ghost',\n            type: t.bool,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'ghost-offset-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'ghost-offset-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'ghost-opacity',\n            type: t.zeroOneNumber\n        }\n    ];\n    var core = [\n        {\n            name: 'selection-box-color',\n            type: t.color\n        },\n        {\n            name: 'selection-box-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'selection-box-border-color',\n            type: t.color\n        },\n        {\n            name: 'selection-box-border-width',\n            type: t.size\n        },\n        {\n            name: 'active-bg-color',\n            type: t.color\n        },\n        {\n            name: 'active-bg-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'active-bg-size',\n            type: t.size\n        },\n        {\n            name: 'outside-texture-bg-color',\n            type: t.color\n        },\n        {\n            name: 'outside-texture-bg-opacity',\n            type: t.zeroOneNumber\n        }\n    ];\n    // pie backgrounds for nodes\n    var pie = [];\n    styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n    pie.push({\n        name: 'pie-size',\n        type: t.sizeMaybePercent\n    });\n    pie.push({\n        name: 'pie-hole',\n        type: t.sizeMaybePercent\n    });\n    pie.push({\n        name: 'pie-start-angle',\n        type: t.angle\n    });\n    for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n        pie.push({\n            name: 'pie-' + i + '-background-color',\n            type: t.color\n        });\n        pie.push({\n            name: 'pie-' + i + '-background-size',\n            type: t.percent\n        });\n        pie.push({\n            name: 'pie-' + i + '-background-opacity',\n            type: t.zeroOneNumber\n        });\n    }\n    // stripe backgrounds for nodes\n    var stripe = [];\n    styfn$2.stripeBackgroundN = 16; // because the stripe properties are numbered, give access to a constant N (for renderer use)\n    stripe.push({\n        name: 'stripe-size',\n        type: t.sizeMaybePercent\n    });\n    stripe.push({\n        name: 'stripe-direction',\n        type: t.axisDirectionPrimary\n    });\n    for(var _i = 1; _i <= styfn$2.stripeBackgroundN; _i++){\n        stripe.push({\n            name: 'stripe-' + _i + '-background-color',\n            type: t.color\n        });\n        stripe.push({\n            name: 'stripe-' + _i + '-background-size',\n            type: t.percent\n        });\n        stripe.push({\n            name: 'stripe-' + _i + '-background-opacity',\n            type: t.zeroOneNumber\n        });\n    }\n    // edge arrows\n    var edgeArrow = [];\n    var arrowPrefixes = styfn$2.arrowPrefixes = [\n        'source',\n        'mid-source',\n        'target',\n        'mid-target'\n    ];\n    [\n        {\n            name: 'arrow-shape',\n            type: t.arrowShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'arrow-color',\n            type: t.color\n        },\n        {\n            name: 'arrow-fill',\n            type: t.arrowFill\n        },\n        {\n            name: 'arrow-width',\n            type: t.arrowWidth\n        }\n    ].forEach(function(prop) {\n        arrowPrefixes.forEach(function(prefix) {\n            var name = prefix + '-' + prop.name;\n            var type = prop.type, triggersBounds = prop.triggersBounds;\n            edgeArrow.push({\n                name: name,\n                type: type,\n                triggersBounds: triggersBounds\n            });\n        });\n    }, {});\n    var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, nodeOutline, backgroundImage, pie, stripe, compound, edgeLine, edgeArrow, core);\n    var propGroups = styfn$2.propertyGroups = {\n        // common to all eles\n        behavior: behavior,\n        transition: transition,\n        visibility: visibility,\n        overlay: overlay,\n        underlay: underlay,\n        ghost: ghost,\n        // labels\n        commonLabel: commonLabel,\n        labelDimensions: labelDimensions,\n        mainLabel: mainLabel,\n        sourceLabel: sourceLabel,\n        targetLabel: targetLabel,\n        // node props\n        nodeBody: nodeBody,\n        nodeBorder: nodeBorder,\n        nodeOutline: nodeOutline,\n        backgroundImage: backgroundImage,\n        pie: pie,\n        stripe: stripe,\n        compound: compound,\n        // edge props\n        edgeLine: edgeLine,\n        edgeArrow: edgeArrow,\n        core: core\n    };\n    var propGroupNames = styfn$2.propertyGroupNames = {};\n    var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n    propGroupKeys.forEach(function(key) {\n        propGroupNames[key] = propGroups[key].map(function(prop) {\n            return prop.name;\n        });\n        propGroups[key].forEach(function(prop) {\n            return prop.groupKey = key;\n        });\n    });\n    // define aliases\n    var aliases = styfn$2.aliases = [\n        {\n            name: 'content',\n            pointsTo: 'label'\n        },\n        {\n            name: 'control-point-distance',\n            pointsTo: 'control-point-distances'\n        },\n        {\n            name: 'control-point-weight',\n            pointsTo: 'control-point-weights'\n        },\n        {\n            name: 'segment-distance',\n            pointsTo: 'segment-distances'\n        },\n        {\n            name: 'segment-weight',\n            pointsTo: 'segment-weights'\n        },\n        {\n            name: 'segment-radius',\n            pointsTo: 'segment-radii'\n        },\n        {\n            name: 'edge-text-rotation',\n            pointsTo: 'text-rotation'\n        },\n        {\n            name: 'padding-left',\n            pointsTo: 'padding'\n        },\n        {\n            name: 'padding-right',\n            pointsTo: 'padding'\n        },\n        {\n            name: 'padding-top',\n            pointsTo: 'padding'\n        },\n        {\n            name: 'padding-bottom',\n            pointsTo: 'padding'\n        }\n    ];\n    // list of property names\n    styfn$2.propertyNames = props.map(function(p) {\n        return p.name;\n    });\n    // allow access of properties by name ( e.g. style.properties.height )\n    for(var _i2 = 0; _i2 < props.length; _i2++){\n        var prop = props[_i2];\n        props[prop.name] = prop; // allow lookup by name\n    }\n    // map aliases\n    for(var _i3 = 0; _i3 < aliases.length; _i3++){\n        var alias = aliases[_i3];\n        var pointsToProp = props[alias.pointsTo];\n        var aliasProp = {\n            name: alias.name,\n            alias: true,\n            pointsTo: pointsToProp\n        };\n        // add alias prop for parsing\n        props.push(aliasProp);\n        props[alias.name] = aliasProp; // allow lookup by name\n    }\n})();\nstyfn$2.getDefaultProperty = function(name) {\n    return this.getDefaultProperties()[name];\n};\nstyfn$2.getDefaultProperties = function() {\n    var _p = this._private;\n    if (_p.defaultProperties != null) {\n        return _p.defaultProperties;\n    }\n    var rawProps = extend({\n        // core props\n        'selection-box-color': '#ddd',\n        'selection-box-opacity': 0.65,\n        'selection-box-border-color': '#aaa',\n        'selection-box-border-width': 1,\n        'active-bg-color': 'black',\n        'active-bg-opacity': 0.15,\n        'active-bg-size': 30,\n        'outside-texture-bg-color': '#000',\n        'outside-texture-bg-opacity': 0.125,\n        // common node/edge props\n        'events': 'yes',\n        'text-events': 'no',\n        'text-valign': 'top',\n        'text-halign': 'center',\n        'text-justification': 'auto',\n        'line-height': 1,\n        'color': '#000',\n        'box-selection': 'contain',\n        'text-outline-color': '#000',\n        'text-outline-width': 0,\n        'text-outline-opacity': 1,\n        'text-opacity': 1,\n        'text-decoration': 'none',\n        'text-transform': 'none',\n        'text-wrap': 'none',\n        'text-overflow-wrap': 'whitespace',\n        'text-max-width': 9999,\n        'text-background-color': '#000',\n        'text-background-opacity': 0,\n        'text-background-shape': 'rectangle',\n        'text-background-padding': 0,\n        'text-border-opacity': 0,\n        'text-border-width': 0,\n        'text-border-style': 'solid',\n        'text-border-color': '#000',\n        'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n        'font-style': 'normal',\n        'font-weight': 'normal',\n        'font-size': 16,\n        'min-zoomed-font-size': 0,\n        'text-rotation': 'none',\n        'source-text-rotation': 'none',\n        'target-text-rotation': 'none',\n        'visibility': 'visible',\n        'display': 'element',\n        'opacity': 1,\n        'z-compound-depth': 'auto',\n        'z-index-compare': 'auto',\n        'z-index': 0,\n        'label': '',\n        'text-margin-x': 0,\n        'text-margin-y': 0,\n        'source-label': '',\n        'source-text-offset': 0,\n        'source-text-margin-x': 0,\n        'source-text-margin-y': 0,\n        'target-label': '',\n        'target-text-offset': 0,\n        'target-text-margin-x': 0,\n        'target-text-margin-y': 0,\n        'overlay-opacity': 0,\n        'overlay-color': '#000',\n        'overlay-padding': 10,\n        'overlay-shape': 'round-rectangle',\n        'overlay-corner-radius': 'auto',\n        'underlay-opacity': 0,\n        'underlay-color': '#000',\n        'underlay-padding': 10,\n        'underlay-shape': 'round-rectangle',\n        'underlay-corner-radius': 'auto',\n        'transition-property': 'none',\n        'transition-duration': 0,\n        'transition-delay': 0,\n        'transition-timing-function': 'linear',\n        'box-select-labels': 'no',\n        // node props\n        'background-blacken': 0,\n        'background-color': '#999',\n        'background-fill': 'solid',\n        'background-opacity': 1,\n        'background-image': 'none',\n        'background-image-crossorigin': 'anonymous',\n        'background-image-opacity': 1,\n        'background-image-containment': 'inside',\n        'background-image-smoothing': 'yes',\n        'background-position-x': '50%',\n        'background-position-y': '50%',\n        'background-offset-x': 0,\n        'background-offset-y': 0,\n        'background-width-relative-to': 'include-padding',\n        'background-height-relative-to': 'include-padding',\n        'background-repeat': 'no-repeat',\n        'background-fit': 'none',\n        'background-clip': 'node',\n        'background-width': 'auto',\n        'background-height': 'auto',\n        'border-color': '#000',\n        'border-opacity': 1,\n        'border-width': 0,\n        'border-style': 'solid',\n        'border-dash-pattern': [\n            4,\n            2\n        ],\n        'border-dash-offset': 0,\n        'border-cap': 'butt',\n        'border-join': 'miter',\n        'border-position': 'center',\n        'outline-color': '#999',\n        'outline-opacity': 1,\n        'outline-width': 0,\n        'outline-offset': 0,\n        'outline-style': 'solid',\n        'height': 30,\n        'width': 30,\n        'shape': 'ellipse',\n        'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n        'corner-radius': 'auto',\n        'bounds-expansion': 0,\n        // node gradient\n        'background-gradient-direction': 'to-bottom',\n        'background-gradient-stop-colors': '#999',\n        'background-gradient-stop-positions': '0%',\n        // ghost props\n        'ghost': 'no',\n        'ghost-offset-y': 0,\n        'ghost-offset-x': 0,\n        'ghost-opacity': 0,\n        // compound props\n        'padding': 0,\n        'padding-relative-to': 'width',\n        'position': 'origin',\n        'compound-sizing-wrt-labels': 'include',\n        'min-width': 0,\n        'min-width-bias-left': 0,\n        'min-width-bias-right': 0,\n        'min-height': 0,\n        'min-height-bias-top': 0,\n        'min-height-bias-bottom': 0\n    }, {\n        // node pie bg\n        'pie-size': '100%',\n        'pie-hole': 0,\n        'pie-start-angle': '0deg'\n    }, [\n        {\n            name: 'pie-{{i}}-background-color',\n            value: 'black'\n        },\n        {\n            name: 'pie-{{i}}-background-size',\n            value: '0%'\n        },\n        {\n            name: 'pie-{{i}}-background-opacity',\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n            var name = prop.name.replace('{{i}}', i);\n            var val = prop.value;\n            css[name] = val;\n        }\n        return css;\n    }, {}), {\n        // node stripes bg\n        'stripe-size': '100%',\n        'stripe-direction': 'horizontal'\n    }, [\n        {\n            name: 'stripe-{{i}}-background-color',\n            value: 'black'\n        },\n        {\n            name: 'stripe-{{i}}-background-size',\n            value: '0%'\n        },\n        {\n            name: 'stripe-{{i}}-background-opacity',\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        for(var i = 1; i <= styfn$2.stripeBackgroundN; i++){\n            var name = prop.name.replace('{{i}}', i);\n            var val = prop.value;\n            css[name] = val;\n        }\n        return css;\n    }, {}), {\n        // edge props\n        'line-style': 'solid',\n        'line-color': '#999',\n        'line-fill': 'solid',\n        'line-cap': 'butt',\n        'line-opacity': 1,\n        'line-outline-width': 0,\n        'line-outline-color': '#000',\n        'line-gradient-stop-colors': '#999',\n        'line-gradient-stop-positions': '0%',\n        'control-point-step-size': 40,\n        'control-point-weights': 0.5,\n        'segment-weights': 0.5,\n        'segment-distances': 20,\n        'segment-radii': 15,\n        'radius-type': 'arc-radius',\n        'taxi-turn': '50%',\n        'taxi-radius': 15,\n        'taxi-turn-min-distance': 10,\n        'taxi-direction': 'auto',\n        'edge-distances': 'intersection',\n        'curve-style': 'haystack',\n        'haystack-radius': 0,\n        'arrow-scale': 1,\n        'loop-direction': '-45deg',\n        'loop-sweep': '-90deg',\n        'source-distance-from-node': 0,\n        'target-distance-from-node': 0,\n        'source-endpoint': 'outside-to-node',\n        'target-endpoint': 'outside-to-node',\n        'line-dash-pattern': [\n            6,\n            3\n        ],\n        'line-dash-offset': 0\n    }, [\n        {\n            name: 'arrow-shape',\n            value: 'none'\n        },\n        {\n            name: 'arrow-color',\n            value: '#999'\n        },\n        {\n            name: 'arrow-fill',\n            value: 'filled'\n        },\n        {\n            name: 'arrow-width',\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        styfn$2.arrowPrefixes.forEach(function(prefix) {\n            var name = prefix + '-' + prop.name;\n            var val = prop.value;\n            css[name] = val;\n        });\n        return css;\n    }, {}));\n    var parsedProps = {};\n    for(var i = 0; i < this.properties.length; i++){\n        var prop = this.properties[i];\n        if (prop.pointsTo) {\n            continue;\n        }\n        var name = prop.name;\n        var val = rawProps[name];\n        var parsedProp = this.parse(name, val);\n        parsedProps[name] = parsedProp;\n    }\n    _p.defaultProperties = parsedProps;\n    return _p.defaultProperties;\n};\nstyfn$2.addDefaultStylesheet = function() {\n    this.selector(':parent').css({\n        'shape': 'rectangle',\n        'padding': 10,\n        'background-color': '#eee',\n        'border-color': '#ccc',\n        'border-width': 1\n    }).selector('edge').css({\n        'width': 3\n    }).selector(':loop').css({\n        'curve-style': 'bezier'\n    }).selector('edge:compound').css({\n        'curve-style': 'bezier',\n        'source-endpoint': 'outside-to-line',\n        'target-endpoint': 'outside-to-line'\n    }).selector(':selected').css({\n        'background-color': '#0169D9',\n        'line-color': '#0169D9',\n        'source-arrow-color': '#0169D9',\n        'target-arrow-color': '#0169D9',\n        'mid-source-arrow-color': '#0169D9',\n        'mid-target-arrow-color': '#0169D9'\n    }).selector(':parent:selected').css({\n        'background-color': '#CCE1F9',\n        'border-color': '#aec8e5'\n    }).selector(':active').css({\n        'overlay-color': 'black',\n        'overlay-padding': 10,\n        'overlay-opacity': 0.25\n    });\n    this.defaultLength = this.length;\n};\nvar styfn$1 = {};\n// a caching layer for property parsing\nstyfn$1.parse = function(name, value, propIsBypass, propIsFlat) {\n    var self1 = this;\n    // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n    if (fn$6(value)) {\n        return self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n    var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n    var bypassKey = propIsBypass ? 't' : 'f';\n    var valueKey = '' + value;\n    var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n    var propCache = self1.propCache = self1.propCache || [];\n    var ret;\n    if (!(ret = propCache[argHash])) {\n        ret = propCache[argHash] = self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n    // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n    // - mappings can't be shared b/c mappings are per-element\n    if (propIsBypass || propIsFlat === 'mapping') {\n        // need a copy since props are mutated later in their lifecycles\n        ret = copy(ret);\n        if (ret) {\n            ret.value = copy(ret.value); // because it could be an array, e.g. colour\n        }\n    }\n    return ret;\n};\nstyfn$1.parseImplWarn = function(name, value, propIsBypass, propIsFlat) {\n    var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n    if (!prop && value != null) {\n        warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n    }\n    if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {\n        warn('The style value of `label` is deprecated for `' + prop.name + '`');\n    }\n    return prop;\n};\n// parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\nstyfn$1.parseImpl = function(name, value, propIsBypass, propIsFlat) {\n    var self1 = this;\n    name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n    var property = self1.properties[name];\n    var passedValue = value;\n    var types = self1.types;\n    if (!property) {\n        return null;\n    } // return null on property of unknown name\n    if (value === undefined) {\n        return null;\n    } // can't assign undefined\n    // the property may be an alias\n    if (property.alias) {\n        property = property.pointsTo;\n        name = property.name;\n    }\n    var valueIsString = string(value);\n    if (valueIsString) {\n        // trim the value to make parsing easier\n        value = value.trim();\n    }\n    var type = property.type;\n    if (!type) {\n        return null;\n    } // no type, no luck\n    // check if bypass is null or empty string (i.e. indication to delete bypass property)\n    if (propIsBypass && (value === '' || value === null)) {\n        return {\n            name: name,\n            value: value,\n            bypass: true,\n            deleteBypass: true\n        };\n    }\n    // check if value is a function used as a mapper\n    if (fn$6(value)) {\n        return {\n            name: name,\n            value: value,\n            strValue: 'fn',\n            mapped: types.fn,\n            bypass: propIsBypass\n        };\n    }\n    // check if value is mapped\n    var data, mapData;\n    if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ;\n    else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {\n        if (propIsBypass) {\n            return false;\n        } // mappers not allowed in bypass\n        var mapped = types.data;\n        return {\n            name: name,\n            value: data,\n            strValue: '' + value,\n            mapped: mapped,\n            field: data[1],\n            bypass: propIsBypass\n        };\n    } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n        if (propIsBypass) {\n            return false;\n        } // mappers not allowed in bypass\n        if (type.multiple) {\n            return false;\n        } // impossible to map to num\n        var _mapped = types.mapData;\n        // we can map only if the type is a colour or a number\n        if (!(type.color || type.number)) {\n            return false;\n        }\n        var valueMin = this.parse(name, mapData[4]); // parse to validate\n        if (!valueMin || valueMin.mapped) {\n            return false;\n        } // can't be invalid or mapped\n        var valueMax = this.parse(name, mapData[5]); // parse to validate\n        if (!valueMax || valueMax.mapped) {\n            return false;\n        } // can't be invalid or mapped\n        // check if valueMin and valueMax are the same\n        if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n            warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');\n            return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n        } else if (type.color) {\n            var c1 = valueMin.value;\n            var c2 = valueMax.value;\n            var same = c1[0] === c2[0] // red\n             && c1[1] === c2[1] // green\n             && c1[2] === c2[2] // blue\n             && // optional alpha\n            (c1[3] === c2[3] // same alpha outright\n             || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n            ) && (c2[3] == null || c2[3] === 1 // full opacity for colour 2?\n            ));\n            if (same) {\n                return false;\n            } // can't make a mapper without a range\n        }\n        return {\n            name: name,\n            value: mapData,\n            strValue: '' + value,\n            mapped: _mapped,\n            field: mapData[1],\n            fieldMin: parseFloat(mapData[2]),\n            // min & max are numeric\n            fieldMax: parseFloat(mapData[3]),\n            valueMin: valueMin.value,\n            valueMax: valueMax.value,\n            bypass: propIsBypass\n        };\n    }\n    if (type.multiple && propIsFlat !== 'multiple') {\n        var vals;\n        if (valueIsString) {\n            vals = value.split(/\\s+/);\n        } else if (array(value)) {\n            vals = value;\n        } else {\n            vals = [\n                value\n            ];\n        }\n        if (type.evenMultiple && vals.length % 2 !== 0) {\n            return null;\n        }\n        var valArr = [];\n        var unitsArr = [];\n        var pfValArr = [];\n        var strVal = '';\n        var hasEnum = false;\n        for(var i = 0; i < vals.length; i++){\n            var p = self1.parse(name, vals[i], propIsBypass, 'multiple');\n            hasEnum = hasEnum || string(p.value);\n            valArr.push(p.value);\n            pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n            unitsArr.push(p.units);\n            strVal += (i > 0 ? ' ' : '') + p.strValue;\n        }\n        if (type.validate && !type.validate(valArr, unitsArr)) {\n            return null;\n        }\n        if (type.singleEnum && hasEnum) {\n            if (valArr.length === 1 && string(valArr[0])) {\n                return {\n                    name: name,\n                    value: valArr[0],\n                    strValue: valArr[0],\n                    bypass: propIsBypass\n                };\n            } else {\n                return null;\n            }\n        }\n        return {\n            name: name,\n            value: valArr,\n            pfValue: pfValArr,\n            strValue: strVal,\n            bypass: propIsBypass,\n            units: unitsArr\n        };\n    }\n    // several types also allow enums\n    var checkEnums = function checkEnums() {\n        for(var _i = 0; _i < type.enums.length; _i++){\n            var en = type.enums[_i];\n            if (en === value) {\n                return {\n                    name: name,\n                    value: value,\n                    strValue: '' + value,\n                    bypass: propIsBypass\n                };\n            }\n        }\n        return null;\n    };\n    // check the type and return the appropriate object\n    if (type.number) {\n        var units;\n        var implicitUnits = 'px'; // not set => px\n        if (type.units) {\n            // use specified units if set\n            units = type.units;\n        }\n        if (type.implicitUnits) {\n            implicitUnits = type.implicitUnits;\n        }\n        if (!type.unitless) {\n            if (valueIsString) {\n                var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n                if (units) {\n                    unitsRegex = units;\n                } // only allow explicit units if so set\n                var match = value.match('^(' + number + ')(' + unitsRegex + ')?' + '$');\n                if (match) {\n                    value = match[1];\n                    units = match[2] || implicitUnits;\n                }\n            } else if (!units || type.implicitUnits) {\n                units = implicitUnits; // implicitly px if unspecified\n            }\n        }\n        value = parseFloat(value);\n        // if not a number and enums not allowed, then the value is invalid\n        if (isNaN(value) && type.enums === undefined) {\n            return null;\n        }\n        // check if this number type also accepts special keywords in place of numbers\n        // (i.e. `left`, `auto`, etc)\n        if (isNaN(value) && type.enums !== undefined) {\n            value = passedValue;\n            return checkEnums();\n        }\n        // check if value must be an integer\n        if (type.integer && !integer(value)) {\n            return null;\n        }\n        // check value is within range\n        if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n            return null;\n        }\n        var ret = {\n            name: name,\n            value: value,\n            strValue: '' + value + (units ? units : ''),\n            units: units,\n            bypass: propIsBypass\n        };\n        // normalise value in pixels\n        if (type.unitless || units !== 'px' && units !== 'em') {\n            ret.pfValue = value;\n        } else {\n            ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n        }\n        // normalise value in ms\n        if (units === 'ms' || units === 's') {\n            ret.pfValue = units === 'ms' ? value : 1000 * value;\n        }\n        // normalise value in rad\n        if (units === 'deg' || units === 'rad') {\n            ret.pfValue = units === 'rad' ? value : deg2rad(value);\n        }\n        // normalize value in %\n        if (units === '%') {\n            ret.pfValue = value / 100;\n        }\n        return ret;\n    } else if (type.propList) {\n        var props = [];\n        var propsStr = '' + value;\n        if (propsStr === 'none') ;\n        else {\n            // go over each prop\n            var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n            for(var _i2 = 0; _i2 < propsSplit.length; _i2++){\n                var propName = propsSplit[_i2].trim();\n                if (self1.properties[propName]) {\n                    props.push(propName);\n                } else {\n                    warn('`' + propName + '` is not a valid property name');\n                }\n            }\n            if (props.length === 0) {\n                return null;\n            }\n        }\n        return {\n            name: name,\n            value: props,\n            strValue: props.length === 0 ? 'none' : props.join(' '),\n            bypass: propIsBypass\n        };\n    } else if (type.color) {\n        var tuple = color2tuple(value);\n        if (!tuple) {\n            return null;\n        }\n        return {\n            name: name,\n            value: tuple,\n            pfValue: tuple,\n            strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',\n            // n.b. no spaces b/c of multiple support\n            bypass: propIsBypass\n        };\n    } else if (type.regex || type.regexes) {\n        // first check enums\n        if (type.enums) {\n            var enumProp = checkEnums();\n            if (enumProp) {\n                return enumProp;\n            }\n        }\n        var regexes = type.regexes ? type.regexes : [\n            type.regex\n        ];\n        for(var _i3 = 0; _i3 < regexes.length; _i3++){\n            var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n            var m1 = regex.exec(value);\n            if (m1) {\n                // regex matches\n                return {\n                    name: name,\n                    value: type.singleRegexMatchValue ? m1[1] : m1,\n                    strValue: '' + value,\n                    bypass: propIsBypass\n                };\n            }\n        }\n        return null; // didn't match any\n    } else if (type.string) {\n        // just return\n        return {\n            name: name,\n            value: '' + value,\n            strValue: '' + value,\n            bypass: propIsBypass\n        };\n    } else if (type.enums) {\n        // check enums last because it's a combo type in others\n        return checkEnums();\n    } else {\n        return null; // not a type we can handle\n    }\n};\nvar _Style = function Style(cy) {\n    if (!(this instanceof _Style)) {\n        return new _Style(cy);\n    }\n    if (!core(cy)) {\n        error('A style must have a core reference');\n        return;\n    }\n    this._private = {\n        cy: cy,\n        coreStyle: {}\n    };\n    this.length = 0;\n    this.resetToDefault();\n};\nvar styfn = _Style.prototype;\nstyfn.instanceString = function() {\n    return 'style';\n};\n// remove all contexts\nstyfn.clear = function() {\n    var _p = this._private;\n    var cy = _p.cy;\n    var eles = cy.elements();\n    for(var i = 0; i < this.length; i++){\n        this[i] = undefined;\n    }\n    this.length = 0;\n    _p.contextStyles = {};\n    _p.propDiffs = {};\n    this.cleanElements(eles, true);\n    eles.forEach(function(ele) {\n        var ele_p = ele[0]._private;\n        ele_p.styleDirty = true;\n        ele_p.appliedInitStyle = false;\n    });\n    return this; // chaining\n};\nstyfn.resetToDefault = function() {\n    this.clear();\n    this.addDefaultStylesheet();\n    return this;\n};\n// builds a style object for the 'core' selector\nstyfn.core = function(propName) {\n    return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n};\n// create a new context from the specified selector string and switch to that context\nstyfn.selector = function(selectorStr) {\n    // 'core' is a special case and does not need a selector\n    var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n    var i = this.length++; // new context means new index\n    this[i] = {\n        selector: selector,\n        properties: [],\n        mappedProperties: [],\n        index: i\n    };\n    return this; // chaining\n};\n// add one or many css rules to the current context\nstyfn.css = function() {\n    var self1 = this;\n    var args = arguments;\n    if (args.length === 1) {\n        var map = args[0];\n        for(var i = 0; i < self1.properties.length; i++){\n            var prop = self1.properties[i];\n            var mapVal = map[prop.name];\n            if (mapVal === undefined) {\n                mapVal = map[dash2camel(prop.name)];\n            }\n            if (mapVal !== undefined) {\n                this.cssRule(prop.name, mapVal);\n            }\n        }\n    } else if (args.length === 2) {\n        this.cssRule(args[0], args[1]);\n    }\n    // do nothing if args are invalid\n    return this; // chaining\n};\nstyfn.style = styfn.css;\n// add a single css rule to the current context\nstyfn.cssRule = function(name, value) {\n    // name-value pair\n    var property = this.parse(name, value);\n    // add property to current context if valid\n    if (property) {\n        var i = this.length - 1;\n        this[i].properties.push(property);\n        this[i].properties[property.name] = property; // allow access by name as well\n        if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n            this._private.hasPie = true;\n        }\n        if (property.name.match(/stripe-(\\d+)-background-size/) && property.value) {\n            this._private.hasStripe = true;\n        }\n        if (property.mapped) {\n            this[i].mappedProperties.push(property);\n        }\n        // add to core style if necessary\n        var currentSelectorIsCore = !this[i].selector;\n        if (currentSelectorIsCore) {\n            this._private.coreStyle[property.name] = property;\n        }\n    }\n    return this; // chaining\n};\nstyfn.append = function(style) {\n    if (stylesheet(style)) {\n        style.appendToStyle(this);\n    } else if (array(style)) {\n        this.appendFromJson(style);\n    } else if (string(style)) {\n        this.appendFromString(style);\n    } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n    return this;\n};\n// static function\n_Style.fromJson = function(cy, json) {\n    var style = new _Style(cy);\n    style.fromJson(json);\n    return style;\n};\n_Style.fromString = function(cy, string) {\n    return new _Style(cy).fromString(string);\n};\n[\n    styfn$8,\n    styfn$7,\n    styfn$6,\n    styfn$5,\n    styfn$4,\n    styfn$3,\n    styfn$2,\n    styfn$1\n].forEach(function(props) {\n    extend(styfn, props);\n});\n_Style.types = styfn.types;\n_Style.properties = styfn.properties;\n_Style.propertyGroups = styfn.propertyGroups;\n_Style.propertyGroupNames = styfn.propertyGroupNames;\n_Style.propertyGroupKeys = styfn.propertyGroupKeys;\nvar corefn$2 = {\n    style: function style(newStyle) {\n        if (newStyle) {\n            var s = this.setStyle(newStyle);\n            s.update();\n        }\n        return this._private.style;\n    },\n    setStyle: function setStyle(style) {\n        var _p = this._private;\n        if (stylesheet(style)) {\n            _p.style = style.generateStyle(this);\n        } else if (array(style)) {\n            _p.style = _Style.fromJson(this, style);\n        } else if (string(style)) {\n            _p.style = _Style.fromString(this, style);\n        } else {\n            _p.style = _Style(this);\n        }\n        return _p.style;\n    },\n    // e.g. cy.data() changed => recalc ele mappers\n    updateStyle: function updateStyle() {\n        this.mutableElements().updateStyle(); // just send to all eles\n    }\n};\nvar defaultSelectionType = 'single';\nvar corefn$1 = {\n    autolock: function autolock(bool) {\n        if (bool !== undefined) {\n            this._private.autolock = bool ? true : false;\n        } else {\n            return this._private.autolock;\n        }\n        return this; // chaining\n    },\n    autoungrabify: function autoungrabify(bool) {\n        if (bool !== undefined) {\n            this._private.autoungrabify = bool ? true : false;\n        } else {\n            return this._private.autoungrabify;\n        }\n        return this; // chaining\n    },\n    autounselectify: function autounselectify(bool) {\n        if (bool !== undefined) {\n            this._private.autounselectify = bool ? true : false;\n        } else {\n            return this._private.autounselectify;\n        }\n        return this; // chaining\n    },\n    selectionType: function selectionType(selType) {\n        var _p = this._private;\n        if (_p.selectionType == null) {\n            _p.selectionType = defaultSelectionType;\n        }\n        if (selType !== undefined) {\n            if (selType === 'additive' || selType === 'single') {\n                _p.selectionType = selType;\n            }\n        } else {\n            return _p.selectionType;\n        }\n        return this;\n    },\n    panningEnabled: function panningEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.panningEnabled = bool ? true : false;\n        } else {\n            return this._private.panningEnabled;\n        }\n        return this; // chaining\n    },\n    userPanningEnabled: function userPanningEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.userPanningEnabled = bool ? true : false;\n        } else {\n            return this._private.userPanningEnabled;\n        }\n        return this; // chaining\n    },\n    zoomingEnabled: function zoomingEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.zoomingEnabled = bool ? true : false;\n        } else {\n            return this._private.zoomingEnabled;\n        }\n        return this; // chaining\n    },\n    userZoomingEnabled: function userZoomingEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.userZoomingEnabled = bool ? true : false;\n        } else {\n            return this._private.userZoomingEnabled;\n        }\n        return this; // chaining\n    },\n    boxSelectionEnabled: function boxSelectionEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.boxSelectionEnabled = bool ? true : false;\n        } else {\n            return this._private.boxSelectionEnabled;\n        }\n        return this; // chaining\n    },\n    pan: function pan() {\n        var args = arguments;\n        var pan = this._private.pan;\n        var dim, val, dims, x, y;\n        switch(args.length){\n            case 0:\n                // .pan()\n                return pan;\n            case 1:\n                if (string(args[0])) {\n                    // .pan('x')\n                    dim = args[0];\n                    return pan[dim];\n                } else if (plainObject(args[0])) {\n                    // .pan({ x: 0, y: 100 })\n                    if (!this._private.panningEnabled) {\n                        return this;\n                    }\n                    dims = args[0];\n                    x = dims.x;\n                    y = dims.y;\n                    if (number$1(x)) {\n                        pan.x = x;\n                    }\n                    if (number$1(y)) {\n                        pan.y = y;\n                    }\n                    this.emit('pan viewport');\n                }\n                break;\n            case 2:\n                // .pan('x', 100)\n                if (!this._private.panningEnabled) {\n                    return this;\n                }\n                dim = args[0];\n                val = args[1];\n                if ((dim === 'x' || dim === 'y') && number$1(val)) {\n                    pan[dim] = val;\n                }\n                this.emit('pan viewport');\n                break;\n        }\n        this.notify('viewport');\n        return this; // chaining\n    },\n    panBy: function panBy(arg0, arg1) {\n        var args = arguments;\n        var pan = this._private.pan;\n        var dim, val, dims, x, y;\n        if (!this._private.panningEnabled) {\n            return this;\n        }\n        switch(args.length){\n            case 1:\n                if (plainObject(arg0)) {\n                    // .panBy({ x: 0, y: 100 })\n                    dims = args[0];\n                    x = dims.x;\n                    y = dims.y;\n                    if (number$1(x)) {\n                        pan.x += x;\n                    }\n                    if (number$1(y)) {\n                        pan.y += y;\n                    }\n                    this.emit('pan viewport');\n                }\n                break;\n            case 2:\n                // .panBy('x', 100)\n                dim = arg0;\n                val = arg1;\n                if ((dim === 'x' || dim === 'y') && number$1(val)) {\n                    pan[dim] += val;\n                }\n                this.emit('pan viewport');\n                break;\n        }\n        this.notify('viewport');\n        return this; // chaining\n    },\n    gc: function gc() {\n        this.notify('gc');\n    },\n    fit: function fit(elements, padding) {\n        var viewportState = this.getFitViewport(elements, padding);\n        if (viewportState) {\n            var _p = this._private;\n            _p.zoom = viewportState.zoom;\n            _p.pan = viewportState.pan;\n            this.emit('pan zoom viewport');\n            this.notify('viewport');\n        }\n        return this; // chaining\n    },\n    getFitViewport: function getFitViewport(elements, padding) {\n        if (number$1(elements) && padding === undefined) {\n            // elements is optional\n            padding = elements;\n            elements = undefined;\n        }\n        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n            return;\n        }\n        var bb;\n        if (string(elements)) {\n            var sel = elements;\n            elements = this.$(sel);\n        } else if (boundingBox(elements)) {\n            // assume bb\n            var bbe = elements;\n            bb = {\n                x1: bbe.x1,\n                y1: bbe.y1,\n                x2: bbe.x2,\n                y2: bbe.y2\n            };\n            bb.w = bb.x2 - bb.x1;\n            bb.h = bb.y2 - bb.y1;\n        } else if (!elementOrCollection(elements)) {\n            elements = this.mutableElements();\n        }\n        if (elementOrCollection(elements) && elements.empty()) {\n            return;\n        } // can't fit to nothing\n        bb = bb || elements.boundingBox();\n        var w = this.width();\n        var h = this.height();\n        var zoom;\n        padding = number$1(padding) ? padding : 0;\n        if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n            zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);\n            // crop zoom\n            zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n            zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n            var pan = {\n                // now pan to middle\n                x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n                y: (h - zoom * (bb.y1 + bb.y2)) / 2\n            };\n            return {\n                zoom: zoom,\n                pan: pan\n            };\n        }\n        return;\n    },\n    zoomRange: function zoomRange(min, max) {\n        var _p = this._private;\n        if (max == null) {\n            var opts = min;\n            min = opts.min;\n            max = opts.max;\n        }\n        if (number$1(min) && number$1(max) && min <= max) {\n            _p.minZoom = min;\n            _p.maxZoom = max;\n        } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n            _p.minZoom = min;\n        } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n            _p.maxZoom = max;\n        }\n        return this;\n    },\n    minZoom: function minZoom(zoom) {\n        if (zoom === undefined) {\n            return this._private.minZoom;\n        } else {\n            return this.zoomRange({\n                min: zoom\n            });\n        }\n    },\n    maxZoom: function maxZoom(zoom) {\n        if (zoom === undefined) {\n            return this._private.maxZoom;\n        } else {\n            return this.zoomRange({\n                max: zoom\n            });\n        }\n    },\n    getZoomedViewport: function getZoomedViewport(params) {\n        var _p = this._private;\n        var currentPan = _p.pan;\n        var currentZoom = _p.zoom;\n        var pos; // in rendered px\n        var zoom;\n        var bail = false;\n        if (!_p.zoomingEnabled) {\n            // zooming disabled\n            bail = true;\n        }\n        if (number$1(params)) {\n            // then set the zoom\n            zoom = params;\n        } else if (plainObject(params)) {\n            // then zoom about a point\n            zoom = params.level;\n            if (params.position != null) {\n                pos = modelToRenderedPosition$1(params.position, currentZoom, currentPan);\n            } else if (params.renderedPosition != null) {\n                pos = params.renderedPosition;\n            }\n            if (pos != null && !_p.panningEnabled) {\n                // panning disabled\n                bail = true;\n            }\n        }\n        // crop zoom\n        zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n        zoom = zoom < _p.minZoom ? _p.minZoom : zoom;\n        // can't zoom with invalid params\n        if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n            return null;\n        }\n        if (pos != null) {\n            // set zoom about position\n            var pan1 = currentPan;\n            var zoom1 = currentZoom;\n            var zoom2 = zoom;\n            var pan2 = {\n                x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n                y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n            };\n            return {\n                zoomed: true,\n                panned: true,\n                zoom: zoom2,\n                pan: pan2\n            };\n        } else {\n            // just set the zoom\n            return {\n                zoomed: true,\n                panned: false,\n                zoom: zoom,\n                pan: currentPan\n            };\n        }\n    },\n    zoom: function zoom(params) {\n        if (params === undefined) {\n            // get\n            return this._private.zoom;\n        } else {\n            // set\n            var vp = this.getZoomedViewport(params);\n            var _p = this._private;\n            if (vp == null || !vp.zoomed) {\n                return this;\n            }\n            _p.zoom = vp.zoom;\n            if (vp.panned) {\n                _p.pan.x = vp.pan.x;\n                _p.pan.y = vp.pan.y;\n            }\n            this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n            this.notify('viewport');\n            return this; // chaining\n        }\n    },\n    viewport: function viewport(opts) {\n        var _p = this._private;\n        var zoomDefd = true;\n        var panDefd = true;\n        var events = []; // to trigger\n        var zoomFailed = false;\n        var panFailed = false;\n        if (!opts) {\n            return this;\n        }\n        if (!number$1(opts.zoom)) {\n            zoomDefd = false;\n        }\n        if (!plainObject(opts.pan)) {\n            panDefd = false;\n        }\n        if (!zoomDefd && !panDefd) {\n            return this;\n        }\n        if (zoomDefd) {\n            var z = opts.zoom;\n            if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n                zoomFailed = true;\n            } else {\n                _p.zoom = z;\n                events.push('zoom');\n            }\n        }\n        if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n            var p = opts.pan;\n            if (number$1(p.x)) {\n                _p.pan.x = p.x;\n                panFailed = false;\n            }\n            if (number$1(p.y)) {\n                _p.pan.y = p.y;\n                panFailed = false;\n            }\n            if (!panFailed) {\n                events.push('pan');\n            }\n        }\n        if (events.length > 0) {\n            events.push('viewport');\n            this.emit(events.join(' '));\n            this.notify('viewport');\n        }\n        return this; // chaining\n    },\n    center: function center(elements) {\n        var pan = this.getCenterPan(elements);\n        if (pan) {\n            this._private.pan = pan;\n            this.emit('pan viewport');\n            this.notify('viewport');\n        }\n        return this; // chaining\n    },\n    getCenterPan: function getCenterPan(elements, zoom) {\n        if (!this._private.panningEnabled) {\n            return;\n        }\n        if (string(elements)) {\n            var selector = elements;\n            elements = this.mutableElements().filter(selector);\n        } else if (!elementOrCollection(elements)) {\n            elements = this.mutableElements();\n        }\n        if (elements.length === 0) {\n            return;\n        } // can't centre pan to nothing\n        var bb = elements.boundingBox();\n        var w = this.width();\n        var h = this.height();\n        zoom = zoom === undefined ? this._private.zoom : zoom;\n        var pan = {\n            // middle\n            x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n            y: (h - zoom * (bb.y1 + bb.y2)) / 2\n        };\n        return pan;\n    },\n    reset: function reset() {\n        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n            return this;\n        }\n        this.viewport({\n            pan: {\n                x: 0,\n                y: 0\n            },\n            zoom: 1\n        });\n        return this; // chaining\n    },\n    invalidateSize: function invalidateSize() {\n        this._private.sizeCache = null;\n    },\n    size: function size() {\n        var _p = this._private;\n        var container = _p.container;\n        var cy = this;\n        return _p.sizeCache = _p.sizeCache || (container ? function() {\n            var style = cy.window().getComputedStyle(container);\n            var val = function val(name) {\n                return parseFloat(style.getPropertyValue(name));\n            };\n            return {\n                width: container.clientWidth - val('padding-left') - val('padding-right'),\n                height: container.clientHeight - val('padding-top') - val('padding-bottom')\n            };\n        }() : {\n            // fallback if no container (not 0 b/c can be used for dividing etc)\n            width: 1,\n            height: 1\n        });\n    },\n    width: function width() {\n        return this.size().width;\n    },\n    height: function height() {\n        return this.size().height;\n    },\n    extent: function extent() {\n        var pan = this._private.pan;\n        var zoom = this._private.zoom;\n        var rb = this.renderedExtent();\n        var b = {\n            x1: (rb.x1 - pan.x) / zoom,\n            x2: (rb.x2 - pan.x) / zoom,\n            y1: (rb.y1 - pan.y) / zoom,\n            y2: (rb.y2 - pan.y) / zoom\n        };\n        b.w = b.x2 - b.x1;\n        b.h = b.y2 - b.y1;\n        return b;\n    },\n    renderedExtent: function renderedExtent() {\n        var width = this.width();\n        var height = this.height();\n        return {\n            x1: 0,\n            y1: 0,\n            x2: width,\n            y2: height,\n            w: width,\n            h: height\n        };\n    },\n    multiClickDebounceTime: function multiClickDebounceTime(_int) {\n        if (_int) this._private.multiClickDebounceTime = _int;\n        else return this._private.multiClickDebounceTime;\n        return this; // chaining\n    }\n};\n// aliases\ncorefn$1.centre = corefn$1.center;\n// backwards compatibility\ncorefn$1.autolockNodes = corefn$1.autolock;\ncorefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\nvar fn = {\n    data: define.data({\n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'data',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeData: define.removeData({\n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        updateStyle: true\n    }),\n    scratch: define.data({\n        field: 'scratch',\n        bindingEvent: 'scratch',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'scratch',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeScratch: define.removeData({\n        field: 'scratch',\n        event: 'scratch',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        updateStyle: true\n    })\n};\n// aliases\nfn.attr = fn.data;\nfn.removeAttr = fn.removeData;\nvar Core = function Core(opts) {\n    var cy = this;\n    opts = extend({}, opts);\n    var container = opts.container;\n    // allow for passing a wrapped jquery object\n    // e.g. cytoscape({ container: $('#cy') })\n    if (container && !htmlElement(container) && htmlElement(container[0])) {\n        container = container[0];\n    }\n    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n    reg = reg || {};\n    if (reg && reg.cy) {\n        reg.cy.destroy();\n        reg = {}; // old instance => replace reg completely\n    }\n    var readies = reg.readies = reg.readies || [];\n    if (container) {\n        container._cyreg = reg;\n    } // make sure container assoc'd reg points to this cy\n    reg.cy = cy;\n    var head = _window !== undefined && container !== undefined && !opts.headless;\n    var options = opts;\n    options.layout = extend({\n        name: head ? 'grid' : 'null'\n    }, options.layout);\n    options.renderer = extend({\n        name: head ? 'canvas' : 'null'\n    }, options.renderer);\n    var defVal = function defVal(def, val, altVal) {\n        if (val !== undefined) {\n            return val;\n        } else if (altVal !== undefined) {\n            return altVal;\n        } else {\n            return def;\n        }\n    };\n    var _p = this._private = {\n        container: container,\n        // html dom ele container\n        ready: false,\n        // whether ready has been triggered\n        options: options,\n        // cached options\n        elements: new Collection(this),\n        // elements in the graph\n        listeners: [],\n        // list of listeners\n        aniEles: new Collection(this),\n        // elements being animated\n        data: options.data || {},\n        // data for the core\n        scratch: {},\n        // scratch object for core\n        layout: null,\n        renderer: null,\n        destroyed: false,\n        // whether destroy was called\n        notificationsEnabled: true,\n        // whether notifications are sent to the renderer\n        minZoom: 1e-50,\n        maxZoom: 1e50,\n        zoomingEnabled: defVal(true, options.zoomingEnabled),\n        userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n        panningEnabled: defVal(true, options.panningEnabled),\n        userPanningEnabled: defVal(true, options.userPanningEnabled),\n        boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n        autolock: defVal(false, options.autolock, options.autolockNodes),\n        autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n        autounselectify: defVal(false, options.autounselectify),\n        styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n        zoom: number$1(options.zoom) ? options.zoom : 1,\n        pan: {\n            x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n            y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n        },\n        animation: {\n            // object for currently-running animations\n            current: [],\n            queue: []\n        },\n        hasCompoundNodes: false,\n        multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n    };\n    this.createEmitter();\n    // set selection type\n    this.selectionType(options.selectionType);\n    // init zoom bounds\n    this.zoomRange({\n        min: options.minZoom,\n        max: options.maxZoom\n    });\n    var loadExtData = function loadExtData(extData, next) {\n        var anyIsPromise = extData.some(promise);\n        if (anyIsPromise) {\n            return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n        } else {\n            next(extData); // exec synchronously for convenience\n        }\n    };\n    // start with the default stylesheet so we have something before loading an external stylesheet\n    if (_p.styleEnabled) {\n        cy.setStyle([]);\n    }\n    // create the renderer\n    var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n    cy.initRenderer(rendererOptions);\n    var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n        cy.notifications(false);\n        // remove old elements\n        var oldEles = cy.mutableElements();\n        if (oldEles.length > 0) {\n            oldEles.remove();\n        }\n        if (elements != null) {\n            if (plainObject(elements) || array(elements)) {\n                cy.add(elements);\n            }\n        }\n        cy.one('layoutready', function(e) {\n            cy.notifications(true);\n            cy.emit(e); // we missed this event by turning notifications off, so pass it on\n            cy.one('load', onload);\n            cy.emitAndNotify('load');\n        }).one('layoutstop', function() {\n            cy.one('done', ondone);\n            cy.emit('done');\n        });\n        var layoutOpts = extend({}, cy._private.options.layout);\n        layoutOpts.eles = cy.elements();\n        cy.layout(layoutOpts).run();\n    };\n    loadExtData([\n        options.style,\n        options.elements\n    ], function(thens) {\n        var initStyle = thens[0];\n        var initEles = thens[1];\n        // init style\n        if (_p.styleEnabled) {\n            cy.style().append(initStyle);\n        }\n        // initial load\n        setElesAndLayout(initEles, function() {\n            // onready\n            cy.startAnimationLoop();\n            _p.ready = true;\n            // if a ready callback is specified as an option, the bind it\n            if (fn$6(options.ready)) {\n                cy.on('ready', options.ready);\n            }\n            // bind all the ready handlers registered before creating this instance\n            for(var i = 0; i < readies.length; i++){\n                var fn = readies[i];\n                cy.on('ready', fn);\n            }\n            if (reg) {\n                reg.readies = [];\n            } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n            cy.emit('ready');\n        }, options.done);\n    });\n};\nvar corefn = Core.prototype; // short alias\nextend(corefn, {\n    instanceString: function instanceString() {\n        return 'core';\n    },\n    isReady: function isReady() {\n        return this._private.ready;\n    },\n    destroyed: function destroyed() {\n        return this._private.destroyed;\n    },\n    ready: function ready(fn) {\n        if (this.isReady()) {\n            this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n        } else {\n            this.on('ready', fn);\n        }\n        return this;\n    },\n    destroy: function destroy() {\n        var cy = this;\n        if (cy.destroyed()) return;\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        this.emit('destroy');\n        cy._private.destroyed = true;\n        return cy;\n    },\n    hasElementWithId: function hasElementWithId(id) {\n        return this._private.elements.hasElementWithId(id);\n    },\n    getElementById: function getElementById(id) {\n        return this._private.elements.getElementById(id);\n    },\n    hasCompoundNodes: function hasCompoundNodes() {\n        return this._private.hasCompoundNodes;\n    },\n    headless: function headless() {\n        return this._private.renderer.isHeadless();\n    },\n    styleEnabled: function styleEnabled() {\n        return this._private.styleEnabled;\n    },\n    addToPool: function addToPool(eles) {\n        this._private.elements.merge(eles);\n        return this; // chaining\n    },\n    removeFromPool: function removeFromPool(eles) {\n        this._private.elements.unmerge(eles);\n        return this;\n    },\n    container: function container() {\n        return this._private.container || null;\n    },\n    window: function window1() {\n        var container = this._private.container;\n        if (container == null) return _window;\n        var ownerDocument = this._private.container.ownerDocument;\n        if (ownerDocument === undefined || ownerDocument == null) {\n            return _window;\n        }\n        return ownerDocument.defaultView || _window;\n    },\n    mount: function mount(container) {\n        if (container == null) {\n            return;\n        }\n        var cy = this;\n        var _p = cy._private;\n        var options = _p.options;\n        if (!htmlElement(container) && htmlElement(container[0])) {\n            container = container[0];\n        }\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        _p.container = container;\n        _p.styleEnabled = true;\n        cy.invalidateSize();\n        cy.initRenderer(extend({}, options, options.renderer, {\n            // allow custom renderer name to be re-used, otherwise use canvas\n            name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name\n        }));\n        cy.startAnimationLoop();\n        cy.style(options.style);\n        cy.emit('mount');\n        return cy;\n    },\n    unmount: function unmount() {\n        var cy = this;\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        cy.initRenderer({\n            name: 'null'\n        });\n        cy.emit('unmount');\n        return cy;\n    },\n    options: function options() {\n        return copy(this._private.options);\n    },\n    json: function json(obj) {\n        var cy = this;\n        var _p = cy._private;\n        var eles = cy.mutableElements();\n        var getFreshRef = function getFreshRef(ele) {\n            return cy.getElementById(ele.id());\n        };\n        if (plainObject(obj)) {\n            // set\n            cy.startBatch();\n            if (obj.elements) {\n                var idInJson = {};\n                var updateEles = function updateEles(jsons, gr) {\n                    var toAdd = [];\n                    var toMod = [];\n                    for(var i = 0; i < jsons.length; i++){\n                        var json = jsons[i];\n                        if (!json.data.id) {\n                            warn('cy.json() cannot handle elements without an ID attribute');\n                            continue;\n                        }\n                        var id = '' + json.data.id; // id must be string\n                        var ele = cy.getElementById(id);\n                        idInJson[id] = true;\n                        if (ele.length !== 0) {\n                            // existing element should be updated\n                            toMod.push({\n                                ele: ele,\n                                json: json\n                            });\n                        } else {\n                            // otherwise should be added\n                            if (gr) {\n                                json.group = gr;\n                                toAdd.push(json);\n                            } else {\n                                toAdd.push(json);\n                            }\n                        }\n                    }\n                    cy.add(toAdd);\n                    for(var _i = 0; _i < toMod.length; _i++){\n                        var _toMod$_i = toMod[_i], _ele = _toMod$_i.ele, _json = _toMod$_i.json;\n                        _ele.json(_json);\n                    }\n                };\n                if (array(obj.elements)) {\n                    // elements: []\n                    updateEles(obj.elements);\n                } else {\n                    // elements: { nodes: [], edges: [] }\n                    var grs = [\n                        'nodes',\n                        'edges'\n                    ];\n                    for(var i = 0; i < grs.length; i++){\n                        var gr = grs[i];\n                        var elements = obj.elements[gr];\n                        if (array(elements)) {\n                            updateEles(elements, gr);\n                        }\n                    }\n                }\n                var parentsToRemove = cy.collection();\n                eles.filter(function(ele) {\n                    return !idInJson[ele.id()];\n                }).forEach(function(ele) {\n                    if (ele.isParent()) {\n                        parentsToRemove.merge(ele);\n                    } else {\n                        ele.remove();\n                    }\n                });\n                // so that children are not removed w/parent\n                parentsToRemove.forEach(function(ele) {\n                    return ele.children().move({\n                        parent: null\n                    });\n                });\n                // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n                parentsToRemove.forEach(function(ele) {\n                    return getFreshRef(ele).remove();\n                });\n            }\n            if (obj.style) {\n                cy.style(obj.style);\n            }\n            if (obj.zoom != null && obj.zoom !== _p.zoom) {\n                cy.zoom(obj.zoom);\n            }\n            if (obj.pan) {\n                if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n                    cy.pan(obj.pan);\n                }\n            }\n            if (obj.data) {\n                cy.data(obj.data);\n            }\n            var fields = [\n                'minZoom',\n                'maxZoom',\n                'zoomingEnabled',\n                'userZoomingEnabled',\n                'panningEnabled',\n                'userPanningEnabled',\n                'boxSelectionEnabled',\n                'autolock',\n                'autoungrabify',\n                'autounselectify',\n                'multiClickDebounceTime'\n            ];\n            for(var _i2 = 0; _i2 < fields.length; _i2++){\n                var f = fields[_i2];\n                if (obj[f] != null) {\n                    cy[f](obj[f]);\n                }\n            }\n            cy.endBatch();\n            return this; // chaining\n        } else {\n            // get\n            var flat = !!obj;\n            var json = {};\n            if (flat) {\n                json.elements = this.elements().map(function(ele) {\n                    return ele.json();\n                });\n            } else {\n                json.elements = {};\n                eles.forEach(function(ele) {\n                    var group = ele.group();\n                    if (!json.elements[group]) {\n                        json.elements[group] = [];\n                    }\n                    json.elements[group].push(ele.json());\n                });\n            }\n            if (this._private.styleEnabled) {\n                json.style = cy.style().json();\n            }\n            json.data = copy(cy.data());\n            var options = _p.options;\n            json.zoomingEnabled = _p.zoomingEnabled;\n            json.userZoomingEnabled = _p.userZoomingEnabled;\n            json.zoom = _p.zoom;\n            json.minZoom = _p.minZoom;\n            json.maxZoom = _p.maxZoom;\n            json.panningEnabled = _p.panningEnabled;\n            json.userPanningEnabled = _p.userPanningEnabled;\n            json.pan = copy(_p.pan);\n            json.boxSelectionEnabled = _p.boxSelectionEnabled;\n            json.renderer = copy(options.renderer);\n            json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n            json.textureOnViewport = options.textureOnViewport;\n            json.wheelSensitivity = options.wheelSensitivity;\n            json.motionBlur = options.motionBlur;\n            json.multiClickDebounceTime = options.multiClickDebounceTime;\n            return json;\n        }\n    }\n});\ncorefn.$id = corefn.getElementById;\n[\n    corefn$9,\n    corefn$8,\n    elesfn,\n    corefn$7,\n    corefn$6,\n    corefn$5,\n    corefn$4,\n    corefn$3,\n    corefn$2,\n    corefn$1,\n    fn\n].forEach(function(props) {\n    extend(corefn, props);\n});\n/* eslint-disable no-unused-vars */ var defaults$7 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    directed: false,\n    // whether the tree is directed downwards (or edges can point in any direction if false)\n    direction: 'downward',\n    // determines the direction in which the tree structure is drawn.  The possible values are 'downward', 'upward', 'rightward', or 'leftward'.\n    padding: 30,\n    // padding on fit\n    circle: false,\n    // put depths in concentric circles if true, put depths top down if false\n    grid: false,\n    // whether to create an even grid into which the DAG is placed (circle:false only)\n    spacingFactor: 1.75,\n    // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    roots: undefined,\n    // the roots of the trees\n    depthSort: undefined,\n    // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled,\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nvar deprecatedOptionDefaults = {\n    maximal: false,\n    // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n    acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n};\n/* eslint-enable */ var getInfo = function getInfo(ele) {\n    return ele.scratch('breadthfirst');\n};\nvar setInfo = function setInfo(ele, obj) {\n    return ele.scratch('breadthfirst', obj);\n};\nfunction BreadthFirstLayout(options) {\n    this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n}\nBreadthFirstLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().filter(function(n) {\n        return n.isChildless();\n    });\n    var graph = eles;\n    var directed = options.directed;\n    var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n    var hasBoundingBox = !!options.boundingBox;\n    var bb = makeBoundingBox(hasBoundingBox ? options.boundingBox : structuredClone(cy.extent()));\n    var roots;\n    if (elementOrCollection(options.roots)) {\n        roots = options.roots;\n    } else if (array(options.roots)) {\n        var rootsArray = [];\n        for(var i = 0; i < options.roots.length; i++){\n            var id = options.roots[i];\n            var ele = cy.getElementById(id);\n            rootsArray.push(ele);\n        }\n        roots = cy.collection(rootsArray);\n    } else if (string(options.roots)) {\n        roots = cy.$(options.roots);\n    } else {\n        if (directed) {\n            roots = nodes.roots();\n        } else {\n            var components = eles.components();\n            roots = cy.collection();\n            var _loop = function _loop() {\n                var comp = components[_i];\n                var maxDegree = comp.maxDegree(false);\n                var compRoots = comp.filter(function(ele) {\n                    return ele.degree(false) === maxDegree;\n                });\n                roots = roots.add(compRoots);\n            };\n            for(var _i = 0; _i < components.length; _i++){\n                _loop();\n            }\n        }\n    }\n    var depths = [];\n    var foundByBfs = {};\n    var addToDepth = function addToDepth(ele, d) {\n        if (depths[d] == null) {\n            depths[d] = [];\n        }\n        var i = depths[d].length;\n        depths[d].push(ele);\n        setInfo(ele, {\n            index: i,\n            depth: d\n        });\n    };\n    var changeDepth = function changeDepth(ele, newDepth) {\n        var _getInfo = getInfo(ele), depth = _getInfo.depth, index = _getInfo.index;\n        depths[depth][index] = null;\n        // add only childless nodes\n        if (ele.isChildless()) addToDepth(ele, newDepth);\n    };\n    // find the depths of the nodes\n    graph.bfs({\n        roots: roots,\n        directed: options.directed,\n        visit: function visit(node, edge, pNode, i, depth) {\n            var ele = node[0];\n            var id = ele.id();\n            // add only childless nodes\n            if (ele.isChildless()) addToDepth(ele, depth);\n            foundByBfs[id] = true;\n        }\n    });\n    // check for nodes not found by bfs\n    var orphanNodes = [];\n    for(var _i2 = 0; _i2 < nodes.length; _i2++){\n        var _ele = nodes[_i2];\n        if (foundByBfs[_ele.id()]) {\n            continue;\n        } else {\n            orphanNodes.push(_ele);\n        }\n    }\n    // assign the nodes a depth and index\n    var assignDepthsAt = function assignDepthsAt(i) {\n        var eles = depths[i];\n        for(var j = 0; j < eles.length; j++){\n            var _ele2 = eles[j];\n            if (_ele2 == null) {\n                eles.splice(j, 1);\n                j--;\n                continue;\n            }\n            setInfo(_ele2, {\n                depth: i,\n                index: j\n            });\n        }\n    };\n    var adjustMaximally = function adjustMaximally(ele, shifted) {\n        var eInfo = getInfo(ele);\n        var incomers = ele.incomers().filter(function(el) {\n            return el.isNode() && eles.has(el);\n        });\n        var maxDepth = -1;\n        var id = ele.id();\n        for(var k = 0; k < incomers.length; k++){\n            var incmr = incomers[k];\n            var iInfo = getInfo(incmr);\n            maxDepth = Math.max(maxDepth, iInfo.depth);\n        }\n        if (eInfo.depth <= maxDepth) {\n            if (!options.acyclic && shifted[id]) {\n                return null;\n            }\n            var newDepth = maxDepth + 1;\n            changeDepth(ele, newDepth);\n            shifted[id] = newDepth;\n            return true;\n        }\n        return false;\n    };\n    // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n    if (directed && maximal) {\n        var Q = [];\n        var shifted = {};\n        var enqueue = function enqueue(n) {\n            return Q.push(n);\n        };\n        var dequeue = function dequeue() {\n            return Q.shift();\n        };\n        nodes.forEach(function(n) {\n            return Q.push(n);\n        });\n        while(Q.length > 0){\n            var _ele3 = dequeue();\n            var didShift = adjustMaximally(_ele3, shifted);\n            if (didShift) {\n                _ele3.outgoers().filter(function(el) {\n                    return el.isNode() && eles.has(el);\n                }).forEach(enqueue);\n            } else if (didShift === null) {\n                warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');\n                break; // exit on failure\n            }\n        }\n    }\n    // find min distance we need to leave between nodes\n    var minDistance = 0;\n    if (options.avoidOverlap) {\n        for(var _i3 = 0; _i3 < nodes.length; _i3++){\n            var n = nodes[_i3];\n            var nbb = n.layoutDimensions(options);\n            var w = nbb.w;\n            var h = nbb.h;\n            minDistance = Math.max(minDistance, w, h);\n        }\n    }\n    // get the weighted percent for an element based on its connectivity to other levels\n    var cachedWeightedPercent = {};\n    var getWeightedPercent = function getWeightedPercent(ele) {\n        if (cachedWeightedPercent[ele.id()]) {\n            return cachedWeightedPercent[ele.id()];\n        }\n        var eleDepth = getInfo(ele).depth;\n        var neighbors = ele.neighborhood();\n        var percent = 0;\n        var samples = 0;\n        for(var _i4 = 0; _i4 < neighbors.length; _i4++){\n            var neighbor = neighbors[_i4];\n            if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n                continue;\n            }\n            var bf = getInfo(neighbor);\n            if (bf == null) {\n                continue;\n            }\n            var index = bf.index;\n            var depth = bf.depth;\n            // unassigned neighbours shouldn't affect the ordering\n            if (index == null || depth == null) {\n                continue;\n            }\n            var nDepth = depths[depth].length;\n            if (depth < eleDepth) {\n                // only get influenced by elements above\n                percent += index / nDepth;\n                samples++;\n            }\n        }\n        samples = Math.max(1, samples);\n        percent = percent / samples;\n        if (samples === 0) {\n            // put lone nodes at the start\n            percent = 0;\n        }\n        cachedWeightedPercent[ele.id()] = percent;\n        return percent;\n    };\n    // rearrange the indices in each depth level based on connectivity\n    var sortFn = function sortFn(a, b) {\n        var apct = getWeightedPercent(a);\n        var bpct = getWeightedPercent(b);\n        var diff = apct - bpct;\n        if (diff === 0) {\n            return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n        } else {\n            return diff;\n        }\n    };\n    if (options.depthSort !== undefined) {\n        sortFn = options.depthSort;\n    }\n    var depthsLen = depths.length;\n    // sort each level to make connected nodes closer\n    for(var _i5 = 0; _i5 < depthsLen; _i5++){\n        depths[_i5].sort(sortFn);\n        assignDepthsAt(_i5);\n    }\n    // assign orphan nodes to a new top-level depth\n    var orphanDepth = [];\n    for(var _i6 = 0; _i6 < orphanNodes.length; _i6++){\n        orphanDepth.push(orphanNodes[_i6]);\n    }\n    var assignDepths = function assignDepths() {\n        for(var _i7 = 0; _i7 < depthsLen; _i7++){\n            assignDepthsAt(_i7);\n        }\n    };\n    // add a new top-level depth only when there are orphan nodes\n    if (orphanDepth.length) {\n        depths.unshift(orphanDepth);\n        depthsLen = depths.length;\n        assignDepths();\n    }\n    var biggestDepthSize = 0;\n    for(var _i8 = 0; _i8 < depthsLen; _i8++){\n        biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n    }\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    // average node size\n    var aveNodeSize = nodes.reduce(function(acc, node) {\n        return function(box) {\n            return {\n                w: acc.w === -1 ? box.w : (acc.w + box.w) / 2,\n                h: acc.h === -1 ? box.h : (acc.h + box.h) / 2\n            };\n        }(node.boundingBox({\n            includeLabels: options.nodeDimensionsIncludeLabels\n        }));\n    }, {\n        w: -1,\n        h: -1\n    });\n    var distanceY = Math.max(// only one depth\n    depthsLen === 1 ? 0 : // inside a bounding box, no need for top & bottom padding\n    hasBoundingBox ? (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen - 1) : (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen + 1), minDistance);\n    var maxDepthSize = depths.reduce(function(max, eles) {\n        return Math.max(max, eles.length);\n    }, 0);\n    var getPositionTopBottom = function getPositionTopBottom(ele) {\n        var _getInfo2 = getInfo(ele), depth = _getInfo2.depth, index = _getInfo2.index;\n        if (options.circle) {\n            var radiusStepSize = Math.min(bb.w / 2 / depthsLen, bb.h / 2 / depthsLen);\n            radiusStepSize = Math.max(radiusStepSize, minDistance);\n            var radius = radiusStepSize * depth + radiusStepSize - (depthsLen > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n            var theta = 2 * Math.PI / depths[depth].length * index;\n            if (depth === 0 && depths[0].length === 1) {\n                radius = 1;\n            }\n            return {\n                x: center.x + radius * Math.cos(theta),\n                y: center.y + radius * Math.sin(theta)\n            };\n        } else {\n            var depthSize = depths[depth].length;\n            var distanceX = Math.max(// only one depth\n            depthSize === 1 ? 0 : // inside a bounding box, no need for left & right padding\n            hasBoundingBox ? (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) - 1) : (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n            var epos = {\n                x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n                y: center.y + (depth + 1 - (depthsLen + 1) / 2) * distanceY\n            };\n            return epos;\n        }\n    };\n    var rotateDegrees = {\n        'downward': 0,\n        'leftward': 90,\n        'upward': 180,\n        'rightward': -90\n    };\n    if (Object.keys(rotateDegrees).indexOf(options.direction) === -1) {\n        error(\"Invalid direction '\".concat(options.direction, \"' specified for breadthfirst layout. Valid values are: \").concat(Object.keys(rotateDegrees).join(', ')));\n    }\n    var getPosition = function getPosition(ele) {\n        return rotatePosAndSkewByBox(getPositionTopBottom(ele), bb, rotateDegrees[options.direction]);\n    };\n    eles.nodes().layoutPositions(this, options, getPosition);\n    return this; // chaining\n};\nvar defaults$6 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox and radius if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    radius: undefined,\n    // the radius of the circle\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction CircleLayout(options) {\n    this.options = extend({}, defaults$6, options);\n}\nCircleLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var nodes = eles.nodes().not(':parent');\n    if (options.sort) {\n        nodes = nodes.sort(options.sort);\n    }\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n    var dTheta = sweep / Math.max(1, nodes.length - 1);\n    var r;\n    var minDistance = 0;\n    for(var i = 0; i < nodes.length; i++){\n        var n = nodes[i];\n        var nbb = n.layoutDimensions(options);\n        var w = nbb.w;\n        var h = nbb.h;\n        minDistance = Math.max(minDistance, w, h);\n    }\n    if (number$1(options.radius)) {\n        r = options.radius;\n    } else if (nodes.length <= 1) {\n        r = 0;\n    } else {\n        r = Math.min(bb.h, bb.w) / 2 - minDistance;\n    }\n    // calculate the radius\n    if (nodes.length > 1 && options.avoidOverlap) {\n        // but only if more than one node (can't overlap)\n        minDistance *= 1.75; // just to have some nice spacing\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n        r = Math.max(rMin, r);\n    }\n    var getPos = function getPos(ele, i) {\n        var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n        var rx = r * Math.cos(theta);\n        var ry = r * Math.sin(theta);\n        var pos = {\n            x: center.x + rx,\n            y: center.y + ry\n        };\n        return pos;\n    };\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n};\nvar defaults$5 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    equidistant: false,\n    // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n    minNodeSpacing: 10,\n    // min spacing between outside of nodes (used for radius adjustment)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    height: undefined,\n    // height of layout area (overrides container height)\n    width: undefined,\n    // width of layout area (overrides container width)\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    concentric: function concentric(node) {\n        // returns numeric value for each node, placing higher nodes in levels towards the centre\n        return node.degree();\n    },\n    levelWidth: function levelWidth(nodes) {\n        // the variation of concentric values in each level\n        return nodes.maxDegree() / 4;\n    },\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nfunction ConcentricLayout(options) {\n    this.options = extend({}, defaults$5, options);\n}\nConcentricLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    var nodeValues = []; // { node, value }\n    var maxNodeSize = 0;\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        var value = undefined;\n        // calculate the node value\n        value = options.concentric(node);\n        nodeValues.push({\n            value: value,\n            node: node\n        });\n        // for style mapping\n        node._private.scratch.concentric = value;\n    }\n    // in case we used the `concentric` in style\n    nodes.updateStyle();\n    // calculate max size now based on potentially updated mappers\n    for(var _i = 0; _i < nodes.length; _i++){\n        var _node = nodes[_i];\n        var nbb = _node.layoutDimensions(options);\n        maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n    }\n    // sort node values in descreasing order\n    nodeValues.sort(function(a, b) {\n        return b.value - a.value;\n    });\n    var levelWidth = options.levelWidth(nodes);\n    // put the values into levels\n    var levels = [\n        []\n    ];\n    var currentLevel = levels[0];\n    for(var _i2 = 0; _i2 < nodeValues.length; _i2++){\n        var val = nodeValues[_i2];\n        if (currentLevel.length > 0) {\n            var diff = Math.abs(currentLevel[0].value - val.value);\n            if (diff >= levelWidth) {\n                currentLevel = [];\n                levels.push(currentLevel);\n            }\n        }\n        currentLevel.push(val);\n    }\n    // create positions from levels\n    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n    if (!options.avoidOverlap) {\n        // then strictly constrain to bb\n        var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n        var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n        var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n        minDist = Math.min(minDist, rStep);\n    }\n    // find the metrics for each level\n    var r = 0;\n    for(var _i3 = 0; _i3 < levels.length; _i3++){\n        var level = levels[_i3];\n        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n        var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);\n        // calculate the radius\n        if (level.length > 1 && options.avoidOverlap) {\n            // but only if more than one node (can't overlap)\n            var dcos = Math.cos(dTheta) - Math.cos(0);\n            var dsin = Math.sin(dTheta) - Math.sin(0);\n            var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n            r = Math.max(rMin, r);\n        }\n        level.r = r;\n        r += minDist;\n    }\n    if (options.equidistant) {\n        var rDeltaMax = 0;\n        var _r = 0;\n        for(var _i4 = 0; _i4 < levels.length; _i4++){\n            var _level = levels[_i4];\n            var rDelta = _level.r - _r;\n            rDeltaMax = Math.max(rDeltaMax, rDelta);\n        }\n        _r = 0;\n        for(var _i5 = 0; _i5 < levels.length; _i5++){\n            var _level2 = levels[_i5];\n            if (_i5 === 0) {\n                _r = _level2.r;\n            }\n            _level2.r = _r;\n            _r += rDeltaMax;\n        }\n    }\n    // calculate the node positions\n    var pos = {}; // id => position\n    for(var _i6 = 0; _i6 < levels.length; _i6++){\n        var _level3 = levels[_i6];\n        var _dTheta = _level3.dTheta;\n        var _r2 = _level3.r;\n        for(var j = 0; j < _level3.length; j++){\n            var _val = _level3[j];\n            var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n            var p = {\n                x: center.x + _r2 * Math.cos(theta),\n                y: center.y + _r2 * Math.sin(theta)\n            };\n            pos[_val.node.id()] = p;\n        }\n    }\n    // position the nodes\n    eles.nodes().layoutPositions(this, options, function(ele) {\n        var id = ele.id();\n        return pos[id];\n    });\n    return this; // chaining\n};\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/ var DEBUG;\n/**\n * @brief :  default layout options\n */ var defaults$4 = {\n    // Called on `layoutready`\n    ready: function ready() {},\n    // Called on `layoutstop`\n    stop: function stop() {},\n    // Whether to animate while running the layout\n    // true : Animate continuously as the layout is running\n    // false : Just show the end result\n    // 'end' : Animate with the end result, from the initial positions to the end positions\n    animate: true,\n    // Easing of the animation for animate:'end'\n    animationEasing: undefined,\n    // The duration of the animation for animate:'end'\n    animationDuration: undefined,\n    // A function that determines whether the node should be animated\n    // All nodes animated by default on animate enabled\n    // Non-animated nodes are positioned immediately when the layout starts\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // The layout animates only after this many milliseconds for animate:true\n    // (prevents flashing on fast runs)\n    animationThreshold: 250,\n    // Number of iterations between consecutive screen positions update\n    refresh: 20,\n    // Whether to fit the network view after when done\n    fit: true,\n    // Padding on fit\n    padding: 30,\n    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    boundingBox: undefined,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    nodeDimensionsIncludeLabels: false,\n    // Randomize the initial positions of the nodes (true) or use existing positions (false)\n    randomize: false,\n    // Extra spacing between components in non-compound graphs\n    componentSpacing: 40,\n    // Node repulsion (non overlapping) multiplier\n    nodeRepulsion: function nodeRepulsion(node) {\n        return 2048;\n    },\n    // Node repulsion (overlapping) multiplier\n    nodeOverlap: 4,\n    // Ideal edge (non nested) length\n    idealEdgeLength: function idealEdgeLength(edge) {\n        return 32;\n    },\n    // Divisor to compute edge forces\n    edgeElasticity: function edgeElasticity(edge) {\n        return 32;\n    },\n    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n    nestingFactor: 1.2,\n    // Gravity force (constant)\n    gravity: 1,\n    // Maximum number of iterations to perform\n    numIter: 1000,\n    // Initial temperature (maximum node displacement)\n    initialTemp: 1000,\n    // Cooling factor (how the temperature is reduced between consecutive iterations\n    coolingFactor: 0.99,\n    // Lower temperature threshold (below this point the layout will end)\n    minTemp: 1.0\n};\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */ function CoseLayout(options) {\n    this.options = extend({}, defaults$4, options);\n    this.options.layout = this;\n    // Exclude any edge that has a source or target node that is not in the set of passed-in nodes\n    var nodes = this.options.eles.nodes();\n    var edges = this.options.eles.edges();\n    var notEdges = edges.filter(function(e) {\n        var sourceId = e.source().data('id');\n        var targetId = e.target().data('id');\n        var hasSource = nodes.some(function(n) {\n            return n.data('id') === sourceId;\n        });\n        var hasTarget = nodes.some(function(n) {\n            return n.data('id') === targetId;\n        });\n        return !hasSource || !hasTarget;\n    });\n    this.options.eles = this.options.eles.not(notEdges);\n}\n/**\n * @brief : runs the layout\n */ CoseLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var layout = this;\n    layout.stopped = false;\n    if (options.animate === true || options.animate === false) {\n        layout.emit({\n            type: 'layoutstart',\n            layout: layout\n        });\n    }\n    // Set DEBUG - Global variable\n    if (true === options.debug) {\n        DEBUG = true;\n    } else {\n        DEBUG = false;\n    }\n    // Initialize layout info\n    var layoutInfo = createLayoutInfo(cy, layout, options);\n    // Show LayoutInfo contents if debugging\n    if (DEBUG) {\n        printLayoutInfo(layoutInfo);\n    }\n    // If required, randomize node positions\n    if (options.randomize) {\n        randomizePositions(layoutInfo);\n    }\n    var startTime = performanceNow();\n    var refresh = function refresh() {\n        refreshPositions(layoutInfo, cy, options);\n        // Fit the graph if necessary\n        if (true === options.fit) {\n            cy.fit(options.padding);\n        }\n    };\n    var mainLoop = function mainLoop(i) {\n        if (layout.stopped || i >= options.numIter) {\n            // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n            return false;\n        }\n        // Do one step in the phisical simulation\n        step(layoutInfo, options);\n        // Update temperature\n        layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n        // logDebug(\"New temperature: \" + layoutInfo.temperature);\n        if (layoutInfo.temperature < options.minTemp) {\n            // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n            return false;\n        }\n        return true;\n    };\n    var done = function done() {\n        if (options.animate === true || options.animate === false) {\n            refresh();\n            // Layout has finished\n            layout.one('layoutstop', options.stop);\n            layout.emit({\n                type: 'layoutstop',\n                layout: layout\n            });\n        } else {\n            var nodes = options.eles.nodes();\n            var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n            nodes.layoutPositions(layout, options, getScaledPos);\n        }\n    };\n    var i = 0;\n    var loopRet = true;\n    if (options.animate === true) {\n        var _frame = function frame() {\n            var f = 0;\n            while(loopRet && f < options.refresh){\n                loopRet = mainLoop(i);\n                i++;\n                f++;\n            }\n            if (!loopRet) {\n                // it's done\n                separateComponents(layoutInfo, options);\n                done();\n            } else {\n                var now = performanceNow();\n                if (now - startTime >= options.animationThreshold) {\n                    refresh();\n                }\n                requestAnimationFrame(_frame);\n            }\n        };\n        _frame();\n    } else {\n        while(loopRet){\n            loopRet = mainLoop(i);\n            i++;\n        }\n        separateComponents(layoutInfo, options);\n        done();\n    }\n    return this; // chaining\n};\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */ CoseLayout.prototype.stop = function() {\n    this.stopped = true;\n    if (this.thread) {\n        this.thread.stop();\n    }\n    this.emit('layoutstop');\n    return this; // chaining\n};\nCoseLayout.prototype.destroy = function() {\n    if (this.thread) {\n        this.thread.stop();\n    }\n    return this; // chaining\n};\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */ var createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n    // Shortcut\n    var edges = options.eles.edges();\n    var nodes = options.eles.nodes();\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var layoutInfo = {\n        isCompound: cy.hasCompoundNodes(),\n        layoutNodes: [],\n        idToIndex: {},\n        nodeSize: nodes.size(),\n        graphSet: [],\n        indexToGraph: [],\n        layoutEdges: [],\n        edgeSize: edges.size(),\n        temperature: options.initialTemp,\n        clientWidth: bb.w,\n        clientHeight: bb.h,\n        boundingBox: bb\n    };\n    var components = options.eles.components();\n    var id2cmptId = {};\n    for(var i = 0; i < components.length; i++){\n        var component = components[i];\n        for(var j = 0; j < component.length; j++){\n            var node = component[j];\n            id2cmptId[node.id()] = i;\n        }\n    }\n    // Iterate over all nodes, creating layout nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = nodes[i];\n        var nbb = n.layoutDimensions(options);\n        var tempNode = {};\n        tempNode.isLocked = n.locked();\n        tempNode.id = n.data('id');\n        tempNode.parentId = n.data('parent');\n        tempNode.cmptId = id2cmptId[n.id()];\n        tempNode.children = [];\n        tempNode.positionX = n.position('x');\n        tempNode.positionY = n.position('y');\n        tempNode.offsetX = 0;\n        tempNode.offsetY = 0;\n        tempNode.height = nbb.w;\n        tempNode.width = nbb.h;\n        tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n        tempNode.minX = tempNode.positionX - tempNode.width / 2;\n        tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n        tempNode.minY = tempNode.positionY - tempNode.height / 2;\n        tempNode.padLeft = parseFloat(n.style('padding'));\n        tempNode.padRight = parseFloat(n.style('padding'));\n        tempNode.padTop = parseFloat(n.style('padding'));\n        tempNode.padBottom = parseFloat(n.style('padding'));\n        // forces\n        tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;\n        // Add new node\n        layoutInfo.layoutNodes.push(tempNode);\n        // Add entry to id-index map\n        layoutInfo.idToIndex[tempNode.id] = i;\n    }\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n    var end = -1; // Points to the end of the queue\n    var tempGraph = [];\n    // Second pass to add child information and\n    // initialize queue for hierarchical traversal\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        var p_id = n.parentId;\n        // Check if node n has a parent node\n        if (null != p_id) {\n            // Add node Id to parent's list of children\n            layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n        } else {\n            // If a node doesn't have a parent, then it's in the root graph\n            queue[++end] = n.id;\n            tempGraph.push(n.id);\n        }\n    }\n    // Add root graph to graphSet\n    layoutInfo.graphSet.push(tempGraph);\n    // Traverse the graph, level by level,\n    while(start <= end){\n        // Get the node to visit and remove it from queue\n        var node_id = queue[start++];\n        var node_ix = layoutInfo.idToIndex[node_id];\n        var node = layoutInfo.layoutNodes[node_ix];\n        var children = node.children;\n        if (children.length > 0) {\n            // Add children nodes as a new graph to graph set\n            layoutInfo.graphSet.push(children);\n            // Add children to que queue to be visited\n            for(var i = 0; i < children.length; i++){\n                queue[++end] = children[i];\n            }\n        }\n    }\n    // Create indexToGraph map\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        for(var j = 0; j < graph.length; j++){\n            var index = layoutInfo.idToIndex[graph[j]];\n            layoutInfo.indexToGraph[index] = i;\n        }\n    }\n    // Iterate over all edges, creating Layout Edges\n    for(var i = 0; i < layoutInfo.edgeSize; i++){\n        var e = edges[i];\n        var tempEdge = {};\n        tempEdge.id = e.data('id');\n        tempEdge.sourceId = e.data('source');\n        tempEdge.targetId = e.data('target');\n        // Compute ideal length\n        var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n        var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;\n        // Check if it's an inter graph edge\n        var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n        var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n        var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n        var targetGraph = layoutInfo.indexToGraph[targetIx];\n        if (sourceGraph != targetGraph) {\n            // Find lowest common graph ancestor\n            var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n            // Compute sum of node depths, relative to lca graph\n            var lcaGraph = layoutInfo.graphSet[lca];\n            var depth = 0;\n            // Source depth\n            var tempNode = layoutInfo.layoutNodes[sourceIx];\n            while(-1 === lcaGraph.indexOf(tempNode.id)){\n                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                depth++;\n            }\n            // Target depth\n            tempNode = layoutInfo.layoutNodes[targetIx];\n            while(-1 === lcaGraph.indexOf(tempNode.id)){\n                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                depth++;\n            }\n            // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n            //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n            //  \". Depth: \" + depth);\n            // Update idealLength\n            idealLength *= depth * options.nestingFactor;\n        }\n        tempEdge.idealLength = idealLength;\n        tempEdge.elasticity = elasticity;\n        layoutInfo.layoutEdges.push(tempEdge);\n    }\n    // Finally, return layoutInfo object\n    return layoutInfo;\n};\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */ var findLCA = function findLCA(node1, node2, layoutInfo) {\n    // Find their common ancester, starting from the root graph\n    var res = _findLCA_aux(node1, node2, 0, layoutInfo);\n    if (2 > res.count) {\n        // If aux function couldn't find the common ancester,\n        // then it is the root graph\n        return 0;\n    } else {\n        return res.graph;\n    }\n};\n/**\n * @brief          : Auxiliary function used for LCA computation\n *\n * @arg node1      : node1's ID\n * @arg node2      : node2's ID\n * @arg graphIx    : subgraph index\n * @arg layoutInfo : layoutInfo object\n *\n * @return         : object of the form {count: X, graph: Y}, where:\n *                   X is the number of ancestors (max: 2) found in\n *                   graphIx (and it's subgraphs),\n *                   Y is the graph index of the lowest graph containing\n *                   all X nodes\n */ var _findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n    var graph = layoutInfo.graphSet[graphIx];\n    // If both nodes belongs to graphIx\n    if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n        return {\n            count: 2,\n            graph: graphIx\n        };\n    }\n    // Make recursive calls for all subgraphs\n    var c = 0;\n    for(var i = 0; i < graph.length; i++){\n        var nodeId = graph[i];\n        var nodeIx = layoutInfo.idToIndex[nodeId];\n        var children = layoutInfo.layoutNodes[nodeIx].children;\n        // If the node has no child, skip it\n        if (0 === children.length) {\n            continue;\n        }\n        var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n        var result = _findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n        if (0 === result.count) {\n            continue;\n        } else if (1 === result.count) {\n            // One of (node1, node2) is present in this subgraph\n            c++;\n            if (2 === c) {\n                break;\n            }\n        } else {\n            // Both nodes are present in this subgraph\n            return result;\n        }\n    }\n    return {\n        count: c,\n        graph: graphIx\n    };\n};\n/**\n * @brief: printsLayoutInfo into js console\n *         Only used for debbuging\n */ var printLayoutInfo;\n/**\n * @brief : Randomizes the position of all nodes\n */ var randomizePositions = function randomizePositions(layoutInfo, cy) {\n    var width = layoutInfo.clientWidth;\n    var height = layoutInfo.clientHeight;\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        // No need to randomize compound nodes or locked nodes\n        if (0 === n.children.length && !n.isLocked) {\n            n.positionX = Math.random() * width;\n            n.positionY = Math.random() * height;\n        }\n    }\n};\nvar getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n    var bb = layoutInfo.boundingBox;\n    var coseBB = {\n        x1: Infinity,\n        x2: -Infinity,\n        y1: Infinity,\n        y2: -Infinity\n    };\n    if (options.boundingBox) {\n        nodes.forEach(function(node) {\n            var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n            coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n            coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n            coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n            coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n        });\n        coseBB.w = coseBB.x2 - coseBB.x1;\n        coseBB.h = coseBB.y2 - coseBB.y1;\n    }\n    return function(ele, i) {\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n        if (options.boundingBox) {\n            // then add extra bounding box constraint\n            // Handle single node case where coseBB.w or coseBB.h is 0\n            var pctX = coseBB.w === 0 ? 0.5 : (lnode.positionX - coseBB.x1) / coseBB.w;\n            var pctY = coseBB.h === 0 ? 0.5 : (lnode.positionY - coseBB.y1) / coseBB.h;\n            return {\n                x: bb.x1 + pctX * bb.w,\n                y: bb.y1 + pctY * bb.h\n            };\n        } else {\n            return {\n                x: lnode.positionX,\n                y: lnode.positionY\n            };\n        }\n    };\n};\n/**\n * @brief          : Updates the positions of nodes in the network\n * @arg layoutInfo : LayoutInfo object\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */ var refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n    // var s = 'Refreshing positions';\n    // logDebug(s);\n    var layout = options.layout;\n    var nodes = options.eles.nodes();\n    var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n    nodes.positions(getScaledPos);\n    // Trigger layoutReady only on first call\n    if (true !== layoutInfo.ready) {\n        // s = 'Triggering layoutready';\n        // logDebug(s);\n        layoutInfo.ready = true;\n        layout.one('layoutready', options.ready);\n        layout.emit({\n            type: 'layoutready',\n            layout: this\n        });\n    }\n};\n/**\n * @brief : Logs a debug message in JS console, if DEBUG is ON\n */ // var logDebug = function(text) {\n//   if (DEBUG) {\n//     console.debug(text);\n//   }\n// };\n/**\n * @brief          : Performs one iteration of the physical simulation\n * @arg layoutInfo : LayoutInfo object already initialized\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */ var step = function step(layoutInfo, options, _step) {\n    // var s = \"\\n\\n###############################\";\n    // s += \"\\nSTEP: \" + step;\n    // s += \"\\n###############################\\n\";\n    // logDebug(s);\n    // Calculate node repulsions\n    calculateNodeForces(layoutInfo, options);\n    // Calculate edge forces\n    calculateEdgeForces(layoutInfo);\n    // Calculate gravity forces\n    calculateGravityForces(layoutInfo, options);\n    // Propagate forces from parent to child\n    propagateForces(layoutInfo);\n    // Update positions based on calculated forces\n    updatePositions(layoutInfo);\n};\n/**\n * @brief : Computes the node repulsion forces\n */ var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n    // Go through each of the graphs in graphSet\n    // Nodes only repel each other if they belong to the same graph\n    // var s = 'calculateNodeForces';\n    // logDebug(s);\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n        // Now get all the pairs of nodes\n        // Only get each pair once, (A, B) = (B, A)\n        for(var j = 0; j < numNodes; j++){\n            var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n            for(var k = j + 1; k < numNodes; k++){\n                var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n                nodeRepulsion(node1, node2, layoutInfo, options);\n            }\n        }\n    }\n};\nvar randomDistance = function randomDistance(max) {\n    return -1 + 2 * max * Math.random();\n};\n/**\n * @brief : Compute the node repulsion forces between a pair of nodes\n */ var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n    // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n    var cmptId1 = node1.cmptId;\n    var cmptId2 = node2.cmptId;\n    if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n        return;\n    }\n    // Get direction of line connecting both node centers\n    var directionX = node2.positionX - node1.positionX;\n    var directionY = node2.positionY - node1.positionY;\n    var maxRandDist = 1;\n    // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n    // If both centers are the same, apply a random force\n    if (0 === directionX && 0 === directionY) {\n        directionX = randomDistance(maxRandDist);\n        directionY = randomDistance(maxRandDist);\n    }\n    var overlap = nodesOverlap(node1, node2, directionX, directionY);\n    if (overlap > 0) {\n        // s += \"\\nNodes DO overlap.\";\n        // s += \"\\nOverlap: \" + overlap;\n        // If nodes overlap, repulsion force is proportional\n        // to the overlap\n        var force = options.nodeOverlap * overlap;\n        // Compute the module and components of the force vector\n        var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n        // s += \"\\nDistance: \" + distance;\n        var forceX = force * directionX / distance;\n        var forceY = force * directionY / distance;\n    } else {\n        // s += \"\\nNodes do NOT overlap.\";\n        // If there's no overlap, force is inversely proportional\n        // to squared distance\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(node1, directionX, directionY);\n        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n        // Use clipping points to compute distance\n        var distanceX = point2.x - point1.x;\n        var distanceY = point2.y - point1.y;\n        var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n        var distance = Math.sqrt(distanceSqr);\n        // s += \"\\nDistance: \" + distance;\n        // Compute the module and components of the force vector\n        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n        var forceX = force * distanceX / distance;\n        var forceY = force * distanceY / distance;\n    }\n    // Apply force\n    if (!node1.isLocked) {\n        node1.offsetX -= forceX;\n        node1.offsetY -= forceY;\n    }\n    if (!node2.isLocked) {\n        node2.offsetX += forceX;\n        node2.offsetY += forceY;\n    }\n    // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n    // logDebug(s);\n    return;\n};\n/**\n * @brief  : Determines whether two nodes overlap or not\n * @return : Amount of overlapping (0 => no overlap)\n */ var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n    if (dX > 0) {\n        var overlapX = node1.maxX - node2.minX;\n    } else {\n        var overlapX = node2.maxX - node1.minX;\n    }\n    if (dY > 0) {\n        var overlapY = node1.maxY - node2.minY;\n    } else {\n        var overlapY = node2.maxY - node1.minY;\n    }\n    if (overlapX >= 0 && overlapY >= 0) {\n        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n    } else {\n        return 0;\n    }\n};\n/**\n * @brief : Finds the point in which an edge (direction dX, dY) intersects\n *          the rectangular bounding box of it's source/target node\n */ var findClippingPoint = function findClippingPoint(node, dX, dY) {\n    // Shorcuts\n    var X = node.positionX;\n    var Y = node.positionY;\n    var H = node.height || 1;\n    var W = node.width || 1;\n    var dirSlope = dY / dX;\n    var nodeSlope = H / W;\n    // var s = 'Computing clipping point of node ' + node.id +\n    //   \" . Height:  \" + H + \", Width: \" + W +\n    //   \"\\nDirection \" + dX + \", \" + dY;\n    //\n    // Compute intersection\n    var res = {};\n    // Case: Vertical direction (up)\n    if (0 === dX && 0 < dY) {\n        res.x = X;\n        // s += \"\\nUp direction\";\n        res.y = Y + H / 2;\n        return res;\n    }\n    // Case: Vertical direction (down)\n    if (0 === dX && 0 > dY) {\n        res.x = X;\n        res.y = Y + H / 2;\n        // s += \"\\nDown direction\";\n        return res;\n    }\n    // Case: Intersects the right border\n    if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X + W / 2;\n        res.y = Y + W * dY / 2 / dX;\n        // s += \"\\nRightborder\";\n        return res;\n    }\n    // Case: Intersects the left border\n    if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X - W / 2;\n        res.y = Y - W * dY / 2 / dX;\n        // s += \"\\nLeftborder\";\n        return res;\n    }\n    // Case: Intersects the top border\n    if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X + H * dX / 2 / dY;\n        res.y = Y + H / 2;\n        // s += \"\\nTop border\";\n        return res;\n    }\n    // Case: Intersects the bottom border\n    if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X - H * dX / 2 / dY;\n        res.y = Y - H / 2;\n        // s += \"\\nBottom border\";\n        return res;\n    }\n    // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n    // logDebug(s);\n    return res;\n};\n/**\n * @brief : Calculates all edge forces\n */ var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n    // Iterate over all edges\n    for(var i = 0; i < layoutInfo.edgeSize; i++){\n        // Get edge, source & target nodes\n        var edge = layoutInfo.layoutEdges[i];\n        var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n        var source = layoutInfo.layoutNodes[sourceIx];\n        var targetIx = layoutInfo.idToIndex[edge.targetId];\n        var target = layoutInfo.layoutNodes[targetIx];\n        // Get direction of line connecting both node centers\n        var directionX = target.positionX - source.positionX;\n        var directionY = target.positionY - source.positionY;\n        // If both centers are the same, do nothing.\n        // A random force has already been applied as node repulsion\n        if (0 === directionX && 0 === directionY) {\n            continue;\n        }\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(source, directionX, directionY);\n        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n        var lx = point2.x - point1.x;\n        var ly = point2.y - point1.y;\n        var l = Math.sqrt(lx * lx + ly * ly);\n        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n        if (0 !== l) {\n            var forceX = force * lx / l;\n            var forceY = force * ly / l;\n        } else {\n            var forceX = 0;\n            var forceY = 0;\n        }\n        // Add this force to target and source nodes\n        if (!source.isLocked) {\n            source.offsetX += forceX;\n            source.offsetY += forceY;\n        }\n        if (!target.isLocked) {\n            target.offsetX -= forceX;\n            target.offsetY -= forceY;\n        }\n    // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n    // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n    // logDebug(s);\n    }\n};\n/**\n * @brief : Computes gravity forces for all nodes\n */ var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n    if (options.gravity === 0) {\n        return;\n    }\n    var distThreshold = 1;\n    // var s = 'calculateGravityForces';\n    // logDebug(s);\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n        // Compute graph center\n        if (0 === i) {\n            var centerX = layoutInfo.clientHeight / 2;\n            var centerY = layoutInfo.clientWidth / 2;\n        } else {\n            // Get Parent node for this graph, and use its position as center\n            var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n            var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n            var centerX = parent.positionX;\n            var centerY = parent.positionY;\n        }\n        // s = \"Center found at: \" + centerX + \", \" + centerY;\n        // logDebug(s);\n        // Apply force to all nodes in graph\n        for(var j = 0; j < numNodes; j++){\n            var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n            // s = \"Node: \" + node.id;\n            if (node.isLocked) {\n                continue;\n            }\n            var dx = centerX - node.positionX;\n            var dy = centerY - node.positionY;\n            var d = Math.sqrt(dx * dx + dy * dy);\n            if (d > distThreshold) {\n                var fx = options.gravity * dx / d;\n                var fy = options.gravity * dy / d;\n                node.offsetX += fx;\n                node.offsetY += fy;\n            // s += \": Applied force: \" + fx + \", \" + fy;\n            }\n        // logDebug(s);\n        }\n    }\n};\n/**\n * @brief          : This function propagates the existing offsets from\n *                   parent nodes to its descendents.\n * @arg layoutInfo : layoutInfo Object\n * @arg cy         : cytoscape Object\n * @arg options    : Layout options\n */ var propagateForces = function propagateForces(layoutInfo, options) {\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n    var end = -1; // Points to the end of the queue\n    // logDebug('propagateForces');\n    // Start by visiting the nodes in the root graph\n    queue.push.apply(queue, layoutInfo.graphSet[0]);\n    end += layoutInfo.graphSet[0].length;\n    // Traverse the graph, level by level,\n    while(start <= end){\n        // Get the node to visit and remove it from queue\n        var nodeId = queue[start++];\n        var nodeIndex = layoutInfo.idToIndex[nodeId];\n        var node = layoutInfo.layoutNodes[nodeIndex];\n        var children = node.children;\n        // We only need to process the node if it's compound\n        if (0 < children.length && !node.isLocked) {\n            var offX = node.offsetX;\n            var offY = node.offsetY;\n            // var s = \"Propagating offset from parent node : \" + node.id +\n            //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n            // s += \"\\n Children: \" + children.toString();\n            // logDebug(s);\n            for(var i = 0; i < children.length; i++){\n                var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n                // Propagate offset\n                childNode.offsetX += offX;\n                childNode.offsetY += offY;\n                // Add children to queue to be visited\n                queue[++end] = children[i];\n            }\n            // Reset parent offsets\n            node.offsetX = 0;\n            node.offsetY = 0;\n        }\n    }\n};\n/**\n * @brief : Updates the layout model positions, based on\n *          the accumulated forces\n */ var updatePositions = function updatePositions(layoutInfo, options) {\n    // var s = 'Updating positions';\n    // logDebug(s);\n    // Reset boundaries for compound nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length) {\n            // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n            n.maxX = undefined;\n            n.minX = undefined;\n            n.maxY = undefined;\n            n.minY = undefined;\n        }\n    }\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length || n.isLocked) {\n            continue;\n        }\n        // s = \"Node: \" + n.id + \" Previous position: (\" +\n        // n.positionX + \", \" + n.positionY + \").\";\n        // Limit displacement in order to improve stability\n        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n        n.positionX += tempForce.x;\n        n.positionY += tempForce.y;\n        n.offsetX = 0;\n        n.offsetY = 0;\n        n.minX = n.positionX - n.width;\n        n.maxX = n.positionX + n.width;\n        n.minY = n.positionY - n.height;\n        n.maxY = n.positionY + n.height;\n        // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n        // logDebug(s);\n        // Update ancestry boudaries\n        _updateAncestryBoundaries(n, layoutInfo);\n    }\n    // Update size, position of compund nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length && !n.isLocked) {\n            n.positionX = (n.maxX + n.minX) / 2;\n            n.positionY = (n.maxY + n.minY) / 2;\n            n.width = n.maxX - n.minX;\n            n.height = n.maxY - n.minY;\n        // s = \"Updating position, size of compound node \" + n.id;\n        // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n        // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n        // logDebug(s);\n        }\n    }\n};\n/**\n * @brief : Limits a force (forceX, forceY) to be not\n *          greater (in modulo) than max.\n 8          Preserves force direction.\n  */ var limitForce = function limitForce(forceX, forceY, max) {\n    // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n    var force = Math.sqrt(forceX * forceX + forceY * forceY);\n    if (force > max) {\n        var res = {\n            x: max * forceX / force,\n            y: max * forceY / force\n        };\n    } else {\n        var res = {\n            x: forceX,\n            y: forceY\n        };\n    }\n    // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n    // logDebug(s);\n    return res;\n};\n/**\n * @brief : Function used for keeping track of compound node\n *          sizes, since they should bound all their subnodes.\n */ var _updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n    // var s = \"Propagating new position/size of node \" + node.id;\n    var parentId = node.parentId;\n    if (null == parentId) {\n        // If there's no parent, we are done\n        // s += \". No parent node.\";\n        // logDebug(s);\n        return;\n    }\n    // Get Parent Node\n    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n    var flag = false;\n    // MaxX\n    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n        p.maxX = node.maxX + p.padRight;\n        flag = true;\n    // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n    }\n    // MinX\n    if (null == p.minX || node.minX - p.padLeft < p.minX) {\n        p.minX = node.minX - p.padLeft;\n        flag = true;\n    // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n    }\n    // MaxY\n    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n        p.maxY = node.maxY + p.padBottom;\n        flag = true;\n    // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n    }\n    // MinY\n    if (null == p.minY || node.minY - p.padTop < p.minY) {\n        p.minY = node.minY - p.padTop;\n        flag = true;\n    // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n    }\n    // If updated boundaries, propagate changes upward\n    if (flag) {\n        // logDebug(s);\n        return _updateAncestryBoundaries(p, layoutInfo);\n    }\n    // s += \". No changes in boundaries/position of parent node \" + p.id;\n    // logDebug(s);\n    return;\n};\nvar separateComponents = function separateComponents(layoutInfo, options) {\n    var nodes = layoutInfo.layoutNodes;\n    var components = [];\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        var cid = node.cmptId;\n        var component = components[cid] = components[cid] || [];\n        component.push(node);\n    }\n    var totalA = 0;\n    for(var i = 0; i < components.length; i++){\n        var c = components[i];\n        if (!c) {\n            continue;\n        }\n        c.x1 = Infinity;\n        c.x2 = -Infinity;\n        c.y1 = Infinity;\n        c.y2 = -Infinity;\n        for(var j = 0; j < c.length; j++){\n            var n = c[j];\n            c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n            c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n            c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n            c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n        }\n        c.w = c.x2 - c.x1;\n        c.h = c.y2 - c.y1;\n        totalA += c.w * c.h;\n    }\n    components.sort(function(c1, c2) {\n        return c2.w * c2.h - c1.w * c1.h;\n    });\n    var x = 0;\n    var y = 0;\n    var usedW = 0;\n    var rowH = 0;\n    var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n    for(var i = 0; i < components.length; i++){\n        var c = components[i];\n        if (!c) {\n            continue;\n        }\n        for(var j = 0; j < c.length; j++){\n            var n = c[j];\n            if (!n.isLocked) {\n                n.positionX += x - c.x1;\n                n.positionY += y - c.y1;\n            }\n        }\n        x += c.w + options.componentSpacing;\n        usedW += c.w + options.componentSpacing;\n        rowH = Math.max(rowH, c.h);\n        if (usedW > maxRowW) {\n            y += rowH + options.componentSpacing;\n            x = 0;\n            usedW = 0;\n            rowH = 0;\n        }\n    }\n};\nvar defaults$3 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // padding used on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    avoidOverlapPadding: 10,\n    // extra spacing around nodes when avoidOverlap: true\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    condense: false,\n    // uses all available space on false, uses minimal space on true\n    rows: undefined,\n    // force num of rows in the grid\n    cols: undefined,\n    // force num of columns in the grid\n    position: function position(node) {},\n    // returns { row, col } for element\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction GridLayout(options) {\n    this.options = extend({}, defaults$3, options);\n}\nGridLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    if (options.sort) {\n        nodes = nodes.sort(options.sort);\n    }\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    if (bb.h === 0 || bb.w === 0) {\n        eles.nodes().layoutPositions(this, options, function(ele) {\n            return {\n                x: bb.x1,\n                y: bb.y1\n            };\n        });\n    } else {\n        // width/height * splits^2 = cells where splits is number of times to split width\n        var cells = nodes.size();\n        var splits = Math.sqrt(cells * bb.h / bb.w);\n        var rows = Math.round(splits);\n        var cols = Math.round(bb.w / bb.h * splits);\n        var small = function small(val) {\n            if (val == null) {\n                return Math.min(rows, cols);\n            } else {\n                var min = Math.min(rows, cols);\n                if (min == rows) {\n                    rows = val;\n                } else {\n                    cols = val;\n                }\n            }\n        };\n        var large = function large(val) {\n            if (val == null) {\n                return Math.max(rows, cols);\n            } else {\n                var max = Math.max(rows, cols);\n                if (max == rows) {\n                    rows = val;\n                } else {\n                    cols = val;\n                }\n            }\n        };\n        var oRows = options.rows;\n        var oCols = options.cols != null ? options.cols : options.columns;\n        // if rows or columns were set in options, use those values\n        if (oRows != null && oCols != null) {\n            rows = oRows;\n            cols = oCols;\n        } else if (oRows != null && oCols == null) {\n            rows = oRows;\n            cols = Math.ceil(cells / rows);\n        } else if (oRows == null && oCols != null) {\n            cols = oCols;\n            rows = Math.ceil(cells / cols);\n        } else if (cols * rows > cells) {\n            var sm = small();\n            var lg = large();\n            // reducing the small side takes away the most cells, so try it first\n            if ((sm - 1) * lg >= cells) {\n                small(sm - 1);\n            } else if ((lg - 1) * sm >= cells) {\n                large(lg - 1);\n            }\n        } else {\n            // if rounding was too low, add rows or columns\n            while(cols * rows < cells){\n                var _sm = small();\n                var _lg = large();\n                // try to add to larger side first (adds less in multiplication)\n                if ((_lg + 1) * _sm >= cells) {\n                    large(_lg + 1);\n                } else {\n                    small(_sm + 1);\n                }\n            }\n        }\n        var cellWidth = bb.w / cols;\n        var cellHeight = bb.h / rows;\n        if (options.condense) {\n            cellWidth = 0;\n            cellHeight = 0;\n        }\n        if (options.avoidOverlap) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var pos = node._private.position;\n                if (pos.x == null || pos.y == null) {\n                    // for bb\n                    pos.x = 0;\n                    pos.y = 0;\n                }\n                var nbb = node.layoutDimensions(options);\n                var p = options.avoidOverlapPadding;\n                var w = nbb.w + p;\n                var h = nbb.h + p;\n                cellWidth = Math.max(cellWidth, w);\n                cellHeight = Math.max(cellHeight, h);\n            }\n        }\n        var cellUsed = {}; // e.g. 'c-0-2' => true\n        var used = function used(row, col) {\n            return cellUsed['c-' + row + '-' + col] ? true : false;\n        };\n        var use = function use(row, col) {\n            cellUsed['c-' + row + '-' + col] = true;\n        };\n        // to keep track of current cell position\n        var row = 0;\n        var col = 0;\n        var moveToNextCell = function moveToNextCell() {\n            col++;\n            if (col >= cols) {\n                col = 0;\n                row++;\n            }\n        };\n        // get a cache of all the manual positions\n        var id2manPos = {};\n        for(var _i = 0; _i < nodes.length; _i++){\n            var _node = nodes[_i];\n            var rcPos = options.position(_node);\n            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n                // must have at least row or col def'd\n                var _pos = {\n                    row: rcPos.row,\n                    col: rcPos.col\n                };\n                if (_pos.col === undefined) {\n                    // find unused col\n                    _pos.col = 0;\n                    while(used(_pos.row, _pos.col)){\n                        _pos.col++;\n                    }\n                } else if (_pos.row === undefined) {\n                    // find unused row\n                    _pos.row = 0;\n                    while(used(_pos.row, _pos.col)){\n                        _pos.row++;\n                    }\n                }\n                id2manPos[_node.id()] = _pos;\n                use(_pos.row, _pos.col);\n            }\n        }\n        var getPos = function getPos(element, i) {\n            var x, y;\n            if (element.locked() || element.isParent()) {\n                return false;\n            }\n            // see if we have a manual position set\n            var rcPos = id2manPos[element.id()];\n            if (rcPos) {\n                x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n                y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n            } else {\n                // otherwise set automatically\n                while(used(row, col)){\n                    moveToNextCell();\n                }\n                x = col * cellWidth + cellWidth / 2 + bb.x1;\n                y = row * cellHeight + cellHeight / 2 + bb.y1;\n                use(row, col);\n                moveToNextCell();\n            }\n            return {\n                x: x,\n                y: y\n            };\n        };\n        nodes.layoutPositions(this, options, getPos);\n    }\n    return this; // chaining\n};\n// default layout options\nvar defaults$2 = {\n    ready: function ready() {},\n    // on layoutready\n    stop: function stop() {} // on layoutstop\n};\n// constructor\n// options : object containing layout options\nfunction NullLayout(options) {\n    this.options = extend({}, defaults$2, options);\n}\n// runs the layout\nNullLayout.prototype.run = function() {\n    var options = this.options;\n    var eles = options.eles; // elements to consider in the layout\n    var layout = this;\n    // cy is automatically populated for us in the constructor\n    // (disable eslint for next line as this serves as example layout code to external developers)\n    // eslint-disable-next-line no-unused-vars\n    options.cy;\n    layout.emit('layoutstart');\n    // puts all nodes at (0, 0)\n    // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n    eles.nodes().positions(function() {\n        return {\n            x: 0,\n            y: 0\n        };\n    });\n    // trigger layoutready when each node has had its position set at least once\n    layout.one('layoutready', options.ready);\n    layout.emit('layoutready');\n    // trigger layoutstop when the layout stops (e.g. finishes)\n    layout.one('layoutstop', options.stop);\n    layout.emit('layoutstop');\n    return this; // chaining\n};\n// called on continuous layouts to stop them before they finish\nNullLayout.prototype.stop = function() {\n    return this; // chaining\n};\nvar defaults$1 = {\n    positions: undefined,\n    // map of (node id) => (position obj); or function(node){ return somPos; }\n    zoom: undefined,\n    // the zoom level to set (prob want fit = false if set)\n    pan: undefined,\n    // the pan level to set (prob want fit = false if set)\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // padding on fit\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nfunction PresetLayout(options) {\n    this.options = extend({}, defaults$1, options);\n}\nPresetLayout.prototype.run = function() {\n    var options = this.options;\n    var eles = options.eles;\n    var nodes = eles.nodes();\n    var posIsFn = fn$6(options.positions);\n    function getPosition(node) {\n        if (options.positions == null) {\n            return copyPosition(node.position());\n        }\n        if (posIsFn) {\n            return options.positions(node);\n        }\n        var pos = options.positions[node._private.data.id];\n        if (pos == null) {\n            return null;\n        }\n        return pos;\n    }\n    nodes.layoutPositions(this, options, function(node, i) {\n        var position = getPosition(node);\n        if (node.locked() || position == null) {\n            return false;\n        }\n        return position;\n    });\n    return this; // chaining\n};\nvar defaults = {\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // fit padding\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction RandomLayout(options) {\n    this.options = extend({}, defaults, options);\n}\nRandomLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var getPos = function getPos(node, i) {\n        return {\n            x: bb.x1 + Math.round(Math.random() * bb.w),\n            y: bb.y1 + Math.round(Math.random() * bb.h)\n        };\n    };\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n};\nvar layout = [\n    {\n        name: 'breadthfirst',\n        impl: BreadthFirstLayout\n    },\n    {\n        name: 'circle',\n        impl: CircleLayout\n    },\n    {\n        name: 'concentric',\n        impl: ConcentricLayout\n    },\n    {\n        name: 'cose',\n        impl: CoseLayout\n    },\n    {\n        name: 'grid',\n        impl: GridLayout\n    },\n    {\n        name: 'null',\n        impl: NullLayout\n    },\n    {\n        name: 'preset',\n        impl: PresetLayout\n    },\n    {\n        name: 'random',\n        impl: RandomLayout\n    }\n];\nfunction NullRenderer(options) {\n    this.options = options;\n    this.notifications = 0; // for testing\n}\nvar noop = function noop() {};\nvar throwImgErr = function throwImgErr() {\n    throw new Error('A headless instance can not render images');\n};\nNullRenderer.prototype = {\n    recalculateRenderedStyle: noop,\n    notify: function notify() {\n        this.notifications++;\n    },\n    init: noop,\n    isHeadless: function isHeadless() {\n        return true;\n    },\n    png: throwImgErr,\n    jpg: throwImgErr\n};\nvar BRp$f = {};\nBRp$f.arrowShapeWidth = 0.3;\nBRp$f.registerArrowShapes = function() {\n    var arrowShapes = this.arrowShapes = {};\n    var renderer = this;\n    // Contract for arrow shapes:\n    // 0, 0 is arrow tip\n    // (0, 1) is direction towards node\n    // (1, 0) is right\n    //\n    // functional api:\n    // collide: check x, y in shape\n    // roughCollide: called before collide, no false negatives\n    // draw: draw\n    // spacing: dist(arrowTip, nodeBoundary)\n    // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n    var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n        var x1 = translation.x - size / 2 - padding;\n        var x2 = translation.x + size / 2 + padding;\n        var y1 = translation.y - size / 2 - padding;\n        var y2 = translation.y + size / 2 + padding;\n        var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n        return inside;\n    };\n    var transform = function transform(x, y, size, angle, translation) {\n        var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n        var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n        var xScaled = xRotated * size;\n        var yScaled = yRotated * size;\n        var xTranslated = xScaled + translation.x;\n        var yTranslated = yScaled + translation.y;\n        return {\n            x: xTranslated,\n            y: yTranslated\n        };\n    };\n    var transformPoints = function transformPoints(pts, size, angle, translation) {\n        var retPts = [];\n        for(var i = 0; i < pts.length; i += 2){\n            var x = pts[i];\n            var y = pts[i + 1];\n            retPts.push(transform(x, y, size, angle, translation));\n        }\n        return retPts;\n    };\n    var pointsToArr = function pointsToArr(pts) {\n        var ret = [];\n        for(var i = 0; i < pts.length; i++){\n            var p = pts[i];\n            ret.push(p.x, p.y);\n        }\n        return ret;\n    };\n    var standardGap = function standardGap(edge) {\n        return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n    };\n    var defineArrowShape = function defineArrowShape(name, defn) {\n        if (string(defn)) {\n            defn = arrowShapes[defn];\n        }\n        arrowShapes[name] = extend({\n            name: name,\n            points: [\n                -0.15,\n                -0.3,\n                0.15,\n                -0.3,\n                0.15,\n                0.3,\n                -0.15,\n                0.3\n            ],\n            collide: function collide(x, y, size, angle, translation, padding) {\n                var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n                var inside = pointInsidePolygonPoints(x, y, points);\n                return inside;\n            },\n            roughCollide: bbCollide,\n            draw: function draw(context, size, angle, translation) {\n                var points = transformPoints(this.points, size, angle, translation);\n                renderer.arrowShapeImpl('polygon')(context, points);\n            },\n            spacing: function spacing(edge) {\n                return 0;\n            },\n            gap: standardGap\n        }, defn);\n    };\n    defineArrowShape('none', {\n        collide: falsify,\n        roughCollide: falsify,\n        draw: noop$1,\n        spacing: zeroify,\n        gap: zeroify\n    });\n    defineArrowShape('triangle', {\n        points: [\n            -0.15,\n            -0.3,\n            0,\n            0,\n            0.15,\n            -0.3\n        ]\n    });\n    defineArrowShape('arrow', 'triangle');\n    defineArrowShape('triangle-backcurve', {\n        points: arrowShapes['triangle'].points,\n        controlPoint: [\n            0,\n            -0.15\n        ],\n        roughCollide: bbCollide,\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var ptsTrans = transformPoints(this.points, size, angle, translation);\n            var ctrlPt = this.controlPoint;\n            var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n        },\n        gap: function gap(edge) {\n            return standardGap(edge) * 0.8;\n        }\n    });\n    defineArrowShape('triangle-tee', {\n        points: [\n            0,\n            0,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3,\n            0,\n            0\n        ],\n        pointsTee: [\n            -0.15,\n            -0.4,\n            -0.15,\n            -0.5,\n            0.15,\n            -0.5,\n            0.15,\n            -0.4\n        ],\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.points, size, angle, translation);\n            var teePts = transformPoints(this.pointsTee, size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n        }\n    });\n    defineArrowShape('circle-triangle', {\n        radius: 0.15,\n        pointsTr: [\n            0,\n            -0.15,\n            0.15,\n            -0.45,\n            -0.15,\n            -0.45,\n            0,\n            -0.15\n        ],\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var t = translation;\n            var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.pointsTr, size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n        },\n        spacing: function spacing(edge) {\n            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n        }\n    });\n    defineArrowShape('triangle-cross', {\n        points: [\n            0,\n            0,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3,\n            0,\n            0\n        ],\n        baseCrossLinePts: [\n            -0.15,\n            -0.4,\n            // first half of the rectangle\n            -0.15,\n            -0.4,\n            0.15,\n            -0.4,\n            // second half of the rectangle\n            0.15,\n            -0.4\n        ],\n        crossLinePts: function crossLinePts(size, edgeWidth) {\n            // shift points so that the distance between the cross points matches edge width\n            var p = this.baseCrossLinePts.slice();\n            var shiftFactor = edgeWidth / size;\n            var y0 = 3;\n            var y1 = 5;\n            p[y0] = p[y0] - shiftFactor;\n            p[y1] = p[y1] - shiftFactor;\n            return p;\n        },\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.points, size, angle, translation);\n            var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n        }\n    });\n    defineArrowShape('vee', {\n        points: [\n            -0.15,\n            -0.3,\n            0,\n            0,\n            0.15,\n            -0.3,\n            0,\n            -0.15\n        ],\n        gap: function gap(edge) {\n            return standardGap(edge) * 0.525;\n        }\n    });\n    defineArrowShape('circle', {\n        radius: 0.15,\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var t = translation;\n            var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n        },\n        spacing: function spacing(edge) {\n            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n        }\n    });\n    defineArrowShape('tee', {\n        points: [\n            -0.15,\n            0,\n            -0.15,\n            -0.1,\n            0.15,\n            -0.1,\n            0.15,\n            0\n        ],\n        spacing: function spacing(edge) {\n            return 1;\n        },\n        gap: function gap(edge) {\n            return 1;\n        }\n    });\n    defineArrowShape('square', {\n        points: [\n            -0.15,\n            0.00,\n            0.15,\n            0.00,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3\n        ]\n    });\n    defineArrowShape('diamond', {\n        points: [\n            -0.15,\n            -0.15,\n            0,\n            -0.3,\n            0.15,\n            -0.15,\n            0,\n            0\n        ],\n        gap: function gap(edge) {\n            return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n        }\n    });\n    defineArrowShape('chevron', {\n        points: [\n            0,\n            0,\n            -0.15,\n            -0.15,\n            -0.1,\n            -0.2,\n            0,\n            -0.1,\n            0.1,\n            -0.2,\n            0.15,\n            -0.15\n        ],\n        gap: function gap(edge) {\n            return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n        }\n    });\n};\nvar BRp$e = {};\n// Project mouse\nBRp$e.projectIntoViewport = function(clientX, clientY) {\n    var cy = this.cy;\n    var offsets = this.findContainerClientCoords();\n    var offsetLeft = offsets[0];\n    var offsetTop = offsets[1];\n    var scale = offsets[4];\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n    var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n    return [\n        x,\n        y\n    ];\n};\nBRp$e.findContainerClientCoords = function() {\n    if (this.containerBB) {\n        return this.containerBB;\n    }\n    var container = this.container;\n    var rect = container.getBoundingClientRect();\n    var style = this.cy.window().getComputedStyle(container);\n    var styleValue = function styleValue(name) {\n        return parseFloat(style.getPropertyValue(name));\n    };\n    var padding = {\n        left: styleValue('padding-left'),\n        right: styleValue('padding-right'),\n        top: styleValue('padding-top'),\n        bottom: styleValue('padding-bottom')\n    };\n    var border = {\n        left: styleValue('border-left-width'),\n        right: styleValue('border-right-width'),\n        top: styleValue('border-top-width'),\n        bottom: styleValue('border-bottom-width')\n    };\n    var clientWidth = container.clientWidth;\n    var clientHeight = container.clientHeight;\n    var paddingHor = padding.left + padding.right;\n    var paddingVer = padding.top + padding.bottom;\n    var borderHor = border.left + border.right;\n    var scale = rect.width / (clientWidth + borderHor);\n    var unscaledW = clientWidth - paddingHor;\n    var unscaledH = clientHeight - paddingVer;\n    var left = rect.left + padding.left + border.left;\n    var top = rect.top + padding.top + border.top;\n    return this.containerBB = [\n        left,\n        top,\n        unscaledW,\n        unscaledH,\n        scale\n    ];\n};\nBRp$e.invalidateContainerClientCoordsCache = function() {\n    this.containerBB = null;\n};\nBRp$e.findNearestElement = function(x, y, interactiveElementsOnly, isTouch) {\n    return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n};\nBRp$e.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {\n    var self1 = this;\n    var r = this;\n    var eles = r.getCachedZSortedEles();\n    var near = []; // 1 node max, 1 edge max\n    var zoom = r.cy.zoom();\n    var hasCompounds = r.cy.hasCompoundNodes();\n    var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n    var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n    var labelThreshold = (isTouch ? 8 : 2) / zoom;\n    var minSqDist = Infinity;\n    var nearEdge;\n    var nearNode;\n    if (interactiveElementsOnly) {\n        eles = eles.interactive;\n    }\n    function addEle(ele, sqDist) {\n        if (ele.isNode()) {\n            if (nearNode) {\n                return; // can't replace node\n            } else {\n                nearNode = ele;\n                near.push(ele);\n            }\n        }\n        if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n            if (nearEdge) {\n                // then replace existing edge\n                // can replace only if same z-index\n                if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {\n                    for(var i = 0; i < near.length; i++){\n                        if (near[i].isEdge()) {\n                            near[i] = ele;\n                            nearEdge = ele;\n                            minSqDist = sqDist != null ? sqDist : minSqDist;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                near.push(ele);\n                nearEdge = ele;\n                minSqDist = sqDist != null ? sqDist : minSqDist;\n            }\n        }\n    }\n    function checkNode(node) {\n        var width = node.outerWidth() + 2 * nodeThreshold;\n        var height = node.outerHeight() + 2 * nodeThreshold;\n        var hw = width / 2;\n        var hh = height / 2;\n        var pos = node.position();\n        var cornerRadius = node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue;\n        var rs = node._private.rscratch;\n        if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n         && pos.y - hh <= y && y <= pos.y + hh // bb check y\n        ) {\n            var shape = r.nodeShapes[self1.getNodeShape(node)];\n            if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y, cornerRadius, rs)) {\n                addEle(node, 0);\n                return true;\n            }\n        }\n    }\n    function checkEdge(edge) {\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        var styleWidth = edge.pstyle('width').pfValue;\n        var scale = edge.pstyle('arrow-scale').value;\n        var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n        var widthSq = width * width;\n        var width2 = width * 2;\n        var src = _p.source;\n        var tgt = _p.target;\n        var sqDist;\n        if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n            var pts = rs.allpts;\n            for(var i = 0; i + 3 < pts.length; i += 2){\n                if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n                    addEle(edge, sqDist);\n                    return true;\n                }\n            }\n        } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n            var pts = rs.allpts;\n            for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n                if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n                    addEle(edge, sqDist);\n                    return true;\n                }\n            }\n        }\n        // if we're close to the edge but didn't hit it, maybe we hit its arrows\n        var src = src || _p.source;\n        var tgt = tgt || _p.target;\n        var arSize = self1.getArrowWidth(styleWidth, scale);\n        var arrows = [\n            {\n                name: 'source',\n                x: rs.arrowStartX,\n                y: rs.arrowStartY,\n                angle: rs.srcArrowAngle\n            },\n            {\n                name: 'target',\n                x: rs.arrowEndX,\n                y: rs.arrowEndY,\n                angle: rs.tgtArrowAngle\n            },\n            {\n                name: 'mid-source',\n                x: rs.midX,\n                y: rs.midY,\n                angle: rs.midsrcArrowAngle\n            },\n            {\n                name: 'mid-target',\n                x: rs.midX,\n                y: rs.midY,\n                angle: rs.midtgtArrowAngle\n            }\n        ];\n        for(var i = 0; i < arrows.length; i++){\n            var ar = arrows[i];\n            var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n            var edgeWidth = edge.pstyle('width').pfValue;\n            if (shape.roughCollide(x, y, arSize, ar.angle, {\n                x: ar.x,\n                y: ar.y\n            }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n                x: ar.x,\n                y: ar.y\n            }, edgeWidth, edgeThreshold)) {\n                addEle(edge);\n                return true;\n            }\n        }\n        // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n        if (hasCompounds && near.length > 0) {\n            checkNode(src);\n            checkNode(tgt);\n        }\n    }\n    function preprop(obj, name, pre) {\n        return getPrefixedProperty(obj, name, pre);\n    }\n    function checkLabel(ele, prefix) {\n        var _p = ele._private;\n        var th = labelThreshold;\n        var prefixDash;\n        if (prefix) {\n            prefixDash = prefix + '-';\n        } else {\n            prefixDash = '';\n        }\n        ele.boundingBox();\n        var bb = _p.labelBounds[prefix || 'main'];\n        var text = ele.pstyle(prefixDash + 'label').value;\n        var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n        if (!eventsEnabled || !text) {\n            return;\n        }\n        var lx = preprop(_p.rscratch, 'labelX', prefix);\n        var ly = preprop(_p.rscratch, 'labelY', prefix);\n        var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n        var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n        var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n        var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n        var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n        var ly1 = bb.y1 - th - oy;\n        var ly2 = bb.y2 + th - oy;\n        if (theta) {\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            var rotate = function rotate(x, y) {\n                x = x - lx;\n                y = y - ly;\n                return {\n                    x: x * cos - y * sin + lx,\n                    y: x * sin + y * cos + ly\n                };\n            };\n            var px1y1 = rotate(lx1, ly1);\n            var px1y2 = rotate(lx1, ly2);\n            var px2y1 = rotate(lx2, ly1);\n            var px2y2 = rotate(lx2, ly2);\n            var points = [\n                // with the margin added after the rotation is applied\n                px1y1.x + ox,\n                px1y1.y + oy,\n                px2y1.x + ox,\n                px2y1.y + oy,\n                px2y2.x + ox,\n                px2y2.y + oy,\n                px1y2.x + ox,\n                px1y2.y + oy\n            ];\n            if (pointInsidePolygonPoints(x, y, points)) {\n                addEle(ele);\n                return true;\n            }\n        } else {\n            // do a cheaper bb check\n            if (inBoundingBox(bb, x, y)) {\n                addEle(ele);\n                return true;\n            }\n        }\n    }\n    for(var i = eles.length - 1; i >= 0; i--){\n        // reverse order for precedence\n        var ele = eles[i];\n        if (ele.isNode()) {\n            checkNode(ele) || checkLabel(ele);\n        } else {\n            // then edge\n            checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n        }\n    }\n    return near;\n};\n// 'Give me everything from this box'\nBRp$e.getAllInBox = function(x1, y1, x2, y2) {\n    var eles = this.getCachedZSortedEles().interactive;\n    var zoom = this.cy.zoom();\n    var labelThreshold = 2 / zoom;\n    var box = [];\n    var x1c = Math.min(x1, x2);\n    var x2c = Math.max(x1, x2);\n    var y1c = Math.min(y1, y2);\n    var y2c = Math.max(y1, y2);\n    x1 = x1c;\n    x2 = x2c;\n    y1 = y1c;\n    y2 = y2c;\n    var boxBb = makeBoundingBox({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    });\n    var selectionBox = [\n        {\n            x: boxBb.x1,\n            y: boxBb.y1\n        },\n        {\n            x: boxBb.x2,\n            y: boxBb.y1\n        },\n        {\n            x: boxBb.x2,\n            y: boxBb.y2\n        },\n        {\n            x: boxBb.x1,\n            y: boxBb.y2\n        }\n    ];\n    var boxEdges = [\n        [\n            selectionBox[0],\n            selectionBox[1]\n        ],\n        [\n            selectionBox[1],\n            selectionBox[2]\n        ],\n        [\n            selectionBox[2],\n            selectionBox[3]\n        ],\n        [\n            selectionBox[3],\n            selectionBox[0]\n        ]\n    ];\n    function preprop(obj, name, pre) {\n        return getPrefixedProperty(obj, name, pre);\n    }\n    function getRotatedLabelBox(ele, prefix) {\n        var _p = ele._private;\n        var th = labelThreshold;\n        var prefixDash = '';\n        ele.boundingBox();\n        var bb = _p.labelBounds['main'];\n        // If the bounding box is not available, return null.\n        // This indicates that the label box cannot be calculated, which is consistent\n        // with the expected behavior of this function. Returning null allows the caller\n        // to handle the absence of a bounding box explicitly.\n        if (!bb) {\n            return null;\n        }\n        var lx = preprop(_p.rscratch, 'labelX', prefix);\n        var ly = preprop(_p.rscratch, 'labelY', prefix);\n        var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n        var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n        var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n        var lx1 = bb.x1 - th - ox;\n        var lx2 = bb.x2 + th - ox;\n        var ly1 = bb.y1 - th - oy;\n        var ly2 = bb.y2 + th - oy;\n        if (theta) {\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            var rotate = function rotate(x, y) {\n                x = x - lx;\n                y = y - ly;\n                return {\n                    x: x * cos - y * sin + lx,\n                    y: x * sin + y * cos + ly\n                };\n            };\n            return [\n                rotate(lx1, ly1),\n                rotate(lx2, ly1),\n                rotate(lx2, ly2),\n                rotate(lx1, ly2)\n            ];\n        } else {\n            return [\n                {\n                    x: lx1,\n                    y: ly1\n                },\n                {\n                    x: lx2,\n                    y: ly1\n                },\n                {\n                    x: lx2,\n                    y: ly2\n                },\n                {\n                    x: lx1,\n                    y: ly2\n                }\n            ];\n        }\n    }\n    function doLinesIntersect(p1, p2, q1, q2) {\n        function ccw(a, b, c) {\n            return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n        }\n        return ccw(p1, q1, q2) !== ccw(p2, q1, q2) && ccw(p1, p2, q1) !== ccw(p1, p2, q2);\n    }\n    for(var e = 0; e < eles.length; e++){\n        var ele = eles[e];\n        if (ele.isNode()) {\n            var node = ele;\n            var textEvents = node.pstyle('text-events').strValue === 'yes';\n            var nodeBoxSelectMode = node.pstyle('box-selection').strValue;\n            var labelBoxSelectEnabled = node.pstyle('box-select-labels').strValue === 'yes';\n            if (nodeBoxSelectMode === 'none') {\n                continue;\n            }\n            var includeLabels = (nodeBoxSelectMode === 'overlap' || labelBoxSelectEnabled) && textEvents;\n            var nodeBb = node.boundingBox({\n                includeNodes: true,\n                includeEdges: false,\n                includeLabels: includeLabels\n            });\n            if (nodeBoxSelectMode === 'contain') {\n                var selected = false;\n                if (labelBoxSelectEnabled && textEvents) {\n                    var rotatedLabelBox = getRotatedLabelBox(node);\n                    if (rotatedLabelBox && satPolygonIntersection(rotatedLabelBox, selectionBox)) {\n                        box.push(node);\n                        selected = true;\n                    }\n                }\n                if (!selected && boundingBoxInBoundingBox(boxBb, nodeBb)) {\n                    box.push(node);\n                }\n            } else if (nodeBoxSelectMode === 'overlap') {\n                if (boundingBoxesIntersect(boxBb, nodeBb)) {\n                    var nodeBodyBb = node.boundingBox({\n                        includeNodes: true,\n                        includeEdges: true,\n                        includeLabels: false,\n                        includeMainLabels: false,\n                        includeSourceLabels: false,\n                        includeTargetLabels: false\n                    });\n                    var nodeBodyCorners = [\n                        {\n                            x: nodeBodyBb.x1,\n                            y: nodeBodyBb.y1\n                        },\n                        {\n                            x: nodeBodyBb.x2,\n                            y: nodeBodyBb.y1\n                        },\n                        {\n                            x: nodeBodyBb.x2,\n                            y: nodeBodyBb.y2\n                        },\n                        {\n                            x: nodeBodyBb.x1,\n                            y: nodeBodyBb.y2\n                        }\n                    ];\n                    // if node body intersects, no need to check label\n                    if (satPolygonIntersection(nodeBodyCorners, selectionBox)) {\n                        box.push(node);\n                    } else {\n                        // only check label if node body didn't intersect\n                        var _rotatedLabelBox = getRotatedLabelBox(node);\n                        if (_rotatedLabelBox && satPolygonIntersection(_rotatedLabelBox, selectionBox)) {\n                            box.push(node);\n                        }\n                    }\n                }\n            }\n        } else {\n            var edge = ele;\n            var _p = edge._private;\n            var rs = _p.rscratch;\n            var edgeBoxSelectMode = edge.pstyle('box-selection').strValue;\n            if (edgeBoxSelectMode === 'none') {\n                continue;\n            }\n            if (edgeBoxSelectMode === 'contain') {\n                if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n                    continue;\n                }\n                if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n                    continue;\n                }\n                if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n                    var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n                    var allInside = true;\n                    for(var i = 0; i < pts.length; i++){\n                        if (!pointInBoundingBox(boxBb, pts[i])) {\n                            allInside = false;\n                            break;\n                        }\n                    }\n                    if (allInside) {\n                        box.push(edge);\n                    }\n                } else if (rs.edgeType === 'straight') {\n                    box.push(edge);\n                }\n            } else if (edgeBoxSelectMode === 'overlap') {\n                var _selected = false;\n                // Check: either endpoint inside box\n                if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null && (inBoundingBox(boxBb, rs.startX, rs.startY) || inBoundingBox(boxBb, rs.endX, rs.endY))) {\n                    box.push(edge);\n                    _selected = true;\n                } else if (!_selected && rs.edgeType === 'haystack') {\n                    var haystackPts = _p.rstyle.haystackPts;\n                    for(var _i = 0; _i < haystackPts.length; _i++){\n                        if (pointInBoundingBox(boxBb, haystackPts[_i])) {\n                            box.push(edge);\n                            _selected = true;\n                            break;\n                        }\n                    }\n                }\n                // Segment intersection check (only if not already selected)\n                if (!_selected) {\n                    var _pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n                    // straight edges\n                    if ((!_pts || _pts.length < 2) && rs.edgeType === 'straight') {\n                        if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null) {\n                            _pts = [\n                                {\n                                    x: rs.startX,\n                                    y: rs.startY\n                                },\n                                {\n                                    x: rs.endX,\n                                    y: rs.endY\n                                }\n                            ];\n                        }\n                    }\n                    if (!_pts || _pts.length < 2) continue;\n                    for(var _i2 = 0; _i2 < _pts.length - 1; _i2++){\n                        var segStart = _pts[_i2];\n                        var segEnd = _pts[_i2 + 1];\n                        for(var b = 0; b < boxEdges.length; b++){\n                            var _boxEdges$b = _slicedToArray(boxEdges[b], 2), boxStart = _boxEdges$b[0], boxEnd = _boxEdges$b[1];\n                            if (doLinesIntersect(segStart, segEnd, boxStart, boxEnd)) {\n                                box.push(edge);\n                                _selected = true;\n                                break;\n                            }\n                        }\n                        if (_selected) break;\n                    }\n                }\n            }\n        }\n    }\n    return box;\n};\nvar BRp$d = {};\nBRp$d.calculateArrowAngles = function(edge) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n    var isBezier = rs.edgeType === 'bezier';\n    var isMultibezier = rs.edgeType === 'multibezier';\n    var isSegments = rs.edgeType === 'segments';\n    var isCompound = rs.edgeType === 'compound';\n    var isSelf = rs.edgeType === 'self';\n    // Displacement gives direction for arrowhead orientation\n    var dispX, dispY;\n    var startX, startY, endX, endY, midX, midY;\n    if (isHaystack) {\n        startX = rs.haystackPts[0];\n        startY = rs.haystackPts[1];\n        endX = rs.haystackPts[2];\n        endY = rs.haystackPts[3];\n    } else {\n        startX = rs.arrowStartX;\n        startY = rs.arrowStartY;\n        endX = rs.arrowEndX;\n        endY = rs.arrowEndY;\n    }\n    midX = rs.midX;\n    midY = rs.midY;\n    // source\n    //\n    if (isSegments) {\n        dispX = startX - rs.segpts[0];\n        dispY = startY - rs.segpts[1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n        var pts = rs.allpts;\n        var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n        var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n        dispX = startX - bX;\n        dispY = startY - bY;\n    } else {\n        dispX = startX - midX;\n        dispY = startY - midY;\n    }\n    rs.srcArrowAngle = getAngleFromDisp(dispX, dispY);\n    // mid target\n    //\n    var midX = rs.midX;\n    var midY = rs.midY;\n    if (isHaystack) {\n        midX = (startX + endX) / 2;\n        midY = (startY + endY) / 2;\n    }\n    dispX = endX - startX;\n    dispY = endY - startY;\n    if (isSegments) {\n        var pts = rs.allpts;\n        if (pts.length / 2 % 2 === 0) {\n            var i2 = pts.length / 2;\n            var i1 = i2 - 2;\n            dispX = pts[i2] - pts[i1];\n            dispY = pts[i2 + 1] - pts[i1 + 1];\n        } else if (rs.isRound) {\n            dispX = rs.midVector[1];\n            dispY = -rs.midVector[0];\n        } else {\n            var i2 = pts.length / 2 - 1;\n            var i1 = i2 - 2;\n            dispX = pts[i2] - pts[i1];\n            dispY = pts[i2 + 1] - pts[i1 + 1];\n        }\n    } else if (isMultibezier || isCompound || isSelf) {\n        var pts = rs.allpts;\n        var cpts = rs.ctrlpts;\n        var bp0x, bp0y;\n        var bp1x, bp1y;\n        if (cpts.length / 2 % 2 === 0) {\n            var p0 = pts.length / 2 - 1; // startpt\n            var ic = p0 + 2;\n            var p1 = ic + 2;\n            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n        } else {\n            var ic = pts.length / 2 - 1; // ctrpt\n            var p0 = ic - 2; // startpt\n            var p1 = ic + 2; // endpt\n            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n        }\n        dispX = bp1x - bp0x;\n        dispY = bp1y - bp0y;\n    }\n    rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n    rs.midDispX = dispX;\n    rs.midDispY = dispY;\n    // mid source\n    //\n    dispX *= -1;\n    dispY *= -1;\n    if (isSegments) {\n        var pts = rs.allpts;\n        if (pts.length / 2 % 2 === 0) ;\n        else if (!rs.isRound) {\n            var i2 = pts.length / 2 - 1;\n            var i3 = i2 + 2;\n            dispX = -(pts[i3] - pts[i2]);\n            dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n        }\n    }\n    rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY);\n    // target\n    //\n    if (isSegments) {\n        dispX = endX - rs.segpts[rs.segpts.length - 2];\n        dispY = endY - rs.segpts[rs.segpts.length - 1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n        var pts = rs.allpts;\n        var l = pts.length;\n        var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n        var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n        dispX = endX - bX;\n        dispY = endY - bY;\n    } else {\n        dispX = endX - midX;\n        dispY = endY - midY;\n    }\n    rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n};\nBRp$d.getArrowWidth = BRp$d.getArrowHeight = function(edgeWidth, scale) {\n    var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n    var cachedVal = cache[edgeWidth + ', ' + scale];\n    if (cachedVal) {\n        return cachedVal;\n    }\n    cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n    cache[edgeWidth + ', ' + scale] = cachedVal;\n    return cachedVal;\n};\n/**\n * Explained by Blindman67 at https://stackoverflow.com/a/44856925/11028828\n */ // Declare reused variable to avoid reallocating variables every time the function is called\nvar x, y, v1 = {}, v2 = {}, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut, radius, limit;\nvar startX, startY, stopX, stopY;\nvar lastPoint;\n// convert 2 points into vector form, polar form, and normalised\nvar asVec = function asVec(p, pp, v) {\n    v.x = pp.x - p.x;\n    v.y = pp.y - p.y;\n    v.len = Math.sqrt(v.x * v.x + v.y * v.y);\n    v.nx = v.x / v.len;\n    v.ny = v.y / v.len;\n    v.ang = Math.atan2(v.ny, v.nx);\n};\nvar invertVec = function invertVec(originalV, invertedV) {\n    invertedV.x = originalV.x * -1;\n    invertedV.y = originalV.y * -1;\n    invertedV.nx = originalV.nx * -1;\n    invertedV.ny = originalV.ny * -1;\n    invertedV.ang = originalV.ang > 0 ? -(Math.PI - originalV.ang) : Math.PI + originalV.ang;\n};\nvar calcCornerArc = function calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius) {\n    //-----------------------------------------\n    // Part 1\n    previousPoint !== lastPoint ? asVec(currentPoint, previousPoint, v1) : invertVec(v2, v1); // Avoid recalculating vec if it is the invert of the last one calculated\n    asVec(currentPoint, nextPoint, v2);\n    sinA = v1.nx * v2.ny - v1.ny * v2.nx;\n    sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;\n    angle = Math.asin(Math.max(-1, Math.min(1, sinA)));\n    if (Math.abs(angle) < 1e-6) {\n        x = currentPoint.x;\n        y = currentPoint.y;\n        cRadius = radius = 0;\n        return;\n    }\n    //-----------------------------------------\n    radDirection = 1;\n    drawDirection = false;\n    if (sinA90 < 0) {\n        if (angle < 0) {\n            angle = Math.PI + angle;\n        } else {\n            angle = Math.PI - angle;\n            radDirection = -1;\n            drawDirection = true;\n        }\n    } else {\n        if (angle > 0) {\n            radDirection = -1;\n            drawDirection = true;\n        }\n    }\n    if (currentPoint.radius !== undefined) {\n        radius = currentPoint.radius;\n    } else {\n        radius = radiusMax;\n    }\n    //-----------------------------------------\n    // Part 2\n    halfAngle = angle / 2;\n    //-----------------------------------------\n    limit = Math.min(v1.len / 2, v2.len / 2);\n    if (isArcRadius) {\n        //-----------------------------------------\n        // Part 3\n        lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));\n        //-----------------------------------------\n        // Special part A\n        if (lenOut > limit) {\n            lenOut = limit;\n            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n        } else {\n            cRadius = radius;\n        }\n    } else {\n        lenOut = Math.min(limit, radius);\n        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    }\n    //-----------------------------------------\n    //-----------------------------------------\n    // Part 4\n    stopX = currentPoint.x + v2.nx * lenOut;\n    stopY = currentPoint.y + v2.ny * lenOut;\n    //-----------------------------------------\n    // Part 5\n    x = stopX - v2.ny * cRadius * radDirection;\n    y = stopY + v2.nx * cRadius * radDirection;\n    //-----------------------------------------\n    // Additional Part : calculate start point E\n    startX = currentPoint.x + v1.nx * lenOut;\n    startY = currentPoint.y + v1.ny * lenOut;\n    // Save last point to avoid recalculating vector when not needed\n    lastPoint = currentPoint;\n};\n/**\n * Draw corner provided by {@link getRoundCorner}\n *\n * @param ctx :CanvasRenderingContext2D\n * @param roundCorner {{cx:number, cy:number, radius:number, endAngle: number, startAngle: number, counterClockwise: boolean}}\n */ function drawPreparedRoundCorner(ctx, roundCorner) {\n    if (roundCorner.radius === 0) ctx.lineTo(roundCorner.cx, roundCorner.cy);\n    else ctx.arc(roundCorner.cx, roundCorner.cy, roundCorner.radius, roundCorner.startAngle, roundCorner.endAngle, roundCorner.counterClockwise);\n}\n/**\n * Get round corner from a point and its previous and next neighbours in a path\n *\n * @param previousPoint {{x: number, y:number, radius: number?}}\n * @param currentPoint {{x: number, y:number, radius: number?}}\n * @param nextPoint {{x: number, y:number, radius: number?}}\n * @param radiusMax :number\n * @param isArcRadius :boolean\n * @return {{\n * cx:number, cy:number, radius:number,\n * startX:number, startY:number,\n * stopX:number, stopY: number,\n * endAngle: number, startAngle: number, counterClockwise: boolean\n * }}\n */ function getRoundCorner(previousPoint, currentPoint, nextPoint, radiusMax) {\n    var isArcRadius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    if (radiusMax === 0 || currentPoint.radius === 0) return {\n        cx: currentPoint.x,\n        cy: currentPoint.y,\n        radius: 0,\n        startX: currentPoint.x,\n        startY: currentPoint.y,\n        stopX: currentPoint.x,\n        stopY: currentPoint.y,\n        startAngle: undefined,\n        endAngle: undefined,\n        counterClockwise: undefined\n    };\n    calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius);\n    return {\n        cx: x,\n        cy: y,\n        radius: cRadius,\n        startX: startX,\n        startY: startY,\n        stopX: stopX,\n        stopY: stopY,\n        startAngle: v1.ang + Math.PI / 2 * radDirection,\n        endAngle: v2.ang - Math.PI / 2 * radDirection,\n        counterClockwise: drawDirection\n    };\n}\nvar AVOID_IMPOSSIBLE_BEZIER_CONSTANT = 0.01;\nvar AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L = Math.sqrt(2 * AVOID_IMPOSSIBLE_BEZIER_CONSTANT);\nvar BRp$c = {};\nBRp$c.findMidptPtsEtc = function(edge, pairInfo) {\n    var posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts, vectorNormInverse = pairInfo.vectorNormInverse;\n    var midptPts;\n    // n.b. assumes all edges in bezier bundle have same endpoints specified\n    var srcManEndpt = edge.pstyle('source-endpoint');\n    var tgtManEndpt = edge.pstyle('target-endpoint');\n    var haveManualEndPts = srcManEndpt.units != null && tgtManEndpt.units != null;\n    var recalcVectorNormInverse = function recalcVectorNormInverse(x1, y1, x2, y2) {\n        var dy = y2 - y1;\n        var dx = x2 - x1;\n        var l = Math.sqrt(dx * dx + dy * dy);\n        return {\n            x: -dy / l,\n            y: dx / l\n        };\n    };\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    switch(edgeDistances){\n        case 'node-position':\n            midptPts = posPts;\n            break;\n        case 'intersection':\n            midptPts = intersectionPts;\n            break;\n        case 'endpoints':\n            {\n                if (haveManualEndPts) {\n                    var _this$manualEndptToPx = this.manualEndptToPx(edge.source()[0], srcManEndpt), _this$manualEndptToPx2 = _slicedToArray(_this$manualEndptToPx, 2), x1 = _this$manualEndptToPx2[0], y1 = _this$manualEndptToPx2[1];\n                    var _this$manualEndptToPx3 = this.manualEndptToPx(edge.target()[0], tgtManEndpt), _this$manualEndptToPx4 = _slicedToArray(_this$manualEndptToPx3, 2), x2 = _this$manualEndptToPx4[0], y2 = _this$manualEndptToPx4[1];\n                    var endPts = {\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2\n                    };\n                    vectorNormInverse = recalcVectorNormInverse(x1, y1, x2, y2);\n                    midptPts = endPts;\n                } else {\n                    warn(\"Edge \".concat(edge.id(), \" has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).\"));\n                    midptPts = intersectionPts; // back to default\n                }\n                break;\n            }\n    }\n    return {\n        midptPts: midptPts,\n        vectorNormInverse: vectorNormInverse\n    };\n};\nBRp$c.findHaystackPoints = function(edges) {\n    for(var i = 0; i < edges.length; i++){\n        var edge = edges[i];\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        if (!rs.haystack) {\n            var angle = Math.random() * 2 * Math.PI;\n            rs.source = {\n                x: Math.cos(angle),\n                y: Math.sin(angle)\n            };\n            angle = Math.random() * 2 * Math.PI;\n            rs.target = {\n                x: Math.cos(angle),\n                y: Math.sin(angle)\n            };\n        }\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcPos = src.position();\n        var tgtPos = tgt.position();\n        var srcW = src.width();\n        var tgtW = tgt.width();\n        var srcH = src.height();\n        var tgtH = tgt.height();\n        var radius = edge.pstyle('haystack-radius').value;\n        var halfRadius = radius / 2; // b/c have to half width/height\n        rs.haystackPts = rs.allpts = [\n            rs.source.x * srcW * halfRadius + srcPos.x,\n            rs.source.y * srcH * halfRadius + srcPos.y,\n            rs.target.x * tgtW * halfRadius + tgtPos.x,\n            rs.target.y * tgtH * halfRadius + tgtPos.y\n        ];\n        rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n        rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n        // always override as haystack in case set to different type previously\n        rs.edgeType = 'haystack';\n        rs.haystack = true;\n        this.storeEdgeProjections(edge);\n        this.calculateArrowAngles(edge);\n        this.recalculateEdgeLabelProjections(edge);\n        this.calculateLabelAngles(edge);\n    }\n};\nBRp$c.findSegmentsPoints = function(edge, pairInfo) {\n    // Segments (multiple straight lines)\n    var rs = edge._private.rscratch;\n    var segmentWs = edge.pstyle('segment-weights');\n    var segmentDs = edge.pstyle('segment-distances');\n    var segmentRs = edge.pstyle('segment-radii');\n    var segmentTs = edge.pstyle('radius-type');\n    var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n    var lastRadius = segmentRs.pfValue[segmentRs.pfValue.length - 1];\n    var lastRadiusType = segmentTs.pfValue[segmentTs.pfValue.length - 1];\n    rs.edgeType = 'segments';\n    rs.segpts = [];\n    rs.radii = [];\n    rs.isArcRadius = [];\n    for(var s = 0; s < segmentsN; s++){\n        var w = segmentWs.pfValue[s];\n        var d = segmentDs.pfValue[s];\n        var w1 = 1 - w;\n        var w2 = w;\n        var _this$findMidptPtsEtc = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc.midptPts, vectorNormInverse = _this$findMidptPtsEtc.vectorNormInverse;\n        var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n        };\n        rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n        rs.radii.push(segmentRs.pfValue[s] !== undefined ? segmentRs.pfValue[s] : lastRadius);\n        rs.isArcRadius.push((segmentTs.pfValue[s] !== undefined ? segmentTs.pfValue[s] : lastRadiusType) === 'arc-radius');\n    }\n};\nBRp$c.findLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n    // Self-edge\n    var rs = edge._private.rscratch;\n    var dirCounts = pairInfo.dirCounts, srcPos = pairInfo.srcPos;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var loopDir = edge.pstyle('loop-direction').pfValue;\n    var loopSwp = edge.pstyle('loop-sweep').pfValue;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    rs.edgeType = 'self';\n    var j = i;\n    var loopDist = stepSize;\n    if (edgeIsUnbundled) {\n        j = 0;\n        loopDist = ctrlptDist;\n    }\n    var loopAngle = loopDir - Math.PI / 2;\n    var outAngle = loopAngle - loopSwp / 2;\n    var inAngle = loopAngle + loopSwp / 2;\n    // increase by step size for overlapping loops, keyed on direction and sweep values\n    var dc = String(loopDir + '_' + loopSwp);\n    j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n    rs.ctrlpts = [\n        srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)\n    ];\n};\nBRp$c.findCompoundLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n    // Compound edge\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'compound';\n    var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var j = i;\n    var loopDist = stepSize;\n    if (edgeIsUnbundled) {\n        j = 0;\n        loopDist = ctrlptDist;\n    }\n    var loopW = 50;\n    var loopaPos = {\n        x: srcPos.x - srcW / 2,\n        y: srcPos.y - srcH / 2\n    };\n    var loopbPos = {\n        x: tgtPos.x - tgtW / 2,\n        y: tgtPos.y - tgtH / 2\n    };\n    var loopPos = {\n        x: Math.min(loopaPos.x, loopbPos.x),\n        y: Math.min(loopaPos.y, loopbPos.y)\n    };\n    // avoids cases with impossible beziers\n    var minCompoundStretch = 0.5;\n    var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n    var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n    rs.ctrlpts = [\n        loopPos.x,\n        loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,\n        loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,\n        loopPos.y\n    ];\n};\nBRp$c.findStraightEdgePoints = function(edge) {\n    // Straight edge within bundle\n    edge._private.rscratch.edgeType = 'straight';\n};\nBRp$c.findBezierPoints = function(edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n    var rs = edge._private.rscratch;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptWs = edge.pstyle('control-point-weights');\n    var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var ctrlptWeight = ctrlptWs.value[0];\n    // (Multi)bezier\n    var multi = edgeIsUnbundled;\n    rs.edgeType = multi ? 'multibezier' : 'bezier';\n    rs.ctrlpts = [];\n    for(var b = 0; b < bezierN; b++){\n        var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n        var manctrlptDist = undefined;\n        var sign = signum(normctrlptDist);\n        if (multi) {\n            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n            ctrlptWeight = ctrlptWs.value[b];\n        }\n        if (edgeIsUnbundled) {\n            // multi or single unbundled\n            manctrlptDist = ctrlptDist;\n        } else {\n            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n        }\n        var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n        var w1 = 1 - ctrlptWeight;\n        var w2 = ctrlptWeight;\n        var _this$findMidptPtsEtc2 = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc2.midptPts, vectorNormInverse = _this$findMidptPtsEtc2.vectorNormInverse;\n        var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n        };\n        rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n    }\n};\nBRp$c.findTaxiPoints = function(edge, pairInfo) {\n    // Taxicab geometry with two turns maximum\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'segments';\n    var VERTICAL = 'vertical';\n    var HORIZONTAL = 'horizontal';\n    var LEFTWARD = 'leftward';\n    var RIGHTWARD = 'rightward';\n    var DOWNWARD = 'downward';\n    var UPWARD = 'upward';\n    var AUTO = 'auto';\n    var posPts = pairInfo.posPts, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var dIncludesNodeBody = edgeDistances !== 'node-position';\n    var taxiDir = edge.pstyle('taxi-direction').value;\n    var rawTaxiDir = taxiDir; // unprocessed value\n    var taxiTurn = edge.pstyle('taxi-turn');\n    var turnIsPercent = taxiTurn.units === '%';\n    var taxiTurnPfVal = taxiTurn.pfValue;\n    var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n    var minD = edge.pstyle('taxi-turn-min-distance').pfValue;\n    var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n    var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n    var pdx = posPts.x2 - posPts.x1;\n    var pdy = posPts.y2 - posPts.y1;\n    // take away the effective w/h from the magnitude of the delta value\n    var subDWH = function subDWH(dxy, dwh) {\n        if (dxy > 0) {\n            return Math.max(dxy - dwh, 0);\n        } else {\n            return Math.min(dxy + dwh, 0);\n        }\n    };\n    var dx = subDWH(pdx, dw);\n    var dy = subDWH(pdy, dh);\n    var isExplicitDir = false;\n    if (rawTaxiDir === AUTO) {\n        taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n    } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n        taxiDir = VERTICAL;\n        isExplicitDir = true;\n    } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n        taxiDir = HORIZONTAL;\n        isExplicitDir = true;\n    }\n    var isVert = taxiDir === VERTICAL;\n    var l = isVert ? dy : dx;\n    var pl = isVert ? pdy : pdx;\n    var sgnL = signum(pl);\n    var forcedDir = false;\n    if (!(isExplicitDir && (turnIsPercent || turnIsNegative) // forcing in this case would cause weird growing in the opposite direction\n    ) && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n        sgnL *= -1;\n        l = sgnL * Math.abs(l);\n        forcedDir = true;\n    }\n    var d;\n    if (turnIsPercent) {\n        var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n        d = p * l;\n    } else {\n        var k = taxiTurnPfVal < 0 ? l : 0;\n        d = k + taxiTurnPfVal * sgnL;\n    }\n    var getIsTooClose = function getIsTooClose(d) {\n        return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n    };\n    var isTooCloseSrc = getIsTooClose(d);\n    var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n    var isTooClose = isTooCloseSrc || isTooCloseTgt;\n    if (isTooClose && !forcedDir) {\n        // non-ideal routing\n        if (isVert) {\n            // vertical fallbacks\n            var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n            var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n            if (lShapeInsideSrc) {\n                // horizontal Z-shape (direction not respected)\n                var x = (posPts.x1 + posPts.x2) / 2;\n                var y1 = posPts.y1, y2 = posPts.y2;\n                rs.segpts = [\n                    x,\n                    y1,\n                    x,\n                    y2\n                ];\n            } else if (lShapeInsideTgt) {\n                // vertical Z-shape (distance not respected)\n                var y = (posPts.y1 + posPts.y2) / 2;\n                var x1 = posPts.x1, x2 = posPts.x2;\n                rs.segpts = [\n                    x1,\n                    y,\n                    x2,\n                    y\n                ];\n            } else {\n                // L-shape fallback (turn distance not respected, but works well with tree siblings)\n                rs.segpts = [\n                    posPts.x1,\n                    posPts.y2\n                ];\n            }\n        } else {\n            // horizontal fallbacks\n            var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n            var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n            if (_lShapeInsideSrc) {\n                // vertical Z-shape (direction not respected)\n                var _y = (posPts.y1 + posPts.y2) / 2;\n                var _x = posPts.x1, _x2 = posPts.x2;\n                rs.segpts = [\n                    _x,\n                    _y,\n                    _x2,\n                    _y\n                ];\n            } else if (_lShapeInsideTgt) {\n                // horizontal Z-shape (turn distance not respected)\n                var _x3 = (posPts.x1 + posPts.x2) / 2;\n                var _y2 = posPts.y1, _y3 = posPts.y2;\n                rs.segpts = [\n                    _x3,\n                    _y2,\n                    _x3,\n                    _y3\n                ];\n            } else {\n                // L-shape (turn distance not respected, but works well for tree siblings)\n                rs.segpts = [\n                    posPts.x2,\n                    posPts.y1\n                ];\n            }\n        }\n    } else {\n        // ideal routing\n        if (isVert) {\n            var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n            var _x4 = posPts.x1, _x5 = posPts.x2;\n            rs.segpts = [\n                _x4,\n                _y4,\n                _x5,\n                _y4\n            ];\n        } else {\n            // horizontal\n            var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n            var _y5 = posPts.y1, _y6 = posPts.y2;\n            rs.segpts = [\n                _x6,\n                _y5,\n                _x6,\n                _y6\n            ];\n        }\n    }\n    if (rs.isRound) {\n        var radius = edge.pstyle('taxi-radius').value;\n        var isArcRadius = edge.pstyle('radius-type').value[0] === 'arc-radius';\n        rs.radii = new Array(rs.segpts.length / 2).fill(radius);\n        rs.isArcRadius = new Array(rs.segpts.length / 2).fill(isArcRadius);\n    }\n};\nBRp$c.tryToCorrectInvalidPoints = function(edge, pairInfo) {\n    var rs = edge._private.rscratch;\n    // can only correct beziers for now...\n    if (rs.edgeType === 'bezier') {\n        var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH, srcShape = pairInfo.srcShape, tgtShape = pairInfo.tgtShape, srcCornerRadius = pairInfo.srcCornerRadius, tgtCornerRadius = pairInfo.tgtCornerRadius, srcRs = pairInfo.srcRs, tgtRs = pairInfo.tgtRs;\n        var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n        var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n        var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n        var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n        var minCpADistFactor = 3;\n        var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n        var minCpADist = minCpADistFactor * arrowW;\n        var startACpDist = dist({\n            x: rs.ctrlpts[0],\n            y: rs.ctrlpts[1]\n        }, {\n            x: rs.startX,\n            y: rs.startY\n        });\n        var closeStartACp = startACpDist < minCpADist;\n        var endACpDist = dist({\n            x: rs.ctrlpts[0],\n            y: rs.ctrlpts[1]\n        }, {\n            x: rs.endX,\n            y: rs.endY\n        });\n        var closeEndACp = endACpDist < minCpADist;\n        var overlapping = false;\n        if (badStart || badAStart || closeStartACp) {\n            overlapping = true;\n            // project control point along line from src centre to outside the src shape\n            // (otherwise intersection will yield nothing)\n            var cpD = {\n                // delta\n                x: rs.ctrlpts[0] - srcPos.x,\n                y: rs.ctrlpts[1] - srcPos.y\n            };\n            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n            var cpM = {\n                // normalised delta\n                x: cpD.x / cpL,\n                y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = {\n                // *2 radius guarantees outside shape\n                x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n                y: rs.ctrlpts[1] + cpM.y * 2 * radius\n            };\n            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0, srcCornerRadius, srcRs);\n            if (closeStartACp) {\n                rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n                rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n            } else {\n                rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n                rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n        }\n        if (badEnd || badAEnd || closeEndACp) {\n            overlapping = true;\n            // project control point along line from tgt centre to outside the tgt shape\n            // (otherwise intersection will yield nothing)\n            var _cpD = {\n                // delta\n                x: rs.ctrlpts[0] - tgtPos.x,\n                y: rs.ctrlpts[1] - tgtPos.y\n            };\n            var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n            var _cpM = {\n                // normalised delta\n                x: _cpD.x / _cpL,\n                y: _cpD.y / _cpL\n            };\n            var _radius = Math.max(srcW, srcH);\n            var _cpProj = {\n                // *2 radius guarantees outside shape\n                x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n                y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n            };\n            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0, tgtCornerRadius, tgtRs);\n            if (closeEndACp) {\n                rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n                rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n            } else {\n                rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n                rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n            }\n        }\n        if (overlapping) {\n            // recalc endpts\n            this.findEndpoints(edge);\n        }\n    }\n};\nBRp$c.storeAllpts = function(edge) {\n    var rs = edge._private.rscratch;\n    if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n        rs.allpts = [];\n        rs.allpts.push(rs.startX, rs.startY);\n        for(var b = 0; b + 1 < rs.ctrlpts.length; b += 2){\n            // ctrl pt itself\n            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);\n            // the midpt between ctrlpts as intermediate destination pts\n            if (b + 3 < rs.ctrlpts.length) {\n                rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n            }\n        }\n        rs.allpts.push(rs.endX, rs.endY);\n        var m1, mt;\n        if (rs.ctrlpts.length / 2 % 2 === 0) {\n            m1 = rs.allpts.length / 2 - 1;\n            rs.midX = rs.allpts[m1];\n            rs.midY = rs.allpts[m1 + 1];\n        } else {\n            m1 = rs.allpts.length / 2 - 3;\n            mt = 0.5;\n            rs.midX = qbezierAt(rs.allpts[m1], rs.allpts[m1 + 2], rs.allpts[m1 + 4], mt);\n            rs.midY = qbezierAt(rs.allpts[m1 + 1], rs.allpts[m1 + 3], rs.allpts[m1 + 5], mt);\n        }\n    } else if (rs.edgeType === 'straight') {\n        // need to calc these after endpts\n        rs.allpts = [\n            rs.startX,\n            rs.startY,\n            rs.endX,\n            rs.endY\n        ];\n        // default midpt for labels etc\n        rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n        rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n    } else if (rs.edgeType === 'segments') {\n        rs.allpts = [];\n        rs.allpts.push(rs.startX, rs.startY);\n        rs.allpts.push.apply(rs.allpts, rs.segpts);\n        rs.allpts.push(rs.endX, rs.endY);\n        if (rs.isRound) {\n            rs.roundCorners = [];\n            for(var i = 2; i + 3 < rs.allpts.length; i += 2){\n                var radius = rs.radii[i / 2 - 1];\n                var isArcRadius = rs.isArcRadius[i / 2 - 1];\n                rs.roundCorners.push(getRoundCorner({\n                    x: rs.allpts[i - 2],\n                    y: rs.allpts[i - 1]\n                }, {\n                    x: rs.allpts[i],\n                    y: rs.allpts[i + 1],\n                    radius: radius\n                }, {\n                    x: rs.allpts[i + 2],\n                    y: rs.allpts[i + 3]\n                }, radius, isArcRadius));\n            }\n        }\n        if (rs.segpts.length % 4 === 0) {\n            var i2 = rs.segpts.length / 2;\n            var i1 = i2 - 2;\n            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n        } else {\n            var _i = rs.segpts.length / 2 - 1;\n            if (!rs.isRound) {\n                rs.midX = rs.segpts[_i];\n                rs.midY = rs.segpts[_i + 1];\n            } else {\n                var point = {\n                    x: rs.segpts[_i],\n                    y: rs.segpts[_i + 1]\n                };\n                var corner = rs.roundCorners[_i / 2];\n                if (corner.radius === 0) {\n                    // On collinear points\n                    var nextPoint = {\n                        x: rs.segpts[_i + 2],\n                        y: rs.segpts[_i + 3]\n                    };\n                    rs.midX = point.x;\n                    rs.midY = point.y;\n                    rs.midVector = [\n                        point.y - nextPoint.y,\n                        nextPoint.x - point.x\n                    ];\n                } else {\n                    // On rounded points\n                    var v = [\n                        point.x - corner.cx,\n                        point.y - corner.cy\n                    ];\n                    var factor = corner.radius / Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n                    v = v.map(function(c) {\n                        return c * factor;\n                    });\n                    rs.midX = corner.cx + v[0];\n                    rs.midY = corner.cy + v[1];\n                    rs.midVector = v;\n                }\n            }\n        }\n    }\n};\nBRp$c.checkForInvalidEdgeWarning = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n        rs.loggedErr = false;\n    } else {\n        if (!rs.loggedErr) {\n            rs.loggedErr = true;\n            warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');\n        }\n    }\n};\nBRp$c.findEdgeControlPoints = function(edges) {\n    var _this = this;\n    if (!edges || edges.length === 0) {\n        return;\n    }\n    var r = this;\n    var cy = r.cy;\n    var hasCompounds = cy.hasCompoundNodes();\n    var hashTable = new Map$1();\n    var getKey = function getKey(pairId, edgeIsUnbundled) {\n        return [].concat(_toConsumableArray(pairId), [\n            edgeIsUnbundled ? 1 : 0\n        ]).join('-');\n    };\n    var pairIds = [];\n    var haystackEdges = [];\n    // create a table of edge (src, tgt) => list of edges between them\n    for(var i = 0; i < edges.length; i++){\n        var edge = edges[i];\n        var _p = edge._private;\n        var curveStyle = edge.pstyle('curve-style').value;\n        // ignore edges who are not to be displayed\n        // they shouldn't take up space\n        if (edge.removed() || !edge.takesUpSpace()) {\n            continue;\n        }\n        if (curveStyle === 'haystack') {\n            haystackEdges.push(edge);\n            continue;\n        }\n        var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || endsWith(curveStyle, 'segments') || curveStyle === 'straight' || curveStyle === 'straight-triangle' || endsWith(curveStyle, 'taxi');\n        var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcIndex = src.poolIndex();\n        var tgtIndex = tgt.poolIndex();\n        var pairId = [\n            srcIndex,\n            tgtIndex\n        ].sort();\n        var key = getKey(pairId, edgeIsUnbundled);\n        var tableEntry = hashTable.get(key);\n        if (tableEntry == null) {\n            tableEntry = {\n                eles: []\n            };\n            pairIds.push({\n                pairId: pairId,\n                edgeIsUnbundled: edgeIsUnbundled\n            });\n            hashTable.set(key, tableEntry);\n        }\n        tableEntry.eles.push(edge);\n        if (edgeIsUnbundled) {\n            tableEntry.hasUnbundled = true;\n        }\n        if (edgeIsBezier) {\n            tableEntry.hasBezier = true;\n        }\n    }\n    // for each pair (src, tgt), create the ctrl pts\n    // Nested for loop is OK; total number of iterations for both loops = edgeCount\n    var _loop = function _loop() {\n        var _pairIds$p = pairIds[p], pairId = _pairIds$p.pairId, edgeIsUnbundled = _pairIds$p.edgeIsUnbundled;\n        var key = getKey(pairId, edgeIsUnbundled);\n        var pairInfo = hashTable.get(key);\n        var swappedpairInfo;\n        if (!pairInfo.hasUnbundled) {\n            var pllEdges = pairInfo.eles[0].parallelEdges().filter(function(e) {\n                return e.isBundledBezier();\n            });\n            clearArray(pairInfo.eles);\n            pllEdges.forEach(function(edge) {\n                return pairInfo.eles.push(edge);\n            });\n            // for each pair id, the edges should be sorted by index\n            pairInfo.eles.sort(function(edge1, edge2) {\n                return edge1.poolIndex() - edge2.poolIndex();\n            });\n        }\n        var firstEdge = pairInfo.eles[0];\n        var src = firstEdge.source();\n        var tgt = firstEdge.target();\n        // make sure src/tgt distinction is consistent w.r.t. pairId\n        if (src.poolIndex() > tgt.poolIndex()) {\n            var temp = src;\n            src = tgt;\n            tgt = temp;\n        }\n        var srcPos = pairInfo.srcPos = src.position();\n        var tgtPos = pairInfo.tgtPos = tgt.position();\n        var srcW = pairInfo.srcW = src.outerWidth();\n        var srcH = pairInfo.srcH = src.outerHeight();\n        var tgtW = pairInfo.tgtW = tgt.outerWidth();\n        var tgtH = pairInfo.tgtH = tgt.outerHeight();\n        var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n        var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n        var srcCornerRadius = pairInfo.srcCornerRadius = src.pstyle('corner-radius').value === 'auto' ? 'auto' : src.pstyle('corner-radius').pfValue;\n        var tgtCornerRadius = pairInfo.tgtCornerRadius = tgt.pstyle('corner-radius').value === 'auto' ? 'auto' : tgt.pstyle('corner-radius').pfValue;\n        var tgtRs = pairInfo.tgtRs = tgt._private.rscratch;\n        var srcRs = pairInfo.srcRs = src._private.rscratch;\n        pairInfo.dirCounts = {\n            'north': 0,\n            'west': 0,\n            'south': 0,\n            'east': 0,\n            'northwest': 0,\n            'southwest': 0,\n            'northeast': 0,\n            'southeast': 0\n        };\n        for(var _i2 = 0; _i2 < pairInfo.eles.length; _i2++){\n            var _edge = pairInfo.eles[_i2];\n            var rs = _edge[0]._private.rscratch;\n            var _curveStyle = _edge.pstyle('curve-style').value;\n            var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || endsWith(_curveStyle, 'segments') || endsWith(_curveStyle, 'taxi');\n            // whether the normalised pair order is the reverse of the edge's src-tgt order\n            var edgeIsSwapped = !src.same(_edge.source());\n            if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n                pairInfo.calculatedIntersection = true;\n                // pt outside src shape to calc distance/displacement from src to tgt\n                var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0, srcCornerRadius, srcRs);\n                var srcIntn = pairInfo.srcIntn = srcOutside;\n                // pt outside tgt shape to calc distance/displacement from src to tgt\n                var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0, tgtCornerRadius, tgtRs);\n                var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n                var intersectionPts = pairInfo.intersectionPts = {\n                    x1: srcOutside[0],\n                    x2: tgtOutside[0],\n                    y1: srcOutside[1],\n                    y2: tgtOutside[1]\n                };\n                var posPts = pairInfo.posPts = {\n                    x1: srcPos.x,\n                    x2: tgtPos.x,\n                    y1: srcPos.y,\n                    y2: tgtPos.y\n                };\n                var dy = tgtOutside[1] - srcOutside[1];\n                var dx = tgtOutside[0] - srcOutside[0];\n                var l = Math.sqrt(dx * dx + dy * dy);\n                if (number$1(l) && l >= AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L) ;\n                else {\n                    l = Math.sqrt(Math.max(dx * dx, AVOID_IMPOSSIBLE_BEZIER_CONSTANT) + Math.max(dy * dy, AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n                }\n                var vector = pairInfo.vector = {\n                    x: dx,\n                    y: dy\n                };\n                var vectorNorm = pairInfo.vectorNorm = {\n                    x: vector.x / l,\n                    y: vector.y / l\n                };\n                var vectorNormInverse = {\n                    x: -vectorNorm.y,\n                    y: vectorNorm.x\n                };\n                // if node shapes overlap, then no ctrl pts to draw\n                pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y, tgtCornerRadius, tgtRs) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y, srcCornerRadius, srcRs);\n                pairInfo.vectorNormInverse = vectorNormInverse;\n                swappedpairInfo = {\n                    nodesOverlap: pairInfo.nodesOverlap,\n                    dirCounts: pairInfo.dirCounts,\n                    calculatedIntersection: true,\n                    hasBezier: pairInfo.hasBezier,\n                    hasUnbundled: pairInfo.hasUnbundled,\n                    eles: pairInfo.eles,\n                    srcPos: tgtPos,\n                    srcRs: tgtRs,\n                    tgtPos: srcPos,\n                    tgtRs: srcRs,\n                    srcW: tgtW,\n                    srcH: tgtH,\n                    tgtW: srcW,\n                    tgtH: srcH,\n                    srcIntn: tgtIntn,\n                    tgtIntn: srcIntn,\n                    srcShape: tgtShape,\n                    tgtShape: srcShape,\n                    posPts: {\n                        x1: posPts.x2,\n                        y1: posPts.y2,\n                        x2: posPts.x1,\n                        y2: posPts.y1\n                    },\n                    intersectionPts: {\n                        x1: intersectionPts.x2,\n                        y1: intersectionPts.y2,\n                        x2: intersectionPts.x1,\n                        y2: intersectionPts.y1\n                    },\n                    vector: {\n                        x: -vector.x,\n                        y: -vector.y\n                    },\n                    vectorNorm: {\n                        x: -vectorNorm.x,\n                        y: -vectorNorm.y\n                    },\n                    vectorNormInverse: {\n                        x: -vectorNormInverse.x,\n                        y: -vectorNormInverse.y\n                    }\n                };\n            }\n            var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n            rs.nodesOverlap = passedPairInfo.nodesOverlap;\n            rs.srcIntn = passedPairInfo.srcIntn;\n            rs.tgtIntn = passedPairInfo.tgtIntn;\n            rs.isRound = _curveStyle.startsWith('round');\n            if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n                _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n            } else if (src === tgt) {\n                _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n            } else if (_curveStyle.endsWith('segments')) {\n                _this.findSegmentsPoints(_edge, passedPairInfo);\n            } else if (_curveStyle.endsWith('taxi')) {\n                _this.findTaxiPoints(_edge, passedPairInfo);\n            } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n                _this.findStraightEdgePoints(_edge);\n            } else {\n                _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n            }\n            _this.findEndpoints(_edge);\n            _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n            _this.checkForInvalidEdgeWarning(_edge);\n            _this.storeAllpts(_edge);\n            _this.storeEdgeProjections(_edge);\n            _this.calculateArrowAngles(_edge);\n            _this.recalculateEdgeLabelProjections(_edge);\n            _this.calculateLabelAngles(_edge);\n        } // for pair edges\n    };\n    for(var p = 0; p < pairIds.length; p++){\n        _loop();\n    } // for pair ids\n    // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n    this.findHaystackPoints(haystackEdges);\n};\nfunction getPts(pts) {\n    var retPts = [];\n    if (pts == null) {\n        return;\n    }\n    for(var i = 0; i < pts.length; i += 2){\n        var x = pts[i];\n        var y = pts[i + 1];\n        retPts.push({\n            x: x,\n            y: y\n        });\n    }\n    return retPts;\n}\nBRp$c.getSegmentPoints = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    var type = rs.edgeType;\n    if (type === 'segments') {\n        return getPts(rs.segpts);\n    }\n};\nBRp$c.getControlPoints = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    var type = rs.edgeType;\n    if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {\n        return getPts(rs.ctrlpts);\n    }\n};\nBRp$c.getEdgeMidpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    return {\n        x: rs.midX,\n        y: rs.midY\n    };\n};\nvar BRp$b = {};\nBRp$b.manualEndptToPx = function(node, prop) {\n    var r = this;\n    var npos = node.position();\n    var w = node.outerWidth();\n    var h = node.outerHeight();\n    var rs = node._private.rscratch;\n    if (prop.value.length === 2) {\n        var p = [\n            prop.pfValue[0],\n            prop.pfValue[1]\n        ];\n        if (prop.units[0] === '%') {\n            p[0] = p[0] * w;\n        }\n        if (prop.units[1] === '%') {\n            p[1] = p[1] * h;\n        }\n        p[0] += npos.x;\n        p[1] += npos.y;\n        return p;\n    } else {\n        var angle = prop.pfValue[0];\n        angle = -Math.PI / 2 + angle; // start at 12 o'clock\n        var l = 2 * Math.max(w, h);\n        var _p = [\n            npos.x + Math.cos(angle) * l,\n            npos.y + Math.sin(angle) * l\n        ];\n        return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0, node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue, rs);\n    }\n};\nBRp$b.findEndpoints = function(edge) {\n    var _ref, _tgtManEndpt$pfValue, _ref2, _srcManEndpt$pfValue;\n    var r = this;\n    var intersect;\n    var source = edge.source()[0];\n    var target = edge.target()[0];\n    var srcPos = source.position();\n    var tgtPos = target.position();\n    var tgtArShape = edge.pstyle('target-arrow-shape').value;\n    var srcArShape = edge.pstyle('source-arrow-shape').value;\n    var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n    var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n    var srcRs = source._private.rscratch;\n    var tgtRs = target._private.rscratch;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var rs = edge._private.rscratch;\n    var et = rs.edgeType;\n    var taxi = endsWith(curveStyle, 'taxi'); // Covers taxi and round-taxi\n    var self1 = et === 'self' || et === 'compound';\n    var bezier = et === 'bezier' || et === 'multibezier' || self1;\n    var multi = et !== 'bezier';\n    var lines = et === 'straight' || et === 'segments';\n    var segments = et === 'segments';\n    var hasEndpts = bezier || multi || lines;\n    var overrideEndpts = self1 || taxi;\n    var srcManEndpt = edge.pstyle('source-endpoint');\n    var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;\n    var srcCornerRadius = source.pstyle('corner-radius').value === 'auto' ? 'auto' : source.pstyle('corner-radius').pfValue;\n    var tgtManEndpt = edge.pstyle('target-endpoint');\n    var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;\n    var tgtCornerRadius = target.pstyle('corner-radius').value === 'auto' ? 'auto' : target.pstyle('corner-radius').pfValue;\n    rs.srcManEndpt = srcManEndpt;\n    rs.tgtManEndpt = tgtManEndpt;\n    var p1; // last known point of edge on target side\n    var p2; // last known point of edge on source side\n    var p1_i; // point to intersect with target shape\n    var p2_i; // point to intersect with source shape\n    var tgtManEndptPt = (_ref = (tgtManEndpt === null || tgtManEndpt === undefined || (_tgtManEndpt$pfValue = tgtManEndpt.pfValue) === null || _tgtManEndpt$pfValue === undefined ? undefined : _tgtManEndpt$pfValue.length) === 2 ? tgtManEndpt.pfValue : null) !== null && _ref !== undefined ? _ref : [\n        0,\n        0\n    ];\n    var srcManEndptPt = (_ref2 = (srcManEndpt === null || srcManEndpt === undefined || (_srcManEndpt$pfValue = srcManEndpt.pfValue) === null || _srcManEndpt$pfValue === undefined ? undefined : _srcManEndpt$pfValue.length) === 2 ? srcManEndpt.pfValue : null) !== null && _ref2 !== undefined ? _ref2 : [\n        0,\n        0\n    ];\n    if (bezier) {\n        var cpStart = [\n            rs.ctrlpts[0],\n            rs.ctrlpts[1]\n        ];\n        var cpEnd = multi ? [\n            rs.ctrlpts[rs.ctrlpts.length - 2],\n            rs.ctrlpts[rs.ctrlpts.length - 1]\n        ] : cpStart;\n        p1 = cpEnd;\n        p2 = cpStart;\n    } else if (lines) {\n        var srcArrowFromPt = !segments ? [\n            tgtPos.x + tgtManEndptPt[0],\n            tgtPos.y + tgtManEndptPt[1]\n        ] : rs.segpts.slice(0, 2);\n        var tgtArrowFromPt = !segments ? [\n            srcPos.x + srcManEndptPt[0],\n            srcPos.y + srcManEndptPt[1]\n        ] : rs.segpts.slice(rs.segpts.length - 2);\n        p1 = tgtArrowFromPt;\n        p2 = srcArrowFromPt;\n    }\n    if (tgtManEndptVal === 'inside-to-node') {\n        intersect = [\n            tgtPos.x,\n            tgtPos.y\n        ];\n    } else if (tgtManEndpt.units) {\n        intersect = this.manualEndptToPx(target, tgtManEndpt);\n    } else if (tgtManEndptVal === 'outside-to-line') {\n        intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n    } else {\n        if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {\n            p1_i = p1;\n        } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {\n            p1_i = [\n                srcPos.x,\n                srcPos.y\n            ];\n        }\n        intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0, tgtCornerRadius, tgtRs);\n        if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {\n            var trs = target._private.rscratch;\n            var lw = trs.labelWidth;\n            var lh = trs.labelHeight;\n            var lx = trs.labelX;\n            var ly = trs.labelY;\n            var lw2 = lw / 2;\n            var lh2 = lh / 2;\n            var va = target.pstyle('text-valign').value;\n            if (va === 'top') {\n                ly -= lh2;\n            } else if (va === 'bottom') {\n                ly += lh2;\n            }\n            var ha = target.pstyle('text-halign').value;\n            if (ha === 'left') {\n                lx -= lw2;\n            } else if (ha === 'right') {\n                lx += lw2;\n            }\n            var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [\n                lx - lw2,\n                ly - lh2,\n                lx + lw2,\n                ly - lh2,\n                lx + lw2,\n                ly + lh2,\n                lx - lw2,\n                ly + lh2\n            ], tgtPos.x, tgtPos.y);\n            if (labelIntersect.length > 0) {\n                var refPt = srcPos;\n                var intSqdist = sqdist(refPt, array2point(intersect));\n                var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n                var minSqDist = intSqdist;\n                if (labIntSqdist < intSqdist) {\n                    intersect = labelIntersect;\n                    minSqDist = labIntSqdist;\n                }\n                if (labelIntersect.length > 2) {\n                    var labInt2SqDist = sqdist(refPt, {\n                        x: labelIntersect[2],\n                        y: labelIntersect[3]\n                    });\n                    if (labInt2SqDist < minSqDist) {\n                        intersect = [\n                            labelIntersect[2],\n                            labelIntersect[3]\n                        ];\n                    }\n                }\n            }\n        }\n    }\n    var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n    var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n    rs.endX = edgeEnd[0];\n    rs.endY = edgeEnd[1];\n    rs.arrowEndX = arrowEnd[0];\n    rs.arrowEndY = arrowEnd[1];\n    if (srcManEndptVal === 'inside-to-node') {\n        intersect = [\n            srcPos.x,\n            srcPos.y\n        ];\n    } else if (srcManEndpt.units) {\n        intersect = this.manualEndptToPx(source, srcManEndpt);\n    } else if (srcManEndptVal === 'outside-to-line') {\n        intersect = rs.srcIntn; // use cached value from ctrlpt calc\n    } else {\n        if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {\n            p2_i = p2;\n        } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {\n            p2_i = [\n                tgtPos.x,\n                tgtPos.y\n            ];\n        }\n        intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0, srcCornerRadius, srcRs);\n        if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {\n            var srs = source._private.rscratch;\n            var _lw = srs.labelWidth;\n            var _lh = srs.labelHeight;\n            var _lx = srs.labelX;\n            var _ly = srs.labelY;\n            var _lw2 = _lw / 2;\n            var _lh2 = _lh / 2;\n            var _va = source.pstyle('text-valign').value;\n            if (_va === 'top') {\n                _ly -= _lh2;\n            } else if (_va === 'bottom') {\n                _ly += _lh2;\n            }\n            var _ha = source.pstyle('text-halign').value;\n            if (_ha === 'left') {\n                _lx -= _lw2;\n            } else if (_ha === 'right') {\n                _lx += _lw2;\n            }\n            var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [\n                _lx - _lw2,\n                _ly - _lh2,\n                _lx + _lw2,\n                _ly - _lh2,\n                _lx + _lw2,\n                _ly + _lh2,\n                _lx - _lw2,\n                _ly + _lh2\n            ], srcPos.x, srcPos.y);\n            if (_labelIntersect.length > 0) {\n                var _refPt = tgtPos;\n                var _intSqdist = sqdist(_refPt, array2point(intersect));\n                var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n                var _minSqDist = _intSqdist;\n                if (_labIntSqdist < _intSqdist) {\n                    intersect = [\n                        _labelIntersect[0],\n                        _labelIntersect[1]\n                    ];\n                    _minSqDist = _labIntSqdist;\n                }\n                if (_labelIntersect.length > 2) {\n                    var _labInt2SqDist = sqdist(_refPt, {\n                        x: _labelIntersect[2],\n                        y: _labelIntersect[3]\n                    });\n                    if (_labInt2SqDist < _minSqDist) {\n                        intersect = [\n                            _labelIntersect[2],\n                            _labelIntersect[3]\n                        ];\n                    }\n                }\n            }\n        }\n    }\n    var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n    var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n    rs.startX = edgeStart[0];\n    rs.startY = edgeStart[1];\n    rs.arrowStartX = arrowStart[0];\n    rs.arrowStartY = arrowStart[1];\n    if (hasEndpts) {\n        if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n            rs.badLine = true;\n        } else {\n            rs.badLine = false;\n        }\n    }\n};\nBRp$b.getSourceEndpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    switch(rs.edgeType){\n        case 'haystack':\n            return {\n                x: rs.haystackPts[0],\n                y: rs.haystackPts[1]\n            };\n        default:\n            return {\n                x: rs.arrowStartX,\n                y: rs.arrowStartY\n            };\n    }\n};\nBRp$b.getTargetEndpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    switch(rs.edgeType){\n        case 'haystack':\n            return {\n                x: rs.haystackPts[2],\n                y: rs.haystackPts[3]\n            };\n        default:\n            return {\n                x: rs.arrowEndX,\n                y: rs.arrowEndY\n            };\n    }\n};\nvar BRp$a = {};\nfunction pushBezierPts(r, edge, pts) {\n    var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n        return qbezierAt(p1, p2, p3, t);\n    };\n    var _p = edge._private;\n    var bpts = _p.rstyle.bezierPts;\n    for(var i = 0; i < r.bezierProjPcts.length; i++){\n        var p = r.bezierProjPcts[i];\n        bpts.push({\n            x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n            y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n        });\n    }\n}\nBRp$a.storeEdgeProjections = function(edge) {\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var et = rs.edgeType;\n    // clear the cached points state\n    _p.rstyle.bezierPts = null;\n    _p.rstyle.linePts = null;\n    _p.rstyle.haystackPts = null;\n    if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n        _p.rstyle.bezierPts = [];\n        for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n            pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n        }\n    } else if (et === 'segments') {\n        var lpts = _p.rstyle.linePts = [];\n        for(var i = 0; i + 1 < rs.allpts.length; i += 2){\n            lpts.push({\n                x: rs.allpts[i],\n                y: rs.allpts[i + 1]\n            });\n        }\n    } else if (et === 'haystack') {\n        var hpts = rs.haystackPts;\n        _p.rstyle.haystackPts = [\n            {\n                x: hpts[0],\n                y: hpts[1]\n            },\n            {\n                x: hpts[2],\n                y: hpts[3]\n            }\n        ];\n    }\n    _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n};\nBRp$a.recalculateEdgeProjections = function(edges) {\n    this.findEdgeControlPoints(edges);\n};\nvar BRp$9 = {};\nBRp$9.recalculateNodeLabelProjection = function(node) {\n    var content = node.pstyle('label').strValue;\n    if (emptyString(content)) {\n        return;\n    }\n    var textX, textY;\n    var _p = node._private;\n    var nodeWidth = node.width();\n    var nodeHeight = node.height();\n    var padding = node.padding();\n    var nodePos = node.position();\n    var textHalign = node.pstyle('text-halign').strValue;\n    var textValign = node.pstyle('text-valign').strValue;\n    var rs = _p.rscratch;\n    var rstyle = _p.rstyle;\n    switch(textHalign){\n        case 'left':\n            textX = nodePos.x - nodeWidth / 2 - padding;\n            break;\n        case 'right':\n            textX = nodePos.x + nodeWidth / 2 + padding;\n            break;\n        default:\n            // e.g. center\n            textX = nodePos.x;\n    }\n    switch(textValign){\n        case 'top':\n            textY = nodePos.y - nodeHeight / 2 - padding;\n            break;\n        case 'bottom':\n            textY = nodePos.y + nodeHeight / 2 + padding;\n            break;\n        default:\n            // e.g. middle\n            textY = nodePos.y;\n    }\n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n    this.calculateLabelAngles(node);\n    this.applyLabelDimensions(node);\n};\nvar lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n    var angle = Math.atan(dy / dx);\n    if (dx === 0 && angle < 0) {\n        angle = angle * -1;\n    }\n    return angle;\n};\nvar lineAngle = function lineAngle(p0, p1) {\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return lineAngleFromDelta(dx, dy);\n};\nvar bezierAngle = function bezierAngle(p0, p1, p2, t) {\n    var t0 = bound(0, t - 0.001, 1);\n    var t1 = bound(0, t + 0.001, 1);\n    var lp0 = qbezierPtAt(p0, p1, p2, t0);\n    var lp1 = qbezierPtAt(p0, p1, p2, t1);\n    return lineAngle(lp0, lp1);\n};\nBRp$9.recalculateEdgeLabelProjections = function(edge) {\n    var p;\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var r = this;\n    var content = {\n        mid: edge.pstyle('label').strValue,\n        source: edge.pstyle('source-label').strValue,\n        target: edge.pstyle('target-label').strValue\n    };\n    if (content.mid || content.source || content.target) ;\n    else {\n        return; // no labels => no calcs\n    }\n    // add center point to style so bounding box calculations can use it\n    //\n    p = {\n        x: rs.midX,\n        y: rs.midY\n    };\n    var setRs = function setRs(propName, prefix, value) {\n        setPrefixedProperty(_p.rscratch, propName, prefix, value);\n        setPrefixedProperty(_p.rstyle, propName, prefix, value);\n    };\n    setRs('labelX', null, p.x);\n    setRs('labelY', null, p.y);\n    var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n    setRs('labelAutoAngle', null, midAngle);\n    var _createControlPointInfo = function createControlPointInfo() {\n        if (_createControlPointInfo.cache) {\n            return _createControlPointInfo.cache;\n        } // use cache so only 1x per edge\n        var ctrlpts = [];\n        // store each ctrlpt info init\n        for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n            var p0 = {\n                x: rs.allpts[i],\n                y: rs.allpts[i + 1]\n            };\n            var p1 = {\n                x: rs.allpts[i + 2],\n                y: rs.allpts[i + 3]\n            }; // ctrlpt\n            var p2 = {\n                x: rs.allpts[i + 4],\n                y: rs.allpts[i + 5]\n            };\n            ctrlpts.push({\n                p0: p0,\n                p1: p1,\n                p2: p2,\n                startDist: 0,\n                length: 0,\n                segments: []\n            });\n        }\n        var bpts = _p.rstyle.bezierPts;\n        var nProjs = r.bezierProjPcts.length;\n        function addSegment(cp, p0, p1, t0, t1) {\n            var length = dist(p0, p1);\n            var prevSegment = cp.segments[cp.segments.length - 1];\n            var segment = {\n                p0: p0,\n                p1: p1,\n                t0: t0,\n                t1: t1,\n                startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n                length: length\n            };\n            cp.segments.push(segment);\n            cp.length += length;\n        }\n        // update each ctrlpt with segment info\n        for(var _i = 0; _i < ctrlpts.length; _i++){\n            var cp = ctrlpts[_i];\n            var prevCp = ctrlpts[_i - 1];\n            if (prevCp) {\n                cp.startDist = prevCp.startDist + prevCp.length;\n            }\n            addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n            for(var j = 0; j < nProjs - 1; j++){\n                addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n            }\n            addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n        }\n        return _createControlPointInfo.cache = ctrlpts;\n    };\n    var calculateEndProjection = function calculateEndProjection(prefix) {\n        var angle;\n        var isSrc = prefix === 'source';\n        if (!content[prefix]) {\n            return;\n        }\n        var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n        switch(rs.edgeType){\n            case 'self':\n            case 'compound':\n            case 'bezier':\n            case 'multibezier':\n                {\n                    var cps = _createControlPointInfo();\n                    var selected;\n                    var startDist = 0;\n                    var totalDist = 0;\n                    // find the segment we're on\n                    for(var i = 0; i < cps.length; i++){\n                        var _cp = cps[isSrc ? i : cps.length - 1 - i];\n                        for(var j = 0; j < _cp.segments.length; j++){\n                            var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n                            var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n                            startDist = totalDist;\n                            totalDist += _seg.length;\n                            if (totalDist >= offset || lastSeg) {\n                                selected = {\n                                    cp: _cp,\n                                    segment: _seg\n                                };\n                                break;\n                            }\n                        }\n                        if (selected) {\n                            break;\n                        }\n                    }\n                    var cp = selected.cp;\n                    var seg = selected.segment;\n                    var tSegment = (offset - startDist) / seg.length;\n                    var segDt = seg.t1 - seg.t0;\n                    var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n                    t = bound(0, t, 1);\n                    p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n                    angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n                    break;\n                }\n            case 'straight':\n            case 'segments':\n            case 'haystack':\n                {\n                    var d = 0, di, d0;\n                    var p0, p1;\n                    var l = rs.allpts.length;\n                    for(var _i2 = 0; _i2 + 3 < l; _i2 += 2){\n                        if (isSrc) {\n                            p0 = {\n                                x: rs.allpts[_i2],\n                                y: rs.allpts[_i2 + 1]\n                            };\n                            p1 = {\n                                x: rs.allpts[_i2 + 2],\n                                y: rs.allpts[_i2 + 3]\n                            };\n                        } else {\n                            p0 = {\n                                x: rs.allpts[l - 2 - _i2],\n                                y: rs.allpts[l - 1 - _i2]\n                            };\n                            p1 = {\n                                x: rs.allpts[l - 4 - _i2],\n                                y: rs.allpts[l - 3 - _i2]\n                            };\n                        }\n                        di = dist(p0, p1);\n                        d0 = d;\n                        d += di;\n                        if (d >= offset) {\n                            break;\n                        }\n                    }\n                    var pD = offset - d0;\n                    var _t = pD / di;\n                    _t = bound(0, _t, 1);\n                    p = lineAt(p0, p1, _t);\n                    angle = lineAngle(p0, p1);\n                    break;\n                }\n        }\n        setRs('labelX', prefix, p.x);\n        setRs('labelY', prefix, p.y);\n        setRs('labelAutoAngle', prefix, angle);\n    };\n    calculateEndProjection('source');\n    calculateEndProjection('target');\n    this.applyLabelDimensions(edge);\n};\nBRp$9.applyLabelDimensions = function(ele) {\n    this.applyPrefixedLabelDimensions(ele);\n    if (ele.isEdge()) {\n        this.applyPrefixedLabelDimensions(ele, 'source');\n        this.applyPrefixedLabelDimensions(ele, 'target');\n    }\n};\nBRp$9.applyPrefixedLabelDimensions = function(ele, prefix) {\n    var _p = ele._private;\n    var text = this.getLabelText(ele, prefix);\n    var cacheKey = hashString(text, ele._private.labelDimsKey);\n    // save recalc if the label is the same as before\n    if (getPrefixedProperty(_p.rscratch, 'prefixedLabelDimsKey', prefix) === cacheKey) {\n        return; // then the label dimensions + text are the same\n    }\n    // save the key\n    setPrefixedProperty(_p.rscratch, 'prefixedLabelDimsKey', prefix, cacheKey);\n    var labelDims = this.calculateLabelDimensions(ele, text);\n    var lineHeight = ele.pstyle('line-height').pfValue;\n    var textWrap = ele.pstyle('text-wrap').strValue;\n    var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];\n    var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);\n    var normPerLineHeight = labelDims.height / numLines;\n    var labelLineHeight = normPerLineHeight * lineHeight;\n    var width = labelDims.width;\n    var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n    setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);\n};\nBRp$9.getLabelText = function(ele, prefix) {\n    var _p = ele._private;\n    var pfd = prefix ? prefix + '-' : '';\n    var text = ele.pstyle(pfd + 'label').strValue;\n    var textTransform = ele.pstyle('text-transform').value;\n    var rscratch = function rscratch(propName, value) {\n        if (value) {\n            setPrefixedProperty(_p.rscratch, propName, prefix, value);\n            return value;\n        } else {\n            return getPrefixedProperty(_p.rscratch, propName, prefix);\n        }\n    };\n    // for empty text, skip all processing\n    if (!text) {\n        return '';\n    }\n    if (textTransform == 'none') ;\n    else if (textTransform == 'uppercase') {\n        text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n        text = text.toLowerCase();\n    }\n    var wrapStyle = ele.pstyle('text-wrap').value;\n    if (wrapStyle === 'wrap') {\n        var labelKey = rscratch('labelKey');\n        // save recalc if the label is the same as before\n        if (labelKey != null && rscratch('labelWrapKey') === labelKey) {\n            return rscratch('labelWrapCachedText');\n        }\n        var zwsp = \"\\u200B\";\n        var lines = text.split('\\n');\n        var maxW = ele.pstyle('text-max-width').pfValue;\n        var overflow = ele.pstyle('text-overflow-wrap').value;\n        var overflowAny = overflow === 'anywhere';\n        var wrappedLines = [];\n        var separatorRegex = /[\\s\\u200b]+|$/g; // Include end of string to add last word\n        for(var l = 0; l < lines.length; l++){\n            var line = lines[l];\n            var lineDims = this.calculateLabelDimensions(ele, line);\n            var lineW = lineDims.width;\n            if (overflowAny) {\n                var processedLine = line.split('').join(zwsp);\n                line = processedLine;\n            }\n            if (lineW > maxW) {\n                // line is too long\n                var separatorMatches = line.matchAll(separatorRegex);\n                var subline = '';\n                var previousIndex = 0;\n                // Add fake match\n                var _iterator = _createForOfIteratorHelper(separatorMatches), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var separatorMatch = _step.value;\n                        var wordSeparator = separatorMatch[0];\n                        var word = line.substring(previousIndex, separatorMatch.index);\n                        previousIndex = separatorMatch.index + wordSeparator.length;\n                        var testLine = subline.length === 0 ? word : subline + word + wordSeparator;\n                        var testDims = this.calculateLabelDimensions(ele, testLine);\n                        var testW = testDims.width;\n                        if (testW <= maxW) {\n                            // word fits on current line\n                            subline += word + wordSeparator;\n                        } else {\n                            // word starts new line\n                            if (subline) {\n                                wrappedLines.push(subline);\n                            }\n                            subline = word + wordSeparator;\n                        }\n                    }\n                // if there's remaining text, put it in a wrapped line\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                if (!subline.match(/^[\\s\\u200b]+$/)) {\n                    wrappedLines.push(subline);\n                }\n            } else {\n                // line is already short enough\n                wrappedLines.push(line);\n            }\n        } // for\n        rscratch('labelWrapCachedLines', wrappedLines);\n        text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n        rscratch('labelWrapKey', labelKey);\n    } else if (wrapStyle === 'ellipsis') {\n        var _maxW = ele.pstyle('text-max-width').pfValue;\n        var ellipsized = '';\n        var ellipsis = \"\\u2026\";\n        var incLastCh = false;\n        if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n            // the label already fits\n            return text;\n        }\n        for(var i = 0; i < text.length; i++){\n            var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n            if (widthWithNextCh > _maxW) {\n                break;\n            }\n            ellipsized += text[i];\n            if (i === text.length - 1) {\n                incLastCh = true;\n            }\n        }\n        if (!incLastCh) {\n            ellipsized += ellipsis;\n        }\n        return ellipsized;\n    } // if ellipsize\n    return text;\n};\nBRp$9.getLabelJustification = function(ele) {\n    var justification = ele.pstyle('text-justification').strValue;\n    var textHalign = ele.pstyle('text-halign').strValue;\n    if (justification === 'auto') {\n        if (ele.isNode()) {\n            switch(textHalign){\n                case 'left':\n                    return 'right';\n                case 'right':\n                    return 'left';\n                default:\n                    return 'center';\n            }\n        } else {\n            return 'center';\n        }\n    } else {\n        return justification;\n    }\n};\nBRp$9.calculateLabelDimensions = function(ele, text) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var document1 = containerWindow.document;\n    var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n    var fStyle = ele.pstyle('font-style').strValue;\n    var size = ele.pstyle('font-size').pfValue;\n    var family = ele.pstyle('font-family').strValue;\n    var weight = ele.pstyle('font-weight').strValue;\n    var canvas = this.labelCalcCanvas;\n    var c2d = this.labelCalcCanvasContext;\n    if (!canvas) {\n        canvas = this.labelCalcCanvas = document1.createElement('canvas');\n        c2d = this.labelCalcCanvasContext = canvas.getContext('2d');\n        var ds = canvas.style;\n        ds.position = 'absolute';\n        ds.left = '-9999px';\n        ds.top = '-9999px';\n        ds.zIndex = '-1';\n        ds.visibility = 'hidden';\n        ds.pointerEvents = 'none';\n    }\n    c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n    var width = 0;\n    var height = 0;\n    var lines = text.split('\\n');\n    for(var i = 0; i < lines.length; i++){\n        var line = lines[i];\n        var metrics = c2d.measureText(line);\n        var w = Math.ceil(metrics.width);\n        var h = size;\n        width = Math.max(w, width);\n        height += h;\n    }\n    width += padding;\n    height += padding;\n    return {\n        width: width,\n        height: height\n    };\n};\nBRp$9.calculateLabelAngle = function(ele, prefix) {\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    var isEdge = ele.isEdge();\n    var prefixDash = prefix ? prefix + '-' : '';\n    var rot = ele.pstyle(prefixDash + 'text-rotation');\n    var rotStr = rot.strValue;\n    if (rotStr === 'none') {\n        return 0;\n    } else if (isEdge && rotStr === 'autorotate') {\n        return rs.labelAutoAngle;\n    } else if (rotStr === 'autorotate') {\n        return 0;\n    } else {\n        return rot.pfValue;\n    }\n};\nBRp$9.calculateLabelAngles = function(ele) {\n    var r = this;\n    var isEdge = ele.isEdge();\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    rs.labelAngle = r.calculateLabelAngle(ele);\n    if (isEdge) {\n        rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');\n        rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');\n    }\n};\nvar BRp$8 = {};\nvar TOO_SMALL_CUT_RECT = 28;\nvar warnedCutRect = false;\nBRp$8.getNodeShape = function(node) {\n    var r = this;\n    var shape = node.pstyle('shape').value;\n    if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n        if (!warnedCutRect) {\n            warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');\n            warnedCutRect = true;\n        }\n        return 'rectangle';\n    }\n    if (node.isParent()) {\n        if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {\n            return shape;\n        } else {\n            return 'rectangle';\n        }\n    }\n    if (shape === 'polygon') {\n        var points = node.pstyle('shape-polygon-points').value;\n        return r.nodeShapes.makePolygon(points).name;\n    }\n    return shape;\n};\nvar BRp$7 = {};\nBRp$7.registerCalculationListeners = function() {\n    var cy = this.cy;\n    var elesToUpdate = cy.collection();\n    var r = this;\n    var enqueue = function enqueue(eles) {\n        var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        elesToUpdate.merge(eles);\n        if (dirtyStyleCaches) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var _p = ele._private;\n                var rstyle = _p.rstyle;\n                rstyle.clean = false;\n                rstyle.cleanConnected = false;\n            }\n        }\n    };\n    r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {\n        var ele = e.target;\n        enqueue(ele);\n    }).on('style.* background.*', function onDirtyStyle(e) {\n        var ele = e.target;\n        enqueue(ele, false);\n    });\n    var updateEleCalcs = function updateEleCalcs(willDraw) {\n        if (willDraw) {\n            var fns = r.onUpdateEleCalcsFns;\n            // because we need to have up-to-date style (e.g. stylesheet mappers)\n            // before calculating rendered style (and pstyle might not be called yet)\n            elesToUpdate.cleanStyle();\n            for(var i = 0; i < elesToUpdate.length; i++){\n                var ele = elesToUpdate[i];\n                var rstyle = ele._private.rstyle;\n                if (ele.isNode() && !rstyle.cleanConnected) {\n                    enqueue(ele.connectedEdges());\n                    rstyle.cleanConnected = true;\n                }\n            }\n            if (fns) {\n                for(var _i = 0; _i < fns.length; _i++){\n                    var fn = fns[_i];\n                    fn(willDraw, elesToUpdate);\n                }\n            }\n            r.recalculateRenderedStyle(elesToUpdate);\n            elesToUpdate = cy.collection();\n        }\n    };\n    r.flushRenderedStyleQueue = function() {\n        updateEleCalcs(true);\n    };\n    r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n};\nBRp$7.onUpdateEleCalcs = function(fn) {\n    var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n    fns.push(fn);\n};\nBRp$7.recalculateRenderedStyle = function(eles, useCache) {\n    var isCleanConnected = function isCleanConnected(ele) {\n        return ele._private.rstyle.cleanConnected;\n    };\n    if (eles.length === 0) {\n        return;\n    }\n    var edges = [];\n    var nodes = [];\n    // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n    if (this.destroyed) {\n        return;\n    }\n    // use cache by default for perf\n    if (useCache === undefined) {\n        useCache = true;\n    }\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n        // an edge may be implicitly dirty b/c of one of its connected nodes\n        // (and a request for recalc may come in between frames)\n        if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n            rstyle.clean = false;\n        }\n        if (ele.isEdge() && ele.isBundledBezier()) {\n            if (ele.parallelEdges().some(function(ele) {\n                return !ele._private.rstyle.clean && ele.isBundledBezier();\n            })) {\n                rstyle.clean = false;\n            }\n        }\n        // only update if dirty and in graph\n        if (useCache && rstyle.clean || ele.removed()) {\n            continue;\n        }\n        // only update if not display: none\n        if (ele.pstyle('display').value === 'none') {\n            continue;\n        }\n        if (_p.group === 'nodes') {\n            nodes.push(ele);\n        } else {\n            // edges\n            edges.push(ele);\n        }\n        rstyle.clean = true;\n    }\n    // update node data from projections\n    for(var _i2 = 0; _i2 < nodes.length; _i2++){\n        var _ele = nodes[_i2];\n        var _p2 = _ele._private;\n        var _rstyle = _p2.rstyle;\n        var pos = _ele.position();\n        this.recalculateNodeLabelProjection(_ele);\n        _rstyle.nodeX = pos.x;\n        _rstyle.nodeY = pos.y;\n        _rstyle.nodeW = _ele.pstyle('width').pfValue;\n        _rstyle.nodeH = _ele.pstyle('height').pfValue;\n    }\n    this.recalculateEdgeProjections(edges);\n    // update edge data from projections\n    for(var _i3 = 0; _i3 < edges.length; _i3++){\n        var _ele2 = edges[_i3];\n        var _p3 = _ele2._private;\n        var _rstyle2 = _p3.rstyle;\n        var rs = _p3.rscratch;\n        // update rstyle positions\n        _rstyle2.srcX = rs.arrowStartX;\n        _rstyle2.srcY = rs.arrowStartY;\n        _rstyle2.tgtX = rs.arrowEndX;\n        _rstyle2.tgtY = rs.arrowEndY;\n        _rstyle2.midX = rs.midX;\n        _rstyle2.midY = rs.midY;\n        _rstyle2.labelAngle = rs.labelAngle;\n        _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n        _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n    }\n};\nvar BRp$6 = {};\nBRp$6.updateCachedGrabbedEles = function() {\n    var eles = this.cachedZSortedEles;\n    if (!eles) {\n        // just let this be recalculated on the next z sort tick\n        return;\n    }\n    eles.drag = [];\n    eles.nondrag = [];\n    var grabTargets = [];\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var rs = ele._private.rscratch;\n        if (ele.grabbed() && !ele.isParent()) {\n            grabTargets.push(ele);\n        } else if (rs.inDragLayer) {\n            eles.drag.push(ele);\n        } else {\n            eles.nondrag.push(ele);\n        }\n    }\n    // put the grab target nodes last so it's on top of its neighbourhood\n    for(var i = 0; i < grabTargets.length; i++){\n        var ele = grabTargets[i];\n        eles.drag.push(ele);\n    }\n};\nBRp$6.invalidateCachedZSortedEles = function() {\n    this.cachedZSortedEles = null;\n};\nBRp$6.getCachedZSortedEles = function(forceRecalc) {\n    if (forceRecalc || !this.cachedZSortedEles) {\n        var eles = this.cy.mutableElements().toArray();\n        eles.sort(zIndexSort);\n        eles.interactive = eles.filter(function(ele) {\n            return ele.interactive();\n        });\n        this.cachedZSortedEles = eles;\n        this.updateCachedGrabbedEles();\n    } else {\n        eles = this.cachedZSortedEles;\n    }\n    return eles;\n};\nvar BRp$5 = {};\n[\n    BRp$e,\n    BRp$d,\n    BRp$c,\n    BRp$b,\n    BRp$a,\n    BRp$9,\n    BRp$8,\n    BRp$7,\n    BRp$6\n].forEach(function(props) {\n    extend(BRp$5, props);\n});\nvar BRp$4 = {};\nBRp$4.getCachedImage = function(url, crossOrigin, onLoad) {\n    var r = this;\n    var imageCache = r.imageCache = r.imageCache || {};\n    var cache = imageCache[url];\n    if (cache) {\n        if (!cache.image.complete) {\n            cache.image.addEventListener('load', onLoad);\n        }\n        return cache.image;\n    } else {\n        cache = imageCache[url] = imageCache[url] || {};\n        var image = cache.image = new Image(); // eslint-disable-line no-undef\n        image.addEventListener('load', onLoad);\n        image.addEventListener('error', function() {\n            image.error = true;\n        });\n        // #1582 safari doesn't load data uris with crossOrigin properly\n        // https://bugs.webkit.org/show_bug.cgi?id=123978\n        var dataUriPrefix = 'data:';\n        var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n        if (!isDataUri) {\n            // if crossorigin is 'null'(stringified), then manually set it to null \n            crossOrigin = crossOrigin === 'null' ? null : crossOrigin;\n            image.crossOrigin = crossOrigin; // prevent tainted canvas\n        }\n        image.src = url;\n        return image;\n    }\n};\nvar BRp$3 = {};\n/* global document, ResizeObserver, MutationObserver */ BRp$3.registerBinding = function(target, event, handler, useCapture) {\n    // eslint-disable-line no-unused-vars\n    var args = Array.prototype.slice.apply(arguments, [\n        1\n    ]); // copy\n    if (Array.isArray(target)) {\n        var res = [];\n        for(var i = 0; i < target.length; i++){\n            var t = target[i];\n            if (t !== undefined) {\n                var b = this.binder(t);\n                res.push(b.on.apply(b, args));\n            }\n        }\n        return res;\n    }\n    var b = this.binder(target);\n    return b.on.apply(b, args);\n};\nBRp$3.binder = function(tgt) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var tgtIsDom = tgt === containerWindow || tgt === containerWindow.document || tgt === containerWindow.document.body || domElement(tgt);\n    if (r.supportsPassiveEvents == null) {\n        // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n        var supportsPassive = false;\n        try {\n            var opts = Object.defineProperty({}, 'passive', {\n                get: function get() {\n                    supportsPassive = true;\n                    return true;\n                }\n            });\n            containerWindow.addEventListener('test', null, opts);\n        } catch (err) {\n        // not supported\n        }\n        r.supportsPassiveEvents = supportsPassive;\n    }\n    var on = function on(event, handler, useCapture) {\n        var args = Array.prototype.slice.call(arguments);\n        if (tgtIsDom && r.supportsPassiveEvents) {\n            // replace useCapture w/ opts obj\n            args[2] = {\n                capture: useCapture != null ? useCapture : false,\n                passive: false,\n                once: false\n            };\n        }\n        r.bindings.push({\n            target: tgt,\n            args: args\n        });\n        (tgt.addEventListener || tgt.on).apply(tgt, args);\n        return this;\n    };\n    return {\n        on: on,\n        addEventListener: on,\n        addListener: on,\n        bind: on\n    };\n};\nBRp$3.nodeIsDraggable = function(node) {\n    return node && node.isNode() && !node.locked() && node.grabbable();\n};\nBRp$3.nodeIsGrabbable = function(node) {\n    return this.nodeIsDraggable(node) && node.interactive();\n};\nBRp$3.load = function() {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var isSelected = function isSelected(ele) {\n        return ele.selected();\n    };\n    var getShadowRoot = function getShadowRoot(element) {\n        var rootNode = element.getRootNode();\n        // Check if the root node is a shadow root\n        if (rootNode && rootNode.nodeType === 11 && rootNode.host !== undefined) {\n            return rootNode;\n        }\n    };\n    var triggerEvents = function triggerEvents(target, names, e, position) {\n        if (target == null) {\n            target = r.cy;\n        }\n        for(var i = 0; i < names.length; i++){\n            var name = names[i];\n            target.emit({\n                originalEvent: e,\n                type: name,\n                position: position\n            });\n        }\n    };\n    var isMultSelKeyDown = function isMultSelKeyDown(e) {\n        return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n    };\n    var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n        var allowPassthrough = true;\n        if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n            // a grabbable compound node below the ele => no passthrough panning\n            for(var i = 0; downs && i < downs.length; i++){\n                var down = downs[i];\n                //if any parent node in event hierarchy isn't pannable, reject passthrough\n                if (down.isNode() && down.isParent() && !down.pannable()) {\n                    allowPassthrough = false;\n                    break;\n                }\n            }\n        } else {\n            allowPassthrough = true;\n        }\n        return allowPassthrough;\n    };\n    var setGrabbed = function setGrabbed(ele) {\n        ele[0]._private.grabbed = true;\n    };\n    var setFreed = function setFreed(ele) {\n        ele[0]._private.grabbed = false;\n    };\n    var setInDragLayer = function setInDragLayer(ele) {\n        ele[0]._private.rscratch.inDragLayer = true;\n    };\n    var setOutDragLayer = function setOutDragLayer(ele) {\n        ele[0]._private.rscratch.inDragLayer = false;\n    };\n    var setGrabTarget = function setGrabTarget(ele) {\n        ele[0]._private.rscratch.isGrabTarget = true;\n    };\n    var removeGrabTarget = function removeGrabTarget(ele) {\n        ele[0]._private.rscratch.isGrabTarget = false;\n    };\n    var addToDragList = function addToDragList(ele, opts) {\n        var list = opts.addToList;\n        var listHasEle = list.has(ele);\n        if (!listHasEle && ele.grabbable() && !ele.locked()) {\n            list.merge(ele);\n            setGrabbed(ele);\n        }\n    };\n    // helper function to determine which child nodes and inner edges\n    // of a compound node to be dragged as well as the grabbed and selected nodes\n    var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n        if (!node.cy().hasCompoundNodes()) {\n            return;\n        }\n        if (opts.inDragLayer == null && opts.addToList == null) {\n            return;\n        } // nothing to do\n        var innerNodes = node.descendants();\n        if (opts.inDragLayer) {\n            innerNodes.forEach(setInDragLayer);\n            innerNodes.connectedEdges().forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            addToDragList(innerNodes, opts);\n        }\n    };\n    // adds the given nodes and its neighbourhood to the drag layer\n    var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n        opts = opts || {};\n        var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n        if (opts.inDragLayer) {\n            nodes.forEach(setInDragLayer);\n            nodes.neighborhood().stdFilter(function(ele) {\n                return !hasCompoundNodes || ele.isEdge();\n            }).forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            nodes.forEach(function(ele) {\n                addToDragList(ele, opts);\n            });\n        }\n        addDescendantsToDrag(nodes, opts); // always add to drag\n        // also add nodes and edges related to the topmost ancestor\n        updateAncestorsInDragLayer(nodes, {\n            inDragLayer: opts.inDragLayer\n        });\n        r.updateCachedGrabbedEles();\n    };\n    var addNodeToDrag = addNodesToDrag;\n    var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n        if (!grabbedEles) {\n            return;\n        }\n        // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n        r.getCachedZSortedEles().forEach(function(ele) {\n            setFreed(ele);\n            setOutDragLayer(ele);\n            removeGrabTarget(ele);\n        });\n        r.updateCachedGrabbedEles();\n    };\n    // helper function to determine which ancestor nodes and edges should go\n    // to the drag layer (or should be removed from drag layer).\n    var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n        if (opts.inDragLayer == null && opts.addToList == null) {\n            return;\n        } // nothing to do\n        if (!node.cy().hasCompoundNodes()) {\n            return;\n        }\n        // find top-level parent\n        var parent = node.ancestors().orphans();\n        // no parent node: no nodes to add to the drag layer\n        if (parent.same(node)) {\n            return;\n        }\n        var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n        var edges = nodes.connectedEdges();\n        if (opts.inDragLayer) {\n            edges.forEach(setInDragLayer);\n            nodes.forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            nodes.forEach(function(ele) {\n                addToDragList(ele, opts);\n            });\n        }\n    };\n    var blurActiveDomElement = function blurActiveDomElement() {\n        if (document.activeElement != null && document.activeElement.blur != null) {\n            document.activeElement.blur();\n        }\n    };\n    var haveMutationsApi = typeof MutationObserver !== 'undefined';\n    var haveResizeObserverApi = typeof ResizeObserver !== 'undefined';\n    // watch for when the cy container is removed from the dom\n    if (haveMutationsApi) {\n        r.removeObserver = new MutationObserver(function(mutns) {\n            // eslint-disable-line no-undef\n            for(var i = 0; i < mutns.length; i++){\n                var mutn = mutns[i];\n                var rNodes = mutn.removedNodes;\n                if (rNodes) {\n                    for(var j = 0; j < rNodes.length; j++){\n                        var rNode = rNodes[j];\n                        if (rNode === r.container) {\n                            r.destroy();\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        if (r.container.parentNode) {\n            r.removeObserver.observe(r.container.parentNode, {\n                childList: true\n            });\n        }\n    } else {\n        r.registerBinding(r.container, 'DOMNodeRemoved', function(e) {\n            // eslint-disable-line no-unused-vars\n            r.destroy();\n        });\n    }\n    var onResize = debounce(function() {\n        r.cy.resize();\n    }, 100);\n    if (haveMutationsApi) {\n        r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n        r.styleObserver.observe(r.container, {\n            attributes: true\n        });\n    }\n    // auto resize\n    r.registerBinding(containerWindow, 'resize', onResize); // eslint-disable-line no-undef\n    if (haveResizeObserverApi) {\n        r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n        r.resizeObserver.observe(r.container);\n    }\n    var forEachUp = function forEachUp(domEle, fn) {\n        while(domEle != null){\n            fn(domEle);\n            domEle = domEle.parentNode;\n        }\n    };\n    var invalidateCoords = function invalidateCoords() {\n        r.invalidateContainerClientCoordsCache();\n    };\n    forEachUp(r.container, function(domEle) {\n        r.registerBinding(domEle, 'transitionend', invalidateCoords);\n        r.registerBinding(domEle, 'animationend', invalidateCoords);\n        r.registerBinding(domEle, 'scroll', invalidateCoords);\n    });\n    // stop right click menu from appearing on cy\n    r.registerBinding(r.container, 'contextmenu', function(e) {\n        e.preventDefault();\n    });\n    var inBoxSelection = function inBoxSelection() {\n        return r.selection[4] !== 0;\n    };\n    var eventInContainer = function eventInContainer(e) {\n        // save cycles if mouse events aren't to be captured\n        var containerPageCoords = r.findContainerClientCoords();\n        var x = containerPageCoords[0];\n        var y = containerPageCoords[1];\n        var width = containerPageCoords[2];\n        var height = containerPageCoords[3];\n        var positions = e.touches ? e.touches : [\n            e\n        ];\n        var atLeastOnePosInside = false;\n        for(var i = 0; i < positions.length; i++){\n            var p = positions[i];\n            if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n                atLeastOnePosInside = true;\n                break;\n            }\n        }\n        if (!atLeastOnePosInside) {\n            return false;\n        }\n        var container = r.container;\n        var target = e.target;\n        var tParent = target.parentNode;\n        var containerIsTarget = false;\n        while(tParent){\n            if (tParent === container) {\n                containerIsTarget = true;\n                break;\n            }\n            tParent = tParent.parentNode;\n        }\n        if (!containerIsTarget) {\n            return false;\n        } // if target is outisde cy container, then this event is not for us\n        return true;\n    };\n    // Primary key\n    r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n        if (!eventInContainer(e)) {\n            return;\n        }\n        // during left mouse button gestures, ignore other buttons\n        if (r.hoverData.which === 1 && e.which !== 1) {\n            return;\n        }\n        e.preventDefault();\n        blurActiveDomElement();\n        r.hoverData.capture = true;\n        r.hoverData.which = e.which;\n        var cy = r.cy;\n        var gpos = [\n            e.clientX,\n            e.clientY\n        ];\n        var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n        var select = r.selection;\n        var nears = r.findNearestElements(pos[0], pos[1], true, false);\n        var near = nears[0];\n        var draggedElements = r.dragData.possibleDragElements;\n        r.hoverData.mdownPos = pos;\n        r.hoverData.mdownGPos = gpos;\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        var checkForTaphold = function checkForTaphold() {\n            r.hoverData.tapholdCancelled = false;\n            clearTimeout(r.hoverData.tapholdTimeout);\n            r.hoverData.tapholdTimeout = setTimeout(function() {\n                if (r.hoverData.tapholdCancelled) {\n                    return;\n                } else {\n                    var ele = r.hoverData.down;\n                    if (ele) {\n                        ele.emit(makeEvent('taphold'));\n                    } else {\n                        cy.emit(makeEvent('taphold'));\n                    }\n                }\n            }, r.tapholdDuration);\n        };\n        // Right click button\n        if (e.which == 3) {\n            r.hoverData.cxtStarted = true;\n            var cxtEvt = {\n                originalEvent: e,\n                type: 'cxttapstart',\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n            if (near) {\n                near.activate();\n                near.emit(cxtEvt);\n                r.hoverData.down = near;\n            } else {\n                cy.emit(cxtEvt);\n            }\n            r.hoverData.downTime = new Date().getTime();\n            r.hoverData.cxtDragged = false;\n        // Primary button\n        } else if (e.which == 1) {\n            if (near) {\n                near.activate();\n            }\n            // Element dragging\n            {\n                // If something is under the cursor and it is draggable, prepare to grab it\n                if (near != null) {\n                    if (r.nodeIsGrabbable(near)) {\n                        var triggerGrab = function triggerGrab(ele) {\n                            ele.emit(makeEvent('grab'));\n                        };\n                        setGrabTarget(near);\n                        if (!near.selected()) {\n                            draggedElements = r.dragData.possibleDragElements = cy.collection();\n                            addNodeToDrag(near, {\n                                addToList: draggedElements\n                            });\n                            near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n                        } else {\n                            draggedElements = r.dragData.possibleDragElements = cy.collection();\n                            var selectedNodes = cy.$(function(ele) {\n                                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n                            });\n                            addNodesToDrag(selectedNodes, {\n                                addToList: draggedElements\n                            });\n                            near.emit(makeEvent('grabon'));\n                            selectedNodes.forEach(triggerGrab);\n                        }\n                        r.redrawHint('eles', true);\n                        r.redrawHint('drag', true);\n                    }\n                }\n                r.hoverData.down = near;\n                r.hoverData.downs = nears;\n                r.hoverData.downTime = new Date().getTime();\n            }\n            triggerEvents(near, [\n                'mousedown',\n                'tapstart',\n                'vmousedown'\n            ], e, {\n                x: pos[0],\n                y: pos[1]\n            });\n            if (near == null) {\n                select[4] = 1;\n                r.data.bgActivePosistion = {\n                    x: pos[0],\n                    y: pos[1]\n                };\n                r.redrawHint('select', true);\n                r.redraw();\n            } else if (near.pannable()) {\n                select[4] = 1; // for future pan\n            }\n            checkForTaphold();\n        }\n        // Initialize selection box coordinates\n        select[0] = select[2] = pos[0];\n        select[1] = select[3] = pos[1];\n    }, false);\n    var shadowRoot = getShadowRoot(r.container);\n    r.registerBinding([\n        containerWindow,\n        shadowRoot\n    ], 'mousemove', function mousemoveHandler(e) {\n        // eslint-disable-line no-undef\n        var capture = r.hoverData.capture;\n        if (!capture && !eventInContainer(e)) {\n            return;\n        }\n        var preventDefault = false;\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var gpos = [\n            e.clientX,\n            e.clientY\n        ];\n        var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n        var mdownPos = r.hoverData.mdownPos;\n        var mdownGPos = r.hoverData.mdownGPos;\n        var select = r.selection;\n        var near = null;\n        if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n            near = r.findNearestElement(pos[0], pos[1], true, false);\n        }\n        var last = r.hoverData.last;\n        var down = r.hoverData.down;\n        var disp = [\n            pos[0] - select[2],\n            pos[1] - select[3]\n        ];\n        var draggedElements = r.dragData.possibleDragElements;\n        var isOverThresholdDrag;\n        if (mdownGPos) {\n            var dx = gpos[0] - mdownGPos[0];\n            var dx2 = dx * dx;\n            var dy = gpos[1] - mdownGPos[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n        }\n        var multSelKeyDown = isMultSelKeyDown(e);\n        if (isOverThresholdDrag) {\n            r.hoverData.tapholdCancelled = true;\n        }\n        var updateDragDelta = function updateDragDelta() {\n            var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n            if (dragDelta.length === 0) {\n                dragDelta.push(disp[0]);\n                dragDelta.push(disp[1]);\n            } else {\n                dragDelta[0] += disp[0];\n                dragDelta[1] += disp[1];\n            }\n        };\n        preventDefault = true;\n        triggerEvents(near, [\n            'mousemove',\n            'vmousemove',\n            'tapdrag'\n        ], e, {\n            x: pos[0],\n            y: pos[1]\n        });\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        var goIntoBoxMode = function goIntoBoxMode() {\n            r.data.bgActivePosistion = undefined;\n            if (!r.hoverData.selecting) {\n                cy.emit(makeEvent('boxstart'));\n            }\n            select[4] = 1;\n            r.hoverData.selecting = true;\n            r.redrawHint('select', true);\n            r.redraw();\n        };\n        // trigger context drag if rmouse down\n        if (r.hoverData.which === 3) {\n            // but only if over threshold\n            if (isOverThresholdDrag) {\n                var cxtEvt = makeEvent('cxtdrag');\n                if (down) {\n                    down.emit(cxtEvt);\n                } else {\n                    cy.emit(cxtEvt);\n                }\n                r.hoverData.cxtDragged = true;\n                if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n                    if (r.hoverData.cxtOver) {\n                        r.hoverData.cxtOver.emit(makeEvent('cxtdragout'));\n                    }\n                    r.hoverData.cxtOver = near;\n                    if (near) {\n                        near.emit(makeEvent('cxtdragover'));\n                    }\n                }\n            }\n        // Check if we are drag panning the entire graph\n        } else if (r.hoverData.dragging) {\n            preventDefault = true;\n            if (cy.panningEnabled() && cy.userPanningEnabled()) {\n                var deltaP;\n                if (r.hoverData.justStartedPan) {\n                    var mdPos = r.hoverData.mdownPos;\n                    deltaP = {\n                        x: (pos[0] - mdPos[0]) * zoom,\n                        y: (pos[1] - mdPos[1]) * zoom\n                    };\n                    r.hoverData.justStartedPan = false;\n                } else {\n                    deltaP = {\n                        x: disp[0] * zoom,\n                        y: disp[1] * zoom\n                    };\n                }\n                cy.panBy(deltaP);\n                cy.emit(makeEvent('dragpan'));\n                r.hoverData.dragged = true;\n            }\n            // Needs reproject due to pan changing viewport\n            pos = r.projectIntoViewport(e.clientX, e.clientY);\n        // Checks primary button down & out of time & mouse not moved much\n        } else if (select[4] == 1 && (down == null || down.pannable())) {\n            if (isOverThresholdDrag) {\n                if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n                    goIntoBoxMode();\n                } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n                    var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n                    if (allowPassthrough) {\n                        r.hoverData.dragging = true;\n                        r.hoverData.justStartedPan = true;\n                        select[4] = 0;\n                        r.data.bgActivePosistion = array2point(mdownPos);\n                        r.redrawHint('select', true);\n                        r.redraw();\n                    }\n                }\n                if (down && down.pannable() && down.active()) {\n                    down.unactivate();\n                }\n            }\n        } else {\n            if (down && down.pannable() && down.active()) {\n                down.unactivate();\n            }\n            if ((!down || !down.grabbed()) && near != last) {\n                if (last) {\n                    triggerEvents(last, [\n                        'mouseout',\n                        'tapdragout'\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                }\n                if (near) {\n                    triggerEvents(near, [\n                        'mouseover',\n                        'tapdragover'\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                }\n                r.hoverData.last = near;\n            }\n            if (down) {\n                if (isOverThresholdDrag) {\n                    // then we can take action\n                    if (cy.boxSelectionEnabled() && multSelKeyDown) {\n                        // then selection overrides\n                        if (down && down.grabbed()) {\n                            freeDraggedElements(draggedElements);\n                            down.emit(makeEvent('freeon'));\n                            draggedElements.emit(makeEvent('free'));\n                            if (r.dragData.didDrag) {\n                                down.emit(makeEvent('dragfreeon'));\n                                draggedElements.emit(makeEvent('dragfree'));\n                            }\n                        }\n                        goIntoBoxMode();\n                    } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n                        // drag node\n                        var justStartedDrag = !r.dragData.didDrag;\n                        if (justStartedDrag) {\n                            r.redrawHint('eles', true);\n                        }\n                        r.dragData.didDrag = true; // indicate that we actually did drag the node\n                        // now, add the elements to the drag layer if not done already\n                        if (!r.hoverData.draggingEles) {\n                            addNodesToDrag(draggedElements, {\n                                inDragLayer: true\n                            });\n                        }\n                        var totalShift = {\n                            x: 0,\n                            y: 0\n                        };\n                        if (number$1(disp[0]) && number$1(disp[1])) {\n                            totalShift.x += disp[0];\n                            totalShift.y += disp[1];\n                            if (justStartedDrag) {\n                                var dragDelta = r.hoverData.dragDelta;\n                                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                    totalShift.x += dragDelta[0];\n                                    totalShift.y += dragDelta[1];\n                                }\n                            }\n                        }\n                        r.hoverData.draggingEles = true;\n                        draggedElements.silentShift(totalShift).emit(makeEvent('position')).emit(makeEvent('drag'));\n                        r.redrawHint('drag', true);\n                        r.redraw();\n                    }\n                } else {\n                    // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n                    updateDragDelta();\n                }\n            }\n            // prevent the dragging from triggering text selection on the page\n            preventDefault = true;\n        }\n        select[2] = pos[0];\n        select[3] = pos[1];\n        if (preventDefault) {\n            if (e.stopPropagation) e.stopPropagation();\n            if (e.preventDefault) e.preventDefault();\n            return false;\n        }\n    }, false);\n    var clickTimeout, didDoubleClick, prevClickTimeStamp;\n    r.registerBinding(containerWindow, 'mouseup', function mouseupHandler(e) {\n        // eslint-disable-line no-undef\n        // during left mouse button gestures, ignore other buttons\n        if (r.hoverData.which === 1 && e.which !== 1 && r.hoverData.capture) {\n            return;\n        }\n        var capture = r.hoverData.capture;\n        if (!capture) {\n            return;\n        }\n        r.hoverData.capture = false;\n        var cy = r.cy;\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        var select = r.selection;\n        var near = r.findNearestElement(pos[0], pos[1], true, false);\n        var draggedElements = r.dragData.possibleDragElements;\n        var down = r.hoverData.down;\n        var multSelKeyDown = isMultSelKeyDown(e);\n        if (r.data.bgActivePosistion) {\n            r.redrawHint('select', true);\n            r.redraw();\n        }\n        r.hoverData.tapholdCancelled = true;\n        r.data.bgActivePosistion = undefined; // not active bg now\n        if (down) {\n            down.unactivate();\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        if (r.hoverData.which === 3) {\n            var cxtEvt = makeEvent('cxttapend');\n            if (down) {\n                down.emit(cxtEvt);\n            } else {\n                cy.emit(cxtEvt);\n            }\n            if (!r.hoverData.cxtDragged) {\n                var cxtTap = makeEvent('cxttap');\n                if (down) {\n                    down.emit(cxtTap);\n                } else {\n                    cy.emit(cxtTap);\n                }\n            }\n            r.hoverData.cxtDragged = false;\n            r.hoverData.which = null;\n        } else if (r.hoverData.which === 1) {\n            triggerEvents(near, [\n                'mouseup',\n                'tapend',\n                'vmouseup'\n            ], e, {\n                x: pos[0],\n                y: pos[1]\n            });\n            if (!r.dragData.didDrag && // didn't move a node around\n            !r.hoverData.dragged && // didn't pan\n            !r.hoverData.selecting && // not box selection\n            !r.hoverData.isOverThresholdDrag // didn't move too much\n            ) {\n                triggerEvents(down, [\n                    \"click\",\n                    \"tap\",\n                    \"vclick\"\n                ], e, {\n                    x: pos[0],\n                    y: pos[1]\n                });\n                didDoubleClick = false;\n                if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n                    clickTimeout && clearTimeout(clickTimeout);\n                    didDoubleClick = true;\n                    prevClickTimeStamp = null;\n                    triggerEvents(down, [\n                        \"dblclick\",\n                        \"dbltap\",\n                        \"vdblclick\"\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                } else {\n                    clickTimeout = setTimeout(function() {\n                        if (didDoubleClick) return;\n                        triggerEvents(down, [\n                            \"oneclick\",\n                            \"onetap\",\n                            \"voneclick\"\n                        ], e, {\n                            x: pos[0],\n                            y: pos[1]\n                        });\n                    }, cy.multiClickDebounceTime());\n                    prevClickTimeStamp = e.timeStamp;\n                }\n            }\n            // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n            if (down == null // not mousedown on node\n             && !r.dragData.didDrag // didn't move the node around\n             && !r.hoverData.selecting // not box selection\n             && !r.hoverData.dragged // didn't pan\n             && !isMultSelKeyDown(e)) {\n                cy.$(isSelected).unselect([\n                    'tapunselect'\n                ]);\n                if (draggedElements.length > 0) {\n                    r.redrawHint('eles', true);\n                }\n                r.dragData.possibleDragElements = draggedElements = cy.collection();\n            }\n            // Single selection\n            if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n                if (near != null && near._private.selectable) {\n                    if (r.hoverData.dragging) ;\n                    else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n                        if (near.selected()) {\n                            near.unselect([\n                                'tapunselect'\n                            ]);\n                        } else {\n                            near.select([\n                                'tapselect'\n                            ]);\n                        }\n                    } else {\n                        if (!multSelKeyDown) {\n                            cy.$(isSelected).unmerge(near).unselect([\n                                'tapunselect'\n                            ]);\n                            near.select([\n                                'tapselect'\n                            ]);\n                        }\n                    }\n                    r.redrawHint('eles', true);\n                }\n            }\n            if (r.hoverData.selecting) {\n                var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n                r.redrawHint('select', true);\n                if (box.length > 0) {\n                    r.redrawHint('eles', true);\n                }\n                cy.emit(makeEvent('boxend'));\n                var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                    return ele.selectable() && !ele.selected();\n                };\n                if (cy.selectionType() === 'additive') {\n                    box.emit(makeEvent('box')).stdFilter(eleWouldBeSelected).select().emit(makeEvent('boxselect'));\n                } else {\n                    if (!multSelKeyDown) {\n                        cy.$(isSelected).unmerge(box).unselect();\n                    }\n                    box.emit(makeEvent('box')).stdFilter(eleWouldBeSelected).select().emit(makeEvent('boxselect'));\n                }\n                // always need redraw in case eles unselectable\n                r.redraw();\n            }\n            // Cancel drag pan\n            if (r.hoverData.dragging) {\n                r.hoverData.dragging = false;\n                r.redrawHint('select', true);\n                r.redrawHint('eles', true);\n                r.redraw();\n            }\n            if (!select[4]) {\n                r.redrawHint('drag', true);\n                r.redrawHint('eles', true);\n                var downWasGrabbed = down && down.grabbed();\n                freeDraggedElements(draggedElements);\n                if (downWasGrabbed) {\n                    down.emit(makeEvent('freeon'));\n                    draggedElements.emit(makeEvent('free'));\n                    if (r.dragData.didDrag) {\n                        down.emit(makeEvent('dragfreeon'));\n                        draggedElements.emit(makeEvent('dragfree'));\n                    }\n                }\n            }\n        } // else not right mouse\n        select[4] = 0;\n        r.hoverData.down = null;\n        r.hoverData.cxtStarted = false;\n        r.hoverData.draggingEles = false;\n        r.hoverData.selecting = false;\n        r.hoverData.isOverThresholdDrag = false;\n        r.dragData.didDrag = false;\n        r.hoverData.dragged = false;\n        r.hoverData.dragDelta = [];\n        r.hoverData.mdownPos = null;\n        r.hoverData.mdownGPos = null;\n        r.hoverData.which = null;\n    }, false);\n    var wheelDeltas = []; // log of first N wheel deltas\n    var wheelDeltaN = 4; // how many events to log\n    var inaccurateScrollDevice;\n    var inaccurateScrollFactor = 100000; // base of inaccurate wheel deltas (e.g. base 5 could yield wheels of 10, 25, 50, etc.)\n    var allAreDivisibleBy = function allAreDivisibleBy(list, factor) {\n        for(var i = 0; i < list.length; i++){\n            if (list[i] % factor !== 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var allAreSameMagnitude = function allAreSameMagnitude(list) {\n        var firstMag = Math.abs(list[0]);\n        for(var i = 1; i < list.length; i++){\n            if (Math.abs(list[i]) !== firstMag) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var wheelHandler = function wheelHandler(e) {\n        var clamp = false;\n        var delta = e.deltaY;\n        if (delta == null) {\n            // compatibility with old browsers\n            if (e.wheelDeltaY != null) {\n                delta = e.wheelDeltaY / 4;\n            } else if (e.wheelDelta != null) {\n                delta = e.wheelDelta / 4;\n            }\n        }\n        if (delta === 0) {\n            return; // no change in zoom (Bug: Zoom becomes erratic on rapid scroll due to deltaY: 0 event #3394)\n        }\n        if (inaccurateScrollDevice == null) {\n            if (wheelDeltas.length >= wheelDeltaN) {\n                // use log to determine if inaccurate\n                var wds = wheelDeltas;\n                inaccurateScrollDevice = allAreDivisibleBy(wds, 5);\n                if (!inaccurateScrollDevice) {\n                    // check for all large values of exact same magnitude\n                    var firstMag = Math.abs(wds[0]);\n                    inaccurateScrollDevice = allAreSameMagnitude(wds) && firstMag > 5;\n                }\n                if (inaccurateScrollDevice) {\n                    for(var i = 0; i < wds.length; i++){\n                        inaccurateScrollFactor = Math.min(Math.abs(wds[i]), inaccurateScrollFactor);\n                    }\n                }\n            // console.log('Sampled wheel deltas:', wds);\n            // console.log('inaccurateScrollDevice:', inaccurateScrollDevice);\n            // console.log('inaccurateScrollFactor:', inaccurateScrollFactor);\n            } else {\n                // clamp and log until we reach N\n                wheelDeltas.push(delta);\n                clamp = true;\n            // console.log('Clamping initial wheel events until we get a good sample');\n            }\n        } else if (inaccurateScrollDevice) {\n            // keep updating\n            inaccurateScrollFactor = Math.min(Math.abs(delta), inaccurateScrollFactor);\n        // console.log('Keep updating inaccurateScrollFactor beyond sample in case we did not get the smallest possible val:', inaccurateScrollFactor);\n        }\n        if (r.scrollingPage) {\n            return;\n        } // while scrolling, ignore wheel-to-zoom\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var pan = cy.pan();\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        var rpos = [\n            pos[0] * zoom + pan.x,\n            pos[1] * zoom + pan.y\n        ];\n        if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n            // if pan dragging or cxt dragging, wheel movements make no zoom\n            e.preventDefault();\n            return;\n        }\n        if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n            e.preventDefault();\n            r.data.wheelZooming = true;\n            clearTimeout(r.data.wheelTimeout);\n            r.data.wheelTimeout = setTimeout(function() {\n                r.data.wheelZooming = false;\n                r.redrawHint('eles', true);\n                r.redraw();\n            }, 150);\n            var diff;\n            if (clamp && Math.abs(delta) > 5) {\n                delta = signum(delta) * 5;\n            }\n            diff = delta / -250;\n            if (inaccurateScrollDevice) {\n                diff /= inaccurateScrollFactor;\n                diff *= 3;\n            }\n            diff = diff * r.wheelSensitivity;\n            // console.log(`delta = ${delta}, diff = ${diff}, mode = ${e.deltaMode}`)\n            var needsWheelFix = e.deltaMode === 1;\n            if (needsWheelFix) {\n                // fixes slow wheel events on ff/linux and ff/windows\n                diff *= 33;\n            }\n            var newZoom = cy.zoom() * Math.pow(10, diff);\n            if (e.type === 'gesturechange') {\n                newZoom = r.gestureStartZoom * e.scale;\n            }\n            cy.zoom({\n                level: newZoom,\n                renderedPosition: {\n                    x: rpos[0],\n                    y: rpos[1]\n                }\n            });\n            cy.emit({\n                type: e.type === 'gesturechange' ? 'pinchzoom' : 'scrollzoom',\n                originalEvent: e,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            });\n        }\n    };\n    // Functions to help with whether mouse wheel should trigger zooming\n    // --\n    r.registerBinding(r.container, 'wheel', wheelHandler, true);\n    // disable nonstandard wheel events\n    // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n    // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n    // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n    r.registerBinding(containerWindow, 'scroll', function scrollHandler(e) {\n        // eslint-disable-line no-unused-vars\n        r.scrollingPage = true;\n        clearTimeout(r.scrollingPageTimeout);\n        r.scrollingPageTimeout = setTimeout(function() {\n            r.scrollingPage = false;\n        }, 250);\n    }, true);\n    // desktop safari pinch to zoom start\n    r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {\n        r.gestureStartZoom = r.cy.zoom();\n        if (!r.hasTouchStarted) {\n            // don't affect touch devices like iphone\n            e.preventDefault();\n        }\n    }, true);\n    r.registerBinding(r.container, 'gesturechange', function(e) {\n        if (!r.hasTouchStarted) {\n            // don't affect touch devices like iphone\n            wheelHandler(e);\n        }\n    }, true);\n    // Functions to help with handling mouseout/mouseover on the Cytoscape container\n    // Handle mouseout on Cytoscape container\n    r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        r.cy.emit({\n            originalEvent: e,\n            type: 'mouseout',\n            position: {\n                x: pos[0],\n                y: pos[1]\n            }\n        });\n    }, false);\n    r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        r.cy.emit({\n            originalEvent: e,\n            type: 'mouseover',\n            position: {\n                x: pos[0],\n                y: pos[1]\n            }\n        });\n    }, false);\n    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n    var center1, modelCenter1; // center point on start pinch to zoom\n    var offsetLeft, offsetTop;\n    var containerWidth, containerHeight;\n    var twoFingersStartInside;\n    var distance = function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    };\n    var distanceSq = function distanceSq(x1, y1, x2, y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    };\n    var touchstartHandler;\n    r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n        r.hasTouchStarted = true;\n        if (!eventInContainer(e)) {\n            return;\n        }\n        blurActiveDomElement();\n        r.touchData.capture = true;\n        r.data.bgActivePosistion = undefined;\n        var cy = r.cy;\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        // record starting points for pinch-to-zoom\n        if (e.touches[1]) {\n            r.touchData.singleTouchMoved = true;\n            freeDraggedElements(r.dragData.touchDragEles);\n            var offsets = r.findContainerClientCoords();\n            offsetLeft = offsets[0];\n            offsetTop = offsets[1];\n            containerWidth = offsets[2];\n            containerHeight = offsets[3];\n            f1x1 = e.touches[0].clientX - offsetLeft;\n            f1y1 = e.touches[0].clientY - offsetTop;\n            f2x1 = e.touches[1].clientX - offsetLeft;\n            f2y1 = e.touches[1].clientY - offsetTop;\n            twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n            var pan = cy.pan();\n            var zoom = cy.zoom();\n            distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n            distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n            center1 = [\n                (f1x1 + f2x1) / 2,\n                (f1y1 + f2y1) / 2\n            ];\n            modelCenter1 = [\n                (center1[0] - pan.x) / zoom,\n                (center1[1] - pan.y) / zoom\n            ];\n            // consider context tap\n            var cxtDistThreshold = 200;\n            var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n            if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n                var near1 = r.findNearestElement(now[0], now[1], true, true);\n                var near2 = r.findNearestElement(now[2], now[3], true, true);\n                if (near1 && near1.isNode()) {\n                    near1.activate().emit(makeEvent('cxttapstart'));\n                    r.touchData.start = near1;\n                } else if (near2 && near2.isNode()) {\n                    near2.activate().emit(makeEvent('cxttapstart'));\n                    r.touchData.start = near2;\n                } else {\n                    cy.emit(makeEvent('cxttapstart'));\n                }\n                if (r.touchData.start) {\n                    r.touchData.start._private.grabbed = false;\n                }\n                r.touchData.cxt = true;\n                r.touchData.cxtDragged = false;\n                r.data.bgActivePosistion = undefined;\n                r.redraw();\n                return;\n            }\n        }\n        if (e.touches[2]) {\n            // ignore\n            // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n            if (cy.boxSelectionEnabled()) {\n                e.preventDefault();\n            }\n        } else if (e.touches[1]) ;\n        else if (e.touches[0]) {\n            var nears = r.findNearestElements(now[0], now[1], true, true);\n            var near = nears[0];\n            if (near != null) {\n                near.activate();\n                r.touchData.start = near;\n                r.touchData.starts = nears;\n                if (r.nodeIsGrabbable(near)) {\n                    var draggedEles = r.dragData.touchDragEles = cy.collection();\n                    var selectedNodes = null;\n                    r.redrawHint('eles', true);\n                    r.redrawHint('drag', true);\n                    if (near.selected()) {\n                        // reset drag elements, since near will be added again\n                        selectedNodes = cy.$(function(ele) {\n                            return ele.selected() && r.nodeIsGrabbable(ele);\n                        });\n                        addNodesToDrag(selectedNodes, {\n                            addToList: draggedEles\n                        });\n                    } else {\n                        addNodeToDrag(near, {\n                            addToList: draggedEles\n                        });\n                    }\n                    setGrabTarget(near);\n                    near.emit(makeEvent('grabon'));\n                    if (selectedNodes) {\n                        selectedNodes.forEach(function(n) {\n                            n.emit(makeEvent('grab'));\n                        });\n                    } else {\n                        near.emit(makeEvent('grab'));\n                    }\n                }\n            }\n            triggerEvents(near, [\n                'touchstart',\n                'tapstart',\n                'vmousedown'\n            ], e, {\n                x: now[0],\n                y: now[1]\n            });\n            if (near == null) {\n                r.data.bgActivePosistion = {\n                    x: pos[0],\n                    y: pos[1]\n                };\n                r.redrawHint('select', true);\n                r.redraw();\n            }\n            // Tap, taphold\n            // -----\n            r.touchData.singleTouchMoved = false;\n            r.touchData.singleTouchStartTime = +new Date();\n            clearTimeout(r.touchData.tapholdTimeout);\n            r.touchData.tapholdTimeout = setTimeout(function() {\n                if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n                 && !r.touchData.selecting // box selection shouldn't allow taphold through\n                ) {\n                    triggerEvents(r.touchData.start, [\n                        'taphold'\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                }\n            }, r.tapholdDuration);\n        }\n        if (e.touches.length >= 1) {\n            var sPos = r.touchData.startPosition = [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ];\n            for(var i = 0; i < now.length; i++){\n                sPos[i] = earlier[i] = now[i];\n            }\n            var touch0 = e.touches[0];\n            r.touchData.startGPosition = [\n                touch0.clientX,\n                touch0.clientY\n            ];\n        }\n    }, false);\n    var touchmoveHandler;\n    r.registerBinding(containerWindow, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n        // eslint-disable-line no-undef\n        var capture = r.touchData.capture;\n        if (!capture && !eventInContainer(e)) {\n            return;\n        }\n        var select = r.selection;\n        var cy = r.cy;\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        var zoom = cy.zoom();\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        var startGPos = r.touchData.startGPosition;\n        var isOverThresholdDrag;\n        if (capture && e.touches[0] && startGPos) {\n            var disp = [];\n            for(var j = 0; j < now.length; j++){\n                disp[j] = now[j] - earlier[j];\n            }\n            var dx = e.touches[0].clientX - startGPos[0];\n            var dx2 = dx * dx;\n            var dy = e.touches[0].clientY - startGPos[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n        }\n        // context swipe cancelling\n        if (capture && r.touchData.cxt) {\n            e.preventDefault();\n            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n            // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n            var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n            var factorSq = distance2Sq / distance1Sq;\n            var distThreshold = 150;\n            var distThresholdSq = distThreshold * distThreshold;\n            var factorThreshold = 1.5;\n            var factorThresholdSq = factorThreshold * factorThreshold;\n            // cancel ctx gestures if the distance b/t the fingers increases\n            if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n                r.touchData.cxt = false;\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint('select', true);\n                var cxtEvt = makeEvent('cxttapend');\n                if (r.touchData.start) {\n                    r.touchData.start.unactivate().emit(cxtEvt);\n                    r.touchData.start = null;\n                } else {\n                    cy.emit(cxtEvt);\n                }\n            }\n        }\n        // context swipe\n        if (capture && r.touchData.cxt) {\n            var cxtEvt = makeEvent('cxtdrag');\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            if (r.touchData.start) {\n                r.touchData.start.emit(cxtEvt);\n            } else {\n                cy.emit(cxtEvt);\n            }\n            if (r.touchData.start) {\n                r.touchData.start._private.grabbed = false;\n            }\n            r.touchData.cxtDragged = true;\n            var near = r.findNearestElement(now[0], now[1], true, true);\n            if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n                if (r.touchData.cxtOver) {\n                    r.touchData.cxtOver.emit(makeEvent('cxtdragout'));\n                }\n                r.touchData.cxtOver = near;\n                if (near) {\n                    near.emit(makeEvent('cxtdragover'));\n                }\n            }\n        // box selection\n        } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n            e.preventDefault();\n            r.data.bgActivePosistion = undefined;\n            this.lastThreeTouch = +new Date();\n            if (!r.touchData.selecting) {\n                cy.emit(makeEvent('boxstart'));\n            }\n            r.touchData.selecting = true;\n            r.touchData.didSelect = true;\n            select[4] = 1;\n            if (!select || select.length === 0 || select[0] === undefined) {\n                select[0] = (now[0] + now[2] + now[4]) / 3;\n                select[1] = (now[1] + now[3] + now[5]) / 3;\n                select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n                select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n            } else {\n                select[2] = (now[0] + now[2] + now[4]) / 3;\n                select[3] = (now[1] + now[3] + now[5]) / 3;\n            }\n            r.redrawHint('select', true);\n            r.redraw();\n        // pinch to zoom\n        } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n         && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n            // two fingers => pinch to zoom\n            e.preventDefault();\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            var draggedEles = r.dragData.touchDragEles;\n            if (draggedEles) {\n                r.redrawHint('drag', true);\n                for(var i = 0; i < draggedEles.length; i++){\n                    var de_p = draggedEles[i]._private;\n                    de_p.grabbed = false;\n                    de_p.rscratch.inDragLayer = false;\n                }\n            }\n            var _start = r.touchData.start;\n            // (x2, y2) for fingers 1 and 2\n            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n            var distance2 = distance(f1x2, f1y2, f2x2, f2y2);\n            // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n            // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n            var factor = distance2 / distance1;\n            if (twoFingersStartInside) {\n                // delta finger1\n                var df1x = f1x2 - f1x1;\n                var df1y = f1y2 - f1y1;\n                // delta finger 2\n                var df2x = f2x2 - f2x1;\n                var df2y = f2y2 - f2y1;\n                // translation is the normalised vector of the two fingers movement\n                // i.e. so pinching cancels out and moving together pans\n                var tx = (df1x + df2x) / 2;\n                var ty = (df1y + df2y) / 2;\n                // now calculate the zoom\n                var zoom1 = cy.zoom();\n                var zoom2 = zoom1 * factor;\n                var pan1 = cy.pan();\n                // the model center point converted to the current rendered pos\n                var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n                var ctry = modelCenter1[1] * zoom1 + pan1.y;\n                var pan2 = {\n                    x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n                    y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n                };\n                // remove dragged eles\n                if (_start && _start.active()) {\n                    var draggedEles = r.dragData.touchDragEles;\n                    freeDraggedElements(draggedEles);\n                    r.redrawHint('drag', true);\n                    r.redrawHint('eles', true);\n                    _start.unactivate().emit(makeEvent('freeon'));\n                    draggedEles.emit(makeEvent('free'));\n                    if (r.dragData.didDrag) {\n                        _start.emit(makeEvent('dragfreeon'));\n                        draggedEles.emit(makeEvent('dragfree'));\n                    }\n                }\n                cy.viewport({\n                    zoom: zoom2,\n                    pan: pan2,\n                    cancelOnFailedZoom: true\n                });\n                cy.emit(makeEvent('pinchzoom'));\n                distance1 = distance2;\n                f1x1 = f1x2;\n                f1y1 = f1y2;\n                f2x1 = f2x2;\n                f2y1 = f2y2;\n                r.pinching = true;\n            }\n            // Re-project\n            if (e.touches[0]) {\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n            if (e.touches[1]) {\n                var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n                now[2] = pos[0];\n                now[3] = pos[1];\n            }\n            if (e.touches[2]) {\n                var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n                now[4] = pos[0];\n                now[5] = pos[1];\n            }\n        } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n        ) {\n            var start = r.touchData.start;\n            var last = r.touchData.last;\n            var near;\n            if (!r.hoverData.draggingEles && !r.swipePanning) {\n                near = r.findNearestElement(now[0], now[1], true, true);\n            }\n            if (capture && start != null) {\n                e.preventDefault();\n            }\n            // dragging nodes\n            if (capture && start != null && r.nodeIsDraggable(start)) {\n                if (isOverThresholdDrag) {\n                    // then dragging can happen\n                    var draggedEles = r.dragData.touchDragEles;\n                    var justStartedDrag = !r.dragData.didDrag;\n                    if (justStartedDrag) {\n                        addNodesToDrag(draggedEles, {\n                            inDragLayer: true\n                        });\n                    }\n                    r.dragData.didDrag = true;\n                    var totalShift = {\n                        x: 0,\n                        y: 0\n                    };\n                    if (number$1(disp[0]) && number$1(disp[1])) {\n                        totalShift.x += disp[0];\n                        totalShift.y += disp[1];\n                        if (justStartedDrag) {\n                            r.redrawHint('eles', true);\n                            var dragDelta = r.touchData.dragDelta;\n                            if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                totalShift.x += dragDelta[0];\n                                totalShift.y += dragDelta[1];\n                            }\n                        }\n                    }\n                    r.hoverData.draggingEles = true;\n                    draggedEles.silentShift(totalShift).emit(makeEvent('position')).emit(makeEvent('drag'));\n                    r.redrawHint('drag', true);\n                    if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n                        r.redrawHint('eles', true);\n                    }\n                    r.redraw();\n                } else {\n                    // otherwise keep track of drag delta for later\n                    var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n                    if (dragDelta.length === 0) {\n                        dragDelta.push(disp[0]);\n                        dragDelta.push(disp[1]);\n                    } else {\n                        dragDelta[0] += disp[0];\n                        dragDelta[1] += disp[1];\n                    }\n                }\n            }\n            // touchmove\n            {\n                triggerEvents(start || near, [\n                    'touchmove',\n                    'tapdrag',\n                    'vmousemove'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                if ((!start || !start.grabbed()) && near != last) {\n                    if (last) {\n                        last.emit(makeEvent('tapdragout'));\n                    }\n                    if (near) {\n                        near.emit(makeEvent('tapdragover'));\n                    }\n                }\n                r.touchData.last = near;\n            }\n            // check to cancel taphold\n            if (capture) {\n                for(var i = 0; i < now.length; i++){\n                    if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n                        r.touchData.singleTouchMoved = true;\n                    }\n                }\n            }\n            // panning\n            if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n                var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n                if (allowPassthrough) {\n                    e.preventDefault();\n                    if (!r.data.bgActivePosistion) {\n                        r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n                    }\n                    if (r.swipePanning) {\n                        cy.panBy({\n                            x: disp[0] * zoom,\n                            y: disp[1] * zoom\n                        });\n                        cy.emit(makeEvent('dragpan'));\n                    } else if (isOverThresholdDrag) {\n                        r.swipePanning = true;\n                        cy.panBy({\n                            x: dx * zoom,\n                            y: dy * zoom\n                        });\n                        cy.emit(makeEvent('dragpan'));\n                        if (start) {\n                            start.unactivate();\n                            r.redrawHint('select', true);\n                            r.touchData.start = null;\n                        }\n                    }\n                }\n                // Re-project\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n        }\n        for(var j = 0; j < now.length; j++){\n            earlier[j] = now[j];\n        }\n        // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n        if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            r.redraw();\n        }\n    }, false);\n    var touchcancelHandler;\n    r.registerBinding(containerWindow, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n        // eslint-disable-line no-unused-vars\n        var start = r.touchData.start;\n        r.touchData.capture = false;\n        if (start) {\n            start.unactivate();\n        }\n    });\n    var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n    r.registerBinding(containerWindow, 'touchend', touchendHandler = function touchendHandler(e) {\n        // eslint-disable-line no-unused-vars\n        var start = r.touchData.start;\n        var capture = r.touchData.capture;\n        if (capture) {\n            if (e.touches.length === 0) {\n                r.touchData.capture = false;\n            }\n            e.preventDefault();\n        } else {\n            return;\n        }\n        var select = r.selection;\n        r.swipePanning = false;\n        r.hoverData.draggingEles = false;\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        if (start) {\n            start.unactivate();\n        }\n        var ctxTapend;\n        if (r.touchData.cxt) {\n            ctxTapend = makeEvent('cxttapend');\n            if (start) {\n                start.emit(ctxTapend);\n            } else {\n                cy.emit(ctxTapend);\n            }\n            if (!r.touchData.cxtDragged) {\n                var ctxTap = makeEvent('cxttap');\n                if (start) {\n                    start.emit(ctxTap);\n                } else {\n                    cy.emit(ctxTap);\n                }\n            }\n            if (r.touchData.start) {\n                r.touchData.start._private.grabbed = false;\n            }\n            r.touchData.cxt = false;\n            r.touchData.start = null;\n            r.redraw();\n            return;\n        }\n        // no more box selection if we don't have three fingers\n        if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n            r.touchData.selecting = false;\n            var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n            select[0] = undefined;\n            select[1] = undefined;\n            select[2] = undefined;\n            select[3] = undefined;\n            select[4] = 0;\n            r.redrawHint('select', true);\n            cy.emit(makeEvent('boxend'));\n            var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                return ele.selectable() && !ele.selected();\n            };\n            box.emit(makeEvent('box')).stdFilter(eleWouldBeSelected).select().emit(makeEvent('boxselect'));\n            if (box.nonempty()) {\n                r.redrawHint('eles', true);\n            }\n            r.redraw();\n        }\n        if (start != null) {\n            start.unactivate();\n        }\n        if (e.touches[2]) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n        } else if (e.touches[1]) ;\n        else if (e.touches[0]) ;\n        else if (!e.touches[0]) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            var draggedEles = r.dragData.touchDragEles;\n            if (start != null) {\n                var startWasGrabbed = start._private.grabbed;\n                freeDraggedElements(draggedEles);\n                r.redrawHint('drag', true);\n                r.redrawHint('eles', true);\n                if (startWasGrabbed) {\n                    start.emit(makeEvent('freeon'));\n                    draggedEles.emit(makeEvent('free'));\n                    if (r.dragData.didDrag) {\n                        start.emit(makeEvent('dragfreeon'));\n                        draggedEles.emit(makeEvent('dragfree'));\n                    }\n                }\n                triggerEvents(start, [\n                    'touchend',\n                    'tapend',\n                    'vmouseup',\n                    'tapdragout'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                start.unactivate();\n                r.touchData.start = null;\n            } else {\n                var near = r.findNearestElement(now[0], now[1], true, true);\n                triggerEvents(near, [\n                    'touchend',\n                    'tapend',\n                    'vmouseup',\n                    'tapdragout'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n            }\n            var dx = r.touchData.startPosition[0] - now[0];\n            var dx2 = dx * dx;\n            var dy = r.touchData.startPosition[1] - now[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            var rdist2 = dist2 * zoom * zoom;\n            // Tap event, roughly same as mouse click event for touch\n            if (!r.touchData.singleTouchMoved) {\n                if (!start) {\n                    cy.$(':selected').unselect([\n                        'tapunselect'\n                    ]);\n                }\n                triggerEvents(start, [\n                    'tap',\n                    'vclick'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                didDoubleTouch = false;\n                if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n                    touchTimeout && clearTimeout(touchTimeout);\n                    didDoubleTouch = true;\n                    prevTouchTimeStamp = null;\n                    triggerEvents(start, [\n                        'dbltap',\n                        'vdblclick'\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                } else {\n                    touchTimeout = setTimeout(function() {\n                        if (didDoubleTouch) return;\n                        triggerEvents(start, [\n                            'onetap',\n                            'voneclick'\n                        ], e, {\n                            x: now[0],\n                            y: now[1]\n                        });\n                    }, cy.multiClickDebounceTime());\n                    prevTouchTimeStamp = e.timeStamp;\n                }\n            }\n            // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n            if (start != null && !r.dragData.didDrag // didn't drag nodes around\n             && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n            ) {\n                if (cy.selectionType() === 'single') {\n                    cy.$(isSelected).unmerge(start).unselect([\n                        'tapunselect'\n                    ]);\n                    start.select([\n                        'tapselect'\n                    ]);\n                } else {\n                    if (start.selected()) {\n                        start.unselect([\n                            'tapunselect'\n                        ]);\n                    } else {\n                        start.select([\n                            'tapselect'\n                        ]);\n                    }\n                }\n                r.redrawHint('eles', true);\n            }\n            r.touchData.singleTouchMoved = true;\n        }\n        for(var j = 0; j < now.length; j++){\n            earlier[j] = now[j];\n        }\n        r.dragData.didDrag = false; // reset for next touchstart\n        if (e.touches.length === 0) {\n            r.touchData.dragDelta = [];\n            r.touchData.startPosition = [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ];\n            r.touchData.startGPosition = null;\n            r.touchData.didSelect = false;\n        }\n        if (e.touches.length < 2) {\n            if (e.touches.length === 1) {\n                // the old start global pos'n may not be the same finger that remains\n                r.touchData.startGPosition = [\n                    e.touches[0].clientX,\n                    e.touches[0].clientY\n                ];\n            }\n            r.pinching = false;\n            r.redrawHint('eles', true);\n            r.redraw();\n        }\n    //r.redraw();\n    }, false);\n    // fallback compatibility layer for ms pointer events\n    if (typeof TouchEvent === 'undefined') {\n        var pointers = [];\n        var makeTouch = function makeTouch(e) {\n            return {\n                clientX: e.clientX,\n                clientY: e.clientY,\n                force: 1,\n                identifier: e.pointerId,\n                pageX: e.pageX,\n                pageY: e.pageY,\n                radiusX: e.width / 2,\n                radiusY: e.height / 2,\n                screenX: e.screenX,\n                screenY: e.screenY,\n                target: e.target\n            };\n        };\n        var makePointer = function makePointer(e) {\n            return {\n                event: e,\n                touch: makeTouch(e)\n            };\n        };\n        var addPointer = function addPointer(e) {\n            pointers.push(makePointer(e));\n        };\n        var removePointer = function removePointer(e) {\n            for(var i = 0; i < pointers.length; i++){\n                var p = pointers[i];\n                if (p.event.pointerId === e.pointerId) {\n                    pointers.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var updatePointer = function updatePointer(e) {\n            var p = pointers.filter(function(p) {\n                return p.event.pointerId === e.pointerId;\n            })[0];\n            p.event = e;\n            p.touch = makeTouch(e);\n        };\n        var addTouchesToEvent = function addTouchesToEvent(e) {\n            e.touches = pointers.map(function(p) {\n                return p.touch;\n            });\n        };\n        var pointerIsMouse = function pointerIsMouse(e) {\n            return e.pointerType === 'mouse' || e.pointerType === 4;\n        };\n        r.registerBinding(r.container, 'pointerdown', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            e.preventDefault();\n            addPointer(e);\n            addTouchesToEvent(e);\n            touchstartHandler(e);\n        });\n        r.registerBinding(r.container, 'pointerup', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            removePointer(e);\n            addTouchesToEvent(e);\n            touchendHandler(e);\n        });\n        r.registerBinding(r.container, 'pointercancel', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            removePointer(e);\n            addTouchesToEvent(e);\n            touchcancelHandler(e);\n        });\n        r.registerBinding(r.container, 'pointermove', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            e.preventDefault();\n            updatePointer(e);\n            addTouchesToEvent(e);\n            touchmoveHandler(e);\n        });\n    }\n};\nvar BRp$2 = {};\nBRp$2.generatePolygon = function(name, points) {\n    return this.nodeShapes[name] = {\n        renderer: this,\n        name: name,\n        points: points,\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [\n                0,\n                -1\n            ], padding);\n        },\n        hasMiterBounds: name !== 'rectangle',\n        miterBounds: function miterBounds(centerX, centerY, width, height, strokeWidth, strokePosition) {\n            return miterBox(this.points, centerX, centerY, width, height, strokeWidth);\n        }\n    };\n};\nBRp$2.generateEllipse = function() {\n    return this.nodeShapes['ellipse'] = {\n        renderer: this,\n        name: 'ellipse',\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n        }\n    };\n};\nBRp$2.generateRoundPolygon = function(name, points) {\n    return this.nodeShapes[name] = {\n        renderer: this,\n        name: name,\n        points: points,\n        getOrCreateCorners: function getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, field) {\n            if (rs[field] !== undefined && rs[field + '-cx'] === centerX && rs[field + '-cy'] === centerY) {\n                return rs[field];\n            }\n            rs[field] = new Array(points.length / 2);\n            rs[field + '-cx'] = centerX;\n            rs[field + '-cy'] = centerY;\n            var halfW = width / 2;\n            var halfH = height / 2;\n            cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(width, height) : cornerRadius;\n            var p = new Array(points.length / 2);\n            for(var _i = 0; _i < points.length / 2; _i++){\n                p[_i] = {\n                    x: centerX + halfW * points[_i * 2],\n                    y: centerY + halfH * points[_i * 2 + 1]\n                };\n            }\n            var i, p1, p2, p3, len = p.length;\n            p1 = p[len - 1];\n            // for each point\n            for(i = 0; i < len; i++){\n                p2 = p[i % len];\n                p3 = p[(i + 1) % len];\n                rs[field][i] = getRoundCorner(p1, p2, p3, cornerRadius);\n                p1 = p2;\n                p2 = p3;\n            }\n            return rs[field];\n        },\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius, rs) {\n            this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'drawCorners'));\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius, rs) {\n            return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height, padding, this.getOrCreateCorners(nodeX, nodeY, width, height, cornerRadius, rs, 'corners'));\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius, rs) {\n            return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'corners'));\n        }\n    };\n};\nBRp$2.generateRoundRectangle = function() {\n    return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {\n        renderer: this,\n        name: 'round-rectangle',\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var halfWidth = width / 2;\n            var halfHeight = height / 2;\n            cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;\n            cornerRadius = Math.min(halfWidth, halfHeight, cornerRadius);\n            var diam = cornerRadius * 2;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check top left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n                return true;\n            }\n            // Check top right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n                return true;\n            }\n            return false;\n        }\n    };\n};\nBRp$2.generateCutRectangle = function() {\n    return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {\n        renderer: this,\n        name: 'cut-rectangle',\n        cornerLength: getCutRectangleCornerLength(),\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, null, cornerRadius);\n        },\n        generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY, cornerRadius) {\n            var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;\n            var hh = height / 2;\n            var hw = width / 2;\n            var xBegin = centerX - hw;\n            var xEnd = centerX + hw;\n            var yBegin = centerY - hh;\n            var yEnd = centerY + hh;\n            // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n            return {\n                topLeft: [\n                    xBegin,\n                    yBegin + cl,\n                    xBegin + cl,\n                    yBegin,\n                    xBegin + cl,\n                    yBegin + cl\n                ],\n                topRight: [\n                    xEnd - cl,\n                    yBegin,\n                    xEnd,\n                    yBegin + cl,\n                    xEnd - cl,\n                    yBegin + cl\n                ],\n                bottomRight: [\n                    xEnd,\n                    yEnd - cl,\n                    xEnd - cl,\n                    yEnd,\n                    xEnd - cl,\n                    yEnd - cl\n                ],\n                bottomLeft: [\n                    xBegin + cl,\n                    yEnd,\n                    xBegin,\n                    yEnd - cl,\n                    xBegin + cl,\n                    yEnd - cl\n                ]\n            };\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY, cornerRadius);\n            var pts = [].concat.apply([], [\n                cPts.topLeft.splice(0, 4),\n                cPts.topRight.splice(0, 4),\n                cPts.bottomRight.splice(0, 4),\n                cPts.bottomLeft.splice(0, 4)\n            ]);\n            return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * cl, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * cl, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n            return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n        }\n    };\n};\nBRp$2.generateBarrel = function() {\n    return this.nodeShapes['barrel'] = {\n        renderer: this,\n        name: 'barrel',\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            // use two fixed t values for the bezier curve approximation\n            var t0 = 0.15;\n            var t1 = 0.5;\n            var t2 = 0.85;\n            var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n            var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n                // approximate curve pts based on the two t values\n                var m0 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t0);\n                var m1 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t1);\n                var m2 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t2);\n                return [\n                    pts[0],\n                    pts[1],\n                    m0.x,\n                    m0.y,\n                    m1.x,\n                    m1.y,\n                    m2.x,\n                    m2.y,\n                    pts[4],\n                    pts[5]\n                ];\n            };\n            var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n            return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n        },\n        generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n            var hh = height / 2;\n            var hw = width / 2;\n            var xBegin = centerX - hw;\n            var xEnd = centerX + hw;\n            var yBegin = centerY - hh;\n            var yEnd = centerY + hh;\n            var curveConstants = getBarrelCurveConstants(width, height);\n            var hOffset = curveConstants.heightOffset;\n            var wOffset = curveConstants.widthOffset;\n            var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;\n            // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n            var pts = {\n                topLeft: [\n                    xBegin,\n                    yBegin + hOffset,\n                    xBegin + ctrlPtXOffset,\n                    yBegin,\n                    xBegin + wOffset,\n                    yBegin\n                ],\n                topRight: [\n                    xEnd - wOffset,\n                    yBegin,\n                    xEnd - ctrlPtXOffset,\n                    yBegin,\n                    xEnd,\n                    yBegin + hOffset\n                ],\n                bottomRight: [\n                    xEnd,\n                    yEnd - hOffset,\n                    xEnd - ctrlPtXOffset,\n                    yEnd,\n                    xEnd - wOffset,\n                    yEnd\n                ],\n                bottomLeft: [\n                    xBegin + wOffset,\n                    yEnd,\n                    xBegin + ctrlPtXOffset,\n                    yEnd,\n                    xBegin,\n                    yEnd - hOffset\n                ]\n            };\n            pts.topLeft.isTop = true;\n            pts.topRight.isTop = true;\n            pts.bottomLeft.isBottom = true;\n            pts.bottomRight.isBottom = true;\n            return pts;\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var curveConstants = getBarrelCurveConstants(width, height);\n            var hOffset = curveConstants.heightOffset;\n            var wOffset = curveConstants.widthOffset;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n            var getCurveT = function getCurveT(x, y, curvePts) {\n                var x0 = curvePts[4];\n                var x1 = curvePts[2];\n                var x2 = curvePts[0];\n                var y0 = curvePts[5];\n                // var y1 = curvePts[ 3 ];\n                var y2 = curvePts[1];\n                var xMin = Math.min(x0, x2);\n                var xMax = Math.max(x0, x2);\n                var yMin = Math.min(y0, y2);\n                var yMax = Math.max(y0, y2);\n                if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n                    var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n                    var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n                    var validRoots = roots.filter(function(r) {\n                        return 0 <= r && r <= 1;\n                    });\n                    if (validRoots.length > 0) {\n                        return validRoots[0];\n                    }\n                }\n                return null;\n            };\n            var curveRegions = Object.keys(barrelCurvePts);\n            for(var i = 0; i < curveRegions.length; i++){\n                var corner = curveRegions[i];\n                var cornerPts = barrelCurvePts[corner];\n                var t = getCurveT(x, y, cornerPts);\n                if (t == null) {\n                    continue;\n                }\n                var y0 = cornerPts[5];\n                var y1 = cornerPts[3];\n                var y2 = cornerPts[1];\n                var bezY = qbezierAt(y0, y1, y2, t);\n                if (cornerPts.isTop && bezY <= y) {\n                    return true;\n                }\n                if (cornerPts.isBottom && y <= bezY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n};\nBRp$2.generateBottomRoundrectangle = function() {\n    return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {\n        renderer: this,\n        name: 'bottom-round-rectangle',\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            var topStartX = nodeX - (width / 2 + padding);\n            var topStartY = nodeY - (height / 2 + padding);\n            var topEndY = topStartY;\n            var topEndX = nodeX + (width / 2 + padding);\n            var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n            if (topIntersections.length > 0) {\n                return topIntersections;\n            }\n            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;\n            var diam = 2 * cornerRadius;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // check non-rounded top side\n            var outerWidth = width / 2 + 2 * padding;\n            var outerHeight = height / 2 + 2 * padding;\n            var points = [\n                centerX - outerWidth,\n                centerY - outerHeight,\n                centerX - outerWidth,\n                centerY,\n                centerX + outerWidth,\n                centerY,\n                centerX + outerWidth,\n                centerY - outerHeight\n            ];\n            if (pointInsidePolygonPoints(x, y, points)) {\n                return true;\n            }\n            // Check bottom right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                return true;\n            }\n            return false;\n        }\n    };\n};\nBRp$2.registerNodeShapes = function() {\n    var nodeShapes = this.nodeShapes = {};\n    var renderer = this;\n    this.generateEllipse();\n    this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));\n    nodeShapes['square'] = nodeShapes['rectangle'];\n    this.generateRoundRectangle();\n    this.generateCutRectangle();\n    this.generateBarrel();\n    this.generateBottomRoundrectangle();\n    {\n        var diamondPoints = [\n            0,\n            1,\n            1,\n            0,\n            0,\n            -1,\n            -1,\n            0\n        ];\n        this.generatePolygon('diamond', diamondPoints);\n        this.generateRoundPolygon('round-diamond', diamondPoints);\n    }\n    this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    var star5Points = new Array(20);\n    {\n        var outerPoints = generateUnitNgonPoints(5, 0);\n        var innerPoints = generateUnitNgonPoints(5, Math.PI / 5);\n        // Outer radius is 1; inner radius of star is smaller\n        var innerRadius = 0.5 * (3 - Math.sqrt(5));\n        innerRadius *= 1.57;\n        for(var i = 0; i < innerPoints.length / 2; i++){\n            innerPoints[i * 2] *= innerRadius;\n            innerPoints[i * 2 + 1] *= innerRadius;\n        }\n        for(var i = 0; i < 20 / 4; i++){\n            star5Points[i * 4] = outerPoints[i * 2];\n            star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n            star5Points[i * 4 + 2] = innerPoints[i * 2];\n            star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n        }\n    }\n    star5Points = fitPolygonToSquare(star5Points);\n    this.generatePolygon('star', star5Points);\n    this.generatePolygon('vee', [\n        -1,\n        -1,\n        0,\n        -0.333,\n        1,\n        -1,\n        0,\n        1\n    ]);\n    this.generatePolygon('rhomboid', [\n        -1,\n        -1,\n        0.333,\n        -1,\n        1,\n        1,\n        -0.333,\n        1\n    ]);\n    this.generatePolygon('right-rhomboid', [\n        -0.333,\n        -1,\n        1,\n        -1,\n        0.333,\n        1,\n        -1,\n        1\n    ]);\n    this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [\n        -1,\n        -0.95,\n        -0.75,\n        0,\n        -1,\n        0.95,\n        1,\n        0.95,\n        0.75,\n        0,\n        1,\n        -0.95\n    ]);\n    {\n        var tagPoints = [\n            -1,\n            -1,\n            0.25,\n            -1,\n            1,\n            0,\n            0.25,\n            1,\n            -1,\n            1\n        ];\n        this.generatePolygon('tag', tagPoints);\n        this.generateRoundPolygon('round-tag', tagPoints);\n    }\n    nodeShapes.makePolygon = function(points) {\n        // use caching on user-specified polygons so they are as fast as native shapes\n        var key = points.join('$');\n        var name = 'polygon-' + key;\n        var shape;\n        if (shape = this[name]) {\n            // got cached shape\n            return shape;\n        }\n        // create and cache new shape\n        return renderer.generatePolygon(name, points);\n    };\n};\nvar BRp$1 = {};\nBRp$1.timeToRender = function() {\n    return this.redrawTotalTime / this.redrawCount;\n};\nBRp$1.redraw = function(options) {\n    options = options || staticEmptyObject();\n    var r = this;\n    if (r.averageRedrawTime === undefined) {\n        r.averageRedrawTime = 0;\n    }\n    if (r.lastRedrawTime === undefined) {\n        r.lastRedrawTime = 0;\n    }\n    if (r.lastDrawTime === undefined) {\n        r.lastDrawTime = 0;\n    }\n    r.requestedFrame = true;\n    r.renderOptions = options;\n};\nBRp$1.beforeRender = function(fn, priority) {\n    // the renderer can't add tick callbacks when destroyed\n    if (this.destroyed) {\n        return;\n    }\n    if (priority == null) {\n        error('Priority is not optional for beforeRender');\n    }\n    var cbs = this.beforeRenderCallbacks;\n    cbs.push({\n        fn: fn,\n        priority: priority\n    });\n    // higher priority callbacks executed first\n    cbs.sort(function(a, b) {\n        return b.priority - a.priority;\n    });\n};\nvar beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n    var cbs = r.beforeRenderCallbacks;\n    for(var i = 0; i < cbs.length; i++){\n        cbs[i].fn(willDraw, startTime);\n    }\n};\nBRp$1.startRenderLoop = function() {\n    var r = this;\n    var cy = r.cy;\n    if (r.renderLoopStarted) {\n        return;\n    } else {\n        r.renderLoopStarted = true;\n    }\n    var _renderFn = function renderFn(requestTime) {\n        if (r.destroyed) {\n            return;\n        }\n        if (cy.batching()) ;\n        else if (r.requestedFrame && !r.skipFrame) {\n            beforeRenderCallbacks(r, true, requestTime);\n            var startTime = performanceNow();\n            r.render(r.renderOptions);\n            var endTime = r.lastDrawTime = performanceNow();\n            if (r.averageRedrawTime === undefined) {\n                r.averageRedrawTime = endTime - startTime;\n            }\n            if (r.redrawCount === undefined) {\n                r.redrawCount = 0;\n            }\n            r.redrawCount++;\n            if (r.redrawTotalTime === undefined) {\n                r.redrawTotalTime = 0;\n            }\n            var duration = endTime - startTime;\n            r.redrawTotalTime += duration;\n            r.lastRedrawTime = duration;\n            // use a weighted average with a bias from the previous average so we don't spike so easily\n            r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n            r.requestedFrame = false;\n        } else {\n            beforeRenderCallbacks(r, false, requestTime);\n        }\n        r.skipFrame = false;\n        requestAnimationFrame(_renderFn);\n    };\n    requestAnimationFrame(_renderFn);\n};\nvar BaseRenderer = function BaseRenderer(options) {\n    this.init(options);\n};\nvar BR = BaseRenderer;\nvar BRp = BR.prototype;\nBRp.clientFunctions = [\n    'redrawHint',\n    'render',\n    'renderTo',\n    'matchCanvasSize',\n    'nodeShapeImpl',\n    'arrowShapeImpl'\n];\nBRp.init = function(options) {\n    var r = this;\n    r.options = options;\n    r.cy = options.cy;\n    var ctr = r.container = options.cy.container();\n    var containerWindow = r.cy.window();\n    // prepend a stylesheet in the head such that\n    if (containerWindow) {\n        var document1 = containerWindow.document;\n        var head = document1.head;\n        var stylesheetId = '__________cytoscape_stylesheet';\n        var className = '__________cytoscape_container';\n        var stylesheetAlreadyExists = document1.getElementById(stylesheetId) != null;\n        if (ctr.className.indexOf(className) < 0) {\n            ctr.className = (ctr.className || '') + ' ' + className;\n        }\n        if (!stylesheetAlreadyExists) {\n            var stylesheet = document1.createElement('style');\n            stylesheet.id = stylesheetId;\n            stylesheet.textContent = '.' + className + ' { position: relative; }';\n            head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n        }\n        var computedStyle = containerWindow.getComputedStyle(ctr);\n        var position = computedStyle.getPropertyValue('position');\n        if (position === 'static') {\n            warn('A Cytoscape container has style position:static and so can not use UI extensions properly');\n        }\n    }\n    r.selection = [\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        0\n    ]; // Coordinates for selection box, plus enabled flag\n    r.bezierProjPcts = [\n        0.05,\n        0.225,\n        0.4,\n        0.5,\n        0.6,\n        0.775,\n        0.95\n    ];\n    //--Pointer-related data\n    r.hoverData = {\n        down: null,\n        last: null,\n        downTime: null,\n        triggerMode: null,\n        dragging: false,\n        initialPan: [\n            null,\n            null\n        ],\n        capture: false\n    };\n    r.dragData = {\n        possibleDragElements: []\n    };\n    r.touchData = {\n        start: null,\n        capture: false,\n        // These 3 fields related to tap, taphold events\n        startPosition: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ],\n        singleTouchStartTime: null,\n        singleTouchMoved: true,\n        now: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ],\n        earlier: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ]\n    };\n    r.redraws = 0;\n    r.showFps = options.showFps;\n    r.debug = options.debug;\n    r.webgl = options.webgl;\n    r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n    r.textureOnViewport = options.textureOnViewport;\n    r.wheelSensitivity = options.wheelSensitivity;\n    r.motionBlurEnabled = options.motionBlur; // on by default\n    r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n    r.motionBlur = options.motionBlur; // for initial kick off\n    r.motionBlurOpacity = options.motionBlurOpacity;\n    r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n    r.motionBlurPxRatio = 1;\n    r.mbPxRBlurry = 1; //0.8;\n    r.minMbLowQualFrames = 4;\n    r.fullQualityMb = false;\n    r.clearedForMotionBlur = [];\n    r.desktopTapThreshold = options.desktopTapThreshold;\n    r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n    r.touchTapThreshold = options.touchTapThreshold;\n    r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n    r.tapholdDuration = 500;\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.beforeRenderPriorities = {\n        // higher priority execs before lower one\n        animations: 400,\n        eleCalcs: 300,\n        eleTxrDeq: 200,\n        lyrTxrDeq: 150,\n        lyrTxrSkip: 100\n    };\n    r.registerNodeShapes();\n    r.registerArrowShapes();\n    r.registerCalculationListeners();\n};\nBRp.notify = function(eventName, eles) {\n    var r = this;\n    var cy = r.cy;\n    // the renderer can't be notified after it's destroyed\n    if (this.destroyed) {\n        return;\n    }\n    if (eventName === 'init') {\n        r.load();\n        return;\n    }\n    if (eventName === 'destroy') {\n        r.destroy();\n        return;\n    }\n    if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {\n        r.invalidateCachedZSortedEles();\n    }\n    if (eventName === 'viewport') {\n        r.redrawHint('select', true);\n    }\n    if (eventName === 'gc') {\n        r.redrawHint('gc', true);\n    }\n    if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {\n        r.invalidateContainerClientCoordsCache();\n        r.matchCanvasSize(r.container);\n    }\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    this.startRenderLoop();\n    this.redraw();\n};\nBRp.destroy = function() {\n    var r = this;\n    r.destroyed = true;\n    r.cy.stopAnimationLoop();\n    for(var i = 0; i < r.bindings.length; i++){\n        var binding = r.bindings[i];\n        var b = binding;\n        var tgt = b.target;\n        (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n    }\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.onUpdateEleCalcsFns = [];\n    if (r.removeObserver) {\n        r.removeObserver.disconnect();\n    }\n    if (r.styleObserver) {\n        r.styleObserver.disconnect();\n    }\n    if (r.resizeObserver) {\n        r.resizeObserver.disconnect();\n    }\n    if (r.labelCalcDiv) {\n        try {\n            document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n        } catch (e) {\n        // ie10 issue #1014\n        }\n    }\n};\nBRp.isHeadless = function() {\n    return false;\n};\n[\n    BRp$f,\n    BRp$5,\n    BRp$4,\n    BRp$3,\n    BRp$2,\n    BRp$1\n].forEach(function(props) {\n    extend(BRp, props);\n});\nvar fullFpsTime = 1000 / 60; // assume 60 frames per second\nvar defs = {\n    setupDequeueing: function setupDequeueing(opts) {\n        return function setupDequeueingImpl() {\n            var self1 = this;\n            var r = this.renderer;\n            if (self1.dequeueingSetup) {\n                return;\n            } else {\n                self1.dequeueingSetup = true;\n            }\n            var queueRedraw = debounce(function() {\n                r.redrawHint('eles', true);\n                r.redrawHint('drag', true);\n                r.redraw();\n            }, opts.deqRedrawThreshold);\n            var dequeue = function dequeue(willDraw, frameStartTime) {\n                var startTime = performanceNow();\n                var avgRenderTime = r.averageRedrawTime;\n                var renderTime = r.lastRedrawTime;\n                var deqd = [];\n                var extent = r.cy.extent();\n                var pixelRatio = r.getPixelRatio();\n                // if we aren't in a tick that causes a draw, then the rendered style\n                // queue won't automatically be flushed before dequeueing starts\n                if (!willDraw) {\n                    r.flushRenderedStyleQueue();\n                }\n                while(true){\n                    // eslint-disable-line no-constant-condition\n                    var now = performanceNow();\n                    var duration = now - startTime;\n                    var frameDuration = now - frameStartTime;\n                    if (renderTime < fullFpsTime) {\n                        // if we're rendering faster than the ideal fps, then do dequeueing\n                        // during all of the remaining frame time\n                        var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n                        if (frameDuration >= opts.deqFastCost * timeAvailable) {\n                            break;\n                        }\n                    } else {\n                        if (willDraw) {\n                            if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                                break;\n                            }\n                        } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n                            break;\n                        }\n                    }\n                    var thisDeqd = opts.deq(self1, pixelRatio, extent);\n                    if (thisDeqd.length > 0) {\n                        for(var i = 0; i < thisDeqd.length; i++){\n                            deqd.push(thisDeqd[i]);\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                // callbacks on dequeue\n                if (deqd.length > 0) {\n                    opts.onDeqd(self1, deqd);\n                    if (!willDraw && opts.shouldRedraw(self1, deqd, pixelRatio, extent)) {\n                        queueRedraw();\n                    }\n                }\n            };\n            var priority = opts.priority || noop$1;\n            r.beforeRender(dequeue, priority(self1));\n        };\n    }\n};\n// Allows lookups for (ele, lvl) => cache.\n// Uses keys so elements may share the same cache.\nvar ElementTextureCacheLookup = /*#__PURE__*/ function() {\n    function ElementTextureCacheLookup(getKey) {\n        var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n        _classCallCheck(this, ElementTextureCacheLookup);\n        this.idsByKey = new Map$1();\n        this.keyForId = new Map$1();\n        this.cachesByLvl = new Map$1();\n        this.lvls = [];\n        this.getKey = getKey;\n        this.doesEleInvalidateKey = doesEleInvalidateKey;\n    }\n    return _createClass(ElementTextureCacheLookup, [\n        {\n            key: \"getIdsFor\",\n            value: function getIdsFor(key) {\n                if (key == null) {\n                    error(\"Can not get id list for null key\");\n                }\n                var idsByKey = this.idsByKey;\n                var ids = this.idsByKey.get(key);\n                if (!ids) {\n                    ids = new Set$1();\n                    idsByKey.set(key, ids);\n                }\n                return ids;\n            }\n        },\n        {\n            key: \"addIdForKey\",\n            value: function addIdForKey(key, id) {\n                if (key != null) {\n                    this.getIdsFor(key).add(id);\n                }\n            }\n        },\n        {\n            key: \"deleteIdForKey\",\n            value: function deleteIdForKey(key, id) {\n                if (key != null) {\n                    this.getIdsFor(key)[\"delete\"](id);\n                }\n            }\n        },\n        {\n            key: \"getNumberOfIdsForKey\",\n            value: function getNumberOfIdsForKey(key) {\n                if (key == null) {\n                    return 0;\n                } else {\n                    return this.getIdsFor(key).size;\n                }\n            }\n        },\n        {\n            key: \"updateKeyMappingFor\",\n            value: function updateKeyMappingFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                var currKey = this.getKey(ele);\n                this.deleteIdForKey(prevKey, id);\n                this.addIdForKey(currKey, id);\n                this.keyForId.set(id, currKey);\n            }\n        },\n        {\n            key: \"deleteKeyMappingFor\",\n            value: function deleteKeyMappingFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                this.deleteIdForKey(prevKey, id);\n                this.keyForId[\"delete\"](id);\n            }\n        },\n        {\n            key: \"keyHasChangedFor\",\n            value: function keyHasChangedFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                var newKey = this.getKey(ele);\n                return prevKey !== newKey;\n            }\n        },\n        {\n            key: \"isInvalid\",\n            value: function isInvalid(ele) {\n                return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n            }\n        },\n        {\n            key: \"getCachesAt\",\n            value: function getCachesAt(lvl) {\n                var cachesByLvl = this.cachesByLvl, lvls = this.lvls;\n                var caches = cachesByLvl.get(lvl);\n                if (!caches) {\n                    caches = new Map$1();\n                    cachesByLvl.set(lvl, caches);\n                    lvls.push(lvl);\n                }\n                return caches;\n            }\n        },\n        {\n            key: \"getCache\",\n            value: function getCache(key, lvl) {\n                return this.getCachesAt(lvl).get(key);\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(ele, lvl) {\n                var key = this.getKey(ele);\n                var cache = this.getCache(key, lvl);\n                // getting for an element may need to add to the id list b/c eles can share keys\n                if (cache != null) {\n                    this.updateKeyMappingFor(ele);\n                }\n                return cache;\n            }\n        },\n        {\n            key: \"getForCachedKey\",\n            value: function getForCachedKey(ele, lvl) {\n                var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n                var cache = this.getCache(key, lvl);\n                return cache;\n            }\n        },\n        {\n            key: \"hasCache\",\n            value: function hasCache(key, lvl) {\n                return this.getCachesAt(lvl).has(key);\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(ele, lvl) {\n                var key = this.getKey(ele);\n                return this.hasCache(key, lvl);\n            }\n        },\n        {\n            key: \"setCache\",\n            value: function setCache(key, lvl, cache) {\n                cache.key = key;\n                this.getCachesAt(lvl).set(key, cache);\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(ele, lvl, cache) {\n                var key = this.getKey(ele);\n                this.setCache(key, lvl, cache);\n                this.updateKeyMappingFor(ele);\n            }\n        },\n        {\n            key: \"deleteCache\",\n            value: function deleteCache(key, lvl) {\n                this.getCachesAt(lvl)[\"delete\"](key);\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(ele, lvl) {\n                var key = this.getKey(ele);\n                this.deleteCache(key, lvl);\n            }\n        },\n        {\n            key: \"invalidateKey\",\n            value: function invalidateKey(key) {\n                var _this = this;\n                this.lvls.forEach(function(lvl) {\n                    return _this.deleteCache(key, lvl);\n                });\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(ele) {\n                var id = ele.id();\n                var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n                this.deleteKeyMappingFor(ele);\n                var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n                if (entireKeyInvalidated) {\n                    // clear mapping for current key\n                    this.invalidateKey(key);\n                }\n                return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n            }\n        }\n    ]);\n}();\nvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\nvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\nvar minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\nvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\nvar defTxrWidth = 1024; // default/minimum texture width\nvar maxTxrW = 1024; // the maximum width of a texture\nvar maxTxrH = 1024; // the maximum height of a texture\nvar minUtility = 0.2; // if usage of texture is less than this, it is retired\nvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\nvar maxFullnessChecks = 10; // dequeued after this many checks\nvar deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\nvar deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\nvar getTxrReasons = {\n    dequeue: 'dequeue',\n    downscale: 'downscale',\n    highQuality: 'highQuality'\n};\nvar initDefaults = defaults$g({\n    getKey: null,\n    doesEleInvalidateKey: falsify,\n    drawElement: null,\n    getBoundingBox: null,\n    getRotationPoint: null,\n    getRotationOffset: null,\n    isVisible: trueify,\n    allowEdgeTxrCaching: true,\n    allowParentTxrCaching: true\n});\nvar ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n    var self1 = this;\n    self1.renderer = renderer;\n    self1.onDequeues = [];\n    var opts = initDefaults(initOptions);\n    extend(self1, opts);\n    self1.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n    self1.setupDequeueing();\n};\nvar ETCp = ElementTextureCache.prototype;\nETCp.reasons = getTxrReasons;\n// the list of textures in which new subtextures for elements can be placed\nETCp.getTextureQueue = function(txrH) {\n    var self1 = this;\n    self1.eleImgCaches = self1.eleImgCaches || {};\n    return self1.eleImgCaches[txrH] = self1.eleImgCaches[txrH] || [];\n};\n// the list of usused textures which can be recycled (in use in texture queue)\nETCp.getRetiredTextureQueue = function(txrH) {\n    var self1 = this;\n    var rtxtrQs = self1.eleImgCaches.retired = self1.eleImgCaches.retired || {};\n    var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n    return rtxtrQ;\n};\n// queue of element draw requests at different scale levels\nETCp.getElementQueue = function() {\n    var self1 = this;\n    var q = self1.eleCacheQueue = self1.eleCacheQueue || new Heap(function(a, b) {\n        return b.reqs - a.reqs;\n    });\n    return q;\n};\n// queue of element draw requests at different scale levels (element id lookup)\nETCp.getElementKeyToQueue = function() {\n    var self1 = this;\n    var k2q = self1.eleKeyToCacheQueue = self1.eleKeyToCacheQueue || {};\n    return k2q;\n};\nETCp.getElement = function(ele, bb, pxRatio, lvl, reason) {\n    var self1 = this;\n    var r = this.renderer;\n    var zoom = r.cy.zoom();\n    var lookup = this.lookup;\n    if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n        return null;\n    }\n    if (!self1.allowEdgeTxrCaching && ele.isEdge() || !self1.allowParentTxrCaching && ele.isParent()) {\n        return null;\n    }\n    if (lvl == null) {\n        lvl = Math.ceil(log2(zoom * pxRatio));\n    }\n    if (lvl < minLvl$1) {\n        lvl = minLvl$1;\n    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n        return null;\n    }\n    var scale = Math.pow(2, lvl);\n    var eleScaledH = bb.h * scale;\n    var eleScaledW = bb.w * scale;\n    var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n    if (!this.isVisible(ele, scaledLabelShown)) {\n        return null;\n    }\n    var eleCache = lookup.get(ele, lvl);\n    // if this get was on an unused/invalidated cache, then restore the texture usage metric\n    if (eleCache && eleCache.invalidated) {\n        eleCache.invalidated = false;\n        eleCache.texture.invalidatedWidth -= eleCache.width;\n    }\n    if (eleCache) {\n        return eleCache;\n    }\n    var txrH; // which texture height this ele belongs to\n    if (eleScaledH <= minTxrH) {\n        txrH = minTxrH;\n    } else if (eleScaledH <= txrStepH) {\n        txrH = txrStepH;\n    } else {\n        txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n    }\n    if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n        return null; // caching large elements is not efficient\n    }\n    var txrQ = self1.getTextureQueue(txrH);\n    // first try the second last one in case it has space at the end\n    var txr = txrQ[txrQ.length - 2];\n    var addNewTxr = function addNewTxr() {\n        return self1.recycleTexture(txrH, eleScaledW) || self1.addTexture(txrH, eleScaledW);\n    };\n    // try the last one if there is no second last one\n    if (!txr) {\n        txr = txrQ[txrQ.length - 1];\n    }\n    // if the last one doesn't exist, we need a first one\n    if (!txr) {\n        txr = addNewTxr();\n    }\n    // if there's no room in the current texture, we need a new one\n    if (txr.width - txr.usedWidth < eleScaledW) {\n        txr = addNewTxr();\n    }\n    var scalableFrom = function scalableFrom(otherCache) {\n        return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n    };\n    var deqing = reason && reason === getTxrReasons.dequeue;\n    var highQualityReq = reason && reason === getTxrReasons.highQuality;\n    var downscaleReq = reason && reason === getTxrReasons.downscale;\n    var higherCache; // the nearest cache with a higher level\n    for(var l = lvl + 1; l <= maxLvl$1; l++){\n        var c = lookup.get(ele, l);\n        if (c) {\n            higherCache = c;\n            break;\n        }\n    }\n    var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n    var downscale = function downscale() {\n        txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n    };\n    // reset ele area in texture\n    txr.context.setTransform(1, 0, 0, 1, 0, 0);\n    txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n    if (scalableFrom(oneUpCache)) {\n        // then we can relatively cheaply rescale the existing image w/o rerendering\n        downscale();\n    } else if (scalableFrom(higherCache)) {\n        // then use the higher cache for now and queue the next level down\n        // to cheaply scale towards the smaller level\n        if (highQualityReq) {\n            for(var _l = higherCache.level; _l > lvl; _l--){\n                oneUpCache = self1.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n            }\n            downscale();\n        } else {\n            self1.queueElement(ele, higherCache.level - 1);\n            return higherCache;\n        }\n    } else {\n        var lowerCache; // the nearest cache with a lower level\n        if (!deqing && !highQualityReq && !downscaleReq) {\n            for(var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--){\n                var _c = lookup.get(ele, _l2);\n                if (_c) {\n                    lowerCache = _c;\n                    break;\n                }\n            }\n        }\n        if (scalableFrom(lowerCache)) {\n            // then use the lower quality cache for now and queue the better one for later\n            self1.queueElement(ele, lvl);\n            return lowerCache;\n        }\n        txr.context.translate(txr.usedWidth, 0);\n        txr.context.scale(scale, scale);\n        this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n        txr.context.scale(1 / scale, 1 / scale);\n        txr.context.translate(-txr.usedWidth, 0);\n    }\n    eleCache = {\n        x: txr.usedWidth,\n        texture: txr,\n        level: lvl,\n        scale: scale,\n        width: eleScaledW,\n        height: eleScaledH,\n        scaledLabelShown: scaledLabelShown\n    };\n    txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n    txr.eleCaches.push(eleCache);\n    lookup.set(ele, lvl, eleCache);\n    self1.checkTextureFullness(txr);\n    return eleCache;\n};\nETCp.invalidateElements = function(eles) {\n    for(var i = 0; i < eles.length; i++){\n        this.invalidateElement(eles[i]);\n    }\n};\nETCp.invalidateElement = function(ele) {\n    var self1 = this;\n    var lookup = self1.lookup;\n    var caches = [];\n    var invalid = lookup.isInvalid(ele);\n    if (!invalid) {\n        return; // override the invalidation request if the element key has not changed\n    }\n    for(var lvl = minLvl$1; lvl <= maxLvl$1; lvl++){\n        var cache = lookup.getForCachedKey(ele, lvl);\n        if (cache) {\n            caches.push(cache);\n        }\n    }\n    var noOtherElesUseCache = lookup.invalidate(ele);\n    if (noOtherElesUseCache) {\n        for(var i = 0; i < caches.length; i++){\n            var _cache = caches[i];\n            var txr = _cache.texture;\n            // remove space from the texture it belongs to\n            txr.invalidatedWidth += _cache.width;\n            // mark the cache as invalidated\n            _cache.invalidated = true;\n            // retire the texture if its utility is low\n            self1.checkTextureUtility(txr);\n        }\n    }\n    // remove from queue since the old req was for the old state\n    self1.removeFromQueue(ele);\n};\nETCp.checkTextureUtility = function(txr) {\n    // invalidate all entries in the cache if the cache size is small\n    if (txr.invalidatedWidth >= minUtility * txr.width) {\n        this.retireTexture(txr);\n    }\n};\nETCp.checkTextureFullness = function(txr) {\n    // if texture has been mostly filled and passed over several times, remove\n    // it from the queue so we don't need to waste time looking at it to put new things\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txr.height);\n    if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n        removeFromArray(txrQ, txr);\n    } else {\n        txr.fullnessChecks++;\n    }\n};\nETCp.retireTexture = function(txr) {\n    var self1 = this;\n    var txrH = txr.height;\n    var txrQ = self1.getTextureQueue(txrH);\n    var lookup = this.lookup;\n    // retire the texture from the active / searchable queue:\n    removeFromArray(txrQ, txr);\n    txr.retired = true;\n    // remove the refs from the eles to the caches:\n    var eleCaches = txr.eleCaches;\n    for(var i = 0; i < eleCaches.length; i++){\n        var eleCache = eleCaches[i];\n        lookup.deleteCache(eleCache.key, eleCache.level);\n    }\n    clearArray(eleCaches);\n    // add the texture to a retired queue so it can be recycled in future:\n    var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n    rtxtrQ.push(txr);\n};\nETCp.addTexture = function(txrH, minW) {\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txrH);\n    var txr = {};\n    txrQ.push(txr);\n    txr.eleCaches = [];\n    txr.height = txrH;\n    txr.width = Math.max(defTxrWidth, minW);\n    txr.usedWidth = 0;\n    txr.invalidatedWidth = 0;\n    txr.fullnessChecks = 0;\n    txr.canvas = self1.renderer.makeOffscreenCanvas(txr.width, txr.height);\n    txr.context = txr.canvas.getContext('2d');\n    return txr;\n};\nETCp.recycleTexture = function(txrH, minW) {\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txrH);\n    var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n    for(var i = 0; i < rtxtrQ.length; i++){\n        var txr = rtxtrQ[i];\n        if (txr.width >= minW) {\n            txr.retired = false;\n            txr.usedWidth = 0;\n            txr.invalidatedWidth = 0;\n            txr.fullnessChecks = 0;\n            clearArray(txr.eleCaches);\n            txr.context.setTransform(1, 0, 0, 1, 0, 0);\n            txr.context.clearRect(0, 0, txr.width, txr.height);\n            removeFromArray(rtxtrQ, txr);\n            txrQ.push(txr);\n            return txr;\n        }\n    }\n};\nETCp.queueElement = function(ele, lvl) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var existingReq = k2q[key];\n    if (existingReq) {\n        // use the max lvl b/c in between lvls are cheap to make\n        existingReq.level = Math.max(existingReq.level, lvl);\n        existingReq.eles.merge(ele);\n        existingReq.reqs++;\n        q.updateItem(existingReq);\n    } else {\n        var req = {\n            eles: ele.spawn().merge(ele),\n            level: lvl,\n            reqs: 1,\n            key: key\n        };\n        q.push(req);\n        k2q[key] = req;\n    }\n};\nETCp.dequeue = function(pxRatio /*, extent*/ ) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var dequeued = [];\n    var lookup = self1.lookup;\n    for(var i = 0; i < maxDeqSize$1; i++){\n        if (q.size() > 0) {\n            var req = q.pop();\n            var key = req.key;\n            var ele = req.eles[0]; // all eles have the same key\n            var cacheExists = lookup.hasCache(ele, req.level);\n            // clear out the key to req lookup\n            k2q[key] = null;\n            // dequeueing isn't necessary with an existing cache\n            if (cacheExists) {\n                continue;\n            }\n            dequeued.push(req);\n            var bb = self1.getBoundingBox(ele);\n            self1.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n        } else {\n            break;\n        }\n    }\n    return dequeued;\n};\nETCp.removeFromQueue = function(ele) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var req = k2q[key];\n    if (req != null) {\n        if (req.eles.length === 1) {\n            // remove if last ele in the req\n            // bring to front of queue\n            req.reqs = MAX_INT$1;\n            q.updateItem(req);\n            q.pop(); // remove from queue\n            k2q[key] = null; // remove from lookup map\n        } else {\n            // otherwise just remove ele from req\n            req.eles.unmerge(ele);\n        }\n    }\n};\nETCp.onDequeue = function(fn) {\n    this.onDequeues.push(fn);\n};\nETCp.offDequeue = function(fn) {\n    removeFromArray(this.onDequeues, fn);\n};\nETCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold$1,\n    deqCost: deqCost$1,\n    deqAvgCost: deqAvgCost$1,\n    deqNoDrawCost: deqNoDrawCost$1,\n    deqFastCost: deqFastCost$1,\n    deq: function deq(self1, pxRatio, extent) {\n        return self1.dequeue(pxRatio, extent);\n    },\n    onDeqd: function onDeqd(self1, deqd) {\n        for(var i = 0; i < self1.onDequeues.length; i++){\n            var fn = self1.onDequeues[i];\n            fn(deqd);\n        }\n    },\n    shouldRedraw: function shouldRedraw(self1, deqd, pxRatio, extent) {\n        for(var i = 0; i < deqd.length; i++){\n            var eles = deqd[i].eles;\n            for(var j = 0; j < eles.length; j++){\n                var bb = eles[j].boundingBox();\n                if (boundingBoxesIntersect(bb, extent)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    priority: function priority(self1) {\n        return self1.renderer.beforeRenderPriorities.eleTxrDeq;\n    }\n});\nvar defNumLayers = 1; // default number of layers to use\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\nvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\nvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\nvar maxLayerDim = 32767; // maximum size for the width/height of layer canvases\nvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n// var log = function(){ console.log.apply( console, arguments ); };\nvar LayeredTextureCache = function LayeredTextureCache(renderer) {\n    var self1 = this;\n    var r = self1.renderer = renderer;\n    var cy = r.cy;\n    self1.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n    self1.firstGet = true;\n    self1.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n    self1.skipping = false;\n    self1.eleTxrDeqs = cy.collection();\n    self1.scheduleElementRefinement = debounce(function() {\n        self1.refineElementTextures(self1.eleTxrDeqs);\n        self1.eleTxrDeqs.unmerge(self1.eleTxrDeqs);\n    }, refineEleDebounceTime);\n    r.beforeRender(function(willDraw, now) {\n        if (now - self1.lastInvalidationTime <= invalidThreshold) {\n            self1.skipping = true;\n        } else {\n            self1.skipping = false;\n        }\n    }, r.beforeRenderPriorities.lyrTxrSkip);\n    var qSort = function qSort(a, b) {\n        return b.reqs - a.reqs;\n    };\n    self1.layersQueue = new Heap(qSort);\n    self1.setupDequeueing();\n};\nvar LTCp = LayeredTextureCache.prototype;\nvar layerIdPool = 0;\nvar MAX_INT = Math.pow(2, 53) - 1;\nLTCp.makeLayer = function(bb, lvl) {\n    var scale = Math.pow(2, lvl);\n    var w = Math.ceil(bb.w * scale);\n    var h = Math.ceil(bb.h * scale);\n    var canvas = this.renderer.makeOffscreenCanvas(w, h);\n    var layer = {\n        id: layerIdPool = ++layerIdPool % MAX_INT,\n        bb: bb,\n        level: lvl,\n        width: w,\n        height: h,\n        canvas: canvas,\n        context: canvas.getContext('2d'),\n        eles: [],\n        elesQueue: [],\n        reqs: 0\n    };\n    // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n    var cxt = layer.context;\n    var dx = -layer.bb.x1;\n    var dy = -layer.bb.y1;\n    // do the transform on creation to save cycles (it's the same for all eles)\n    cxt.scale(scale, scale);\n    cxt.translate(dx, dy);\n    return layer;\n};\nLTCp.getLayers = function(eles, pxRatio, lvl) {\n    var self1 = this;\n    var r = self1.renderer;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var firstGet = self1.firstGet;\n    self1.firstGet = false;\n    // log('--\\nget layers with %s eles', eles.length);\n    //log eles.map(function(ele){ return ele.id() }) );\n    if (lvl == null) {\n        lvl = Math.ceil(log2(zoom * pxRatio));\n        if (lvl < minLvl) {\n            lvl = minLvl;\n        } else if (zoom >= maxZoom || lvl > maxLvl) {\n            return null;\n        }\n    }\n    self1.validateLayersElesOrdering(lvl, eles);\n    var layersByLvl = self1.layersByLevel;\n    var scale = Math.pow(2, lvl);\n    var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n    var bb;\n    var lvlComplete = self1.levelIsComplete(lvl, eles);\n    var tmpLayers;\n    var checkTempLevels = function checkTempLevels() {\n        var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n            self1.validateLayersElesOrdering(l, eles);\n            if (self1.levelIsComplete(l, eles)) {\n                tmpLayers = layersByLvl[l];\n                return true;\n            }\n        };\n        var checkLvls = function checkLvls(dir) {\n            if (tmpLayers) {\n                return;\n            }\n            for(var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir){\n                if (canUseAsTmpLvl(l)) {\n                    break;\n                }\n            }\n        };\n        checkLvls(1);\n        checkLvls(-1);\n        // remove the invalid layers; they will be replaced as needed later in this function\n        for(var i = layers.length - 1; i >= 0; i--){\n            var layer = layers[i];\n            if (layer.invalid) {\n                removeFromArray(layers, layer);\n            }\n        }\n    };\n    if (!lvlComplete) {\n        // if the current level is incomplete, then use the closest, best quality layerset temporarily\n        // and later queue the current layerset so we can get the proper quality level soon\n        checkTempLevels();\n    } else {\n        // log('level complete, using existing layers\\n--');\n        return layers;\n    }\n    var getBb = function getBb() {\n        if (!bb) {\n            bb = makeBoundingBox();\n            for(var i = 0; i < eles.length; i++){\n                updateBoundingBox(bb, eles[i].boundingBox());\n            }\n        }\n        return bb;\n    };\n    var makeLayer = function makeLayer(opts) {\n        opts = opts || {};\n        var after = opts.after;\n        getBb();\n        var w = Math.ceil(bb.w * scale);\n        var h = Math.ceil(bb.h * scale);\n        if (w > maxLayerDim || h > maxLayerDim) {\n            return null;\n        }\n        var area = w * h;\n        if (area > maxLayerArea) {\n            return null;\n        }\n        var layer = self1.makeLayer(bb, lvl);\n        if (after != null) {\n            var index = layers.indexOf(after) + 1;\n            layers.splice(index, 0, layer);\n        } else if (opts.insert === undefined || opts.insert) {\n            // no after specified => first layer made so put at start\n            layers.unshift(layer);\n        }\n        // if( tmpLayers ){\n        //self.queueLayer( layer );\n        // }\n        return layer;\n    };\n    if (self1.skipping && !firstGet) {\n        // log('skip layers');\n        return null;\n    }\n    // log('do layers');\n    var layer = null;\n    var maxElesPerLayer = eles.length / defNumLayers;\n    var allowLazyQueueing = !firstGet;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var rs = ele._private.rscratch;\n        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n        // log('look at ele', ele.id());\n        var existingLayer = caches[lvl];\n        if (existingLayer) {\n            // reuse layer for later eles\n            // log('reuse layer for', ele.id());\n            layer = existingLayer;\n            continue;\n        }\n        if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n            // log('make new layer for ele %s', ele.id());\n            layer = makeLayer({\n                insert: true,\n                after: layer\n            });\n            // if now layer can be built then we can't use layers at this level\n            if (!layer) {\n                return null;\n            }\n        // log('new layer with id %s', layer.id);\n        }\n        if (tmpLayers || allowLazyQueueing) {\n            // log('queue ele %s in layer %s', ele.id(), layer.id);\n            self1.queueLayer(layer, ele);\n        } else {\n            // log('draw ele %s in layer %s', ele.id(), layer.id);\n            self1.drawEleInLayer(layer, ele, lvl, pxRatio);\n        }\n        layer.eles.push(ele);\n        caches[lvl] = layer;\n    }\n    // log('--');\n    if (tmpLayers) {\n        // then we only queued the current layerset and can't draw it yet\n        return tmpLayers;\n    }\n    if (allowLazyQueueing) {\n        // log('lazy queue level', lvl);\n        return null;\n    }\n    return layers;\n};\n// a layer may want to use an ele cache of a higher level to avoid blurriness\n// so the layer level might not equal the ele level\nLTCp.getEleLevelForLayerLevel = function(lvl, pxRatio) {\n    return lvl;\n};\nLTCp.drawEleInLayer = function(layer, ele, lvl, pxRatio) {\n    var self1 = this;\n    var r = this.renderer;\n    var context = layer.context;\n    var bb = ele.boundingBox();\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n        return;\n    }\n    lvl = self1.getEleLevelForLayerLevel(lvl, pxRatio);\n    {\n        r.setImgSmoothing(context, false);\n    }\n    {\n        r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n    }\n    {\n        r.setImgSmoothing(context, true);\n    }\n};\nLTCp.levelIsComplete = function(lvl, eles) {\n    var self1 = this;\n    var layers = self1.layersByLevel[lvl];\n    if (!layers || layers.length === 0) {\n        return false;\n    }\n    var numElesInLayers = 0;\n    for(var i = 0; i < layers.length; i++){\n        var layer = layers[i];\n        // if there are any eles needed to be drawn yet, the level is not complete\n        if (layer.reqs > 0) {\n            return false;\n        }\n        // if the layer is invalid, the level is not complete\n        if (layer.invalid) {\n            return false;\n        }\n        numElesInLayers += layer.eles.length;\n    }\n    // we should have exactly the number of eles passed in to be complete\n    if (numElesInLayers !== eles.length) {\n        return false;\n    }\n    return true;\n};\nLTCp.validateLayersElesOrdering = function(lvl, eles) {\n    var layers = this.layersByLevel[lvl];\n    if (!layers) {\n        return;\n    }\n    // if in a layer the eles are not in the same order, then the layer is invalid\n    // (i.e. there is an ele in between the eles in the layer)\n    for(var i = 0; i < layers.length; i++){\n        var layer = layers[i];\n        var offset = -1;\n        // find the offset\n        for(var j = 0; j < eles.length; j++){\n            if (layer.eles[0] === eles[j]) {\n                offset = j;\n                break;\n            }\n        }\n        if (offset < 0) {\n            // then the layer has nonexistent elements and is invalid\n            this.invalidateLayer(layer);\n            continue;\n        }\n        // the eles in the layer must be in the same continuous order, else the layer is invalid\n        var o = offset;\n        for(var j = 0; j < layer.eles.length; j++){\n            if (layer.eles[j] !== eles[o + j]) {\n                // log('invalidate based on ordering', layer.id);\n                this.invalidateLayer(layer);\n                break;\n            }\n        }\n    }\n};\nLTCp.updateElementsInLayers = function(eles, update) {\n    var self1 = this;\n    var isEles = element(eles[0]);\n    // collect udpated elements (cascaded from the layers) and update each\n    // layer itself along the way\n    for(var i = 0; i < eles.length; i++){\n        var req = isEles ? null : eles[i];\n        var ele = isEles ? eles[i] : eles[i].ele;\n        var rs = ele._private.rscratch;\n        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n        for(var l = minLvl; l <= maxLvl; l++){\n            var layer = caches[l];\n            if (!layer) {\n                continue;\n            }\n            // if update is a request from the ele cache, then it affects only\n            // the matching level\n            if (req && self1.getEleLevelForLayerLevel(layer.level) !== req.level) {\n                continue;\n            }\n            update(layer, ele, req);\n        }\n    }\n};\nLTCp.haveLayers = function() {\n    var self1 = this;\n    var haveLayers = false;\n    for(var l = minLvl; l <= maxLvl; l++){\n        var layers = self1.layersByLevel[l];\n        if (layers && layers.length > 0) {\n            haveLayers = true;\n            break;\n        }\n    }\n    return haveLayers;\n};\nLTCp.invalidateElements = function(eles) {\n    var self1 = this;\n    if (eles.length === 0) {\n        return;\n    }\n    self1.lastInvalidationTime = performanceNow();\n    // log('update invalidate layer time from eles');\n    if (eles.length === 0 || !self1.haveLayers()) {\n        return;\n    }\n    self1.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n        self1.invalidateLayer(layer);\n    });\n};\nLTCp.invalidateLayer = function(layer) {\n    // log('update invalidate layer time');\n    this.lastInvalidationTime = performanceNow();\n    if (layer.invalid) {\n        return;\n    } // save cycles\n    var lvl = layer.level;\n    var eles = layer.eles;\n    var layers = this.layersByLevel[lvl];\n    // log('invalidate layer', layer.id );\n    removeFromArray(layers, layer);\n    // layer.eles = [];\n    layer.elesQueue = [];\n    layer.invalid = true;\n    if (layer.replacement) {\n        layer.replacement.invalid = true;\n    }\n    for(var i = 0; i < eles.length; i++){\n        var caches = eles[i]._private.rscratch.imgLayerCaches;\n        if (caches) {\n            caches[lvl] = null;\n        }\n    }\n};\nLTCp.refineElementTextures = function(eles) {\n    var self1 = this;\n    // log('refine', eles.length);\n    self1.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n        var rLyr = layer.replacement;\n        if (!rLyr) {\n            rLyr = layer.replacement = self1.makeLayer(layer.bb, layer.level);\n            rLyr.replaces = layer;\n            rLyr.eles = layer.eles;\n        // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n        }\n        if (!rLyr.reqs) {\n            for(var i = 0; i < rLyr.eles.length; i++){\n                self1.queueLayer(rLyr, rLyr.eles[i]);\n            }\n        // log('queue replacement layer refinement', rLyr.id);\n        }\n    });\n};\nLTCp.enqueueElementRefinement = function(ele) {\n    this.eleTxrDeqs.merge(ele);\n    this.scheduleElementRefinement();\n};\nLTCp.queueLayer = function(layer, ele) {\n    var self1 = this;\n    var q = self1.layersQueue;\n    var elesQ = layer.elesQueue;\n    var hasId = elesQ.hasId = elesQ.hasId || {};\n    // if a layer is going to be replaced, queuing is a waste of time\n    if (layer.replacement) {\n        return;\n    }\n    if (ele) {\n        if (hasId[ele.id()]) {\n            return;\n        }\n        elesQ.push(ele);\n        hasId[ele.id()] = true;\n    }\n    if (layer.reqs) {\n        layer.reqs++;\n        q.updateItem(layer);\n    } else {\n        layer.reqs = 1;\n        q.push(layer);\n    }\n};\nLTCp.dequeue = function(pxRatio) {\n    var self1 = this;\n    var q = self1.layersQueue;\n    var deqd = [];\n    var eleDeqs = 0;\n    while(eleDeqs < maxDeqSize){\n        if (q.size() === 0) {\n            break;\n        }\n        var layer = q.peek();\n        // if a layer has been or will be replaced, then don't waste time with it\n        if (layer.replacement) {\n            // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n            q.pop();\n            continue;\n        }\n        // if this is a replacement layer that has been superceded, then forget it\n        if (layer.replaces && layer !== layer.replaces.replacement) {\n            // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n            q.pop();\n            continue;\n        }\n        if (layer.invalid) {\n            // log('replacement layer %s is invalid; dequeued', layer.id);\n            q.pop();\n            continue;\n        }\n        var ele = layer.elesQueue.shift();\n        if (ele) {\n            // log('dequeue layer %s', layer.id);\n            self1.drawEleInLayer(layer, ele, layer.level, pxRatio);\n            eleDeqs++;\n        }\n        if (deqd.length === 0) {\n            // we need only one entry in deqd to queue redrawing etc\n            deqd.push(true);\n        }\n        // if the layer has all its eles done, then remove from the queue\n        if (layer.elesQueue.length === 0) {\n            q.pop();\n            layer.reqs = 0;\n            // log('dequeue of layer %s complete', layer.id);\n            // when a replacement layer is dequeued, it replaces the old layer in the level\n            if (layer.replaces) {\n                self1.applyLayerReplacement(layer);\n            }\n            self1.requestRedraw();\n        }\n    }\n    return deqd;\n};\nLTCp.applyLayerReplacement = function(layer) {\n    var self1 = this;\n    var layersInLevel = self1.layersByLevel[layer.level];\n    var replaced = layer.replaces;\n    var index = layersInLevel.indexOf(replaced);\n    // if the replaced layer is not in the active list for the level, then replacing\n    // refs would be a mistake (i.e. overwriting the true active layer)\n    if (index < 0 || replaced.invalid) {\n        // log('replacement layer would have no effect', layer.id);\n        return;\n    }\n    layersInLevel[index] = layer; // replace level ref\n    // replace refs in eles\n    for(var i = 0; i < layer.eles.length; i++){\n        var _p = layer.eles[i]._private;\n        var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n        if (cache) {\n            cache[layer.level] = layer;\n        }\n    }\n    // log('apply replacement layer %s over %s', layer.id, replaced.id);\n    self1.requestRedraw();\n};\nLTCp.requestRedraw = debounce(function() {\n    var r = this.renderer;\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    r.redraw();\n}, 100);\nLTCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold,\n    deqCost: deqCost,\n    deqAvgCost: deqAvgCost,\n    deqNoDrawCost: deqNoDrawCost,\n    deqFastCost: deqFastCost,\n    deq: function deq(self1, pxRatio) {\n        return self1.dequeue(pxRatio);\n    },\n    onDeqd: noop$1,\n    shouldRedraw: trueify,\n    priority: function priority(self1) {\n        return self1.renderer.beforeRenderPriorities.lyrTxrDeq;\n    }\n});\nvar CRp$b = {};\nvar impl;\nfunction polygon(context, points) {\n    for(var i = 0; i < points.length; i++){\n        var pt = points[i];\n        context.lineTo(pt.x, pt.y);\n    }\n}\nfunction triangleBackcurve(context, points, controlPoint) {\n    var firstPt;\n    for(var i = 0; i < points.length; i++){\n        var pt = points[i];\n        if (i === 0) {\n            firstPt = pt;\n        }\n        context.lineTo(pt.x, pt.y);\n    }\n    context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n}\nfunction triangleTee(context, trianglePoints, teePoints) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    var triPts = trianglePoints;\n    for(var i = 0; i < triPts.length; i++){\n        var pt = triPts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    var teePts = teePoints;\n    var firstTeePt = teePoints[0];\n    context.moveTo(firstTeePt.x, firstTeePt.y);\n    for(var i = 1; i < teePts.length; i++){\n        var pt = teePts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    if (context.closePath) {\n        context.closePath();\n    }\n}\nfunction circleTriangle(context, trianglePoints, rx, ry, r) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n    var triPts = trianglePoints;\n    var firstTrPt = triPts[0];\n    context.moveTo(firstTrPt.x, firstTrPt.y);\n    for(var i = 0; i < triPts.length; i++){\n        var pt = triPts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    if (context.closePath) {\n        context.closePath();\n    }\n}\nfunction circle$1(context, rx, ry, r) {\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n}\nCRp$b.arrowShapeImpl = function(name) {\n    return (impl || (impl = {\n        'polygon': polygon,\n        'triangle-backcurve': triangleBackcurve,\n        'triangle-tee': triangleTee,\n        'circle-triangle': circleTriangle,\n        'triangle-cross': triangleTee,\n        'circle': circle$1\n    }))[name];\n};\nvar CRp$a = {};\nCRp$a.drawElement = function(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    } else {\n        r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    }\n};\nCRp$a.drawElementOverlay = function(context, ele) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNodeOverlay(context, ele);\n    } else {\n        r.drawEdgeOverlay(context, ele);\n    }\n};\nCRp$a.drawElementUnderlay = function(context, ele) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNodeUnderlay(context, ele);\n    } else {\n        r.drawEdgeUnderlay(context, ele);\n    }\n};\nCRp$a.drawCachedElementPortion = function(context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n    var r = this;\n    var bb = eleTxrCache.getBoundingBox(ele);\n    if (bb.w === 0 || bb.h === 0) {\n        return;\n    } // ignore zero size case\n    var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n    if (eleCache != null) {\n        var opacity = getOpacity(r, ele);\n        if (opacity === 0) {\n            return;\n        }\n        var theta = getRotation(r, ele);\n        var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h;\n        var x, y, sx, sy, smooth;\n        if (theta !== 0) {\n            var rotPt = eleTxrCache.getRotationPoint(ele);\n            sx = rotPt.x;\n            sy = rotPt.y;\n            context.translate(sx, sy);\n            context.rotate(theta);\n            smooth = r.getImgSmoothing(context);\n            if (!smooth) {\n                r.setImgSmoothing(context, true);\n            }\n            var off = eleTxrCache.getRotationOffset(ele);\n            x = off.x;\n            y = off.y;\n        } else {\n            x = x1;\n            y = y1;\n        }\n        var oldGlobalAlpha;\n        if (opacity !== 1) {\n            oldGlobalAlpha = context.globalAlpha;\n            context.globalAlpha = oldGlobalAlpha * opacity;\n        }\n        context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n        if (opacity !== 1) {\n            context.globalAlpha = oldGlobalAlpha;\n        }\n        if (theta !== 0) {\n            context.rotate(-theta);\n            context.translate(-sx, -sy);\n            if (!smooth) {\n                r.setImgSmoothing(context, false);\n            }\n        }\n    } else {\n        eleTxrCache.drawElement(context, ele); // direct draw fallback\n    }\n};\nvar getZeroRotation = function getZeroRotation() {\n    return 0;\n};\nvar getLabelRotation = function getLabelRotation(r, ele) {\n    return r.getTextAngle(ele, null);\n};\nvar getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'source');\n};\nvar getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'target');\n};\nvar getOpacity = function getOpacity(r, ele) {\n    return ele.effectiveOpacity();\n};\nvar getTextOpacity = function getTextOpacity(e, ele) {\n    return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();\n};\nCRp$a.drawCachedElement = function(context, ele, pxRatio, extent, lvl, requestHighQuality) {\n    var r = this;\n    var _r$data = r.data, eleTxrCache = _r$data.eleTxrCache, lblTxrCache = _r$data.lblTxrCache, slbTxrCache = _r$data.slbTxrCache, tlbTxrCache = _r$data.tlbTxrCache;\n    var bb = ele.boundingBox();\n    var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n        return;\n    }\n    if (!extent || boundingBoxesIntersect(bb, extent)) {\n        var isEdge = ele.isEdge();\n        var badLine = ele.element()._private.rscratch.badLine;\n        r.drawElementUnderlay(context, ele);\n        r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n        if (!isEdge || !badLine) {\n            r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n        }\n        if (isEdge && !badLine) {\n            r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n            r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n        }\n        r.drawElementOverlay(context, ele);\n    }\n};\nCRp$a.drawElements = function(context, eles) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        r.drawElement(context, ele);\n    }\n};\nCRp$a.drawCachedElements = function(context, eles, pxRatio, extent) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n};\nCRp$a.drawCachedNodes = function(context, eles, pxRatio, extent) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (!ele.isNode()) {\n            continue;\n        }\n        r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n};\nCRp$a.drawLayeredElements = function(context, eles, pxRatio, extent) {\n    var r = this;\n    var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n    if (layers) {\n        for(var i = 0; i < layers.length; i++){\n            var layer = layers[i];\n            var bb = layer.bb;\n            if (bb.w === 0 || bb.h === 0) {\n                continue;\n            }\n            context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n        }\n    } else {\n        // fall back on plain caching if no layers\n        r.drawCachedElements(context, eles, pxRatio, extent);\n    }\n};\nvar CRp$9 = {};\nCRp$9.drawEdge = function(context, edge, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var rs = edge._private.rscratch;\n    if (shouldDrawOpacity && !edge.visible()) {\n        return;\n    }\n    // if bezier ctrl pts can not be calculated, then die\n    if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n        // isNaN in case edge is impossible and browser bugs (e.g. safari)\n        return;\n    }\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;\n    var lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var lineStyle = edge.pstyle('line-style').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var lineCap = edge.pstyle('line-cap').value;\n    var lineOutlineWidth = edge.pstyle('line-outline-width').value;\n    var lineOutlineColor = edge.pstyle('line-outline-color').value;\n    var effectiveLineOpacity = opacity * lineOpacity;\n    // separate arrow opacity would require arrow-opacity property\n    var effectiveArrowOpacity = opacity * lineOpacity;\n    var drawLine = function drawLine() {\n        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n        if (curveStyle === 'straight-triangle') {\n            r.eleStrokeStyle(context, edge, strokeOpacity);\n            r.drawEdgeTrianglePath(edge, context, rs.allpts);\n        } else {\n            context.lineWidth = edgeWidth;\n            context.lineCap = lineCap;\n            r.eleStrokeStyle(context, edge, strokeOpacity);\n            r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n            context.lineCap = 'butt'; // reset for other drawing functions\n        }\n    };\n    var drawLineOutline = function drawLineOutline() {\n        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n        context.lineWidth = edgeWidth + lineOutlineWidth;\n        context.lineCap = lineCap;\n        if (lineOutlineWidth > 0) {\n            r.colorStrokeStyle(context, lineOutlineColor[0], lineOutlineColor[1], lineOutlineColor[2], strokeOpacity);\n        } else {\n            // do not draw any lineOutline\n            context.lineCap = 'butt'; // reset for other drawing functions\n            return;\n        }\n        if (curveStyle === 'straight-triangle') {\n            r.drawEdgeTrianglePath(edge, context, rs.allpts);\n        } else {\n            r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n            context.lineCap = 'butt'; // reset for other drawing functions\n        }\n    };\n    var drawOverlay = function drawOverlay() {\n        if (!shouldDrawOverlay) {\n            return;\n        }\n        r.drawEdgeOverlay(context, edge);\n    };\n    var drawUnderlay = function drawUnderlay() {\n        if (!shouldDrawOverlay) {\n            return;\n        }\n        r.drawEdgeUnderlay(context, edge);\n    };\n    var drawArrows = function drawArrows() {\n        var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n        r.drawArrowheads(context, edge, arrowOpacity);\n    };\n    var drawText = function drawText() {\n        r.drawElementText(context, edge, null, drawLabel);\n    };\n    context.lineJoin = 'round';\n    var ghost = edge.pstyle('ghost').value === 'yes';\n    if (ghost) {\n        var gx = edge.pstyle('ghost-offset-x').pfValue;\n        var gy = edge.pstyle('ghost-offset-y').pfValue;\n        var ghostOpacity = edge.pstyle('ghost-opacity').value;\n        var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n        context.translate(gx, gy);\n        drawLine(effectiveGhostOpacity);\n        drawArrows(effectiveGhostOpacity);\n        context.translate(-gx, -gy);\n    } else {\n        drawLineOutline();\n    }\n    drawUnderlay();\n    drawLine();\n    drawArrows();\n    drawOverlay();\n    drawText();\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nvar drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n    if (![\n        'overlay',\n        'underlay'\n    ].includes(overlayOrUnderlay)) {\n        throw new Error('Invalid state');\n    }\n    return function(context, edge) {\n        if (!edge.visible()) {\n            return;\n        }\n        var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n        if (opacity === 0) {\n            return;\n        }\n        var r = this;\n        var usePaths = r.usePaths();\n        var rs = edge._private.rscratch;\n        var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n        var width = 2 * padding;\n        var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n        context.lineWidth = width;\n        if (rs.edgeType === 'self' && !usePaths) {\n            context.lineCap = 'butt';\n        } else {\n            context.lineCap = 'round';\n        }\n        r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n        r.drawEdgePath(edge, context, rs.allpts, 'solid');\n    };\n};\nCRp$9.drawEdgeOverlay = drawEdgeOverlayUnderlay('overlay');\nCRp$9.drawEdgeUnderlay = drawEdgeOverlayUnderlay('underlay');\nCRp$9.drawEdgePath = function(edge, context, pts, type) {\n    var rs = edge._private.rscratch;\n    var canvasCxt = context;\n    var path;\n    var pathCacheHit = false;\n    var usePaths = this.usePaths();\n    var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;\n    var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;\n    if (usePaths) {\n        var pathCacheKey = pts.join('$');\n        var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n        if (keyMatches) {\n            path = context = rs.pathCache;\n            pathCacheHit = true;\n        } else {\n            path = context = new Path2D();\n            rs.pathCacheKey = pathCacheKey;\n            rs.pathCache = path;\n        }\n    }\n    if (canvasCxt.setLineDash) {\n        // for very outofdate browsers\n        switch(type){\n            case 'dotted':\n                canvasCxt.setLineDash([\n                    1,\n                    1\n                ]);\n                break;\n            case 'dashed':\n                canvasCxt.setLineDash(lineDashPattern);\n                canvasCxt.lineDashOffset = lineDashOffset;\n                break;\n            case 'solid':\n                canvasCxt.setLineDash([]);\n                break;\n        }\n    }\n    if (!pathCacheHit && !rs.badLine) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        context.moveTo(pts[0], pts[1]);\n        switch(rs.edgeType){\n            case 'bezier':\n            case 'self':\n            case 'compound':\n            case 'multibezier':\n                for(var i = 2; i + 3 < pts.length; i += 4){\n                    context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n                }\n                break;\n            case 'straight':\n            case 'haystack':\n                for(var _i = 2; _i + 1 < pts.length; _i += 2){\n                    context.lineTo(pts[_i], pts[_i + 1]);\n                }\n                break;\n            case 'segments':\n                if (rs.isRound) {\n                    var _iterator = _createForOfIteratorHelper(rs.roundCorners), _step;\n                    try {\n                        for(_iterator.s(); !(_step = _iterator.n()).done;){\n                            var corner = _step.value;\n                            drawPreparedRoundCorner(context, corner);\n                        }\n                    } catch (err) {\n                        _iterator.e(err);\n                    } finally{\n                        _iterator.f();\n                    }\n                    context.lineTo(pts[pts.length - 2], pts[pts.length - 1]);\n                } else {\n                    for(var _i2 = 2; _i2 + 1 < pts.length; _i2 += 2){\n                        context.lineTo(pts[_i2], pts[_i2 + 1]);\n                    }\n                }\n                break;\n        }\n    }\n    context = canvasCxt;\n    if (usePaths) {\n        context.stroke(path);\n    } else {\n        context.stroke();\n    }\n    // reset any line dashes\n    if (context.setLineDash) {\n        // for very outofdate browsers\n        context.setLineDash([]);\n    }\n};\nCRp$9.drawEdgeTrianglePath = function(edge, context, pts) {\n    // use line stroke style for triangle fill style\n    context.fillStyle = context.strokeStyle;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    for(var i = 0; i + 1 < pts.length; i += 2){\n        var vector = [\n            pts[i + 2] - pts[i],\n            pts[i + 3] - pts[i + 1]\n        ];\n        var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n        var normal = [\n            vector[1] / length,\n            -vector[0] / length\n        ];\n        var triangleHead = [\n            normal[0] * edgeWidth / 2,\n            normal[1] * edgeWidth / 2\n        ];\n        context.beginPath();\n        context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n        context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n        context.lineTo(pts[i + 2], pts[i + 3]);\n        context.closePath();\n        context.fill();\n    }\n};\nCRp$9.drawArrowheads = function(context, edge, opacity) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n    if (!isHaystack) {\n        this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n    }\n    this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n    this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n    if (!isHaystack) {\n        this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n    }\n};\nCRp$9.drawArrowhead = function(context, edge, prefix, x, y, angle, opacity) {\n    if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n        return;\n    }\n    var self1 = this;\n    var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n    if (arrowShape === 'none') {\n        return;\n    }\n    var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n    var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var pArrowWidth = edge.pstyle(prefix + '-arrow-width');\n    var arrowWidth = pArrowWidth.value === 'match-line' ? edgeWidth : pArrowWidth.pfValue;\n    if (pArrowWidth.units === '%') arrowWidth *= edgeWidth;\n    var edgeOpacity = edge.pstyle('opacity').value;\n    if (opacity === undefined) {\n        opacity = edgeOpacity;\n    }\n    var gco = context.globalCompositeOperation;\n    if (opacity !== 1 || arrowFill === 'hollow') {\n        // then extra clear is needed\n        context.globalCompositeOperation = 'destination-out';\n        self1.colorFillStyle(context, 255, 255, 255, 1);\n        self1.colorStrokeStyle(context, 255, 255, 255, 1);\n        self1.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n        context.globalCompositeOperation = gco;\n    } // otherwise, the opaque arrow clears it for free :)\n    var color = edge.pstyle(prefix + '-arrow-color').value;\n    self1.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    self1.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n    self1.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n};\nCRp$9.drawArrowShape = function(edge, context, fill, edgeWidth, shape, shapeWidth, x, y, angle) {\n    var r = this;\n    var usePaths = this.usePaths() && shape !== 'triangle-cross';\n    var pathCacheHit = false;\n    var path;\n    var canvasContext = context;\n    var translation = {\n        x: x,\n        y: y\n    };\n    var scale = edge.pstyle('arrow-scale').value;\n    var size = this.getArrowWidth(edgeWidth, scale);\n    var shapeImpl = r.arrowShapes[shape];\n    if (usePaths) {\n        var cache = r.arrowPathCache = r.arrowPathCache || [];\n        var key = hashString(shape);\n        var cachedPath = cache[key];\n        if (cachedPath != null) {\n            path = context = cachedPath;\n            pathCacheHit = true;\n        } else {\n            path = context = new Path2D();\n            cache[key] = path;\n        }\n    }\n    if (!pathCacheHit) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        if (usePaths) {\n            // store in the path cache with values easily manipulated later\n            shapeImpl.draw(context, 1, 0, {\n                x: 0,\n                y: 0\n            }, 1);\n        } else {\n            shapeImpl.draw(context, size, angle, translation, edgeWidth);\n        }\n        if (context.closePath) {\n            context.closePath();\n        }\n    }\n    context = canvasContext;\n    if (usePaths) {\n        // set transform to arrow position/orientation\n        context.translate(x, y);\n        context.rotate(angle);\n        context.scale(size, size);\n    }\n    if (fill === 'filled' || fill === 'both') {\n        if (usePaths) {\n            context.fill(path);\n        } else {\n            context.fill();\n        }\n    }\n    if (fill === 'hollow' || fill === 'both') {\n        context.lineWidth = shapeWidth / (usePaths ? size : 1);\n        context.lineJoin = 'miter';\n        if (usePaths) {\n            context.stroke(path);\n        } else {\n            context.stroke();\n        }\n    }\n    if (usePaths) {\n        // reset transform by applying inverse\n        context.scale(1 / size, 1 / size);\n        context.rotate(-angle);\n        context.translate(-x, -y);\n    }\n};\nvar CRp$8 = {};\nCRp$8.safeDrawImage = function(context, img, ix, iy, iw, ih, x, y, w, h) {\n    // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n    if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n        return;\n    }\n    try {\n        context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n    } catch (e) {\n        warn(e);\n    }\n};\nCRp$8.drawInscribedImage = function(context, img, node, index, nodeOpacity) {\n    var r = this;\n    var pos = node.position();\n    var nodeX = pos.x;\n    var nodeY = pos.y;\n    var styleObj = node.cy().style();\n    var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n    var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n    var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var paddingX2 = node.padding() * 2;\n    var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var rs = node._private.rscratch;\n    var clip = getIndexedStyle(node, 'background-clip', 'value', index);\n    var shouldClip = clip === 'node';\n    var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n    var smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);\n    var cornerRadius = node.pstyle('corner-radius').value;\n    if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;\n    var imgW = img.width || img.cachedW;\n    var imgH = img.height || img.cachedH;\n    // workaround for broken browsers like ie\n    if (null == imgW || null == imgH) {\n        document.body.appendChild(img); // eslint-disable-line no-undef\n        imgW = img.cachedW = img.width || img.offsetWidth;\n        imgH = img.cachedH = img.height || img.offsetHeight;\n        document.body.removeChild(img); // eslint-disable-line no-undef\n    }\n    var w = imgW;\n    var h = imgH;\n    if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n        if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n            w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n        } else {\n            w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n        }\n    }\n    if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n        if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n            h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n        } else {\n            h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n        }\n    }\n    if (w === 0 || h === 0) {\n        return; // no point in drawing empty image (and chrome is broken in this case)\n    }\n    if (fit === 'contain') {\n        var scale = Math.min(nodeTW / w, nodeTH / h);\n        w *= scale;\n        h *= scale;\n    } else if (fit === 'cover') {\n        var scale = Math.max(nodeTW / w, nodeTH / h);\n        w *= scale;\n        h *= scale;\n    }\n    var x = nodeX - nodeTW / 2; // left\n    var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);\n    var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n    if (posXUnits === '%') {\n        x += (nodeTW - w) * posXPfVal;\n    } else {\n        x += posXPfVal;\n    }\n    var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);\n    var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);\n    if (offXUnits === '%') {\n        x += (nodeTW - w) * offXPfVal;\n    } else {\n        x += offXPfVal;\n    }\n    var y = nodeY - nodeTH / 2; // top\n    var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);\n    var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n    if (posYUnits === '%') {\n        y += (nodeTH - h) * posYPfVal;\n    } else {\n        y += posYPfVal;\n    }\n    var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);\n    var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);\n    if (offYUnits === '%') {\n        y += (nodeTH - h) * offYPfVal;\n    } else {\n        y += offYPfVal;\n    }\n    if (rs.pathCache) {\n        x -= nodeX;\n        y -= nodeY;\n        nodeX = 0;\n        nodeY = 0;\n    }\n    var gAlpha = context.globalAlpha;\n    context.globalAlpha = imgOpacity;\n    var smoothingEnabled = r.getImgSmoothing(context);\n    var isSmoothingSwitched = false;\n    if (smooth === 'no' && smoothingEnabled) {\n        r.setImgSmoothing(context, false);\n        isSmoothingSwitched = true;\n    } else if (smooth === 'yes' && !smoothingEnabled) {\n        r.setImgSmoothing(context, true);\n        isSmoothingSwitched = true;\n    }\n    if (repeat === 'no-repeat') {\n        if (shouldClip) {\n            context.save();\n            if (rs.pathCache) {\n                context.clip(rs.pathCache);\n            } else {\n                r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n                context.clip();\n            }\n        }\n        r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n        if (shouldClip) {\n            context.restore();\n        }\n    } else {\n        var pattern = context.createPattern(img, repeat);\n        context.fillStyle = pattern;\n        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n        context.translate(x, y);\n        context.fill();\n        context.translate(-x, -y);\n    }\n    context.globalAlpha = gAlpha;\n    if (isSmoothingSwitched) {\n        r.setImgSmoothing(context, smoothingEnabled);\n    }\n};\nvar CRp$7 = {};\nCRp$7.eleTextBiggerThanMin = function(ele, scale) {\n    if (!scale) {\n        var zoom = ele.cy().zoom();\n        var pxRatio = this.getPixelRatio();\n        var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n        scale = Math.pow(2, lvl);\n    }\n    var computedSize = ele.pstyle('font-size').pfValue * scale;\n    var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n    if (computedSize < minSize) {\n        return false;\n    }\n    return true;\n};\nCRp$7.drawElementText = function(context, ele, shiftToOriginWithBb, force, prefix) {\n    var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    if (force == null) {\n        if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n            return;\n        }\n    } else if (force === false) {\n        return;\n    }\n    if (ele.isNode()) {\n        var label = ele.pstyle('label');\n        if (!label || !label.value) {\n            return;\n        }\n        var justification = r.getLabelJustification(ele);\n        context.textAlign = justification;\n        context.textBaseline = 'bottom';\n    } else {\n        var badLine = ele.element()._private.rscratch.badLine;\n        var _label = ele.pstyle('label');\n        var srcLabel = ele.pstyle('source-label');\n        var tgtLabel = ele.pstyle('target-label');\n        if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n            return;\n        }\n        context.textAlign = 'center';\n        context.textBaseline = 'bottom';\n    }\n    var applyRotation = !shiftToOriginWithBb;\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    if (prefix == null) {\n        r.drawText(context, ele, null, applyRotation, useEleOpacity);\n        if (ele.isEdge()) {\n            r.drawText(context, ele, 'source', applyRotation, useEleOpacity);\n            r.drawText(context, ele, 'target', applyRotation, useEleOpacity);\n        }\n    } else {\n        r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n    }\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nCRp$7.getFontCache = function(context) {\n    var cache;\n    this.fontCaches = this.fontCaches || [];\n    for(var i = 0; i < this.fontCaches.length; i++){\n        cache = this.fontCaches[i];\n        if (cache.context === context) {\n            return cache;\n        }\n    }\n    cache = {\n        context: context\n    };\n    this.fontCaches.push(cache);\n    return cache;\n};\n// set up canvas context with font\n// returns transformed text string\nCRp$7.setupTextStyle = function(context, ele) {\n    var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Font style\n    var labelStyle = ele.pstyle('font-style').strValue;\n    var labelSize = ele.pstyle('font-size').pfValue + 'px';\n    var labelFamily = ele.pstyle('font-family').strValue;\n    var labelWeight = ele.pstyle('font-weight').strValue;\n    var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;\n    var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n    var color = ele.pstyle('color').value;\n    var outlineColor = ele.pstyle('text-outline-color').value;\n    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n    context.lineJoin = 'round'; // so text outlines aren't jagged\n    this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n};\nfunction circle(ctx, x, y, width, height) {\n    var diameter = Math.min(width, height);\n    var radius = diameter / 2;\n    var centerX = x + width / 2;\n    var centerY = y + height / 2;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n    ctx.closePath();\n}\nfunction roundRect(ctx, x, y, width, height) {\n    var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n    var r = Math.min(radius, width / 2, height / 2); // prevent overflow\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + width - r, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + r);\n    ctx.lineTo(x + width, y + height - r);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);\n    ctx.lineTo(x + r, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n}\nCRp$7.getTextAngle = function(ele, prefix) {\n    var theta;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var pdash = prefix ? prefix + '-' : '';\n    var rotation = ele.pstyle(pdash + 'text-rotation');\n    if (rotation.strValue === 'autorotate') {\n        var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);\n        theta = ele.isEdge() ? textAngle : 0;\n    } else if (rotation.strValue === 'none') {\n        theta = 0;\n    } else {\n        theta = rotation.pfValue;\n    }\n    return theta;\n};\nCRp$7.drawText = function(context, ele, prefix) {\n    var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n    if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {\n        return;\n    }\n    // use 'main' as an alias for the main label (i.e. null prefix)\n    if (prefix === 'main') {\n        prefix = null;\n    }\n    var textX = getPrefixedProperty(rscratch, 'labelX', prefix);\n    var textY = getPrefixedProperty(rscratch, 'labelY', prefix);\n    var orgTextX, orgTextY; // used for rotation\n    var text = this.getLabelText(ele, prefix);\n    if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n        this.setupTextStyle(context, ele, useEleOpacity);\n        var pdash = prefix ? prefix + '-' : '';\n        var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);\n        var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);\n        var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n        var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n        var isEdge = ele.isEdge();\n        var halign = ele.pstyle('text-halign').value;\n        var valign = ele.pstyle('text-valign').value;\n        if (isEdge) {\n            halign = 'center';\n            valign = 'center';\n        }\n        textX += marginX;\n        textY += marginY;\n        var theta;\n        if (!applyRotation) {\n            theta = 0;\n        } else {\n            theta = this.getTextAngle(ele, prefix);\n        }\n        if (theta !== 0) {\n            orgTextX = textX;\n            orgTextY = textY;\n            context.translate(orgTextX, orgTextY);\n            context.rotate(theta);\n            textX = 0;\n            textY = 0;\n        }\n        switch(valign){\n            case 'top':\n                break;\n            case 'center':\n                textY += textH / 2;\n                break;\n            case 'bottom':\n                textY += textH;\n                break;\n        }\n        var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n        var borderOpacity = ele.pstyle('text-border-opacity').value;\n        var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n        var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n        var styleShape = ele.pstyle('text-background-shape').strValue;\n        var rounded = styleShape === 'round-rectangle' || styleShape === 'roundrectangle';\n        var circled = styleShape === 'circle';\n        var roundRadius = 2;\n        if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n            var textFill = context.fillStyle;\n            var textStroke = context.strokeStyle;\n            var textLineWidth = context.lineWidth;\n            var textBackgroundColor = ele.pstyle('text-background-color').value;\n            var textBorderColor = ele.pstyle('text-border-color').value;\n            var textBorderStyle = ele.pstyle('text-border-style').value;\n            var doFill = backgroundOpacity > 0;\n            var doStroke = textBorderWidth > 0 && borderOpacity > 0;\n            var bgX = textX - backgroundPadding;\n            switch(halign){\n                case 'left':\n                    bgX -= textW;\n                    break;\n                case 'center':\n                    bgX -= textW / 2;\n                    break;\n            }\n            var bgY = textY - textH - backgroundPadding;\n            var bgW = textW + 2 * backgroundPadding;\n            var bgH = textH + 2 * backgroundPadding;\n            if (doFill) {\n                context.fillStyle = \"rgba(\".concat(textBackgroundColor[0], \",\").concat(textBackgroundColor[1], \",\").concat(textBackgroundColor[2], \",\").concat(backgroundOpacity * parentOpacity, \")\");\n            }\n            if (doStroke) {\n                context.strokeStyle = \"rgba(\".concat(textBorderColor[0], \",\").concat(textBorderColor[1], \",\").concat(textBorderColor[2], \",\").concat(borderOpacity * parentOpacity, \")\");\n                context.lineWidth = textBorderWidth;\n                if (context.setLineDash) {\n                    switch(textBorderStyle){\n                        case 'dotted':\n                            context.setLineDash([\n                                1,\n                                1\n                            ]);\n                            break;\n                        case 'dashed':\n                            context.setLineDash([\n                                4,\n                                2\n                            ]);\n                            break;\n                        case 'double':\n                            context.lineWidth = textBorderWidth / 4;\n                            context.setLineDash([]);\n                            break;\n                        case 'solid':\n                        default:\n                            context.setLineDash([]);\n                            break;\n                    }\n                }\n            }\n            if (rounded) {\n                context.beginPath();\n                roundRect(context, bgX, bgY, bgW, bgH, roundRadius);\n            } else if (circled) {\n                context.beginPath();\n                circle(context, bgX, bgY, bgW, bgH);\n            } else {\n                context.beginPath();\n                context.rect(bgX, bgY, bgW, bgH);\n            }\n            if (doFill) context.fill();\n            if (doStroke) context.stroke();\n            // Double border pass for 'double' style\n            if (doStroke && textBorderStyle === 'double') {\n                var whiteWidth = textBorderWidth / 2;\n                context.beginPath();\n                if (rounded) {\n                    roundRect(context, bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth, roundRadius);\n                } else {\n                    context.rect(bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth);\n                }\n                context.stroke();\n            }\n            context.fillStyle = textFill;\n            context.strokeStyle = textStroke;\n            context.lineWidth = textLineWidth;\n            if (context.setLineDash) context.setLineDash([]);\n        }\n        var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n        if (lineWidth > 0) {\n            context.lineWidth = lineWidth;\n        }\n        if (ele.pstyle('text-wrap').value === 'wrap') {\n            var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n            var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);\n            var halfTextW = textW / 2;\n            var justification = this.getLabelJustification(ele);\n            if (justification === 'auto') ;\n            else if (halign === 'left') {\n                // auto justification : right\n                if (justification === 'left') {\n                    textX += -textW;\n                } else if (justification === 'center') {\n                    textX += -halfTextW;\n                } // else same as auto\n            } else if (halign === 'center') {\n                // auto justfication : center\n                if (justification === 'left') {\n                    textX += -halfTextW;\n                } else if (justification === 'right') {\n                    textX += halfTextW;\n                } // else same as auto\n            } else if (halign === 'right') {\n                // auto justification : left\n                if (justification === 'center') {\n                    textX += halfTextW;\n                } else if (justification === 'right') {\n                    textX += textW;\n                } // else same as auto\n            }\n            switch(valign){\n                case 'top':\n                    textY -= (lines.length - 1) * lineHeight;\n                    break;\n                case 'center':\n                case 'bottom':\n                    textY -= (lines.length - 1) * lineHeight;\n                    break;\n            }\n            for(var l = 0; l < lines.length; l++){\n                if (lineWidth > 0) {\n                    context.strokeText(lines[l], textX, textY);\n                }\n                context.fillText(lines[l], textX, textY);\n                textY += lineHeight;\n            }\n        } else {\n            if (lineWidth > 0) {\n                context.strokeText(text, textX, textY);\n            }\n            context.fillText(text, textX, textY);\n        }\n        if (theta !== 0) {\n            context.rotate(-theta);\n            context.translate(-orgTextX, -orgTextY);\n        }\n    }\n};\n/* global Path2D */ var CRp$6 = {};\nCRp$6.drawNode = function(context, node, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var nodeWidth, nodeHeight;\n    var _p = node._private;\n    var rs = _p.rscratch;\n    var pos = node.position();\n    if (!number$1(pos.x) || !number$1(pos.y)) {\n        return; // can't draw node with undefined position\n    }\n    if (shouldDrawOpacity && !node.visible()) {\n        return;\n    }\n    var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n    var usePaths = r.usePaths();\n    var path;\n    var pathCacheHit = false;\n    var padding = node.padding();\n    nodeWidth = node.width() + 2 * padding;\n    nodeHeight = node.height() + 2 * padding;\n    //\n    // setup shift\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    //\n    // load bg image\n    var bgImgProp = node.pstyle('background-image');\n    var urls = bgImgProp.value;\n    var urlDefined = new Array(urls.length);\n    var image = new Array(urls.length);\n    var numImages = 0;\n    for(var i = 0; i < urls.length; i++){\n        var url = urls[i];\n        var defd = urlDefined[i] = url != null && url !== 'none';\n        if (defd) {\n            var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n            numImages++;\n            // get image, and if not loaded then ask to redraw when later loaded\n            image[i] = r.getCachedImage(url, bgImgCrossOrigin, function() {\n                _p.backgroundTimestamp = Date.now();\n                node.emitAndNotify('background');\n            });\n        }\n    }\n    //\n    // setup styles\n    var darkness = node.pstyle('background-blacken').value;\n    var borderWidth = node.pstyle('border-width').pfValue;\n    var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;\n    var borderColor = node.pstyle('border-color').value;\n    var borderStyle = node.pstyle('border-style').value;\n    var borderJoin = node.pstyle('border-join').value;\n    var borderCap = node.pstyle('border-cap').value;\n    var borderPosition = node.pstyle('border-position').value;\n    var borderPattern = node.pstyle('border-dash-pattern').pfValue;\n    var borderOffset = node.pstyle('border-dash-offset').pfValue;\n    var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;\n    var outlineWidth = node.pstyle('outline-width').pfValue;\n    var outlineColor = node.pstyle('outline-color').value;\n    var outlineStyle = node.pstyle('outline-style').value;\n    var outlineOpacity = node.pstyle('outline-opacity').value * eleOpacity;\n    var outlineOffset = node.pstyle('outline-offset').value;\n    var cornerRadius = node.pstyle('corner-radius').value;\n    if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;\n    var setupShapeColor = function setupShapeColor() {\n        var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n        r.eleFillStyle(context, node, bgOpy);\n    };\n    var setupBorderColor = function setupBorderColor() {\n        var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n        r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n    };\n    var setupOutlineColor = function setupOutlineColor() {\n        var otlnOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : outlineOpacity;\n        r.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], otlnOpy);\n    };\n    //\n    // setup shape\n    var getPath = function getPath(width, height, shape, points) {\n        var pathCache = r.nodePathCache = r.nodePathCache || [];\n        var key = hashStrings(shape === 'polygon' ? shape + ',' + points.join(',') : shape, '' + height, '' + width, '' + cornerRadius);\n        var cachedPath = pathCache[key];\n        var path;\n        var cacheHit = false;\n        if (cachedPath != null) {\n            path = cachedPath;\n            cacheHit = true;\n            rs.pathCache = path;\n        } else {\n            path = new Path2D();\n            pathCache[key] = rs.pathCache = path;\n        }\n        return {\n            path: path,\n            cacheHit: cacheHit\n        };\n    };\n    var styleShape = node.pstyle('shape').strValue;\n    var shapePts = node.pstyle('shape-polygon-points').pfValue;\n    if (usePaths) {\n        context.translate(pos.x, pos.y);\n        var shapePath = getPath(nodeWidth, nodeHeight, styleShape, shapePts);\n        path = shapePath.path;\n        pathCacheHit = shapePath.cacheHit;\n    }\n    var drawShape = function drawShape() {\n        if (!pathCacheHit) {\n            var npos = pos;\n            if (usePaths) {\n                npos = {\n                    x: 0,\n                    y: 0\n                };\n            }\n            r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n        }\n        if (usePaths) {\n            context.fill(path);\n        } else {\n            context.fill();\n        }\n    };\n    var drawImages = function drawImages() {\n        var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n        var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var prevBging = _p.backgrounding;\n        var totalCompleted = 0;\n        for(var _i = 0; _i < image.length; _i++){\n            var bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);\n            if (inside && bgContainment === 'over' || !inside && bgContainment === 'inside') {\n                totalCompleted++;\n                continue;\n            }\n            if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n                totalCompleted++;\n                r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n            }\n        }\n        _p.backgrounding = !(totalCompleted === numImages);\n        if (prevBging !== _p.backgrounding) {\n            // update style b/c :backgrounding state changed\n            node.updateStyle(false);\n        }\n    };\n    var drawPie = function drawPie() {\n        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n        if (r.hasPie(node)) {\n            r.drawPie(context, node, pieOpacity);\n            // redraw/restore path if steps after pie need it\n            if (redrawShape) {\n                if (!usePaths) {\n                    r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                }\n            }\n        }\n    };\n    var drawStripe = function drawStripe() {\n        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var stripeOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n        if (r.hasStripe(node)) {\n            context.save();\n            if (usePaths) {\n                context.clip(rs.pathCache);\n            } else {\n                r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                context.clip();\n            }\n            r.drawStripe(context, node, stripeOpacity);\n            context.restore();\n            // redraw/restore path if steps after stripes need it\n            if (redrawShape) {\n                if (!usePaths) {\n                    r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                }\n            }\n        }\n    };\n    var darken = function darken() {\n        var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n        var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n        var c = darkness > 0 ? 0 : 255;\n        if (darkness !== 0) {\n            r.colorFillStyle(context, c, c, c, opacity);\n            if (usePaths) {\n                context.fill(path);\n            } else {\n                context.fill();\n            }\n        }\n    };\n    var drawBorder = function drawBorder() {\n        if (borderWidth > 0) {\n            context.lineWidth = borderWidth;\n            context.lineCap = borderCap;\n            context.lineJoin = borderJoin;\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                switch(borderStyle){\n                    case 'dotted':\n                        context.setLineDash([\n                            1,\n                            1\n                        ]);\n                        break;\n                    case 'dashed':\n                        context.setLineDash(borderPattern);\n                        context.lineDashOffset = borderOffset;\n                        break;\n                    case 'solid':\n                    case 'double':\n                        context.setLineDash([]);\n                        break;\n                }\n            }\n            if (borderPosition !== 'center') {\n                context.save();\n                context.lineWidth *= 2;\n                if (borderPosition === 'inside') {\n                    usePaths ? context.clip(path) : context.clip();\n                } else {\n                    var region = new Path2D();\n                    region.rect(-nodeWidth / 2 - borderWidth, -nodeHeight / 2 - borderWidth, nodeWidth + 2 * borderWidth, nodeHeight + 2 * borderWidth);\n                    region.addPath(path);\n                    context.clip(region, 'evenodd');\n                }\n                usePaths ? context.stroke(path) : context.stroke();\n                context.restore();\n            } else {\n                usePaths ? context.stroke(path) : context.stroke();\n            }\n            if (borderStyle === 'double') {\n                context.lineWidth = borderWidth / 3;\n                var gco = context.globalCompositeOperation;\n                context.globalCompositeOperation = 'destination-out';\n                if (usePaths) {\n                    context.stroke(path);\n                } else {\n                    context.stroke();\n                }\n                context.globalCompositeOperation = gco;\n            }\n            // reset in case we changed the border style\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                context.setLineDash([]);\n            }\n        }\n    };\n    var drawOutline = function drawOutline() {\n        if (outlineWidth > 0) {\n            context.lineWidth = outlineWidth;\n            context.lineCap = 'butt';\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                switch(outlineStyle){\n                    case 'dotted':\n                        context.setLineDash([\n                            1,\n                            1\n                        ]);\n                        break;\n                    case 'dashed':\n                        context.setLineDash([\n                            4,\n                            2\n                        ]);\n                        break;\n                    case 'solid':\n                    case 'double':\n                        context.setLineDash([]);\n                        break;\n                }\n            }\n            var npos = pos;\n            if (usePaths) {\n                npos = {\n                    x: 0,\n                    y: 0\n                };\n            }\n            var shape = r.getNodeShape(node);\n            var bWidth = borderWidth;\n            if (borderPosition === 'inside') bWidth = 0;\n            if (borderPosition === 'outside') bWidth *= 2;\n            var scaleX = (nodeWidth + bWidth + (outlineWidth + outlineOffset)) / nodeWidth;\n            var scaleY = (nodeHeight + bWidth + (outlineWidth + outlineOffset)) / nodeHeight;\n            var sWidth = nodeWidth * scaleX;\n            var sHeight = nodeHeight * scaleY;\n            var points = r.nodeShapes[shape].points;\n            var _path;\n            if (usePaths) {\n                var outlinePath = getPath(sWidth, sHeight, shape, points);\n                _path = outlinePath.path;\n            }\n            // draw the outline path, either by using expanded points or by scaling \n            // the dimensions, depending on shape\n            if (shape === \"ellipse\") {\n                r.drawEllipsePath(_path || context, npos.x, npos.y, sWidth, sHeight);\n            } else if ([\n                'round-diamond',\n                'round-heptagon',\n                'round-hexagon',\n                'round-octagon',\n                'round-pentagon',\n                'round-polygon',\n                'round-triangle',\n                'round-tag'\n            ].includes(shape)) {\n                var sMult = 0;\n                var offsetX = 0;\n                var offsetY = 0;\n                if (shape === 'round-diamond') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.4;\n                } else if (shape === 'round-heptagon') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.075;\n                    offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 35;\n                } else if (shape === 'round-hexagon') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n                } else if (shape === 'round-pentagon') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.13;\n                    offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 15;\n                } else if (shape === 'round-tag') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n                    offsetX = (bWidth / 2 + outlineWidth + outlineOffset) * .07;\n                } else if (shape === 'round-triangle') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * (Math.PI / 2);\n                    offsetY = -(bWidth + outlineOffset / 2 + outlineWidth) / Math.PI;\n                }\n                if (sMult !== 0) {\n                    scaleX = (nodeWidth + sMult) / nodeWidth;\n                    sWidth = nodeWidth * scaleX;\n                    if (![\n                        'round-hexagon',\n                        'round-tag'\n                    ].includes(shape)) {\n                        scaleY = (nodeHeight + sMult) / nodeHeight;\n                        sHeight = nodeHeight * scaleY;\n                    }\n                }\n                cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(sWidth, sHeight) : cornerRadius;\n                var halfW = sWidth / 2;\n                var halfH = sHeight / 2;\n                var radius = cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2;\n                var p = new Array(points.length / 2);\n                var corners = new Array(points.length / 2);\n                for(var _i2 = 0; _i2 < points.length / 2; _i2++){\n                    p[_i2] = {\n                        x: npos.x + offsetX + halfW * points[_i2 * 2],\n                        y: npos.y + offsetY + halfH * points[_i2 * 2 + 1]\n                    };\n                }\n                var _i3, p1, p2, p3, len = p.length;\n                p1 = p[len - 1];\n                // for each point\n                for(_i3 = 0; _i3 < len; _i3++){\n                    p2 = p[_i3 % len];\n                    p3 = p[(_i3 + 1) % len];\n                    corners[_i3] = getRoundCorner(p1, p2, p3, radius);\n                    p1 = p2;\n                    p2 = p3;\n                }\n                r.drawRoundPolygonPath(_path || context, npos.x + offsetX, npos.y + offsetY, nodeWidth * scaleX, nodeHeight * scaleY, points, corners);\n            } else if ([\n                'roundrectangle',\n                'round-rectangle'\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n                r.drawRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n            } else if ([\n                'cutrectangle',\n                'cut-rectangle'\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === 'auto' ? getCutRectangleCornerLength() : cornerRadius;\n                r.drawCutRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, null, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 4);\n            } else if ([\n                'bottomroundrectangle',\n                'bottom-round-rectangle'\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n                r.drawBottomRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n            } else if (shape === \"barrel\") {\n                r.drawBarrelPath(_path || context, npos.x, npos.y, sWidth, sHeight);\n            } else if (shape.startsWith(\"polygon\") || [\n                'rhomboid',\n                'right-rhomboid',\n                'round-tag',\n                'tag',\n                'vee'\n            ].includes(shape)) {\n                var pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n                points = joinLines(expandPolygon(points, pad));\n                r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n            } else {\n                var _pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n                points = joinLines(expandPolygon(points, -_pad));\n                r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n            }\n            if (usePaths) {\n                context.stroke(_path);\n            } else {\n                context.stroke();\n            }\n            if (outlineStyle === 'double') {\n                context.lineWidth = bWidth / 3;\n                var gco = context.globalCompositeOperation;\n                context.globalCompositeOperation = 'destination-out';\n                if (usePaths) {\n                    context.stroke(_path);\n                } else {\n                    context.stroke();\n                }\n                context.globalCompositeOperation = gco;\n            }\n            // reset in case we changed the border style\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                context.setLineDash([]);\n            }\n        }\n    };\n    var drawOverlay = function drawOverlay() {\n        if (shouldDrawOverlay) {\n            r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n        }\n    };\n    var drawUnderlay = function drawUnderlay() {\n        if (shouldDrawOverlay) {\n            r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n        }\n    };\n    var drawText = function drawText() {\n        r.drawElementText(context, node, null, drawLabel);\n    };\n    var ghost = node.pstyle('ghost').value === 'yes';\n    if (ghost) {\n        var gx = node.pstyle('ghost-offset-x').pfValue;\n        var gy = node.pstyle('ghost-offset-y').pfValue;\n        var ghostOpacity = node.pstyle('ghost-opacity').value;\n        var effGhostOpacity = ghostOpacity * eleOpacity;\n        context.translate(gx, gy);\n        setupOutlineColor();\n        drawOutline();\n        setupShapeColor(ghostOpacity * bgOpacity);\n        drawShape();\n        drawImages(effGhostOpacity, true);\n        setupBorderColor(ghostOpacity * borderOpacity);\n        drawBorder();\n        drawPie(darkness !== 0 || borderWidth !== 0);\n        drawStripe(darkness !== 0 || borderWidth !== 0);\n        drawImages(effGhostOpacity, false);\n        darken(effGhostOpacity);\n        context.translate(-gx, -gy);\n    }\n    if (usePaths) {\n        context.translate(-pos.x, -pos.y);\n    }\n    drawUnderlay();\n    if (usePaths) {\n        context.translate(pos.x, pos.y);\n    }\n    setupOutlineColor();\n    drawOutline();\n    setupShapeColor();\n    drawShape();\n    drawImages(eleOpacity, true);\n    setupBorderColor();\n    drawBorder();\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    drawStripe(darkness !== 0 || borderWidth !== 0);\n    drawImages(eleOpacity, false);\n    darken();\n    if (usePaths) {\n        context.translate(-pos.x, -pos.y);\n    }\n    drawText();\n    drawOverlay();\n    //\n    // clean up shift\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nvar drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n    if (![\n        'overlay',\n        'underlay'\n    ].includes(overlayOrUnderlay)) {\n        throw new Error('Invalid state');\n    }\n    return function(context, node, pos, nodeWidth, nodeHeight) {\n        var r = this;\n        if (!node.visible()) {\n            return;\n        }\n        var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n        var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n        var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n        var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n        var radius = node.pstyle(\"\".concat(overlayOrUnderlay, \"-corner-radius\")).value;\n        if (opacity > 0) {\n            pos = pos || node.position();\n            if (nodeWidth == null || nodeHeight == null) {\n                var _padding = node.padding();\n                nodeWidth = node.width() + 2 * _padding;\n                nodeHeight = node.height() + 2 * _padding;\n            }\n            r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n            r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2, radius);\n            context.fill();\n        }\n    };\n};\nCRp$6.drawNodeOverlay = drawNodeOverlayUnderlay('overlay');\nCRp$6.drawNodeUnderlay = drawNodeOverlayUnderlay('underlay');\n// does the node have at least one pie piece?\nCRp$6.hasPie = function(node) {\n    node = node[0]; // ensure ele ref\n    return node._private.hasPie;\n};\nCRp$6.hasStripe = function(node) {\n    node = node[0]; // ensure ele ref\n    return node._private.hasStripe;\n};\nCRp$6.drawPie = function(context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var pieSize = node.pstyle('pie-size');\n    var hole = node.pstyle('pie-hole');\n    var overallStartAngle = node.pstyle('pie-start-angle').pfValue;\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n    var holeRadius;\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = this.usePaths();\n    if (usePaths) {\n        x = 0;\n        y = 0;\n    }\n    if (pieSize.units === '%') {\n        radius = radius * pieSize.pfValue;\n    } else if (pieSize.pfValue !== undefined) {\n        radius = pieSize.pfValue / 2; // diameter in pixels => radius\n    }\n    if (hole.units === '%') {\n        holeRadius = radius * hole.pfValue;\n    } else if (hole.pfValue !== undefined) {\n        holeRadius = hole.pfValue / 2; // diameter in pixels => radius\n    }\n    if (holeRadius >= radius) {\n        return; // the pie would be invisible anyway\n    }\n    for(var i = 1; i <= cyStyle.pieBackgroundN; i++){\n        // 1..N\n        var size = node.pstyle('pie-' + i + '-background-size').value;\n        var color = node.pstyle('pie-' + i + '-background-color').value;\n        var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n        var percent = size / 100; // map integer range [0, 100] to [0, 1]\n        // percent can't push beyond 1\n        if (percent + lastPercent > 1) {\n            percent = 1 - lastPercent;\n        }\n        var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n        angleStart += overallStartAngle; // shift by the overall pie start angle\n        var angleDelta = 2 * Math.PI * percent;\n        var angleEnd = angleStart + angleDelta;\n        // ignore if\n        // - zero size\n        // - we're already beyond the full circle\n        // - adding the current slice would go beyond the full circle\n        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n            continue;\n        }\n        if (holeRadius === 0) {\n            // make a pie slice\n            context.beginPath();\n            context.moveTo(x, y);\n            context.arc(x, y, radius, angleStart, angleEnd);\n            context.closePath();\n        } else {\n            // make a pie slice that's like the above but with a hole in the middle\n            context.beginPath();\n            context.arc(x, y, radius, angleStart, angleEnd);\n            context.arc(x, y, holeRadius, angleEnd, angleStart, true); // true for anticlockwise\n            context.closePath();\n        }\n        this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        context.fill();\n        lastPercent += percent;\n    }\n};\nCRp$6.drawStripe = function(context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = this.usePaths();\n    context.save();\n    var direction = node.pstyle('stripe-direction').value;\n    var stripeSize = node.pstyle('stripe-size');\n    switch(direction){\n        case 'vertical':\n            break;\n        // default\n        case 'righward':\n            context.rotate(-Math.PI / 2);\n            break;\n    }\n    var stripeW = nodeW;\n    var stripeH = nodeH;\n    if (stripeSize.units === '%') {\n        stripeW = stripeW * stripeSize.pfValue;\n        stripeH = stripeH * stripeSize.pfValue;\n    } else if (stripeSize.pfValue !== undefined) {\n        stripeW = stripeSize.pfValue;\n        stripeH = stripeSize.pfValue;\n    }\n    if (usePaths) {\n        x = 0;\n        y = 0;\n    }\n    // shift up from the centre of the node to the top-left corner\n    y -= stripeW / 2;\n    x -= stripeH / 2;\n    for(var i = 1; i <= cyStyle.stripeBackgroundN; i++){\n        // 1..N\n        var size = node.pstyle('stripe-' + i + '-background-size').value;\n        var color = node.pstyle('stripe-' + i + '-background-color').value;\n        var opacity = node.pstyle('stripe-' + i + '-background-opacity').value * nodeOpacity;\n        var percent = size / 100; // map integer range [0, 100] to [0, 1]\n        // percent can't push beyond 1\n        if (percent + lastPercent > 1) {\n            percent = 1 - lastPercent;\n        }\n        // ignore if\n        // - zero size\n        // - we're already beyond the full chart\n        // - adding the current slice would go beyond the full chart\n        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n            continue;\n        }\n        // draw rect for the current stripe\n        context.beginPath();\n        context.rect(x, y + stripeH * lastPercent, stripeW, stripeH * percent);\n        context.closePath();\n        this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        context.fill();\n        lastPercent += percent;\n    }\n    context.restore();\n};\nvar CRp$5 = {};\nvar motionBlurDelay = 100;\n// var isFirefox = typeof InstallTrigger !== 'undefined';\nCRp$5.getPixelRatio = function() {\n    var context = this.data.contexts[0];\n    if (this.forcedPixelRatio != null) {\n        return this.forcedPixelRatio;\n    }\n    var containerWindow = this.cy.window();\n    var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    return (containerWindow.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n};\nCRp$5.paintCache = function(context) {\n    var caches = this.paintCaches = this.paintCaches || [];\n    var needToCreateCache = true;\n    var cache;\n    for(var i = 0; i < caches.length; i++){\n        cache = caches[i];\n        if (cache.context === context) {\n            needToCreateCache = false;\n            break;\n        }\n    }\n    if (needToCreateCache) {\n        cache = {\n            context: context\n        };\n        caches.push(cache);\n    }\n    return cache;\n};\nCRp$5.createGradientStyleFor = function(context, shapeStyleName, ele, fill, opacity) {\n    var gradientStyle;\n    var usePaths = this.usePaths();\n    var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value, positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;\n    if (fill === 'radial-gradient') {\n        if (ele.isEdge()) {\n            var start = ele.sourceEndpoint(), end = ele.targetEndpoint(), mid = ele.midpoint();\n            var d1 = dist(start, mid);\n            var d2 = dist(end, mid);\n            gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n        } else {\n            var pos = usePaths ? {\n                x: 0,\n                y: 0\n            } : ele.position(), width = ele.paddedWidth(), height = ele.paddedHeight();\n            gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n        }\n    } else {\n        if (ele.isEdge()) {\n            var _start = ele.sourceEndpoint(), _end = ele.targetEndpoint();\n            gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n        } else {\n            var _pos = usePaths ? {\n                x: 0,\n                y: 0\n            } : ele.position(), _width = ele.paddedWidth(), _height = ele.paddedHeight(), halfWidth = _width / 2, halfHeight = _height / 2;\n            var direction = ele.pstyle('background-gradient-direction').value;\n            switch(direction){\n                case 'to-bottom':\n                    gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n                    break;\n                case 'to-top':\n                    gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n                    break;\n                case 'to-left':\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n                    break;\n                case 'to-right':\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n                    break;\n                case 'to-bottom-right':\n                case 'to-right-bottom':\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n                    break;\n                case 'to-top-right':\n                case 'to-right-top':\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n                    break;\n                case 'to-bottom-left':\n                case 'to-left-bottom':\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n                    break;\n                case 'to-top-left':\n                case 'to-left-top':\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n                    break;\n            }\n        }\n    }\n    if (!gradientStyle) return null; // invalid gradient style\n    var hasPositions = positions.length === colors.length;\n    var length = colors.length;\n    for(var i = 0; i < length; i++){\n        gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');\n    }\n    return gradientStyle;\n};\nCRp$5.gradientFillStyle = function(context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n    context.fillStyle = gradientStyle;\n};\nCRp$5.colorFillStyle = function(context, r, g, b, a) {\n    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// turn off for now, seems context does its own caching\n// var cache = this.paintCache(context);\n// var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// if( cache.fillStyle !== fillStyle ){\n//   context.fillStyle = cache.fillStyle = fillStyle;\n// }\n};\nCRp$5.eleFillStyle = function(context, ele, opacity) {\n    var backgroundFill = ele.pstyle('background-fill').value;\n    if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {\n        this.gradientFillStyle(context, ele, backgroundFill, opacity);\n    } else {\n        var backgroundColor = ele.pstyle('background-color').value;\n        this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n    }\n};\nCRp$5.gradientStrokeStyle = function(context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n    context.strokeStyle = gradientStyle;\n};\nCRp$5.colorStrokeStyle = function(context, r, g, b, a) {\n    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// turn off for now, seems context does its own caching\n// var cache = this.paintCache(context);\n// var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// if( cache.strokeStyle !== strokeStyle ){\n//   context.strokeStyle = cache.strokeStyle = strokeStyle;\n// }\n};\nCRp$5.eleStrokeStyle = function(context, ele, opacity) {\n    var lineFill = ele.pstyle('line-fill').value;\n    if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {\n        this.gradientStrokeStyle(context, ele, lineFill, opacity);\n    } else {\n        var lineColor = ele.pstyle('line-color').value;\n        this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n    }\n};\n// Resize canvas\nCRp$5.matchCanvasSize = function(container) {\n    var r = this;\n    var data = r.data;\n    var bb = r.findContainerClientCoords();\n    var width = bb[2];\n    var height = bb[3];\n    var pixelRatio = r.getPixelRatio();\n    var mbPxRatio = r.motionBlurPxRatio;\n    if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n        pixelRatio = mbPxRatio;\n    }\n    var canvasWidth = width * pixelRatio;\n    var canvasHeight = height * pixelRatio;\n    var canvas;\n    if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n        return; // save cycles if same\n    }\n    r.fontCaches = null; // resizing resets the style\n    var canvasContainer = data.canvasContainer;\n    canvasContainer.style.width = width + 'px';\n    canvasContainer.style.height = height + 'px';\n    for(var i = 0; i < r.CANVAS_LAYERS; i++){\n        canvas = data.canvases[i];\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n    }\n    for(var i = 0; i < r.BUFFER_COUNT; i++){\n        canvas = data.bufferCanvases[i];\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n    }\n    r.textureMult = 1;\n    if (pixelRatio <= 1) {\n        canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n        r.textureMult = 2;\n        canvas.width = canvasWidth * r.textureMult;\n        canvas.height = canvasHeight * r.textureMult;\n    }\n    r.canvasWidth = canvasWidth;\n    r.canvasHeight = canvasHeight;\n    r.pixelRatio = pixelRatio;\n};\nCRp$5.renderTo = function(cxt, zoom, pan, pxRatio) {\n    this.render({\n        forcedContext: cxt,\n        forcedZoom: zoom,\n        forcedPan: pan,\n        drawAllLayers: true,\n        forcedPxRatio: pxRatio\n    });\n};\nCRp$5.clearCanvas = function() {\n    var r = this;\n    var data = r.data;\n    function clear(context) {\n        context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n    }\n    clear(data.contexts[r.NODE]);\n    clear(data.contexts[r.DRAG]);\n};\nCRp$5.render = function(options) {\n    var r = this;\n    options = options || staticEmptyObject();\n    var cy = r.cy;\n    var forcedContext = options.forcedContext;\n    var drawAllLayers = options.drawAllLayers;\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var forcedZoom = options.forcedZoom;\n    var forcedPan = options.forcedPan;\n    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n    var data = r.data;\n    var needDraw = data.canvasNeedsRedraw;\n    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n    var mbPxRatio = r.motionBlurPxRatio;\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var inNodeDragGesture = r.hoverData.draggingEles;\n    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n    var motionBlurFadeEffect = motionBlur;\n    if (!forcedContext) {\n        if (r.prevPxRatio !== pixelRatio) {\n            r.invalidateContainerClientCoordsCache();\n            r.matchCanvasSize(r.container);\n            r.redrawHint('eles', true);\n            r.redrawHint('drag', true);\n        }\n        r.prevPxRatio = pixelRatio;\n    }\n    if (!forcedContext && r.motionBlurTimeout) {\n        clearTimeout(r.motionBlurTimeout);\n    }\n    if (motionBlur) {\n        if (r.mbFrames == null) {\n            r.mbFrames = 0;\n        }\n        r.mbFrames++;\n        if (r.mbFrames < 3) {\n            // need several frames before even high quality motionblur\n            motionBlurFadeEffect = false;\n        }\n        // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n        if (r.mbFrames > r.minMbLowQualFrames) {\n            //r.fullQualityMb = false;\n            r.motionBlurPxRatio = r.mbPxRBlurry;\n        }\n    }\n    if (r.clearingMotionBlur) {\n        r.motionBlurPxRatio = 1;\n    }\n    // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n    // because a rogue async texture frame would clear needDraw\n    if (r.textureDrawLastFrame && !textureDraw) {\n        needDraw[r.NODE] = true;\n        needDraw[r.SELECT_BOX] = true;\n    }\n    var style = cy.style();\n    var zoom = cy.zoom();\n    var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n    var pan = cy.pan();\n    var effectivePan = {\n        x: pan.x,\n        y: pan.y\n    };\n    var vp = {\n        zoom: zoom,\n        pan: {\n            x: pan.x,\n            y: pan.y\n        }\n    };\n    var prevVp = r.prevViewport;\n    var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n    // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n    if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n        r.motionBlurPxRatio = 1;\n    }\n    if (forcedPan) {\n        effectivePan = forcedPan;\n    }\n    // apply pixel ratio\n    effectiveZoom *= pixelRatio;\n    effectivePan.x *= pixelRatio;\n    effectivePan.y *= pixelRatio;\n    var eles = r.getCachedZSortedEles();\n    function mbclear(context, x, y, w, h) {\n        var gco = context.globalCompositeOperation;\n        context.globalCompositeOperation = 'destination-out';\n        r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n        context.fillRect(x, y, w, h);\n        context.globalCompositeOperation = gco;\n    }\n    function setContextTransform(context, clear) {\n        var ePan, eZoom, w, h;\n        if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n            ePan = {\n                x: pan.x * mbPxRatio,\n                y: pan.y * mbPxRatio\n            };\n            eZoom = zoom * mbPxRatio;\n            w = r.canvasWidth * mbPxRatio;\n            h = r.canvasHeight * mbPxRatio;\n        } else {\n            ePan = effectivePan;\n            eZoom = effectiveZoom;\n            w = r.canvasWidth;\n            h = r.canvasHeight;\n        }\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        if (clear === 'motionBlur') {\n            mbclear(context, 0, 0, w, h);\n        } else if (!forcedContext && (clear === undefined || clear)) {\n            context.clearRect(0, 0, w, h);\n        }\n        if (!drawAllLayers) {\n            context.translate(ePan.x, ePan.y);\n            context.scale(eZoom, eZoom);\n        }\n        if (forcedPan) {\n            context.translate(forcedPan.x, forcedPan.y);\n        }\n        if (forcedZoom) {\n            context.scale(forcedZoom, forcedZoom);\n        }\n    }\n    if (!textureDraw) {\n        r.textureDrawLastFrame = false;\n    }\n    if (textureDraw) {\n        r.textureDrawLastFrame = true;\n        if (!r.textureCache) {\n            r.textureCache = {};\n            r.textureCache.bb = cy.mutableElements().boundingBox();\n            r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n            var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n            cxt.setTransform(1, 0, 0, 1, 0, 0);\n            cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n            r.render({\n                forcedContext: cxt,\n                drawOnlyNodeLayer: true,\n                forcedPxRatio: pixelRatio * r.textureMult\n            });\n            var vp = r.textureCache.viewport = {\n                zoom: cy.zoom(),\n                pan: cy.pan(),\n                width: r.canvasWidth,\n                height: r.canvasHeight\n            };\n            vp.mpan = {\n                x: (0 - vp.pan.x) / vp.zoom,\n                y: (0 - vp.pan.y) / vp.zoom\n            };\n        }\n        needDraw[r.DRAG] = false;\n        needDraw[r.NODE] = false;\n        var context = data.contexts[r.NODE];\n        var texture = r.textureCache.texture;\n        var vp = r.textureCache.viewport;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        if (motionBlur) {\n            mbclear(context, 0, 0, vp.width, vp.height);\n        } else {\n            context.clearRect(0, 0, vp.width, vp.height);\n        }\n        var outsideBgColor = style.core('outside-texture-bg-color').value;\n        var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;\n        r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n        context.fillRect(0, 0, vp.width, vp.height);\n        var zoom = cy.zoom();\n        setContextTransform(context, false);\n        context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n        context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    } else if (r.textureOnViewport && !forcedContext) {\n        // clear the cache since we don't need it\n        r.textureCache = null;\n    }\n    var extent = cy.extent();\n    var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n    var hideEdges = r.hideEdgesOnViewport && vpManip;\n    var needMbClear = [];\n    needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n    if (needMbClear[r.NODE]) {\n        r.clearedForMotionBlur[r.NODE] = true;\n    }\n    needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n    if (needMbClear[r.DRAG]) {\n        r.clearedForMotionBlur[r.DRAG] = true;\n    }\n    if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n        var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n        var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n        setContextTransform(context, clear);\n        if (hideEdges) {\n            r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n        } else {\n            r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n        }\n        if (r.debug) {\n            r.drawDebugPoints(context, eles.nondrag);\n        }\n        if (!drawAllLayers && !motionBlur) {\n            needDraw[r.NODE] = false;\n        }\n    }\n    if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n        var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n        setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n        if (hideEdges) {\n            r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n        } else {\n            r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n        }\n        if (r.debug) {\n            r.drawDebugPoints(context, eles.drag);\n        }\n        if (!drawAllLayers && !motionBlur) {\n            needDraw[r.DRAG] = false;\n        }\n    }\n    this.drawSelectionRectangle(options, setContextTransform);\n    // motionblur: blit rendered blurry frames\n    if (motionBlur && mbPxRatio !== 1) {\n        var cxtNode = data.contexts[r.NODE];\n        var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n        var cxtDrag = data.contexts[r.DRAG];\n        var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n        var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n            cxt.setTransform(1, 0, 0, 1, 0, 0);\n            if (needClear || !motionBlurFadeEffect) {\n                cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n            } else {\n                mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n            }\n            var pxr = mbPxRatio;\n            cxt.drawImage(txt, // img\n            0, 0, // sx, sy\n            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n            0, 0, // x, y\n            r.canvasWidth, r.canvasHeight // w, h\n            );\n        };\n        if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n            drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n            needDraw[r.NODE] = false;\n        }\n        if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n            drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n            needDraw[r.DRAG] = false;\n        }\n    }\n    r.prevViewport = vp;\n    if (r.clearingMotionBlur) {\n        r.clearingMotionBlur = false;\n        r.motionBlurCleared = true;\n        r.motionBlur = true;\n    }\n    if (motionBlur) {\n        r.motionBlurTimeout = setTimeout(function() {\n            r.motionBlurTimeout = null;\n            r.clearedForMotionBlur[r.NODE] = false;\n            r.clearedForMotionBlur[r.DRAG] = false;\n            r.motionBlur = false;\n            r.clearingMotionBlur = !textureDraw;\n            r.mbFrames = 0;\n            needDraw[r.NODE] = true;\n            needDraw[r.DRAG] = true;\n            r.redraw();\n        }, motionBlurDelay);\n    }\n    if (!forcedContext) {\n        cy.emit('render');\n    }\n};\nvar fpsHeight;\nCRp$5.drawSelectionRectangle = function(options, setContextTransform) {\n    var r = this;\n    var cy = r.cy;\n    var data = r.data;\n    var style = cy.style();\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var drawAllLayers = options.drawAllLayers;\n    var needDraw = data.canvasNeedsRedraw;\n    var forcedContext = options.forcedContext;\n    if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n        var context = forcedContext || data.contexts[r.SELECT_BOX];\n        setContextTransform(context);\n        if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n            var zoom = r.cy.zoom();\n            var borderWidth = style.core('selection-box-border-width').value / zoom;\n            context.lineWidth = borderWidth;\n            context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n            context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n            if (borderWidth > 0) {\n                context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n                context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n            }\n        }\n        if (data.bgActivePosistion && !r.hoverData.selecting) {\n            var zoom = r.cy.zoom();\n            var pos = data.bgActivePosistion;\n            context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';\n            context.beginPath();\n            context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);\n            context.fill();\n        }\n        var timeToRender = r.lastRedrawTime;\n        if (r.showFps && timeToRender) {\n            timeToRender = Math.round(timeToRender);\n            var fps = Math.round(1000 / timeToRender);\n            var text = '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps';\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n            context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n            // context.lineWidth = 1;\n            context.font = '30px Arial';\n            if (!fpsHeight) {\n                var dims = context.measureText(text);\n                fpsHeight = dims.actualBoundingBoxAscent;\n            }\n            context.fillText(text, 0, fpsHeight);\n            var maxFps = 60;\n            context.strokeRect(0, fpsHeight + 10, 250, 20);\n            context.fillRect(0, fpsHeight + 10, 250 * Math.min(fps / maxFps, 1), 20);\n        }\n        if (!drawAllLayers) {\n            needDraw[r.SELECT_BOX] = false;\n        }\n    }\n};\n/**\n * Notes:\n * - All colors have premultiplied alpha. Very important for textues and \n *   blending to work correctly.\n */ function compileShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        throw new Error(gl.getShaderInfoLog(shader));\n    }\n    // console.log(gl.getShaderInfoLog(shader));\n    return shader;\n}\nfunction createProgram(gl, vertexSource, fragementSource) {\n    var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);\n    var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragementSource);\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error('Could not initialize shaders');\n    }\n    return program;\n}\n/**\n * Creates an offscren canvas with a 2D context, for the\n * canvas renderer to use for drawing textures.\n */ function createTextureCanvas(r, width, height) {\n    if (height === undefined) {\n        height = width;\n    }\n    var canvas = r.makeOffscreenCanvas(width, height);\n    var ctx = canvas.context = canvas.getContext('2d');\n    canvas.clear = function() {\n        return ctx.clearRect(0, 0, canvas.width, canvas.height);\n    };\n    canvas.clear();\n    return canvas;\n}\n/**\n * Returns the current pan & zoom values, scaled by the pixel ratio.\n */ function getEffectivePanZoom(r) {\n    var pixelRatio = r.pixelRatio;\n    var zoom = r.cy.zoom();\n    var pan = r.cy.pan();\n    return {\n        zoom: zoom * pixelRatio,\n        pan: {\n            x: pan.x * pixelRatio,\n            y: pan.y * pixelRatio\n        }\n    };\n}\n/**\n * Returns the zoom value, scaled by the pixel ratio.\n */ function getEffectiveZoom(r) {\n    var pixelRatio = r.pixelRatio;\n    var zoom = r.cy.zoom();\n    return zoom * pixelRatio;\n}\nfunction modelToRenderedPosition(r, pan, zoom, x, y) {\n    var rx = x * zoom + pan.x;\n    var ry = y * zoom + pan.y;\n    ry = Math.round(r.canvasHeight - ry); // adjust for webgl\n    return [\n        rx,\n        ry\n    ];\n}\nfunction isSimpleShape(node) {\n    // the actual shape is checked in ElementDrawingWebGL._getVertTypeForShape()\n    // no need to check it twice, this just checks other visual properties\n    if (node.pstyle('background-fill').value !== 'solid') return false;\n    if (node.pstyle('background-image').strValue !== 'none') return false;\n    if (node.pstyle('border-width').value === 0) return true;\n    if (node.pstyle('border-opacity').value === 0) return true;\n    // we have a border but it must be simple\n    if (node.pstyle('border-style').value !== 'solid') return false;\n    // TODO ignoring 'border-cap', 'border-join' and 'border-position' for now\n    return true;\n}\nfunction arrayEqual(a1, a2) {\n    if (a1.length !== a2.length) {\n        return false;\n    }\n    for(var i = 0; i < a1.length; i++){\n        if (a1[i] !== a2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Takes color & opacity style values and converts them to WebGL format. \n * Alpha is premultiplied.\n */ function toWebGLColor(color, opacity, outArray) {\n    var r = color[0] / 255;\n    var g = color[1] / 255;\n    var b = color[2] / 255;\n    var a = opacity;\n    var arr = outArray || new Array(4);\n    arr[0] = r * a;\n    arr[1] = g * a;\n    arr[2] = b * a;\n    arr[3] = a;\n    return arr;\n}\nfunction indexToVec4(index, outArray) {\n    var arr = outArray || new Array(4);\n    arr[0] = (index >> 0 & 0xFF) / 0xFF;\n    arr[1] = (index >> 8 & 0xFF) / 0xFF;\n    arr[2] = (index >> 16 & 0xFF) / 0xFF;\n    arr[3] = (index >> 24 & 0xFF) / 0xFF;\n    return arr;\n}\nfunction vec4ToIndex(vec4) {\n    return vec4[0] + (vec4[1] << 8) + (vec4[2] << 16) + (vec4[3] << 24);\n}\nfunction createTexture(gl, debugID) {\n    var texture = gl.createTexture();\n    texture.buffer = function(offscreenCanvas) {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n        // very important, this tells webgl to premultiply colors by the alpha channel\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, offscreenCanvas);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    };\n    texture.deleteTexture = function() {\n        gl.deleteTexture(texture);\n    };\n    return texture;\n}\nfunction getTypeInfo(gl, glslType) {\n    switch(glslType){\n        case 'float':\n            return [\n                1,\n                gl.FLOAT,\n                4\n            ];\n        case 'vec2':\n            return [\n                2,\n                gl.FLOAT,\n                4\n            ];\n        case 'vec3':\n            return [\n                3,\n                gl.FLOAT,\n                4\n            ];\n        case 'vec4':\n            return [\n                4,\n                gl.FLOAT,\n                4\n            ];\n        case 'int':\n            return [\n                1,\n                gl.INT,\n                4\n            ];\n        case 'ivec2':\n            return [\n                2,\n                gl.INT,\n                4\n            ];\n    }\n}\nfunction createTypedArray(gl, glType, dataOrSize) {\n    switch(glType){\n        case gl.FLOAT:\n            return new Float32Array(dataOrSize);\n        case gl.INT:\n            return new Int32Array(dataOrSize);\n    }\n}\nfunction createTypedArrayView(gl, glType, array, stride, size, i) {\n    switch(glType){\n        case gl.FLOAT:\n            return new Float32Array(array.buffer, i * stride, size);\n        case gl.INT:\n            return new Int32Array(array.buffer, i * stride, size);\n    }\n}\n/** @param {WebGLRenderingContext} gl */ function createBufferStaticDraw(gl, type, attributeLoc, dataArray) {\n    var _getTypeInfo = getTypeInfo(gl, type), _getTypeInfo2 = _slicedToArray(_getTypeInfo, 2), size = _getTypeInfo2[0], glType = _getTypeInfo2[1];\n    var data = createTypedArray(gl, glType, dataArray);\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n    if (glType === gl.FLOAT) {\n        gl.vertexAttribPointer(attributeLoc, size, glType, false, 0, 0);\n    } else if (glType === gl.INT) {\n        gl.vertexAttribIPointer(attributeLoc, size, glType, 0, 0);\n    }\n    gl.enableVertexAttribArray(attributeLoc);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    return buffer;\n}\n/** \n * Creates a float buffer with gl.DYNAMIC_DRAW.\n * The returned buffer object contains functions to easily set instance data and buffer the data before a draw call.\n * @param {WebGLRenderingContext} gl \n */ function createBufferDynamicDraw(gl, instances, type, attributeLoc) {\n    var _getTypeInfo3 = getTypeInfo(gl, type), _getTypeInfo4 = _slicedToArray(_getTypeInfo3, 3), size = _getTypeInfo4[0], glType = _getTypeInfo4[1], bytes = _getTypeInfo4[2];\n    var dataArray = createTypedArray(gl, glType, instances * size);\n    var stride = size * bytes;\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, instances * stride, gl.DYNAMIC_DRAW);\n    gl.enableVertexAttribArray(attributeLoc);\n    if (glType === gl.FLOAT) {\n        gl.vertexAttribPointer(attributeLoc, size, glType, false, stride, 0);\n    } else if (glType === gl.INT) {\n        gl.vertexAttribIPointer(attributeLoc, size, glType, stride, 0);\n    }\n    gl.vertexAttribDivisor(attributeLoc, 1);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    // use array views to set values directly into the buffer array\n    var views = new Array(instances);\n    for(var i = 0; i < instances; i++){\n        views[i] = createTypedArrayView(gl, glType, dataArray, stride, size, i);\n    }\n    buffer.dataArray = dataArray;\n    buffer.stride = stride;\n    buffer.size = size;\n    buffer.getView = function(i) {\n        return views[i];\n    };\n    buffer.setPoint = function(i, x, y) {\n        var view = views[i];\n        view[0] = x;\n        view[1] = y;\n    };\n    buffer.bufferSubData = function(count) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        if (count) {\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray, 0, count * size);\n        } else {\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray);\n        }\n    };\n    return buffer;\n}\n/** \n * Creates a buffer of 3x3 matrix data for use as attribute data.\n * @param {WebGLRenderingContext} gl \n */ function create3x3MatrixBufferDynamicDraw(gl, instances, attributeLoc) {\n    var matrixSize = 9; // 3x3 matrix\n    var matrixData = new Float32Array(instances * matrixSize);\n    // use matrix views to set values directly into the matrixData array\n    var matrixViews = new Array(instances);\n    for(var i = 0; i < instances; i++){\n        var byteOffset = i * matrixSize * 4; // 4 bytes per float\n        matrixViews[i] = new Float32Array(matrixData.buffer, byteOffset, matrixSize); // array view\n    }\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);\n    // each row of the matrix needs to be a separate attribute\n    for(var _i = 0; _i < 3; _i++){\n        var loc = attributeLoc + _i;\n        gl.enableVertexAttribArray(loc);\n        gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 3 * 12, _i * 12);\n        gl.vertexAttribDivisor(loc, 1);\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    buffer.getMatrixView = function(i) {\n        return matrixViews[i];\n    };\n    // TODO this is too slow, use getMatrixView and pass the view directly to the glmatrix library\n    buffer.setData = function(matrix, i) {\n        matrixViews[i].set(matrix, 0);\n    };\n    buffer.bufferSubData = function() {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);\n    };\n    return buffer;\n}\n/** \n * Creates a Frame Buffer to use for offscreen rendering.\n * @param {WebGLRenderingContext} gl \n */ function createPickingFrameBuffer(gl) {\n    // Create and bind the framebuffer\n    var fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    // Create a texture to render to\n    var targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    // attach the texture as the first color attachment\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    fb.setFramebufferAttachmentSizes = function(width, height) {\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    };\n    return fb;\n}\n/**\n * Common utilities\n * @module glMatrix\n */ // Configuration Constants\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nif (!Math.hypot) Math.hypot = function() {\n    var y = 0, i = arguments.length;\n    while(i--){\n        y += arguments[i] * arguments[i];\n    }\n    return Math.sqrt(y);\n};\n/**\n * 3x3 Matrix\n * @module mat3\n */ /**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */ function create() {\n    var out = new ARRAY_TYPE(9);\n    if (ARRAY_TYPE != Float32Array) {\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[5] = 0;\n        out[6] = 0;\n        out[7] = 0;\n    }\n    out[0] = 1;\n    out[4] = 1;\n    out[8] = 1;\n    return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */ function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */ function multiply(out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2];\n    var a10 = a[3], a11 = a[4], a12 = a[5];\n    var a20 = a[6], a21 = a[7], a22 = a[8];\n    var b00 = b[0], b01 = b[1], b02 = b[2];\n    var b10 = b[3], b11 = b[4], b12 = b[5];\n    var b20 = b[6], b21 = b[7], b22 = b[8];\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */ function translate(out, a, v) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */ function rotate(out, a, rad) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/ function scale(out, a, v) {\n    var x = v[0], y = v[1];\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */ function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n// A \"texture atlas\" is a big canvas, and sections of it are used as textures for nodes/labels.\n/**\n * A single square texture atlas (also known as a \"sprite sheet\").\n */ var Atlas = /*#__PURE__*/ function() {\n    function Atlas(r, texSize, texRows, createTextureCanvas) {\n        _classCallCheck(this, Atlas);\n        this.debugID = Math.floor(Math.random() * 10000);\n        this.r = r;\n        this.texSize = texSize;\n        this.texRows = texRows;\n        this.texHeight = Math.floor(texSize / texRows);\n        this.enableWrapping = true; // hardcoded for now, can be made an option\n        this.locked = false; // once an atlas is locked it can no longer be drawn to\n        this.texture = null; // WebGLTexture object\n        this.needsBuffer = true;\n        // a \"location\" is an pointer into the atlas with a 'row' and 'x' fields\n        this.freePointer = {\n            x: 0,\n            row: 0\n        };\n        // map from the style key to the row/x where the texture starts\n        // if the texture wraps then there's a second location\n        this.keyToLocation = new Map(); // styleKey -> [ location, location ]\n        this.canvas = createTextureCanvas(r, texSize, texSize);\n        this.scratch = createTextureCanvas(r, texSize, this.texHeight, 'scratch');\n    }\n    return _createClass(Atlas, [\n        {\n            key: \"lock\",\n            value: function lock() {\n                this.locked = true;\n            }\n        },\n        {\n            key: \"getKeys\",\n            value: function getKeys() {\n                return new Set(this.keyToLocation.keys());\n            }\n        },\n        {\n            key: \"getScale\",\n            value: function getScale(_ref) {\n                var w = _ref.w, h = _ref.h;\n                var texHeight = this.texHeight, maxTexWidth = this.texSize;\n                // try to fit to the height of a row\n                var scale = texHeight / h; // TODO what about pixelRatio?\n                var texW = w * scale;\n                var texH = h * scale;\n                // if the scaled width is too wide then scale to fit max width instead\n                if (texW > maxTexWidth) {\n                    scale = maxTexWidth / w;\n                    texW = w * scale;\n                    texH = h * scale;\n                }\n                return {\n                    scale: scale,\n                    texW: texW,\n                    texH: texH\n                };\n            }\n        },\n        {\n            key: \"draw\",\n            value: function draw(key, bb, doDrawing) {\n                var _this = this;\n                if (this.locked) throw new Error('can\\'t draw, atlas is locked');\n                var texSize = this.texSize, texRows = this.texRows, texHeight = this.texHeight;\n                var _this$getScale = this.getScale(bb), scale = _this$getScale.scale, texW = _this$getScale.texW, texH = _this$getScale.texH;\n                var drawAt = function drawAt(location, canvas) {\n                    if (doDrawing && canvas) {\n                        var context = canvas.context;\n                        var x = location.x, row = location.row;\n                        var xOffset = x;\n                        var yOffset = texHeight * row;\n                        context.save();\n                        context.translate(xOffset, yOffset);\n                        context.scale(scale, scale);\n                        doDrawing(context, bb);\n                        context.restore();\n                    }\n                };\n                var locations = [\n                    null,\n                    null\n                ];\n                var drawNormal = function drawNormal() {\n                    // don't need to wrap, draw directly on the canvas\n                    drawAt(_this.freePointer, _this.canvas);\n                    locations[0] = {\n                        x: _this.freePointer.x,\n                        y: _this.freePointer.row * texHeight,\n                        w: texW,\n                        h: texH\n                    };\n                    locations[1] = {\n                        // create a second location with a width of 0, for convenience\n                        x: _this.freePointer.x + texW,\n                        y: _this.freePointer.row * texHeight,\n                        w: 0,\n                        h: texH\n                    };\n                    // move the pointer to the end of the texture\n                    _this.freePointer.x += texW;\n                    if (_this.freePointer.x == texSize) {\n                        _this.freePointer.x = 0;\n                        _this.freePointer.row++;\n                    }\n                };\n                var drawWrapped = function drawWrapped() {\n                    var scratch = _this.scratch, canvas = _this.canvas;\n                    // Draw to the scratch canvas\n                    scratch.clear();\n                    drawAt({\n                        x: 0,\n                        row: 0\n                    }, scratch);\n                    var firstTexW = texSize - _this.freePointer.x;\n                    var secondTexW = texW - firstTexW;\n                    var h = texHeight;\n                    {\n                        // copy first part of scratch to the first texture\n                        var dx = _this.freePointer.x;\n                        var dy = _this.freePointer.row * texHeight;\n                        var w = firstTexW;\n                        canvas.context.drawImage(scratch, 0, 0, w, h, dx, dy, w, h);\n                        locations[0] = {\n                            x: dx,\n                            y: dy,\n                            w: w,\n                            h: texH\n                        };\n                    }\n                    {\n                        // copy second part of scratch to the second texture\n                        var sx = firstTexW;\n                        var _dy = (_this.freePointer.row + 1) * texHeight;\n                        var _w = secondTexW;\n                        if (canvas) {\n                            canvas.context.drawImage(scratch, sx, 0, _w, h, 0, _dy, _w, h);\n                        }\n                        locations[1] = {\n                            x: 0,\n                            y: _dy,\n                            w: _w,\n                            h: texH\n                        };\n                    }\n                    _this.freePointer.x = secondTexW;\n                    _this.freePointer.row++;\n                };\n                var moveToStartOfNextRow = function moveToStartOfNextRow() {\n                    _this.freePointer.x = 0;\n                    _this.freePointer.row++;\n                };\n                if (this.freePointer.x + texW <= texSize) {\n                    // There's enough space in the current row\n                    drawNormal();\n                } else if (this.freePointer.row >= texRows - 1) {\n                    // Need to move to the next row, but there are no more rows, atlas is full.\n                    return false;\n                } else if (this.freePointer.x === texSize) {\n                    // happen to be right at end of current row\n                    moveToStartOfNextRow();\n                    drawNormal();\n                } else if (this.enableWrapping) {\n                    // draw part of the texture to the end of the curent row, then wrap to the next row\n                    drawWrapped();\n                } else {\n                    // move to the start of the next row, then draw normally\n                    moveToStartOfNextRow();\n                    drawNormal();\n                }\n                this.keyToLocation.set(key, locations);\n                this.needsBuffer = true;\n                return locations;\n            }\n        },\n        {\n            key: \"getOffsets\",\n            value: function getOffsets(key) {\n                return this.keyToLocation.get(key);\n            }\n        },\n        {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n                return this.freePointer.x === 0 && this.freePointer.row === 0;\n            }\n        },\n        {\n            key: \"canFit\",\n            value: function canFit(bb) {\n                if (this.locked) return false;\n                var texSize = this.texSize, texRows = this.texRows;\n                var _this$getScale2 = this.getScale(bb), texW = _this$getScale2.texW;\n                if (this.freePointer.x + texW > texSize) {\n                    // need to wrap\n                    return this.freePointer.row < texRows - 1; // return true if there's a row to wrap to\n                }\n                return true;\n            }\n        },\n        {\n            key: \"bufferIfNeeded\",\n            value: function bufferIfNeeded(gl) {\n                if (!this.texture) {\n                    this.texture = createTexture(gl, this.debugID);\n                }\n                if (this.needsBuffer) {\n                    this.texture.buffer(this.canvas);\n                    this.needsBuffer = false;\n                    if (this.locked) {\n                        this.canvas = null;\n                        this.scratch = null;\n                    }\n                }\n            }\n        },\n        {\n            key: \"dispose\",\n            value: function dispose() {\n                if (this.texture) {\n                    this.texture.deleteTexture();\n                    this.texture = null;\n                }\n                this.canvas = null;\n                this.scratch = null;\n                this.locked = true;\n            }\n        }\n    ]);\n}();\n/**\n * A collection of texture atlases, all of the same \"render type\". \n * ('node-body' is an example of a render type.)\n * An AtlasCollection can also be notified when a texture is no longer needed, \n * and it can garbage collect the unused textures.\n */ var AtlasCollection = /*#__PURE__*/ function() {\n    function AtlasCollection(r, texSize, texRows, createTextureCanvas) {\n        _classCallCheck(this, AtlasCollection);\n        this.r = r;\n        this.texSize = texSize;\n        this.texRows = texRows;\n        this.createTextureCanvas = createTextureCanvas;\n        this.atlases = [];\n        this.styleKeyToAtlas = new Map();\n        this.markedKeys = new Set(); // marked for garbage collection\n    }\n    return _createClass(AtlasCollection, [\n        {\n            key: \"getKeys\",\n            value: function getKeys() {\n                return new Set(this.styleKeyToAtlas.keys());\n            }\n        },\n        {\n            key: \"_createAtlas\",\n            value: function _createAtlas() {\n                var r = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas = this.createTextureCanvas;\n                return new Atlas(r, texSize, texRows, createTextureCanvas);\n            }\n        },\n        {\n            key: \"_getScratchCanvas\",\n            value: function _getScratchCanvas() {\n                if (!this.scratch) {\n                    var r = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas = this.createTextureCanvas;\n                    var texHeight = Math.floor(texSize / texRows);\n                    this.scratch = createTextureCanvas(r, texSize, texHeight, 'scratch');\n                }\n                return this.scratch;\n            }\n        },\n        {\n            key: \"draw\",\n            value: function draw(key, bb, doDrawing) {\n                var atlas = this.styleKeyToAtlas.get(key);\n                if (!atlas) {\n                    // check for space at the end of the last atlas\n                    atlas = this.atlases[this.atlases.length - 1];\n                    if (!atlas || !atlas.canFit(bb)) {\n                        if (atlas) atlas.lock();\n                        // create a new atlas\n                        atlas = this._createAtlas();\n                        this.atlases.push(atlas);\n                    }\n                    atlas.draw(key, bb, doDrawing);\n                    this.styleKeyToAtlas.set(key, atlas);\n                }\n                return atlas;\n            }\n        },\n        {\n            key: \"getAtlas\",\n            value: function getAtlas(key) {\n                return this.styleKeyToAtlas.get(key);\n            }\n        },\n        {\n            key: \"hasAtlas\",\n            value: function hasAtlas(key) {\n                return this.styleKeyToAtlas.has(key);\n            }\n        },\n        {\n            key: \"markKeyForGC\",\n            value: function markKeyForGC(key) {\n                this.markedKeys.add(key);\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                var _this2 = this;\n                var markedKeys = this.markedKeys;\n                if (markedKeys.size === 0) {\n                    console.log('nothing to garbage collect');\n                    return;\n                }\n                var newAtlases = [];\n                var newStyleKeyToAtlas = new Map();\n                var newAtlas = null;\n                var _iterator = _createForOfIteratorHelper(this.atlases), _step;\n                try {\n                    var _loop = function _loop() {\n                        var atlas = _step.value;\n                        var keys = atlas.getKeys();\n                        var keysToCollect = intersection(markedKeys, keys);\n                        if (keysToCollect.size === 0) {\n                            // this atlas can still be used\n                            newAtlases.push(atlas);\n                            keys.forEach(function(k) {\n                                return newStyleKeyToAtlas.set(k, atlas);\n                            });\n                            return 1; // continue\n                        }\n                        if (!newAtlas) {\n                            newAtlas = _this2._createAtlas();\n                            newAtlases.push(newAtlas);\n                        }\n                        var _iterator2 = _createForOfIteratorHelper(keys), _step2;\n                        try {\n                            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                                var key = _step2.value;\n                                if (!keysToCollect.has(key)) {\n                                    var _atlas$getOffsets = atlas.getOffsets(key), _atlas$getOffsets2 = _slicedToArray(_atlas$getOffsets, 2), s1 = _atlas$getOffsets2[0], s2 = _atlas$getOffsets2[1];\n                                    if (!newAtlas.canFit({\n                                        w: s1.w + s2.w,\n                                        h: s1.h\n                                    })) {\n                                        newAtlas.lock();\n                                        newAtlas = _this2._createAtlas();\n                                        newAtlases.push(newAtlas);\n                                    }\n                                    if (atlas.canvas) {\n                                        // if the texture can't be copied then it will have to be redrawn on the next frame\n                                        _this2._copyTextureToNewAtlas(key, atlas, newAtlas);\n                                        newStyleKeyToAtlas.set(key, newAtlas);\n                                    }\n                                }\n                            }\n                        } catch (err) {\n                            _iterator2.e(err);\n                        } finally{\n                            _iterator2.f();\n                        }\n                        atlas.dispose();\n                    };\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        if (_loop()) continue;\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                this.atlases = newAtlases;\n                this.styleKeyToAtlas = newStyleKeyToAtlas;\n                this.markedKeys = new Set();\n            }\n        },\n        {\n            key: \"_copyTextureToNewAtlas\",\n            value: function _copyTextureToNewAtlas(key, oldAtlas, newAtlas) {\n                var _oldAtlas$getOffsets = oldAtlas.getOffsets(key), _oldAtlas$getOffsets2 = _slicedToArray(_oldAtlas$getOffsets, 2), s1 = _oldAtlas$getOffsets2[0], s2 = _oldAtlas$getOffsets2[1];\n                if (s2.w === 0) {\n                    // the texture does not wrap, draw directly to new atlas\n                    newAtlas.draw(key, s1, function(context) {\n                        context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);\n                    });\n                } else {\n                    // the texture wraps, first draw both parts to a scratch canvas\n                    var scratch = this._getScratchCanvas();\n                    scratch.clear();\n                    scratch.context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);\n                    scratch.context.drawImage(oldAtlas.canvas, s2.x, s2.y, s2.w, s2.h, s1.w, 0, s2.w, s2.h);\n                    // now draw the scratch to the new atlas\n                    var w = s1.w + s2.w;\n                    var h = s1.h;\n                    newAtlas.draw(key, {\n                        w: w,\n                        h: h\n                    }, function(context) {\n                        context.drawImage(scratch, 0, 0, w, h, 0, 0, w, h // the destination context has already been translated to the correct position\n                        );\n                    });\n                }\n            }\n        },\n        {\n            key: \"getCounts\",\n            value: function getCounts() {\n                return {\n                    keyCount: this.styleKeyToAtlas.size,\n                    atlasCount: new Set(this.styleKeyToAtlas.values()).size\n                };\n            }\n        }\n    ]);\n}();\nfunction intersection(set1, set2) {\n    // TODO why no Set.intersection in node 16???\n    if (set1.intersection) return set1.intersection(set2);\n    else return new Set(_toConsumableArray(set1).filter(function(x) {\n        return set2.has(x);\n    }));\n}\n/**\n * Used to manage batches of Atlases for drawing nodes and labels.\n * Supports different types of AtlasCollections for different render types,\n * for example 'node-body' and 'node-label' would be different render types.\n * Render types are kept separate because they will likely need to be garbage collected\n * separately and its not entierly guaranteed that their style keys won't collide.\n */ var AtlasManager = /*#__PURE__*/ function() {\n    function AtlasManager(r, globalOptions) {\n        _classCallCheck(this, AtlasManager);\n        this.r = r;\n        this.globalOptions = globalOptions;\n        this.atlasSize = globalOptions.webglTexSize;\n        this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;\n        this.renderTypes = new Map(); // renderType:string -> renderTypeOptions\n        this.collections = new Map(); // collectionName:string -> AtlasCollection\n        this.typeAndIdToKey = new Map(); // [renderType,id] => Array<style key>\n    }\n    return _createClass(AtlasManager, [\n        {\n            key: \"getAtlasSize\",\n            value: function getAtlasSize() {\n                return this.atlasSize;\n            }\n        },\n        {\n            key: \"addAtlasCollection\",\n            value: function addAtlasCollection(collectionName, atlasCollectionOptions) {\n                var _this$globalOptions = this.globalOptions, webglTexSize = _this$globalOptions.webglTexSize, createTextureCanvas = _this$globalOptions.createTextureCanvas;\n                var texRows = atlasCollectionOptions.texRows;\n                var cachedCreateTextureCanvas = this._cacheScratchCanvas(createTextureCanvas);\n                var atlasCollection = new AtlasCollection(this.r, webglTexSize, texRows, cachedCreateTextureCanvas);\n                this.collections.set(collectionName, atlasCollection);\n            }\n        },\n        {\n            key: \"addRenderType\",\n            value: function addRenderType(type, renderTypeOptions) {\n                var collection = renderTypeOptions.collection;\n                if (!this.collections.has(collection)) throw new Error(\"invalid atlas collection name '\".concat(collection, \"'\"));\n                var atlasCollection = this.collections.get(collection);\n                var opts = extend({\n                    type: type,\n                    atlasCollection: atlasCollection\n                }, renderTypeOptions);\n                this.renderTypes.set(type, opts);\n            }\n        },\n        {\n            key: \"getRenderTypeOpts\",\n            value: function getRenderTypeOpts(type) {\n                return this.renderTypes.get(type);\n            }\n        },\n        {\n            key: \"getAtlasCollection\",\n            value: function getAtlasCollection(name) {\n                return this.collections.get(name);\n            }\n        },\n        {\n            key: \"_cacheScratchCanvas\",\n            value: function _cacheScratchCanvas(createTextureCanvas) {\n                // all scratch canvases for the same render type will have the same width and height (ie webglTexRows option)\n                // but we'll keep track of the width and height just to be safe\n                var prevW = -1;\n                var prevH = -1;\n                var scratchCanvas = null;\n                return function(r, w, h, scratch) {\n                    if (scratch) {\n                        if (!scratchCanvas || w != prevW || h != prevH) {\n                            prevW = w;\n                            prevH = h;\n                            scratchCanvas = createTextureCanvas(r, w, h);\n                        }\n                        return scratchCanvas;\n                    } else {\n                        return createTextureCanvas(r, w, h);\n                    }\n                };\n            }\n        },\n        {\n            key: \"_key\",\n            value: function _key(renderType, id) {\n                return \"\".concat(renderType, \"-\").concat(id); // TODO not very efficient\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(eles) {\n                var _this3 = this;\n                var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref2$forceRedraw = _ref2.forceRedraw, forceRedraw = _ref2$forceRedraw === undefined ? false : _ref2$forceRedraw, _ref2$filterEle = _ref2.filterEle, filterEle = _ref2$filterEle === undefined ? function() {\n                    return true;\n                } : _ref2$filterEle, _ref2$filterType = _ref2.filterType, filterType = _ref2$filterType === undefined ? function() {\n                    return true;\n                } : _ref2$filterType;\n                var needGC = false;\n                var runGCNow = false;\n                var _iterator3 = _createForOfIteratorHelper(eles), _step3;\n                try {\n                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                        var ele = _step3.value;\n                        if (filterEle(ele)) {\n                            var _iterator4 = _createForOfIteratorHelper(this.renderTypes.values()), _step4;\n                            try {\n                                var _loop2 = function _loop2() {\n                                    var opts = _step4.value;\n                                    var renderType = opts.type;\n                                    if (filterType(renderType)) {\n                                        var atlasCollection = _this3.collections.get(opts.collection);\n                                        var key = opts.getKey(ele);\n                                        var keyArray = Array.isArray(key) ? key : [\n                                            key\n                                        ];\n                                        // when a node's background image finishes loading, the style key doesn't change but still needs to be redrawn\n                                        if (forceRedraw) {\n                                            keyArray.forEach(function(key) {\n                                                return atlasCollection.markKeyForGC(key);\n                                            });\n                                            runGCNow = true; // run GC to remove the old texture right now, that way we don't need to remember for the next gc \n                                        } else {\n                                            var id = opts.getID ? opts.getID(ele) : ele.id();\n                                            var mapKey = _this3._key(renderType, id);\n                                            var oldKeyArray = _this3.typeAndIdToKey.get(mapKey);\n                                            if (oldKeyArray !== undefined && !arrayEqual(keyArray, oldKeyArray)) {\n                                                // conservative approach, if any of the keys don't match then throw them all away\n                                                needGC = true;\n                                                _this3.typeAndIdToKey[\"delete\"](mapKey);\n                                                oldKeyArray.forEach(function(oldKey) {\n                                                    return atlasCollection.markKeyForGC(oldKey);\n                                                });\n                                            }\n                                        }\n                                    }\n                                };\n                                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                                    _loop2();\n                                }\n                            } catch (err) {\n                                _iterator4.e(err);\n                            } finally{\n                                _iterator4.f();\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _iterator3.e(err);\n                } finally{\n                    _iterator3.f();\n                }\n                if (runGCNow) {\n                    this.gc();\n                    needGC = false;\n                }\n                return needGC;\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                var _iterator5 = _createForOfIteratorHelper(this.collections.values()), _step5;\n                try {\n                    for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                        var collection = _step5.value;\n                        collection.gc();\n                    }\n                } catch (err) {\n                    _iterator5.e(err);\n                } finally{\n                    _iterator5.f();\n                }\n            }\n        },\n        {\n            key: \"getOrCreateAtlas\",\n            value: function getOrCreateAtlas(ele, type, bb, styleKey) {\n                // styleKey is not an array here\n                var opts = this.renderTypes.get(type);\n                var atlasCollection = this.collections.get(opts.collection);\n                // draws the texture only if needed\n                var drawn = false;\n                var atlas = atlasCollection.draw(styleKey, bb, function(context) {\n                    if (opts.drawClipped) {\n                        context.save();\n                        context.beginPath();\n                        context.rect(0, 0, bb.w, bb.h);\n                        context.clip();\n                        opts.drawElement(context, ele, bb, true, true);\n                        context.restore();\n                    } else {\n                        opts.drawElement(context, ele, bb, true, true);\n                    }\n                    drawn = true;\n                });\n                if (drawn) {\n                    var id = opts.getID ? opts.getID(ele) : ele.id(); // for testing\n                    var mapKey = this._key(type, id);\n                    if (this.typeAndIdToKey.has(mapKey)) {\n                        this.typeAndIdToKey.get(mapKey).push(styleKey);\n                    } else {\n                        this.typeAndIdToKey.set(mapKey, [\n                            styleKey\n                        ]);\n                    }\n                }\n                return atlas;\n            }\n        },\n        {\n            key: \"getAtlasInfo\",\n            value: function getAtlasInfo(ele, type) {\n                var _this4 = this;\n                var opts = this.renderTypes.get(type);\n                var key = opts.getKey(ele);\n                var keyArray = Array.isArray(key) ? key : [\n                    key\n                ];\n                return keyArray.map(function(styleKey) {\n                    var bb = opts.getBoundingBox(ele, styleKey); // pass the key back to the getBoundingBox method\n                    var atlas = _this4.getOrCreateAtlas(ele, type, bb, styleKey);\n                    var _atlas$getOffsets3 = atlas.getOffsets(styleKey), _atlas$getOffsets4 = _slicedToArray(_atlas$getOffsets3, 2), tex1 = _atlas$getOffsets4[0], tex2 = _atlas$getOffsets4[1];\n                    return {\n                        atlas: atlas,\n                        tex: tex1,\n                        tex1: tex1,\n                        tex2: tex2,\n                        bb: bb\n                    };\n                });\n            }\n        },\n        {\n            key: \"getDebugInfo\",\n            value: function getDebugInfo() {\n                var debugInfo = [];\n                var _iterator6 = _createForOfIteratorHelper(this.collections), _step6;\n                try {\n                    for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                        var _step6$value = _slicedToArray(_step6.value, 2), name = _step6$value[0], collection = _step6$value[1];\n                        var _collection$getCounts = collection.getCounts(), keyCount = _collection$getCounts.keyCount, atlasCount = _collection$getCounts.atlasCount;\n                        debugInfo.push({\n                            type: name,\n                            keyCount: keyCount,\n                            atlasCount: atlasCount\n                        });\n                    }\n                } catch (err) {\n                    _iterator6.e(err);\n                } finally{\n                    _iterator6.f();\n                }\n                return debugInfo;\n            }\n        }\n    ]);\n}();\nvar AtlasBatchManager = /*#__PURE__*/ function() {\n    function AtlasBatchManager(globalOptions) {\n        _classCallCheck(this, AtlasBatchManager);\n        this.globalOptions = globalOptions;\n        this.atlasSize = globalOptions.webglTexSize;\n        this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;\n        this.batchAtlases = [];\n    }\n    return _createClass(AtlasBatchManager, [\n        {\n            key: \"getMaxAtlasesPerBatch\",\n            value: function getMaxAtlasesPerBatch() {\n                return this.maxAtlasesPerBatch;\n            }\n        },\n        {\n            key: \"getAtlasSize\",\n            value: function getAtlasSize() {\n                return this.atlasSize;\n            }\n        },\n        {\n            key: \"getIndexArray\",\n            value: function getIndexArray() {\n                return Array.from({\n                    length: this.maxAtlasesPerBatch\n                }, function(v, i) {\n                    return i;\n                });\n            }\n        },\n        {\n            key: \"startBatch\",\n            value: function startBatch() {\n                this.batchAtlases = [];\n            }\n        },\n        {\n            key: \"getAtlasCount\",\n            value: function getAtlasCount() {\n                return this.batchAtlases.length;\n            }\n        },\n        {\n            key: \"getAtlases\",\n            value: function getAtlases() {\n                return this.batchAtlases;\n            }\n        },\n        {\n            key: \"canAddToCurrentBatch\",\n            value: function canAddToCurrentBatch(atlas) {\n                if (this.batchAtlases.length === this.maxAtlasesPerBatch) {\n                    return this.batchAtlases.includes(atlas);\n                }\n                return true; // not full\n            }\n        },\n        {\n            key: \"getAtlasIndexForBatch\",\n            value: function getAtlasIndexForBatch(atlas) {\n                var atlasID = this.batchAtlases.indexOf(atlas);\n                if (atlasID < 0) {\n                    if (this.batchAtlases.length === this.maxAtlasesPerBatch) {\n                        throw new Error('cannot add more atlases to batch');\n                    }\n                    this.batchAtlases.push(atlas);\n                    atlasID = this.batchAtlases.length - 1;\n                }\n                return atlasID;\n            }\n        }\n    ]);\n}();\n// Fragment shader functions to calculate signed distance\n// https://iquilezles.org/articles/distfunctions2d/\n// ellipse: https://www.shadertoy.com/view/4lsXDN \n/**\n * param p - point\n * float r - circle radius, eg 0.5 for unit circle\n */ var circleSD = \"\\n  float circleSD(vec2 p, float r) {\\n    return distance(vec2(0), p) - r; // signed distance\\n  }\\n\";\n/**\n * param p - point\n * param b - b.x = half width, b.y = half height\n */ var rectangleSD = \"\\n  float rectangleSD(vec2 p, vec2 b) {\\n    vec2 d = abs(p)-b;\\n    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);\\n  }\\n\";\n/**\n * param p - point\n * param b - b.x = half width, b.y = half height\n * param cr - vector of corner radiuses\n */ var roundRectangleSD = \"\\n  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {\\n    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;\\n    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;\\n    vec2 q = abs(p) - b + cr.x;\\n    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;\\n  }\\n\";\n/**\n * param p - point\n * param ab - a.x = horizontal radius, a.y = vertical radius\n */ var ellipseSD = \"\\n  float ellipseSD(vec2 p, vec2 ab) {\\n    p = abs( p ); // symmetry\\n\\n    // find root with Newton solver\\n    vec2 q = ab*(p-ab);\\n    float w = (q.x<q.y)? 1.570796327 : 0.0;\\n    for( int i=0; i<5; i++ ) {\\n      vec2 cs = vec2(cos(w),sin(w));\\n      vec2 u = ab*vec2( cs.x,cs.y);\\n      vec2 v = ab*vec2(-cs.y,cs.x);\\n      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\\n    }\\n    \\n    // compute final point and distance\\n    float d = length(p-ab*vec2(cos(w),sin(w)));\\n    \\n    // return signed distance\\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\\n  }\\n\";\n/**\n * Two render modes. Each mode has its own shader program. They are almost identical, the main difference is the output.\n * SCREEN:  output pixel colors to the screen\n * PICKING: output z-order index to an offscreen framebuffer, used to detect what's under the mouse cursor\n */ var RENDER_TARGET = {\n    SCREEN: {\n        name: 'screen',\n        screen: true\n    },\n    PICKING: {\n        name: 'picking',\n        picking: true\n    }\n};\n/**\n * Special handing for label textures in PICKING mode. See issue #3337.\n */ var TEX_PICKING_MODE = {\n    // render the texture just like in RENDER_TARGET.SCREEN mode\n    IGNORE: 1,\n    // don't render the texture at all\n    USE_BB: 2 // render the bounding box as an opaque rectangle\n};\n// Vertex types.\n// Used directly in the shaders so must be numeric.\n// There is only one shader program used for an entire frame that renders all types of elements.\n// There are if-else blocks in the shaders that do different things depending on the vertex type.\n// This allows all elements to be rendererd in large batches without switching shader programs.\nvar TEXTURE = 0;\nvar EDGE_STRAIGHT = 1;\nvar EDGE_CURVE_SEGMENT = 2;\nvar EDGE_ARROW = 3;\nvar RECTANGLE = 4;\nvar ROUND_RECTANGLE = 5;\nvar BOTTOM_ROUND_RECTANGLE = 6;\nvar ELLIPSE = 7;\nvar ElementDrawingWebGL = /*#__PURE__*/ function() {\n    /**\n   * @param {WebGLRenderingContext} gl\n   */ function ElementDrawingWebGL(r, gl, opts) {\n        _classCallCheck(this, ElementDrawingWebGL);\n        this.r = r; // reference to the canvas renderer\n        this.gl = gl;\n        this.maxInstances = opts.webglBatchSize;\n        this.atlasSize = opts.webglTexSize;\n        this.bgColor = opts.bgColor;\n        this.debug = opts.webglDebug;\n        this.batchDebugInfo = [];\n        opts.enableWrapping = true;\n        opts.createTextureCanvas = createTextureCanvas; // Unit tests mock this\n        this.atlasManager = new AtlasManager(r, opts);\n        this.batchManager = new AtlasBatchManager(opts);\n        this.simpleShapeOptions = new Map();\n        this.program = this._createShaderProgram(RENDER_TARGET.SCREEN);\n        this.pickingProgram = this._createShaderProgram(RENDER_TARGET.PICKING);\n        this.vao = this._createVAO();\n    }\n    /**\n   * @param { string } collectionName\n   * @param {{ texRows: number }} opts\n   */ return _createClass(ElementDrawingWebGL, [\n        {\n            key: \"addAtlasCollection\",\n            value: function addAtlasCollection(collectionName, opts) {\n                this.atlasManager.addAtlasCollection(collectionName, opts);\n            }\n        },\n        {\n            key: \"addTextureAtlasRenderType\",\n            value: function addTextureAtlasRenderType(typeName, opts) {\n                this.atlasManager.addRenderType(typeName, opts);\n            }\n        },\n        {\n            key: \"addSimpleShapeRenderType\",\n            value: function addSimpleShapeRenderType(typeName, opts) {\n                this.simpleShapeOptions.set(typeName, opts);\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(eles) {\n                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, type = _ref.type;\n                var atlasManager = this.atlasManager;\n                if (type) {\n                    return atlasManager.invalidate(eles, {\n                        filterType: function filterType(t) {\n                            return t === type;\n                        },\n                        forceRedraw: true\n                    });\n                } else {\n                    return atlasManager.invalidate(eles);\n                }\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                this.atlasManager.gc();\n            }\n        },\n        {\n            key: \"_createShaderProgram\",\n            value: function _createShaderProgram(renderTarget) {\n                var gl = this.gl;\n                var vertexShaderSource = \"#version 300 es\\n      precision highp float;\\n\\n      uniform mat3 uPanZoomMatrix;\\n      uniform int  uAtlasSize;\\n      \\n      // instanced\\n      in vec2 aPosition; // a vertex from the unit square\\n      \\n      in mat3 aTransform; // used to transform verticies, eg into a bounding box\\n      in int aVertType; // the type of thing we are rendering\\n\\n      // the z-index that is output when using picking mode\\n      in vec4 aIndex;\\n      \\n      // For textures\\n      in int aAtlasId; // which shader unit/atlas to use\\n      in vec4 aTex; // x/y/w/h of texture in atlas\\n\\n      // for edges\\n      in vec4 aPointAPointB;\\n      in vec4 aPointCPointD;\\n      in vec2 aLineWidth; // also used for node border width\\n\\n      // simple shapes\\n      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]\\n      in vec4 aColor; // also used for edges\\n      in vec4 aBorderColor; // aLineWidth is used for border width\\n\\n      // output values passed to the fragment shader\\n      out vec2 vTexCoord;\\n      out vec4 vColor;\\n      out vec2 vPosition;\\n      // flat values are not interpolated\\n      flat out int vAtlasId; \\n      flat out int vVertType;\\n      flat out vec2 vTopRight;\\n      flat out vec2 vBotLeft;\\n      flat out vec4 vCornerRadius;\\n      flat out vec4 vBorderColor;\\n      flat out vec2 vBorderWidth;\\n      flat out vec4 vIndex;\\n      \\n      void main(void) {\\n        int vid = gl_VertexID;\\n        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below\\n\\n        if(aVertType == \".concat(TEXTURE, \") {\\n          float texX = aTex.x; // texture coordinates\\n          float texY = aTex.y;\\n          float texW = aTex.z;\\n          float texH = aTex.w;\\n\\n          if(vid == 1 || vid == 2 || vid == 4) {\\n            texX += texW;\\n          }\\n          if(vid == 2 || vid == 4 || vid == 5) {\\n            texY += texH;\\n          }\\n\\n          float d = float(uAtlasSize);\\n          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n        }\\n        else if(aVertType == \").concat(RECTANGLE, \" || aVertType == \").concat(ELLIPSE, \" \\n             || aVertType == \").concat(ROUND_RECTANGLE, \" || aVertType == \").concat(BOTTOM_ROUND_RECTANGLE, \") { // simple shapes\\n\\n          // the bounding box is needed by the fragment shader\\n          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat\\n          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat\\n          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated\\n\\n          // calculations are done in the fragment shader, just pass these along\\n          vColor = aColor;\\n          vCornerRadius = aCornerRadius;\\n          vBorderColor = aBorderColor;\\n          vBorderWidth = aLineWidth;\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n        }\\n        else if(aVertType == \").concat(EDGE_STRAIGHT, \") {\\n          vec2 source = aPointAPointB.xy;\\n          vec2 target = aPointAPointB.zw;\\n\\n          // adjust the geometry so that the line is centered on the edge\\n          position.y = position.y - 0.5;\\n\\n          // stretch the unit square into a long skinny rectangle\\n          vec2 xBasis = target - source;\\n          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\\n          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;\\n\\n          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);\\n          vColor = aColor;\\n        } \\n        else if(aVertType == \").concat(EDGE_CURVE_SEGMENT, \") {\\n          vec2 pointA = aPointAPointB.xy;\\n          vec2 pointB = aPointAPointB.zw;\\n          vec2 pointC = aPointCPointD.xy;\\n          vec2 pointD = aPointCPointD.zw;\\n\\n          // adjust the geometry so that the line is centered on the edge\\n          position.y = position.y - 0.5;\\n\\n          vec2 p0, p1, p2, pos;\\n          if(position.x == 0.0) { // The left side of the unit square\\n            p0 = pointA;\\n            p1 = pointB;\\n            p2 = pointC;\\n            pos = position;\\n          } else { // The right side of the unit square, use same approach but flip the geometry upside down\\n            p0 = pointD;\\n            p1 = pointC;\\n            p2 = pointB;\\n            pos = vec2(0.0, -position.y);\\n          }\\n\\n          vec2 p01 = p1 - p0;\\n          vec2 p12 = p2 - p1;\\n          vec2 p21 = p1 - p2;\\n\\n          // Find the normal vector.\\n          vec2 tangent = normalize(normalize(p12) + normalize(p01));\\n          vec2 normal = vec2(-tangent.y, tangent.x);\\n\\n          // Find the vector perpendicular to p0 -> p1.\\n          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));\\n\\n          // Determine the bend direction.\\n          float sigma = sign(dot(p01 + p21, normal));\\n          float width = aLineWidth[0];\\n\\n          if(sign(pos.y) == -sigma) {\\n            // This is an intersecting vertex. Adjust the position so that there's no overlap.\\n            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);\\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\\n          } else {\\n            // This is a non-intersecting vertex. Treat it like a mitre join.\\n            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);\\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\\n          }\\n\\n          vColor = aColor;\\n        } \\n        else if(aVertType == \").concat(EDGE_ARROW, \" && vid < 3) {\\n          // massage the first triangle into an edge arrow\\n          if(vid == 0)\\n            position = vec2(-0.15, -0.3);\\n          if(vid == 1)\\n            position = vec2(  0.0,  0.0);\\n          if(vid == 2)\\n            position = vec2( 0.15, -0.3);\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n          vColor = aColor;\\n        }\\n        else {\\n          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space\\n        }\\n\\n        vAtlasId = aAtlasId;\\n        vVertType = aVertType;\\n        vIndex = aIndex;\\n      }\\n    \");\n                var idxs = this.batchManager.getIndexArray();\n                var fragmentShaderSource = \"#version 300 es\\n      precision highp float;\\n\\n      // declare texture unit for each texture atlas in the batch\\n      \".concat(idxs.map(function(i) {\n                    return \"uniform sampler2D uTexture\".concat(i, \";\");\n                }).join('\\n\\t'), \"\\n\\n      uniform vec4 uBGColor;\\n      uniform float uZoom;\\n\\n      in vec2 vTexCoord;\\n      in vec4 vColor;\\n      in vec2 vPosition; // model coordinates\\n\\n      flat in int vAtlasId;\\n      flat in vec4 vIndex;\\n      flat in int vVertType;\\n      flat in vec2 vTopRight;\\n      flat in vec2 vBotLeft;\\n      flat in vec4 vCornerRadius;\\n      flat in vec4 vBorderColor;\\n      flat in vec2 vBorderWidth;\\n\\n      out vec4 outColor;\\n\\n      \").concat(circleSD, \"\\n      \").concat(rectangleSD, \"\\n      \").concat(roundRectangleSD, \"\\n      \").concat(ellipseSD, \"\\n\\n      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha\\n        return vec4( \\n          top.rgb + (bot.rgb * (1.0 - top.a)),\\n          top.a   + (bot.a   * (1.0 - top.a)) \\n        );\\n      }\\n\\n      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance\\n        // scale to the zoom level so that borders don't look blurry when zoomed in\\n        // note 1.5 is an aribitrary value chosen because it looks good\\n        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); \\n      }\\n\\n      void main(void) {\\n        if(vVertType == \").concat(TEXTURE, \") {\\n          // look up the texel from the texture unit\\n          \").concat(idxs.map(function(i) {\n                    return \"if(vAtlasId == \".concat(i, \") outColor = texture(uTexture\").concat(i, \", vTexCoord);\");\n                }).join('\\n\\telse '), \"\\n        } \\n        else if(vVertType == \").concat(EDGE_ARROW, \") {\\n          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';\\n          outColor = blend(vColor, uBGColor);\\n          outColor.a = 1.0; // make opaque, masks out line under arrow\\n        }\\n        else if(vVertType == \").concat(RECTANGLE, \" && vBorderWidth == vec2(0.0)) { // simple rectangle with no border\\n          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done\\n        }\\n        else if(vVertType == \").concat(RECTANGLE, \" || vVertType == \").concat(ELLIPSE, \" \\n          || vVertType == \").concat(ROUND_RECTANGLE, \" || vVertType == \").concat(BOTTOM_ROUND_RECTANGLE, \") { // use SDF\\n\\n          float outerBorder = vBorderWidth[0];\\n          float innerBorder = vBorderWidth[1];\\n          float borderPadding = outerBorder * 2.0;\\n          float w = vTopRight.x - vBotLeft.x - borderPadding;\\n          float h = vTopRight.y - vBotLeft.y - borderPadding;\\n          vec2 b = vec2(w/2.0, h/2.0); // half width, half height\\n          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center\\n\\n          float d; // signed distance\\n          if(vVertType == \").concat(RECTANGLE, \") {\\n            d = rectangleSD(p, b);\\n          } else if(vVertType == \").concat(ELLIPSE, \" && w == h) {\\n            d = circleSD(p, b.x); // faster than ellipse\\n          } else if(vVertType == \").concat(ELLIPSE, \") {\\n            d = ellipseSD(p, b);\\n          } else {\\n            d = roundRectangleSD(p, b, vCornerRadius.wzyx);\\n          }\\n\\n          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling\\n          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box\\n          if(d > 0.0) {\\n            if(d > outerBorder) {\\n              discard;\\n            } else {\\n              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);\\n            }\\n          } else {\\n            if(d > innerBorder) {\\n              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;\\n              vec4 innerBorderColor = blend(vBorderColor, vColor);\\n              outColor = distInterp(innerBorderColor, outerColor, d);\\n            } \\n            else {\\n              vec4 outerColor;\\n              if(innerBorder == 0.0 && outerBorder == 0.0) {\\n                outerColor = vec4(0);\\n              } else if(innerBorder == 0.0) {\\n                outerColor = vBorderColor;\\n              } else {\\n                outerColor = blend(vBorderColor, vColor);\\n              }\\n              outColor = distInterp(vColor, outerColor, d - innerBorder);\\n            }\\n          }\\n        }\\n        else {\\n          outColor = vColor;\\n        }\\n\\n        \").concat(renderTarget.picking ? \"if(outColor.a == 0.0) discard;\\n             else outColor = vIndex;\" : '', \"\\n      }\\n    \");\n                var program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n                // instance geometry\n                program.aPosition = gl.getAttribLocation(program, 'aPosition');\n                // attributes\n                program.aIndex = gl.getAttribLocation(program, 'aIndex');\n                program.aVertType = gl.getAttribLocation(program, 'aVertType');\n                program.aTransform = gl.getAttribLocation(program, 'aTransform');\n                program.aAtlasId = gl.getAttribLocation(program, 'aAtlasId');\n                program.aTex = gl.getAttribLocation(program, 'aTex');\n                program.aPointAPointB = gl.getAttribLocation(program, 'aPointAPointB');\n                program.aPointCPointD = gl.getAttribLocation(program, 'aPointCPointD');\n                program.aLineWidth = gl.getAttribLocation(program, 'aLineWidth');\n                program.aColor = gl.getAttribLocation(program, 'aColor');\n                program.aCornerRadius = gl.getAttribLocation(program, 'aCornerRadius');\n                program.aBorderColor = gl.getAttribLocation(program, 'aBorderColor');\n                // uniforms\n                program.uPanZoomMatrix = gl.getUniformLocation(program, 'uPanZoomMatrix');\n                program.uAtlasSize = gl.getUniformLocation(program, 'uAtlasSize');\n                program.uBGColor = gl.getUniformLocation(program, 'uBGColor');\n                program.uZoom = gl.getUniformLocation(program, 'uZoom');\n                program.uTextures = [];\n                for(var i = 0; i < this.batchManager.getMaxAtlasesPerBatch(); i++){\n                    program.uTextures.push(gl.getUniformLocation(program, \"uTexture\".concat(i)));\n                }\n                return program;\n            }\n        },\n        {\n            key: \"_createVAO\",\n            value: function _createVAO() {\n                var unitSquare = [\n                    0,\n                    0,\n                    1,\n                    0,\n                    1,\n                    1,\n                    0,\n                    0,\n                    1,\n                    1,\n                    0,\n                    1\n                ];\n                this.vertexCount = unitSquare.length / 2;\n                var n = this.maxInstances;\n                var gl = this.gl, program = this.program;\n                var vao = gl.createVertexArray();\n                gl.bindVertexArray(vao);\n                createBufferStaticDraw(gl, 'vec2', program.aPosition, unitSquare);\n                // Create buffers for all the attributes\n                this.transformBuffer = create3x3MatrixBufferDynamicDraw(gl, n, program.aTransform);\n                this.indexBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aIndex);\n                this.vertTypeBuffer = createBufferDynamicDraw(gl, n, 'int', program.aVertType);\n                this.atlasIdBuffer = createBufferDynamicDraw(gl, n, 'int', program.aAtlasId);\n                this.texBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aTex);\n                this.pointAPointBBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aPointAPointB);\n                this.pointCPointDBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aPointCPointD);\n                this.lineWidthBuffer = createBufferDynamicDraw(gl, n, 'vec2', program.aLineWidth);\n                this.colorBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aColor);\n                this.cornerRadiusBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aCornerRadius);\n                this.borderColorBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aBorderColor);\n                gl.bindVertexArray(null);\n                return vao;\n            }\n        },\n        {\n            key: \"buffers\",\n            get: function get() {\n                var _this = this;\n                if (!this._buffers) {\n                    this._buffers = Object.keys(this).filter(function(k) {\n                        return endsWith(k, 'Buffer');\n                    }).map(function(k) {\n                        return _this[k];\n                    });\n                }\n                return this._buffers;\n            }\n        },\n        {\n            key: \"startFrame\",\n            value: function startFrame(panZoomMatrix) {\n                var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RENDER_TARGET.SCREEN;\n                this.panZoomMatrix = panZoomMatrix;\n                this.renderTarget = renderTarget;\n                this.batchDebugInfo = [];\n                this.wrappedCount = 0;\n                this.simpleCount = 0;\n                this.startBatch();\n            }\n        },\n        {\n            key: \"startBatch\",\n            value: function startBatch() {\n                this.instanceCount = 0;\n                this.batchManager.startBatch();\n            }\n        },\n        {\n            key: \"endFrame\",\n            value: function endFrame() {\n                this.endBatch();\n            }\n        },\n        {\n            key: \"_isVisible\",\n            value: function _isVisible(ele, opts) {\n                if (ele.visible()) {\n                    if (opts && opts.isVisible) {\n                        return opts.isVisible(ele);\n                    }\n                    return true;\n                }\n                return false;\n            }\n        },\n        {\n            key: \"drawTexture\",\n            value: function drawTexture(ele, eleIndex, type) {\n                var atlasManager = this.atlasManager, batchManager = this.batchManager;\n                var opts = atlasManager.getRenderTypeOpts(type);\n                if (!this._isVisible(ele, opts)) {\n                    return;\n                }\n                // Edges with invalid points could be passed here (labels), causing errors\n                // Ref: Random \"Script Error\" thrown when generating nodes and edges in newest webgl version #3365\n                // https://github.com/cytoscape/cytoscape.js/issues/3365\n                if (ele.isEdge() && !this._isValidEdge(ele)) {\n                    return;\n                }\n                if (this.renderTarget.picking && opts.getTexPickingMode) {\n                    var mode = opts.getTexPickingMode(ele);\n                    if (mode === TEX_PICKING_MODE.IGNORE) {\n                        return;\n                    } else if (mode == TEX_PICKING_MODE.USE_BB) {\n                        this.drawPickingRectangle(ele, eleIndex, type);\n                        return;\n                    }\n                }\n                // Get the atlas and the texture coordinates, will draw the texture if it hasn't been drawn yet\n                // May be more than one texture if for example the label has multiple lines\n                var atlasInfoArray = atlasManager.getAtlasInfo(ele, type);\n                var _iterator = _createForOfIteratorHelper(atlasInfoArray), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var atlasInfo = _step.value;\n                        var atlas = atlasInfo.atlas, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2; // tex2 is used if the label wraps and there are two textures\n                        if (!batchManager.canAddToCurrentBatch(atlas)) {\n                            this.endBatch();\n                        }\n                        var atlasIndex = batchManager.getAtlasIndexForBatch(atlas);\n                        for(var _i = 0, _arr = [\n                            [\n                                tex1,\n                                true\n                            ],\n                            [\n                                tex2,\n                                false\n                            ]\n                        ]; _i < _arr.length; _i++){\n                            var _arr$_i = _slicedToArray(_arr[_i], 2), tex = _arr$_i[0], first = _arr$_i[1];\n                            if (tex.w != 0) {\n                                var instance = this.instanceCount;\n                                this.vertTypeBuffer.getView(instance)[0] = TEXTURE;\n                                var indexView = this.indexBuffer.getView(instance);\n                                indexToVec4(eleIndex, indexView);\n                                // Set values in the buffers using Typed Array Views for performance.\n                                var atlasIdView = this.atlasIdBuffer.getView(instance);\n                                atlasIdView[0] = atlasIndex;\n                                // we have two sets of texture coordinates and transforms because textures can wrap in the atlas\n                                var texView = this.texBuffer.getView(instance);\n                                texView[0] = tex.x;\n                                texView[1] = tex.y;\n                                texView[2] = tex.w;\n                                texView[3] = tex.h;\n                                var matrixView = this.transformBuffer.getMatrixView(instance);\n                                this.setTransformMatrix(ele, matrixView, opts, atlasInfo, first);\n                                this.instanceCount++;\n                                if (!first) this.wrappedCount++;\n                                if (this.instanceCount >= this.maxInstances) {\n                                    this.endBatch();\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n            }\n        },\n        {\n            key: \"setTransformMatrix\",\n            value: function setTransformMatrix(ele, matrix, opts, atlasInfo) {\n                var first = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n                var padding = 0;\n                if (opts.shapeProps && opts.shapeProps.padding) {\n                    padding = ele.pstyle(opts.shapeProps.padding).pfValue;\n                }\n                if (atlasInfo) {\n                    // we've already computed the bb and tex bounds for a texture\n                    var bb = atlasInfo.bb, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2;\n                    // wrapped textures need separate matrix for each part\n                    var ratio = tex1.w / (tex1.w + tex2.w);\n                    if (!first) {\n                        // first = true means its the first part of the wrapped texture\n                        ratio = 1 - ratio;\n                    }\n                    var adjBB = this._getAdjustedBB(bb, padding, first, ratio);\n                    this._applyTransformMatrix(matrix, adjBB, opts, ele);\n                } else {\n                    // we don't have a texture, or we want to avoid creating a texture for simple shapes\n                    var _bb = opts.getBoundingBox(ele);\n                    var _adjBB = this._getAdjustedBB(_bb, padding, true, 1);\n                    this._applyTransformMatrix(matrix, _adjBB, opts, ele);\n                }\n            }\n        },\n        {\n            key: \"_applyTransformMatrix\",\n            value: function _applyTransformMatrix(matrix, adjBB, opts, ele) {\n                var x, y;\n                identity(matrix);\n                var theta = opts.getRotation ? opts.getRotation(ele) : 0;\n                if (theta !== 0) {\n                    var _opts$getRotationPoin = opts.getRotationPoint(ele), sx = _opts$getRotationPoin.x, sy = _opts$getRotationPoin.y;\n                    translate(matrix, matrix, [\n                        sx,\n                        sy\n                    ]);\n                    rotate(matrix, matrix, theta);\n                    var offset = opts.getRotationOffset(ele);\n                    x = offset.x + (adjBB.xOffset || 0);\n                    y = offset.y + (adjBB.yOffset || 0);\n                } else {\n                    x = adjBB.x1;\n                    y = adjBB.y1;\n                }\n                translate(matrix, matrix, [\n                    x,\n                    y\n                ]);\n                scale(matrix, matrix, [\n                    adjBB.w,\n                    adjBB.h\n                ]);\n            }\n        },\n        {\n            key: \"_getAdjustedBB\",\n            value: function _getAdjustedBB(bb, padding, first, ratio) {\n                var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h, yOffset = bb.yOffset;\n                if (padding) {\n                    x1 -= padding;\n                    y1 -= padding;\n                    w += 2 * padding;\n                    h += 2 * padding;\n                }\n                var xOffset = 0;\n                var adjW = w * ratio;\n                if (first && ratio < 1) {\n                    w = adjW;\n                } else if (!first && ratio < 1) {\n                    xOffset = w - adjW;\n                    x1 += xOffset;\n                    w = adjW;\n                }\n                return {\n                    x1: x1,\n                    y1: y1,\n                    w: w,\n                    h: h,\n                    xOffset: xOffset,\n                    yOffset: yOffset\n                };\n            }\n        },\n        {\n            key: \"drawPickingRectangle\",\n            value: function drawPickingRectangle(ele, eleIndex, type) {\n                var opts = this.atlasManager.getRenderTypeOpts(type);\n                var instance = this.instanceCount;\n                this.vertTypeBuffer.getView(instance)[0] = RECTANGLE;\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor([\n                    0,\n                    0,\n                    0\n                ], 1, colorView); // opaque, so entire label BB is clickable\n                var matrixView = this.transformBuffer.getMatrixView(instance);\n                this.setTransformMatrix(ele, matrixView, opts);\n                this.simpleCount++;\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"drawNode\",\n            value: function drawNode(node, eleIndex, type) {\n                var opts = this.simpleShapeOptions.get(type);\n                if (!this._isVisible(node, opts)) {\n                    return;\n                }\n                var props = opts.shapeProps;\n                // Check if we have to use a texture\n                var vertType = this._getVertTypeForShape(node, props.shape);\n                if (vertType === undefined || opts.isSimple && !opts.isSimple(node)) {\n                    this.drawTexture(node, eleIndex, type);\n                    return;\n                }\n                // Render a \"simple shape\" using SDF (signed distance fields)\n                var instance = this.instanceCount;\n                this.vertTypeBuffer.getView(instance)[0] = vertType;\n                if (vertType === ROUND_RECTANGLE || vertType === BOTTOM_ROUND_RECTANGLE) {\n                    // get corner radius\n                    var bb = opts.getBoundingBox(node);\n                    var radius = this._getCornerRadius(node, props.radius, bb);\n                    var radiusView = this.cornerRadiusBuffer.getView(instance);\n                    radiusView[0] = radius; // top-right\n                    radiusView[1] = radius; // bottom-right\n                    radiusView[2] = radius; // top-left\n                    radiusView[3] = radius; // bottom-left\n                    if (vertType === BOTTOM_ROUND_RECTANGLE) {\n                        radiusView[0] = 0;\n                        radiusView[2] = 0;\n                    }\n                }\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var color = node.pstyle(props.color).value;\n                var opacity = node.pstyle(props.opacity).value;\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor(color, opacity, colorView);\n                var lineWidthView = this.lineWidthBuffer.getView(instance); // reuse edge line width attribute for node border\n                lineWidthView[0] = 0;\n                lineWidthView[1] = 0;\n                if (props.border) {\n                    var borderWidth = node.pstyle('border-width').value;\n                    if (borderWidth > 0) {\n                        var borderColor = node.pstyle('border-color').value;\n                        var borderOpacity = node.pstyle('border-opacity').value;\n                        var borderColorView = this.borderColorBuffer.getView(instance);\n                        toWebGLColor(borderColor, borderOpacity, borderColorView);\n                        // SDF distance is negative inside the shape and positive outside\n                        var borderPos = node.pstyle('border-position').value;\n                        if (borderPos === 'inside') {\n                            lineWidthView[0] = 0;\n                            lineWidthView[1] = -borderWidth;\n                        } else if (borderPos === 'outside') {\n                            lineWidthView[0] = borderWidth;\n                            lineWidthView[1] = 0;\n                        } else {\n                            // 'center'\n                            var halfWidth = borderWidth / 2;\n                            lineWidthView[0] = halfWidth;\n                            lineWidthView[1] = -halfWidth;\n                        }\n                    }\n                }\n                var matrixView = this.transformBuffer.getMatrixView(instance);\n                this.setTransformMatrix(node, matrixView, opts);\n                this.simpleCount++;\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"_getVertTypeForShape\",\n            value: function _getVertTypeForShape(node, shapeProp) {\n                var shape = node.pstyle(shapeProp).value;\n                switch(shape){\n                    case 'rectangle':\n                        return RECTANGLE;\n                    case 'ellipse':\n                        return ELLIPSE;\n                    case 'roundrectangle':\n                    case 'round-rectangle':\n                        return ROUND_RECTANGLE;\n                    case 'bottom-round-rectangle':\n                        return BOTTOM_ROUND_RECTANGLE;\n                    default:\n                        return undefined;\n                }\n            }\n        },\n        {\n            key: \"_getCornerRadius\",\n            value: function _getCornerRadius(node, radiusProp, _ref2) {\n                var w = _ref2.w, h = _ref2.h;\n                // see CRp.drawRoundRectanglePath\n                if (node.pstyle(radiusProp).value === 'auto') {\n                    return getRoundRectangleRadius(w, h);\n                } else {\n                    var radius = node.pstyle(radiusProp).pfValue;\n                    var halfWidth = w / 2;\n                    var halfHeight = h / 2;\n                    return Math.min(radius, halfHeight, halfWidth);\n                }\n            }\n        },\n        {\n            key: \"drawEdgeArrow\",\n            value: function drawEdgeArrow(edge, eleIndex, prefix) {\n                if (!edge.visible()) {\n                    return;\n                }\n                // Edge points and arrow angles etc are calculated by the base renderer and cached in the rscratch object.\n                var rs = edge._private.rscratch;\n                var x, y, angle;\n                if (prefix === 'source') {\n                    x = rs.arrowStartX;\n                    y = rs.arrowStartY;\n                    angle = rs.srcArrowAngle;\n                } else {\n                    x = rs.arrowEndX;\n                    y = rs.arrowEndY;\n                    angle = rs.tgtArrowAngle;\n                }\n                // taken from CRp.drawArrowhead\n                if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n                    return;\n                }\n                // check shape after the x/y check because pstyle() is a bit slow\n                var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n                if (arrowShape === 'none') {\n                    return;\n                }\n                var color = edge.pstyle(prefix + '-arrow-color').value;\n                var baseOpacity = edge.pstyle('opacity').value;\n                var lineOpacity = edge.pstyle('line-opacity').value;\n                var opacity = baseOpacity * lineOpacity;\n                var lineWidth = edge.pstyle('width').pfValue;\n                var scale$1 = edge.pstyle('arrow-scale').value;\n                var size = this.r.getArrowWidth(lineWidth, scale$1);\n                var instance = this.instanceCount;\n                var transform = this.transformBuffer.getMatrixView(instance);\n                identity(transform);\n                translate(transform, transform, [\n                    x,\n                    y\n                ]);\n                scale(transform, transform, [\n                    size,\n                    size\n                ]);\n                rotate(transform, transform, angle);\n                this.vertTypeBuffer.getView(instance)[0] = EDGE_ARROW;\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor(color, opacity, colorView);\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"drawEdgeLine\",\n            value: function drawEdgeLine(edge, eleIndex) {\n                if (!edge.visible()) {\n                    return;\n                }\n                var points = this._getEdgePoints(edge);\n                if (!points) {\n                    return;\n                }\n                // line style\n                var baseOpacity = edge.pstyle('opacity').value;\n                var lineOpacity = edge.pstyle('line-opacity').value;\n                var width = edge.pstyle('width').pfValue;\n                var color = edge.pstyle('line-color').value;\n                var opacity = baseOpacity * lineOpacity;\n                if (points.length / 2 + this.instanceCount > this.maxInstances) {\n                    this.endBatch();\n                }\n                if (points.length == 4) {\n                    // straight line\n                    var instance = this.instanceCount;\n                    this.vertTypeBuffer.getView(instance)[0] = EDGE_STRAIGHT;\n                    var indexView = this.indexBuffer.getView(instance);\n                    indexToVec4(eleIndex, indexView);\n                    var colorView = this.colorBuffer.getView(instance);\n                    toWebGLColor(color, opacity, colorView);\n                    var lineWidthBuffer = this.lineWidthBuffer.getView(instance);\n                    lineWidthBuffer[0] = width;\n                    var sourceTargetView = this.pointAPointBBuffer.getView(instance);\n                    sourceTargetView[0] = points[0]; // source x\n                    sourceTargetView[1] = points[1]; // source y\n                    sourceTargetView[2] = points[2]; // target x\n                    sourceTargetView[3] = points[3]; // target y\n                    this.instanceCount++;\n                    if (this.instanceCount >= this.maxInstances) {\n                        this.endBatch();\n                    }\n                } else {\n                    // curved line\n                    for(var i = 0; i < points.length - 2; i += 2){\n                        var _instance = this.instanceCount;\n                        this.vertTypeBuffer.getView(_instance)[0] = EDGE_CURVE_SEGMENT;\n                        var _indexView = this.indexBuffer.getView(_instance);\n                        indexToVec4(eleIndex, _indexView);\n                        var _colorView = this.colorBuffer.getView(_instance);\n                        toWebGLColor(color, opacity, _colorView);\n                        var _lineWidthBuffer = this.lineWidthBuffer.getView(_instance);\n                        _lineWidthBuffer[0] = width;\n                        var pAx = points[i - 2], pAy = points[i - 1];\n                        var pBx = points[i], pBy = points[i + 1];\n                        var pCx = points[i + 2], pCy = points[i + 3];\n                        var pDx = points[i + 4], pDy = points[i + 5];\n                        // make phantom points for the first and last segments\n                        // TODO adding 0.001 to avoid division by zero in the shader (I think), need a better solution\n                        if (i == 0) {\n                            pAx = 2 * pBx - pCx + 0.001;\n                            pAy = 2 * pBy - pCy + 0.001;\n                        }\n                        if (i == points.length - 4) {\n                            pDx = 2 * pCx - pBx + 0.001;\n                            pDy = 2 * pCy - pBy + 0.001;\n                        }\n                        var pointABView = this.pointAPointBBuffer.getView(_instance);\n                        pointABView[0] = pAx;\n                        pointABView[1] = pAy;\n                        pointABView[2] = pBx;\n                        pointABView[3] = pBy;\n                        var pointCDView = this.pointCPointDBuffer.getView(_instance);\n                        pointCDView[0] = pCx;\n                        pointCDView[1] = pCy;\n                        pointCDView[2] = pDx;\n                        pointCDView[3] = pDy;\n                        this.instanceCount++;\n                        if (this.instanceCount >= this.maxInstances) {\n                            this.endBatch();\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"_isValidEdge\",\n            value: function _isValidEdge(edge) {\n                var rs = edge._private.rscratch;\n                if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n                    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n                    return false;\n                }\n                return true;\n            }\n        },\n        {\n            key: \"_getEdgePoints\",\n            value: function _getEdgePoints(edge) {\n                var rs = edge._private.rscratch;\n                // if bezier ctrl pts can not be calculated, then die\n                if (!this._isValidEdge(edge)) {\n                    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n                    return;\n                }\n                var controlPoints = rs.allpts;\n                if (controlPoints.length == 4) {\n                    return controlPoints;\n                }\n                var numSegments = this._getNumSegments(edge);\n                return this._getCurveSegmentPoints(controlPoints, numSegments);\n            }\n        },\n        {\n            key: \"_getNumSegments\",\n            value: function _getNumSegments(edge) {\n                // TODO Need a heuristic that decides how many segments to use. Factors to consider:\n                // - edge width/length\n                // - edge curvature (the more the curvature, the more segments)\n                // - zoom level (more segments when zoomed in)\n                // - number of visible edges (more segments when there are fewer edges)\n                // - performance (fewer segments when performance is a concern)\n                // - user configurable option(s)\n                // note: number of segments must be less than the max number of instances\n                // note: segments don't need to be evenly spaced out, it might make sense to have shorter segments nearer to the control points\n                var numSegments = 15;\n                return Math.min(Math.max(numSegments, 5), this.maxInstances);\n            }\n        },\n        {\n            key: \"_getCurveSegmentPoints\",\n            value: function _getCurveSegmentPoints(controlPoints, segments) {\n                if (controlPoints.length == 4) {\n                    return controlPoints; // straight line\n                }\n                var curvePoints = Array((segments + 1) * 2);\n                for(var i = 0; i <= segments; i++){\n                    // the first and last points are the same as the first and last control points\n                    if (i == 0) {\n                        curvePoints[0] = controlPoints[0];\n                        curvePoints[1] = controlPoints[1];\n                    } else if (i == segments) {\n                        curvePoints[i * 2] = controlPoints[controlPoints.length - 2];\n                        curvePoints[i * 2 + 1] = controlPoints[controlPoints.length - 1];\n                    } else {\n                        var t = i / segments; // segments have equal length, its not strictly necessary to do it this way\n                        // pass in curvePoints to set the values in the array directly\n                        this._setCurvePoint(controlPoints, t, curvePoints, i * 2);\n                    }\n                }\n                return curvePoints;\n            }\n        },\n        {\n            key: \"_setCurvePoint\",\n            value: function _setCurvePoint(points, t, curvePoints, cpi) {\n                if (points.length <= 2) {\n                    curvePoints[cpi] = points[0];\n                    curvePoints[cpi + 1] = points[1];\n                } else {\n                    var newpoints = Array(points.length - 2);\n                    for(var i = 0; i < newpoints.length; i += 2){\n                        var x = (1 - t) * points[i] + t * points[i + 2];\n                        var y = (1 - t) * points[i + 1] + t * points[i + 3];\n                        newpoints[i] = x;\n                        newpoints[i + 1] = y;\n                    }\n                    return this._setCurvePoint(newpoints, t, curvePoints, cpi);\n                }\n            }\n        },\n        {\n            key: \"endBatch\",\n            value: function endBatch() {\n                var gl = this.gl, vao = this.vao, vertexCount = this.vertexCount, count = this.instanceCount;\n                if (count === 0) return;\n                var program = this.renderTarget.picking ? this.pickingProgram : this.program;\n                gl.useProgram(program);\n                gl.bindVertexArray(vao);\n                // buffer the attribute data\n                var _iterator2 = _createForOfIteratorHelper(this.buffers), _step2;\n                try {\n                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                        var buffer = _step2.value;\n                        buffer.bufferSubData(count);\n                    }\n                } catch (err) {\n                    _iterator2.e(err);\n                } finally{\n                    _iterator2.f();\n                }\n                var atlases = this.batchManager.getAtlases();\n                // must buffer before activating texture units\n                for(var i = 0; i < atlases.length; i++){\n                    atlases[i].bufferIfNeeded(gl);\n                }\n                // Activate all the texture units that we need\n                for(var _i2 = 0; _i2 < atlases.length; _i2++){\n                    gl.activeTexture(gl.TEXTURE0 + _i2);\n                    gl.bindTexture(gl.TEXTURE_2D, atlases[_i2].texture);\n                    gl.uniform1i(program.uTextures[_i2], _i2);\n                }\n                // Set the uniforms\n                gl.uniform1f(program.uZoom, getEffectiveZoom(this.r));\n                gl.uniformMatrix3fv(program.uPanZoomMatrix, false, this.panZoomMatrix);\n                gl.uniform1i(program.uAtlasSize, this.batchManager.getAtlasSize());\n                // set background color, needed for edge arrow color blending\n                var webglBgColor = toWebGLColor(this.bgColor, 1);\n                gl.uniform4fv(program.uBGColor, webglBgColor);\n                // draw!\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, vertexCount, count);\n                gl.bindVertexArray(null);\n                gl.bindTexture(gl.TEXTURE_2D, null); // TODO is this right when having multiple texture units?\n                if (this.debug) {\n                    this.batchDebugInfo.push({\n                        count: count,\n                        // instance count\n                        atlasCount: atlases.length\n                    });\n                }\n                // start the next batch, even if not needed\n                this.startBatch();\n            }\n        },\n        {\n            key: \"getDebugInfo\",\n            value: function getDebugInfo() {\n                var atlasInfo = this.atlasManager.getDebugInfo();\n                var totalAtlases = atlasInfo.reduce(function(count, info) {\n                    return count + info.atlasCount;\n                }, 0);\n                var batchInfo = this.batchDebugInfo;\n                var totalInstances = batchInfo.reduce(function(count, info) {\n                    return count + info.count;\n                }, 0);\n                return {\n                    atlasInfo: atlasInfo,\n                    totalAtlases: totalAtlases,\n                    wrappedCount: this.wrappedCount,\n                    simpleCount: this.simpleCount,\n                    batchCount: batchInfo.length,\n                    batchInfo: batchInfo,\n                    totalInstances: totalInstances\n                };\n            }\n        }\n    ]);\n}();\nvar CRp$4 = {};\n/**\n * Initialize the WebGL rendering mode after the Canvas renderer has been initialized.\n */ CRp$4.initWebgl = function(opts, fns) {\n    var r = this;\n    var gl = r.data.contexts[r.WEBGL];\n    // Set defaults and limits for configuration options.\n    opts.bgColor = getBGColor(r);\n    opts.webglTexSize = Math.min(opts.webglTexSize, gl.getParameter(gl.MAX_TEXTURE_SIZE));\n    opts.webglTexRows = Math.min(opts.webglTexRows, 54);\n    opts.webglTexRowsNodes = Math.min(opts.webglTexRowsNodes, 54);\n    opts.webglBatchSize = Math.min(opts.webglBatchSize, 16384);\n    opts.webglTexPerBatch = Math.min(opts.webglTexPerBatch, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));\n    // Turn debug mode on or off.\n    r.webglDebug = opts.webglDebug;\n    r.webglDebugShowAtlases = opts.webglDebugShowAtlases;\n    // Create offscreen framebuffer that stores the results when RENDER_TARGET.PICKING is enabled.\n    // This is used to store the topmost element z-index for each pixel, which is used to tell whats under the mouse cursor point.\n    r.pickingFrameBuffer = createPickingFrameBuffer(gl);\n    r.pickingFrameBuffer.needsDraw = true;\n    // Create an ElementDrawingWebGL instance wich is used to do the actual WebGL rendering.\n    // This instance needs to be configured to draw various types of elements.\n    r.drawing = new ElementDrawingWebGL(r, gl, opts);\n    // Some functions that are used to configure ElementDrawingWebGL\n    var getLabelRotation = function getLabelRotation(prop) {\n        return function(ele) {\n            return r.getTextAngle(ele, prop);\n        };\n    };\n    var isLabelVisible = function isLabelVisible(prop) {\n        return function(ele) {\n            var label = ele.pstyle(prop);\n            return label && label.value;\n        };\n    };\n    var isLayerVisible = function isLayerVisible(prefix) {\n        return function(node) {\n            // prefix is 'overlay' or 'underlay'\n            return node.pstyle(\"\".concat(prefix, \"-opacity\")).value > 0;\n        };\n    };\n    var getTexPickingMode = function getTexPickingMode(ele) {\n        // tells when a label should be clickable\n        var enabled = ele.pstyle('text-events').strValue === 'yes';\n        return enabled ? TEX_PICKING_MODE.USE_BB : TEX_PICKING_MODE.IGNORE;\n    };\n    var getBBForSimpleShape = function getBBForSimpleShape(node) {\n        // \"simple\" shapes need their BB to include border and padding\n        var _node$position = node.position(), x = _node$position.x, y = _node$position.y;\n        var w = node.outerWidth(); // includes border and padding\n        var h = node.outerHeight();\n        return {\n            w: w,\n            h: h,\n            x1: x - w / 2,\n            y1: y - h / 2\n        };\n    };\n    // An AtlasCollection is a collection of Atlases that have the same configuraiton options.\n    // Create one for node bodies and one for all types of labels.\n    r.drawing.addAtlasCollection('node', {\n        texRows: opts.webglTexRowsNodes\n    });\n    r.drawing.addAtlasCollection('label', {\n        texRows: opts.webglTexRows\n    });\n    // Configure the different types of elements that can be rendered.\n    // Node bodies can be rendered as textures or as \"simple shapes\". \n    // Simple shapes are preferred because they do not use texture memory.\n    // Textures are required if the node body uses complex styles. \n    r.drawing.addTextureAtlasRenderType('node-body', {\n        collection: 'node',\n        getKey: fns.getStyleKey,\n        getBoundingBox: fns.getElementBox,\n        drawElement: fns.drawElement\n    });\n    r.drawing.addSimpleShapeRenderType('node-body', {\n        getBoundingBox: getBBForSimpleShape,\n        isSimple: isSimpleShape,\n        shapeProps: {\n            shape: 'shape',\n            color: 'background-color',\n            opacity: 'background-opacity',\n            radius: 'corner-radius',\n            border: true\n        }\n    });\n    r.drawing.addSimpleShapeRenderType('node-overlay', {\n        getBoundingBox: getBBForSimpleShape,\n        isVisible: isLayerVisible('overlay'),\n        shapeProps: {\n            shape: 'overlay-shape',\n            color: 'overlay-color',\n            opacity: 'overlay-opacity',\n            padding: 'overlay-padding',\n            radius: 'overlay-corner-radius'\n        }\n    });\n    r.drawing.addSimpleShapeRenderType('node-underlay', {\n        getBoundingBox: getBBForSimpleShape,\n        isVisible: isLayerVisible('underlay'),\n        shapeProps: {\n            shape: 'underlay-shape',\n            color: 'underlay-color',\n            opacity: 'underlay-opacity',\n            padding: 'underlay-padding',\n            radius: 'underlay-corner-radius'\n        }\n    });\n    r.drawing.addTextureAtlasRenderType('label', {\n        // node label or edge mid label\n        collection: 'label',\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getLabelKey, null),\n        getBoundingBox: getBoundingBoxForLabel(fns.getLabelBox, null),\n        drawClipped: true,\n        drawElement: fns.drawLabel,\n        getRotation: getLabelRotation(null),\n        getRotationPoint: fns.getLabelRotationPoint,\n        getRotationOffset: fns.getLabelRotationOffset,\n        isVisible: isLabelVisible('label')\n    });\n    r.drawing.addTextureAtlasRenderType('edge-source-label', {\n        collection: 'label',\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getSourceLabelKey, 'source'),\n        getBoundingBox: getBoundingBoxForLabel(fns.getSourceLabelBox, 'source'),\n        drawClipped: true,\n        drawElement: fns.drawSourceLabel,\n        getRotation: getLabelRotation('source'),\n        getRotationPoint: fns.getSourceLabelRotationPoint,\n        getRotationOffset: fns.getSourceLabelRotationOffset,\n        isVisible: isLabelVisible('source-label')\n    });\n    r.drawing.addTextureAtlasRenderType('edge-target-label', {\n        collection: 'label',\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getTargetLabelKey, 'target'),\n        getBoundingBox: getBoundingBoxForLabel(fns.getTargetLabelBox, 'target'),\n        drawClipped: true,\n        drawElement: fns.drawTargetLabel,\n        getRotation: getLabelRotation('target'),\n        getRotationPoint: fns.getTargetLabelRotationPoint,\n        getRotationOffset: fns.getTargetLabelRotationOffset,\n        isVisible: isLabelVisible('target-label')\n    });\n    // Very simplistic way of triggering garbage collection, just use a timer.\n    var setGCFlag = debounce(function() {\n        console.log('garbage collect flag set');\n        r.data.gc = true;\n    }, 10000);\n    // Event listener checks if style keys are no longer in use.\n    r.onUpdateEleCalcs(function(willDraw, eles) {\n        var gcNeeded = false;\n        if (eles && eles.length > 0) {\n            gcNeeded |= r.drawing.invalidate(eles);\n        }\n        if (gcNeeded) {\n            setGCFlag();\n        }\n    });\n    // \"Override\" certain functions in canvas and base renderer\n    overrideCanvasRendererFunctions(r);\n};\nfunction getBGColor(r) {\n    var container = r.cy.container();\n    var cssColor = container && container.style && container.style.backgroundColor || 'white';\n    return color2tuple(cssColor);\n}\nfunction getLabelLines(ele, prefix) {\n    var rs = ele._private.rscratch;\n    return getPrefixedProperty(rs, 'labelWrapCachedLines', prefix) || [];\n}\n/** \n * Handle multi-line labels by rendering each line as a seperate texture.\n * That means each line needs its own style key.\n */ var getStyleKeysForLabel = function getStyleKeysForLabel(getKey, prefix) {\n    return function(ele) {\n        var key = getKey(ele);\n        var lines = getLabelLines(ele, prefix);\n        if (lines.length > 1) {\n            return lines.map(function(line, index) {\n                return \"\".concat(key, \"_\").concat(index);\n            });\n        }\n        return key;\n    };\n};\n/**\n * Need to create a separate bounding box for each line of a multi-line label.\n * Note that 'drawClipped: true' should be used with this.\n */ var getBoundingBoxForLabel = function getBoundingBoxForLabel(getBoundingBox, prefix) {\n    return function(ele, styleKey) {\n        var bb = getBoundingBox(ele);\n        if (typeof styleKey === 'string') {\n            var ui = styleKey.indexOf('_');\n            if (ui > 0) {\n                var lineIndex = Number(styleKey.substring(ui + 1));\n                var lines = getLabelLines(ele, prefix);\n                // Adjust the height and Y coordinate for one line of the label.\n                var h = bb.h / lines.length;\n                var yOffset = h * lineIndex;\n                var y1 = bb.y1 + yOffset;\n                // the yOffset is needed when rotating the label\n                return {\n                    x1: bb.x1,\n                    w: bb.w,\n                    y1: y1,\n                    h: h,\n                    yOffset: yOffset\n                };\n            }\n        }\n        return bb;\n    };\n};\n/**\n * Plug into the canvas renderer by dynamically overriding some of its functions.\n * This requires minimal changes to the canvas rendrerer.\n */ function overrideCanvasRendererFunctions(r) {\n    {\n        // Override the render function to call the webgl render function if the zoom level is appropriate\n        var renderCanvas = r.render;\n        r.render = function(options) {\n            options = options || {};\n            var cy = r.cy;\n            if (r.webgl) {\n                // If the zoom level is greater than the max zoom level, then disable webgl and switch back to \n                // the canvas renderer.\n                if (cy.zoom() > maxZoom$1) {\n                    clearWebgl(r);\n                    renderCanvas.call(r, options);\n                } else {\n                    clearCanvas(r);\n                    renderWebgl(r, options, RENDER_TARGET.SCREEN);\n                }\n            }\n        };\n    }\n    {\n        // Override the matchCanvasSize function to update the picking frame buffer size\n        var baseFunc = r.matchCanvasSize;\n        r.matchCanvasSize = function(container) {\n            baseFunc.call(r, container);\n            r.pickingFrameBuffer.setFramebufferAttachmentSizes(r.canvasWidth, r.canvasHeight);\n            r.pickingFrameBuffer.needsDraw = true;\n        };\n    }\n    {\n        // Override function to call the webgl version for picking.\n        // Don't override r.getAllInBox() selction box picking, its not accurate enough with webgl\n        r.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {\n            // the canvas version of this function is very slow on large graphs\n            return findNearestElementsWebgl(r, x, y);\n        };\n    }\n    {\n        // need to know when the cached elements have changed so we can invalidate our caches\n        var _baseFunc = r.invalidateCachedZSortedEles;\n        r.invalidateCachedZSortedEles = function() {\n            _baseFunc.call(r);\n            r.pickingFrameBuffer.needsDraw = true;\n        };\n    }\n    {\n        // need to know when the cached elements have changed so we can invalidate our caches\n        var _baseFunc2 = r.notify;\n        r.notify = function(eventName, eles) {\n            _baseFunc2.call(r, eventName, eles);\n            if (eventName === 'viewport' || eventName === 'bounds') {\n                r.pickingFrameBuffer.needsDraw = true;\n            } else if (eventName === 'background') {\n                // background image finished loading, need to redraw\n                r.drawing.invalidate(eles, {\n                    type: 'node-body'\n                });\n            }\n        };\n    }\n}\nfunction clearWebgl(r) {\n    var gl = r.data.contexts[r.WEBGL];\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n}\nfunction clearCanvas(r) {\n    // the CRp.clearCanvas() function doesn't take the transform into account\n    var clear = function clear(context) {\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n        context.restore();\n    };\n    clear(r.data.contexts[r.NODE]);\n    clear(r.data.contexts[r.DRAG]);\n}\nfunction createPanZoomMatrix(r) {\n    var width = r.canvasWidth;\n    var height = r.canvasHeight;\n    var _util$getEffectivePan = getEffectivePanZoom(r), pan = _util$getEffectivePan.pan, zoom = _util$getEffectivePan.zoom;\n    var transform = create();\n    translate(transform, transform, [\n        pan.x,\n        pan.y\n    ]);\n    scale(transform, transform, [\n        zoom,\n        zoom\n    ]);\n    var projection$1 = create();\n    projection(projection$1, width, height);\n    var product = create();\n    multiply(product, projection$1, transform);\n    return product;\n}\nfunction setContextTransform(r, context) {\n    var width = r.canvasWidth;\n    var height = r.canvasHeight;\n    var _util$getEffectivePan2 = getEffectivePanZoom(r), pan = _util$getEffectivePan2.pan, zoom = _util$getEffectivePan2.zoom;\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.clearRect(0, 0, width, height);\n    context.translate(pan.x, pan.y);\n    context.scale(zoom, zoom);\n}\nfunction drawSelectionRectangle(r, options) {\n    r.drawSelectionRectangle(options, function(context) {\n        return setContextTransform(r, context);\n    });\n}\nfunction drawAxes(r) {\n    // for debgging\n    var context = r.data.contexts[r.NODE];\n    context.save();\n    setContextTransform(r, context);\n    context.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n    context.beginPath();\n    context.moveTo(-1e3, 0);\n    context.lineTo(1000, 0);\n    context.stroke();\n    context.beginPath();\n    context.moveTo(0, -1e3);\n    context.lineTo(0, 1000);\n    context.stroke();\n    context.restore();\n}\nfunction drawAtlases(r) {\n    // For debugging the atlases, this doesn't work for Atlases that are locked\n    var draw = function draw(drawing, name, row) {\n        var collection = drawing.atlasManager.getAtlasCollection(name);\n        var context = r.data.contexts[r.NODE];\n        var atlases = collection.atlases;\n        for(var _i = 0; _i < atlases.length; _i++){\n            var atlas = atlases[_i];\n            var canvas = atlas.canvas;\n            if (canvas) {\n                var w = canvas.width;\n                var h = canvas.height;\n                var x = w * _i;\n                var y = canvas.height * row;\n                var scale = 0.4;\n                context.save();\n                context.scale(scale, scale);\n                context.drawImage(canvas, x, y);\n                context.strokeStyle = 'black';\n                context.rect(x, y, w, h);\n                context.stroke();\n                context.restore();\n            }\n        }\n    };\n    var i = 0;\n    draw(r.drawing, 'node', i++);\n    draw(r.drawing, 'label', i++);\n}\n/**\n * Returns the z-order index of elments under or very close to the mouse cursor point.\n * Arguments are in model coordinates.\n * (x1, y1) is top left corner\n * (x2, y2) is bottom right corner (optional)\n * Returns a Set of indexes.\n */ function getPickingIndexes(r, mX1, mY1, mX2, mY2) {\n    var x, y, w, h;\n    var _util$getEffectivePan3 = getEffectivePanZoom(r), pan = _util$getEffectivePan3.pan, zoom = _util$getEffectivePan3.zoom;\n    {\n        var _util$modelToRendered = modelToRenderedPosition(r, pan, zoom, mX1, mY1), _util$modelToRendered2 = _slicedToArray(_util$modelToRendered, 2), cX1 = _util$modelToRendered2[0], cY1 = _util$modelToRendered2[1];\n        var t = 6; // should be even\n        x = cX1 - t / 2;\n        y = cY1 - t / 2;\n        w = t;\n        h = t;\n    }\n    if (w === 0 || h === 0) {\n        return [];\n    }\n    var gl = r.data.contexts[r.WEBGL];\n    gl.bindFramebuffer(gl.FRAMEBUFFER, r.pickingFrameBuffer);\n    if (r.pickingFrameBuffer.needsDraw) {\n        // Draw element z-indexes to the picking framebuffer\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        renderWebgl(r, null, RENDER_TARGET.PICKING);\n        r.pickingFrameBuffer.needsDraw = false;\n    }\n    var n = w * h; // number of pixels to read\n    var data = new Uint8Array(n * 4); // 4 bytes per pixel\n    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    var indexes = new Set();\n    for(var i = 0; i < n; i++){\n        var pixel = data.slice(i * 4, i * 4 + 4);\n        var index = vec4ToIndex(pixel) - 1; // The framebuffer is cleared with 0s, so z-indexes are offset by 1\n        if (index >= 0) {\n            indexes.add(index);\n        }\n    }\n    return indexes;\n}\n/**\n * Cy.js: model coordinate y axis goes down\n */ function findNearestElementsWebgl(r, x, y) {\n    // model coordinates\n    var indexes = getPickingIndexes(r, x, y);\n    var eles = r.getCachedZSortedEles();\n    var node, edge;\n    var _iterator = _createForOfIteratorHelper(indexes), _step;\n    try {\n        for(_iterator.s(); !(_step = _iterator.n()).done;){\n            var index = _step.value;\n            var ele = eles[index];\n            if (!node && ele.isNode()) {\n                node = ele;\n            }\n            if (!edge && ele.isEdge()) {\n                edge = ele;\n            }\n            if (node && edge) {\n                break;\n            }\n        }\n    } catch (err) {\n        _iterator.e(err);\n    } finally{\n        _iterator.f();\n    }\n    return [\n        node,\n        edge\n    ].filter(Boolean);\n}\n/**\n * Draw one node or edge. \n */ function drawEle(r, index, ele) {\n    var drawing = r.drawing;\n    index += 1; // 0 is used to clear the background, need to offset all z-indexes by one\n    if (ele.isNode()) {\n        drawing.drawNode(ele, index, 'node-underlay');\n        drawing.drawNode(ele, index, 'node-body');\n        drawing.drawTexture(ele, index, 'label');\n        drawing.drawNode(ele, index, 'node-overlay');\n    } else {\n        drawing.drawEdgeLine(ele, index);\n        drawing.drawEdgeArrow(ele, index, 'source');\n        drawing.drawEdgeArrow(ele, index, 'target');\n        drawing.drawTexture(ele, index, 'label');\n        drawing.drawTexture(ele, index, 'edge-source-label');\n        drawing.drawTexture(ele, index, 'edge-target-label');\n    }\n}\n/**\n * Render one frame.\n */ function renderWebgl(r, options, renderTarget) {\n    var start;\n    if (r.webglDebug) {\n        start = performance.now(); // eslint-disable-line no-undef\n    }\n    var drawing = r.drawing;\n    var eleCount = 0;\n    if (renderTarget.screen) {\n        if (r.data.canvasNeedsRedraw[r.SELECT_BOX]) {\n            drawSelectionRectangle(r, options);\n        }\n    }\n    // see drawing-elements.js drawCachedElement()\n    if (r.data.canvasNeedsRedraw[r.NODE] || renderTarget.picking) {\n        var gl = r.data.contexts[r.WEBGL];\n        if (renderTarget.screen) {\n            gl.clearColor(0, 0, 0, 0); // background color\n            gl.enable(gl.BLEND); // enable alpha blending of colors\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // webgl colors use premultiplied alpha\n        } else {\n            gl.disable(gl.BLEND); // don't blend z-order index values! they are not colors\n        }\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        var panZoomMatrix = createPanZoomMatrix(r);\n        var eles = r.getCachedZSortedEles();\n        eleCount = eles.length;\n        drawing.startFrame(panZoomMatrix, renderTarget);\n        if (renderTarget.screen) {\n            for(var i = 0; i < eles.nondrag.length; i++){\n                drawEle(r, i, eles.nondrag[i]);\n            }\n            for(var _i2 = 0; _i2 < eles.drag.length; _i2++){\n                drawEle(r, _i2, eles.drag[_i2]);\n            }\n        } else if (renderTarget.picking) {\n            for(var _i3 = 0; _i3 < eles.length; _i3++){\n                drawEle(r, _i3, eles[_i3]);\n            }\n        }\n        drawing.endFrame();\n        if (renderTarget.screen && r.webglDebugShowAtlases) {\n            drawAxes(r);\n            drawAtlases(r);\n        }\n        r.data.canvasNeedsRedraw[r.NODE] = false;\n        r.data.canvasNeedsRedraw[r.DRAG] = false;\n    }\n    if (r.webglDebug) {\n        // eslint-disable-next-line no-undef\n        var end = performance.now();\n        var compact = false;\n        var time = Math.ceil(end - start);\n        var debugInfo = drawing.getDebugInfo();\n        var report = [\n            \"\".concat(eleCount, \" elements\"),\n            \"\".concat(debugInfo.totalInstances, \" instances\"),\n            \"\".concat(debugInfo.batchCount, \" batches\"),\n            \"\".concat(debugInfo.totalAtlases, \" atlases\"),\n            \"\".concat(debugInfo.wrappedCount, \" wrapped textures\"),\n            \"\".concat(debugInfo.simpleCount, \" simple shapes\")\n        ].join(', ');\n        if (compact) {\n            console.log(\"WebGL (\".concat(renderTarget.name, \") - time \").concat(time, \"ms, \").concat(report));\n        } else {\n            console.log(\"WebGL (\".concat(renderTarget.name, \") - frame time \").concat(time, \"ms\"));\n            console.log('Totals:');\n            console.log(\"  \".concat(report));\n            console.log('Texture Atlases Used:');\n            var atlasInfo = debugInfo.atlasInfo;\n            var _iterator2 = _createForOfIteratorHelper(atlasInfo), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var info = _step2.value;\n                    console.log(\"  \".concat(info.type, \": \").concat(info.keyCount, \" keys, \").concat(info.atlasCount, \" atlases\"));\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            console.log('');\n        }\n    }\n    if (r.data.gc) {\n        console.log('Garbage Collect!');\n        r.data.gc = false;\n        drawing.gc();\n    }\n}\nvar CRp$3 = {};\n// @O Polygon drawing\nCRp$3.drawPolygonPath = function(context, x, y, width, height, points) {\n    var halfW = width / 2;\n    var halfH = height / 2;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n    for(var i = 1; i < points.length / 2; i++){\n        context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n    }\n    context.closePath();\n};\nCRp$3.drawRoundPolygonPath = function(context, x, y, width, height, points, corners) {\n    corners.forEach(function(corner) {\n        return drawPreparedRoundCorner(context, corner);\n    });\n    context.closePath();\n};\n// Round rectangle drawing\nCRp$3.drawRoundRectanglePath = function(context, x, y, width, height, radius) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : Math.min(radius, halfHeight, halfWidth);\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    // Arc from middle top to right side\n    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n    // Arc from right side to bottom\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    // Arc from bottom to left side\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    // Arc from left side to topBorder\n    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n    // Join line\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n};\nCRp$3.drawBottomRoundRectanglePath = function(context, x, y, width, height, radius) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight);\n    context.lineTo(x + halfWidth, y);\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    context.lineTo(x - halfWidth, y - halfHeight);\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n};\nCRp$3.drawCutRectanglePath = function(context, x, y, width, height, points, corners) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerLength = corners === 'auto' ? getCutRectangleCornerLength() : corners;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n    context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n    context.closePath();\n};\nCRp$3.drawBarrelPath = function(context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var xBegin = x - halfWidth;\n    var xEnd = x + halfWidth;\n    var yBegin = y - halfHeight;\n    var yEnd = y + halfHeight;\n    var barrelCurveConstants = getBarrelCurveConstants(width, height);\n    var wOffset = barrelCurveConstants.widthOffset;\n    var hOffset = barrelCurveConstants.heightOffset;\n    var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(xBegin, yBegin + hOffset);\n    context.lineTo(xBegin, yEnd - hOffset);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n    context.lineTo(xEnd - wOffset, yEnd);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n    context.lineTo(xEnd, yBegin + hOffset);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n    context.lineTo(xBegin + wOffset, yBegin);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n    context.closePath();\n};\nvar sin0 = Math.sin(0);\nvar cos0 = Math.cos(0);\nvar sin = {};\nvar cos = {};\nvar ellipseStepSize = Math.PI / 40;\nfor(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n    sin[i] = Math.sin(i);\n    cos[i] = Math.cos(i);\n}\nCRp$3.drawEllipsePath = function(context, centerX, centerY, width, height) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    if (context.ellipse) {\n        context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n    } else {\n        var xPos, yPos;\n        var rw = width / 2;\n        var rh = height / 2;\n        for(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n            xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n            yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n            if (i === 0) {\n                context.moveTo(xPos, yPos);\n            } else {\n                context.lineTo(xPos, yPos);\n            }\n        }\n    }\n    context.closePath();\n};\n/* global atob, ArrayBuffer, Uint8Array, Blob */ var CRp$2 = {};\nCRp$2.createBuffer = function(w, h) {\n    var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n    buffer.width = w;\n    buffer.height = h;\n    return [\n        buffer,\n        buffer.getContext('2d')\n    ];\n};\nCRp$2.bufferCanvasImage = function(options) {\n    var cy = this.cy;\n    var eles = cy.mutableElements();\n    var bb = eles.boundingBox();\n    var ctrRect = this.findContainerClientCoords();\n    var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n    var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n    var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n    var pxRatio = this.getPixelRatio();\n    var scale = 1;\n    if (options.scale !== undefined) {\n        width *= options.scale;\n        height *= options.scale;\n        scale = options.scale;\n    } else if (specdMaxDims) {\n        var maxScaleW = Infinity;\n        var maxScaleH = Infinity;\n        if (number$1(options.maxWidth)) {\n            maxScaleW = scale * options.maxWidth / width;\n        }\n        if (number$1(options.maxHeight)) {\n            maxScaleH = scale * options.maxHeight / height;\n        }\n        scale = Math.min(maxScaleW, maxScaleH);\n        width *= scale;\n        height *= scale;\n    }\n    if (!specdMaxDims) {\n        width *= pxRatio;\n        height *= pxRatio;\n        scale *= pxRatio;\n    }\n    var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n    buffCanvas.width = width;\n    buffCanvas.height = height;\n    buffCanvas.style.width = width + 'px';\n    buffCanvas.style.height = height + 'px';\n    var buffCxt = buffCanvas.getContext('2d');\n    // Rasterize the layers, but only if container has nonzero size\n    if (width > 0 && height > 0) {\n        buffCxt.clearRect(0, 0, width, height);\n        buffCxt.globalCompositeOperation = 'source-over';\n        var zsortedEles = this.getCachedZSortedEles();\n        if (options.full) {\n            // draw the full bounds of the graph\n            buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n            buffCxt.scale(scale, scale);\n            this.drawElements(buffCxt, zsortedEles);\n            buffCxt.scale(1 / scale, 1 / scale);\n            buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n        } else {\n            // draw the current view\n            var pan = cy.pan();\n            var translation = {\n                x: pan.x * scale,\n                y: pan.y * scale\n            };\n            scale *= cy.zoom();\n            buffCxt.translate(translation.x, translation.y);\n            buffCxt.scale(scale, scale);\n            this.drawElements(buffCxt, zsortedEles);\n            buffCxt.scale(1 / scale, 1 / scale);\n            buffCxt.translate(-translation.x, -translation.y);\n        }\n        // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n        if (options.bg) {\n            buffCxt.globalCompositeOperation = 'destination-over';\n            buffCxt.fillStyle = options.bg;\n            buffCxt.rect(0, 0, width, height);\n            buffCxt.fill();\n        }\n    }\n    return buffCanvas;\n};\nfunction b64ToBlob(b64, mimeType) {\n    var bytes = atob(b64);\n    var buff = new ArrayBuffer(bytes.length);\n    var buffUint8 = new Uint8Array(buff);\n    for(var i = 0; i < bytes.length; i++){\n        buffUint8[i] = bytes.charCodeAt(i);\n    }\n    return new Blob([\n        buff\n    ], {\n        type: mimeType\n    });\n}\nfunction b64UriToB64(b64uri) {\n    var i = b64uri.indexOf(',');\n    return b64uri.substr(i + 1);\n}\nfunction output(options, canvas, mimeType) {\n    var getB64Uri = function getB64Uri() {\n        return canvas.toDataURL(mimeType, options.quality);\n    };\n    switch(options.output){\n        case 'blob-promise':\n            return new Promise$1(function(resolve, reject) {\n                try {\n                    canvas.toBlob(function(blob) {\n                        if (blob != null) {\n                            resolve(blob);\n                        } else {\n                            reject(new Error('`canvas.toBlob()` sent a null value in its callback'));\n                        }\n                    }, mimeType, options.quality);\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        case 'blob':\n            return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n        case 'base64':\n            return b64UriToB64(getB64Uri());\n        case 'base64uri':\n        default:\n            return getB64Uri();\n    }\n}\nCRp$2.png = function(options) {\n    return output(options, this.bufferCanvasImage(options), 'image/png');\n};\nCRp$2.jpg = function(options) {\n    return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n};\nvar CRp$1 = {};\nCRp$1.nodeShapeImpl = function(name, context, centerX, centerY, width, height, points, corners) {\n    switch(name){\n        case 'ellipse':\n            return this.drawEllipsePath(context, centerX, centerY, width, height);\n        case 'polygon':\n            return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n        case 'round-polygon':\n            return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points, corners);\n        case 'roundrectangle':\n        case 'round-rectangle':\n            return this.drawRoundRectanglePath(context, centerX, centerY, width, height, corners);\n        case 'cutrectangle':\n        case 'cut-rectangle':\n            return this.drawCutRectanglePath(context, centerX, centerY, width, height, points, corners);\n        case 'bottomroundrectangle':\n        case 'bottom-round-rectangle':\n            return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height, corners);\n        case 'barrel':\n            return this.drawBarrelPath(context, centerX, centerY, width, height);\n    }\n};\nvar CR = CanvasRenderer;\nvar CRp = CanvasRenderer.prototype;\nCRp.CANVAS_LAYERS = 3;\n//\nCRp.SELECT_BOX = 0;\nCRp.DRAG = 1;\nCRp.NODE = 2;\nCRp.WEBGL = 3;\nCRp.CANVAS_TYPES = [\n    '2d',\n    '2d',\n    '2d',\n    'webgl2'\n];\nCRp.BUFFER_COUNT = 3;\n//\nCRp.TEXTURE_BUFFER = 0;\nCRp.MOTIONBLUR_BUFFER_NODE = 1;\nCRp.MOTIONBLUR_BUFFER_DRAG = 2;\nfunction CanvasRenderer(options) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var document1 = containerWindow.document;\n    if (options.webgl) {\n        CRp.CANVAS_LAYERS = r.CANVAS_LAYERS = 4;\n        console.log('webgl rendering enabled');\n    }\n    r.data = {\n        canvases: new Array(CRp.CANVAS_LAYERS),\n        contexts: new Array(CRp.CANVAS_LAYERS),\n        canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n        bufferCanvases: new Array(CRp.BUFFER_COUNT),\n        bufferContexts: new Array(CRp.CANVAS_LAYERS)\n    };\n    var tapHlOffAttr = '-webkit-tap-highlight-color';\n    var tapHlOffStyle = 'rgba(0,0,0,0)';\n    r.data.canvasContainer = document1.createElement('div'); // eslint-disable-line no-undef\n    var containerStyle = r.data.canvasContainer.style;\n    r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n    containerStyle.position = 'relative';\n    containerStyle.zIndex = '0';\n    containerStyle.overflow = 'hidden';\n    var container = options.cy.container();\n    container.appendChild(r.data.canvasContainer);\n    container.style[tapHlOffAttr] = tapHlOffStyle;\n    var styleMap = {\n        '-webkit-user-select': 'none',\n        '-moz-user-select': '-moz-none',\n        'user-select': 'none',\n        '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n        'outline-style': 'none'\n    };\n    if (ms()) {\n        styleMap['-ms-touch-action'] = 'none';\n        styleMap['touch-action'] = 'none';\n    }\n    for(var i = 0; i < CRp.CANVAS_LAYERS; i++){\n        var canvas = r.data.canvases[i] = document1.createElement('canvas'); // eslint-disable-line no-undef\n        var type = CRp.CANVAS_TYPES[i];\n        r.data.contexts[i] = canvas.getContext(type);\n        if (!r.data.contexts[i]) {\n            error('Could not create canvas of type ' + type);\n        }\n        Object.keys(styleMap).forEach(function(k) {\n            canvas.style[k] = styleMap[k];\n        });\n        canvas.style.position = 'absolute';\n        canvas.setAttribute('data-id', 'layer' + i);\n        canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n        r.data.canvasContainer.appendChild(canvas);\n        r.data.canvasNeedsRedraw[i] = false;\n    }\n    r.data.topCanvas = r.data.canvases[0];\n    r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n    r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n    r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n    if (r.data.canvases[CRp.WEBGL]) {\n        r.data.canvases[CRp.WEBGL].setAttribute('data-id', 'layer' + CRp.WEBGL + '-webgl');\n    }\n    for(var i = 0; i < CRp.BUFFER_COUNT; i++){\n        r.data.bufferCanvases[i] = document1.createElement('canvas'); // eslint-disable-line no-undef\n        r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n        r.data.bufferCanvases[i].style.position = 'absolute';\n        r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n        r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n        r.data.bufferCanvases[i].style.visibility = 'hidden';\n    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n    }\n    r.pathsEnabled = true;\n    var emptyBb = makeBoundingBox();\n    var getBoxCenter = function getBoxCenter(bb) {\n        return {\n            x: (bb.x1 + bb.x2) / 2,\n            y: (bb.y1 + bb.y2) / 2\n        };\n    };\n    var getCenterOffset = function getCenterOffset(bb) {\n        return {\n            x: -bb.w / 2,\n            y: -bb.h / 2\n        };\n    };\n    var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n        var _p = ele[0]._private;\n        var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n        return !same;\n    };\n    var getStyleKey = function getStyleKey(ele) {\n        return ele[0]._private.nodeKey;\n    };\n    var getLabelKey = function getLabelKey(ele) {\n        return ele[0]._private.labelStyleKey;\n    };\n    var getSourceLabelKey = function getSourceLabelKey(ele) {\n        return ele[0]._private.sourceLabelStyleKey;\n    };\n    var getTargetLabelKey = function getTargetLabelKey(ele) {\n        return ele[0]._private.targetLabelStyleKey;\n    };\n    var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n    };\n    var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);\n    };\n    var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);\n    };\n    var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);\n    };\n    var getElementBox = function getElementBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.bodyBounds;\n    };\n    var getLabelBox = function getLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.main || emptyBb;\n    };\n    var getSourceLabelBox = function getSourceLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.source || emptyBb;\n    };\n    var getTargetLabelBox = function getTargetLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.target || emptyBb;\n    };\n    var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n        return scaledLabelShown;\n    };\n    var getElementRotationPoint = function getElementRotationPoint(ele) {\n        return getBoxCenter(getElementBox(ele));\n    };\n    var addTextMargin = function addTextMargin(prefix, pt, ele) {\n        var pre = prefix ? prefix + '-' : '';\n        return {\n            x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,\n            y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue\n        };\n    };\n    var getRsPt = function getRsPt(ele, x, y) {\n        var rs = ele[0]._private.rscratch;\n        return {\n            x: rs[x],\n            y: rs[y]\n        };\n    };\n    var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n        return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);\n    };\n    var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n        return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);\n    };\n    var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n        return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);\n    };\n    var getElementRotationOffset = function getElementRotationOffset(ele) {\n        return getCenterOffset(getElementBox(ele));\n    };\n    var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n        return getCenterOffset(getSourceLabelBox(ele));\n    };\n    var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n        return getCenterOffset(getTargetLabelBox(ele));\n    };\n    var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n        var bb = getLabelBox(ele);\n        var p = getCenterOffset(getLabelBox(ele));\n        if (ele.isNode()) {\n            switch(ele.pstyle('text-halign').value){\n                case 'left':\n                    p.x = -bb.w - (bb.leftPad || 0);\n                    break;\n                case 'right':\n                    p.x = -(bb.rightPad || 0);\n                    break;\n            }\n            switch(ele.pstyle('text-valign').value){\n                case 'top':\n                    p.y = -bb.h - (bb.topPad || 0);\n                    break;\n                case 'bottom':\n                    p.y = -(bb.botPad || 0);\n                    break;\n            }\n        }\n        return p;\n    };\n    var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n        getKey: getStyleKey,\n        doesEleInvalidateKey: backgroundTimestampHasChanged,\n        drawElement: drawElement,\n        getBoundingBox: getElementBox,\n        getRotationPoint: getElementRotationPoint,\n        getRotationOffset: getElementRotationOffset,\n        allowEdgeTxrCaching: false,\n        allowParentTxrCaching: false\n    });\n    var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n        getKey: getLabelKey,\n        drawElement: drawLabel,\n        getBoundingBox: getLabelBox,\n        getRotationPoint: getLabelRotationPoint,\n        getRotationOffset: getLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n        getKey: getSourceLabelKey,\n        drawElement: drawSourceLabel,\n        getBoundingBox: getSourceLabelBox,\n        getRotationPoint: getSourceLabelRotationPoint,\n        getRotationOffset: getSourceLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n        getKey: getTargetLabelKey,\n        drawElement: drawTargetLabel,\n        getBoundingBox: getTargetLabelBox,\n        getRotationPoint: getTargetLabelRotationPoint,\n        getRotationOffset: getTargetLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n    r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n        // each cache should check for sub-key diff to see that the update affects that cache particularly\n        eleTxrCache.invalidateElements(eles);\n        lblTxrCache.invalidateElements(eles);\n        slbTxrCache.invalidateElements(eles);\n        tlbTxrCache.invalidateElements(eles);\n        // any change invalidates the layers\n        lyrTxrCache.invalidateElements(eles);\n        // update the old bg timestamp so diffs can be done in the ele txr caches\n        for(var _i = 0; _i < eles.length; _i++){\n            var _p = eles[_i]._private;\n            _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n        }\n    });\n    var refineInLayers = function refineInLayers(reqs) {\n        for(var i = 0; i < reqs.length; i++){\n            lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n        }\n    };\n    eleTxrCache.onDequeue(refineInLayers);\n    lblTxrCache.onDequeue(refineInLayers);\n    slbTxrCache.onDequeue(refineInLayers);\n    tlbTxrCache.onDequeue(refineInLayers);\n    if (options.webgl) {\n        r.initWebgl(options, {\n            getStyleKey: getStyleKey,\n            getLabelKey: getLabelKey,\n            getSourceLabelKey: getSourceLabelKey,\n            getTargetLabelKey: getTargetLabelKey,\n            drawElement: drawElement,\n            drawLabel: drawLabel,\n            drawSourceLabel: drawSourceLabel,\n            drawTargetLabel: drawTargetLabel,\n            getElementBox: getElementBox,\n            getLabelBox: getLabelBox,\n            getSourceLabelBox: getSourceLabelBox,\n            getTargetLabelBox: getTargetLabelBox,\n            getElementRotationPoint: getElementRotationPoint,\n            getElementRotationOffset: getElementRotationOffset,\n            getLabelRotationPoint: getLabelRotationPoint,\n            getSourceLabelRotationPoint: getSourceLabelRotationPoint,\n            getTargetLabelRotationPoint: getTargetLabelRotationPoint,\n            getLabelRotationOffset: getLabelRotationOffset,\n            getSourceLabelRotationOffset: getSourceLabelRotationOffset,\n            getTargetLabelRotationOffset: getTargetLabelRotationOffset\n        });\n    }\n}\nCRp.redrawHint = function(group, bool) {\n    var r = this;\n    switch(group){\n        case 'eles':\n            r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n            break;\n        case 'drag':\n            r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n            break;\n        case 'select':\n            r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n            break;\n        case 'gc':\n            r.data.gc = true;\n            break;\n    }\n};\n// whether to use Path2D caching for drawing\nvar pathsImpld = typeof Path2D !== 'undefined';\nCRp.path2dEnabled = function(on) {\n    if (on === undefined) {\n        return this.pathsEnabled;\n    }\n    this.pathsEnabled = on ? true : false;\n};\nCRp.usePaths = function() {\n    return pathsImpld && this.pathsEnabled;\n};\nCRp.setImgSmoothing = function(context, bool) {\n    if (context.imageSmoothingEnabled != null) {\n        context.imageSmoothingEnabled = bool;\n    } else {\n        context.webkitImageSmoothingEnabled = bool;\n        context.mozImageSmoothingEnabled = bool;\n        context.msImageSmoothingEnabled = bool;\n    }\n};\nCRp.getImgSmoothing = function(context) {\n    if (context.imageSmoothingEnabled != null) {\n        return context.imageSmoothingEnabled;\n    } else {\n        return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n    }\n};\nCRp.makeOffscreenCanvas = function(width, height) {\n    var canvas;\n    if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== \"undefined\") {\n        canvas = new OffscreenCanvas(width, height);\n    } else {\n        var containerWindow = this.cy.window();\n        var document1 = containerWindow.document;\n        canvas = document1.createElement('canvas'); // eslint-disable-line no-undef\n        canvas.width = width;\n        canvas.height = height;\n    }\n    return canvas;\n};\n[\n    CRp$b,\n    CRp$a,\n    CRp$9,\n    CRp$8,\n    CRp$7,\n    CRp$6,\n    CRp$5,\n    CRp$4,\n    CRp$3,\n    CRp$2,\n    CRp$1\n].forEach(function(props) {\n    extend(CRp, props);\n});\nvar renderer = [\n    {\n        name: 'null',\n        impl: NullRenderer\n    },\n    {\n        name: 'base',\n        impl: BR\n    },\n    {\n        name: 'canvas',\n        impl: CR\n    }\n];\nvar incExts = [\n    {\n        type: 'layout',\n        extensions: layout\n    },\n    {\n        type: 'renderer',\n        extensions: renderer\n    }\n];\n// registered extensions to cytoscape, indexed by name\nvar extensions = {};\n// registered modules for extensions, indexed by name\nvar modules = {};\nfunction setExtension(type, name, registrant) {\n    var ext = registrant;\n    var overrideErr = function overrideErr(field) {\n        warn('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n    };\n    if (type === 'core') {\n        if (Core.prototype[name]) {\n            return overrideErr(name);\n        } else {\n            Core.prototype[name] = registrant;\n        }\n    } else if (type === 'collection') {\n        if (Collection.prototype[name]) {\n            return overrideErr(name);\n        } else {\n            Collection.prototype[name] = registrant;\n        }\n    } else if (type === 'layout') {\n        // fill in missing layout functions in the prototype\n        var Layout = function Layout(options) {\n            this.options = options;\n            registrant.call(this, options);\n            // make sure layout has _private for use w/ std apis like .on()\n            if (!plainObject(this._private)) {\n                this._private = {};\n            }\n            this._private.cy = options.cy;\n            this._private.listeners = [];\n            this.createEmitter();\n        };\n        var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n        var optLayoutFns = [];\n        for(var i = 0; i < optLayoutFns.length; i++){\n            var fnName = optLayoutFns[i];\n            layoutProto[fnName] = layoutProto[fnName] || function() {\n                return this;\n            };\n        }\n        // either .start() or .run() is defined, so autogen the other\n        if (layoutProto.start && !layoutProto.run) {\n            layoutProto.run = function() {\n                this.start();\n                return this;\n            };\n        } else if (!layoutProto.start && layoutProto.run) {\n            layoutProto.start = function() {\n                this.run();\n                return this;\n            };\n        }\n        var regStop = registrant.prototype.stop;\n        layoutProto.stop = function() {\n            var opts = this.options;\n            if (opts && opts.animate) {\n                var anis = this.animations;\n                if (anis) {\n                    for(var _i = 0; _i < anis.length; _i++){\n                        anis[_i].stop();\n                    }\n                }\n            }\n            if (regStop) {\n                regStop.call(this);\n            } else {\n                this.emit('layoutstop');\n            }\n            return this;\n        };\n        if (!layoutProto.destroy) {\n            layoutProto.destroy = function() {\n                return this;\n            };\n        }\n        layoutProto.cy = function() {\n            return this._private.cy;\n        };\n        var getCy = function getCy(layout) {\n            return layout._private.cy;\n        };\n        var emitterOpts = {\n            addEventFields: function addEventFields(layout, evt) {\n                evt.layout = layout;\n                evt.cy = getCy(layout);\n                evt.target = layout;\n            },\n            bubble: function bubble() {\n                return true;\n            },\n            parent: function parent(layout) {\n                return getCy(layout);\n            }\n        };\n        extend(layoutProto, {\n            createEmitter: function createEmitter() {\n                this._private.emitter = new Emitter(emitterOpts, this);\n                return this;\n            },\n            emitter: function emitter() {\n                return this._private.emitter;\n            },\n            on: function on(evt, cb) {\n                this.emitter().on(evt, cb);\n                return this;\n            },\n            one: function one(evt, cb) {\n                this.emitter().one(evt, cb);\n                return this;\n            },\n            once: function once(evt, cb) {\n                this.emitter().one(evt, cb);\n                return this;\n            },\n            removeListener: function removeListener(evt, cb) {\n                this.emitter().removeListener(evt, cb);\n                return this;\n            },\n            removeAllListeners: function removeAllListeners() {\n                this.emitter().removeAllListeners();\n                return this;\n            },\n            emit: function emit(evt, params) {\n                this.emitter().emit(evt, params);\n                return this;\n            }\n        });\n        define.eventAliasesOn(layoutProto);\n        ext = Layout; // replace with our wrapped layout\n    } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n        // user registered renderers inherit from base\n        var BaseRenderer = getExtension('renderer', 'base');\n        var bProto = BaseRenderer.prototype;\n        var RegistrantRenderer = registrant;\n        var rProto = registrant.prototype;\n        var Renderer = function Renderer() {\n            BaseRenderer.apply(this, arguments);\n            RegistrantRenderer.apply(this, arguments);\n        };\n        var proto = Renderer.prototype;\n        for(var pName in bProto){\n            var pVal = bProto[pName];\n            var existsInR = rProto[pName] != null;\n            if (existsInR) {\n                return overrideErr(pName);\n            }\n            proto[pName] = pVal; // take impl from base\n        }\n        for(var _pName in rProto){\n            proto[_pName] = rProto[_pName]; // take impl from registrant\n        }\n        bProto.clientFunctions.forEach(function(name) {\n            proto[name] = proto[name] || function() {\n                error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n            };\n        });\n        ext = Renderer;\n    } else if (type === '__proto__' || type === 'constructor' || type === 'prototype') {\n        // to avoid potential prototype pollution\n        return error(type + ' is an illegal type to be registered, possibly lead to prototype pollutions');\n    }\n    return setMap({\n        map: extensions,\n        keys: [\n            type,\n            name\n        ],\n        value: ext\n    });\n}\nfunction getExtension(type, name) {\n    return getMap({\n        map: extensions,\n        keys: [\n            type,\n            name\n        ]\n    });\n}\nfunction setModule(type, name, moduleType, moduleName, registrant) {\n    return setMap({\n        map: modules,\n        keys: [\n            type,\n            name,\n            moduleType,\n            moduleName\n        ],\n        value: registrant\n    });\n}\nfunction getModule(type, name, moduleType, moduleName) {\n    return getMap({\n        map: modules,\n        keys: [\n            type,\n            name,\n            moduleType,\n            moduleName\n        ]\n    });\n}\nvar extension = function extension() {\n    // e.g. extension('renderer', 'svg')\n    if (arguments.length === 2) {\n        return getExtension.apply(null, arguments);\n    } else if (arguments.length === 3) {\n        return setExtension.apply(null, arguments);\n    } else if (arguments.length === 4) {\n        return getModule.apply(null, arguments);\n    } else if (arguments.length === 5) {\n        return setModule.apply(null, arguments);\n    } else {\n        error('Invalid extension access syntax');\n    }\n};\n// allows a core instance to access extensions internally\nCore.prototype.extension = extension;\n// included extensions\nincExts.forEach(function(group) {\n    group.extensions.forEach(function(ext) {\n        setExtension(group.type, ext.name, ext.impl);\n    });\n});\n// a dummy stylesheet object that doesn't need a reference to the core\n// (useful for init)\nvar _Stylesheet = function Stylesheet() {\n    if (!(this instanceof _Stylesheet)) {\n        return new _Stylesheet();\n    }\n    this.length = 0;\n};\nvar sheetfn = _Stylesheet.prototype;\nsheetfn.instanceString = function() {\n    return 'stylesheet';\n};\n// just store the selector to be parsed later\nsheetfn.selector = function(selector) {\n    var i = this.length++;\n    this[i] = {\n        selector: selector,\n        properties: []\n    };\n    return this; // chaining\n};\n// just store the property to be parsed later\nsheetfn.css = function(name, value) {\n    var i = this.length - 1;\n    if (string(name)) {\n        this[i].properties.push({\n            name: name,\n            value: value\n        });\n    } else if (plainObject(name)) {\n        var map = name;\n        var propNames = Object.keys(map);\n        for(var j = 0; j < propNames.length; j++){\n            var key = propNames[j];\n            var mapVal = map[key];\n            if (mapVal == null) {\n                continue;\n            }\n            var prop = _Style.properties[key] || _Style.properties[dash2camel(key)];\n            if (prop == null) {\n                continue;\n            }\n            var _name = prop.name;\n            var _value = mapVal;\n            this[i].properties.push({\n                name: _name,\n                value: _value\n            });\n        }\n    }\n    return this; // chaining\n};\nsheetfn.style = sheetfn.css;\n// generate a real style object from the dummy stylesheet\nsheetfn.generateStyle = function(cy) {\n    var style = new _Style(cy);\n    return this.appendToStyle(style);\n};\n// append a dummy stylesheet object on a real style object\nsheetfn.appendToStyle = function(style) {\n    for(var i = 0; i < this.length; i++){\n        var context = this[i];\n        var selector = context.selector;\n        var props = context.properties;\n        style.selector(selector); // apply selector\n        for(var j = 0; j < props.length; j++){\n            var prop = props[j];\n            style.css(prop.name, prop.value); // apply property\n        }\n    }\n    return style;\n};\nvar version = \"3.33.1\";\nvar cytoscape = function cytoscape(options) {\n    // if no options specified, use default\n    if (options === undefined) {\n        options = {};\n    }\n    // create instance\n    if (plainObject(options)) {\n        return new Core(options);\n    } else if (string(options)) {\n        return extension.apply(extension, arguments);\n    }\n};\n// e.g. cytoscape.use( require('cytoscape-foo'), bar )\ncytoscape.use = function(ext) {\n    var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n    args.unshift(cytoscape); // cytoscape is first arg to ext\n    ext.apply(null, args);\n    return this;\n};\ncytoscape.warnings = function(bool) {\n    return warnings(bool);\n};\n// replaced by build system\ncytoscape.version = version;\n// expose public apis (mostly for extensions)\ncytoscape.stylesheet = cytoscape.Stylesheet = _Stylesheet;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUVELFNBQVNBLGtCQUFrQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCLFNBQVFBLEtBQUtBLElBQUlELEVBQUVFLE1BQU0sS0FBTUQsQ0FBQUEsSUFBSUQsRUFBRUUsTUFBTTtJQUM1QyxJQUFLLElBQUlDLElBQUksR0FBR0MsSUFBSUMsTUFBTUosSUFBSUUsSUFBSUYsR0FBR0UsSUFBS0MsQ0FBQyxDQUFDRCxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNyRCxPQUFPQztBQUNUO0FBQ0EsU0FBU0UsZ0JBQWdCTixDQUFDO0lBQ3hCLElBQUlLLE1BQU1FLE9BQU8sQ0FBQ1AsSUFBSSxPQUFPQTtBQUMvQjtBQUNBLFNBQVNRLG1CQUFtQlIsQ0FBQztJQUMzQixJQUFJSyxNQUFNRSxPQUFPLENBQUNQLElBQUksT0FBT0Qsa0JBQWtCQztBQUNqRDtBQUNBLFNBQVNTLGdCQUFnQlIsQ0FBQyxFQUFFRyxDQUFDO0lBQzNCLElBQUksQ0FBRUgsQ0FBQUEsYUFBYUcsQ0FBQUEsR0FBSSxNQUFNLElBQUlNLFVBQVU7QUFDN0M7QUFDQSxTQUFTQyxrQkFBa0JSLENBQUMsRUFBRUgsQ0FBQztJQUM3QixJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSVosRUFBRUUsTUFBTSxFQUFFVSxJQUFLO1FBQ2pDLElBQUlDLElBQUliLENBQUMsQ0FBQ1ksRUFBRTtRQUNaQyxFQUFFQyxVQUFVLEdBQUdELEVBQUVDLFVBQVUsSUFBSSxPQUFPRCxFQUFFRSxZQUFZLEdBQUcsTUFBTSxXQUFXRixLQUFNQSxDQUFBQSxFQUFFRyxRQUFRLEdBQUcsSUFBRyxHQUFJQyxPQUFPQyxjQUFjLENBQUNmLEdBQUdnQixlQUFlTixFQUFFTyxHQUFHLEdBQUdQO0lBQ3BKO0FBQ0Y7QUFDQSxTQUFTUSxhQUFhbEIsQ0FB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RSxHQUFHO0lBQzNCLElBQUkzNkssT0FBT25HLE1BQU1pQixTQUFTLENBQUMrQixLQUFLLENBQUNwQixJQUFJLENBQUNzRSxXQUFXLElBQUksc0JBQXNCO0lBRTNFQyxLQUFLMGhCLE9BQU8sQ0FBQzA2SixZQUFZLGdDQUFnQztJQUV6RHpCLElBQUlwNkssS0FBSyxDQUFDLE1BQU1QO0lBQ2hCLE9BQU8sSUFBSTtBQUNiO0FBQ0FvOEssVUFBVXZpSyxRQUFRLEdBQUcsU0FBVXd5RSxJQUFJO0lBQ2pDLE9BQU94eUUsU0FBU3d5RTtBQUNsQjtBQUVBLDJCQUEyQjtBQUMzQit2RixVQUFVRCxPQUFPLEdBQUdBO0FBRXBCLDZDQUE2QztBQUM3Q0MsVUFBVXI5SyxVQUFVLEdBQUdxOUssVUFBVUgsVUFBVSxHQUFHRDtBQUVkIiwic291cmNlcyI6WyIvaG9tZS9jaGFpemhlbmh1YS9Db2Rlcy91bmNhcnZlL2UyZS9leGFtcGxlcy90cmF2ZWwtdWkvbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5lc20ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjUsIFRoZSBDeXRvc2NhcGUgQ29uc29ydGl1bS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCdLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCBmYWxzZSwgby5jb25maWd1cmFibGUgPSB0cnVlLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9IHRydWUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHIsIGUpIHtcbiAgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoIXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSkgfHwgZSkge1xuICAgICAgdCAmJiAociA9IHQpO1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG4gPj0gci5sZW5ndGggPyB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHJbbisrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG4gIHZhciBvLFxuICAgIGEgPSB0cnVlLFxuICAgIHUgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0ID0gdC5jYWxsKHIpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHIgPSB0Lm5leHQoKTtcbiAgICAgIHJldHVybiBhID0gci5kb25lLCByO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gKHIpIHtcbiAgICAgIHUgPSB0cnVlLCBvID0gcjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGEgfHwgbnVsbCA9PSB0LnJldHVybiB8fCB0LnJldHVybigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHUpIHRocm93IG87XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5JDEoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9IHRydWUsXG4gICAgICBvID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuO1xuICAgICAgICBmID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgbyA9IHRydWUsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHVuZGVmaW5lZCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChTdHJpbmcgKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBfd2luZG93ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbnZhciBuYXZpZ2F0b3IgPSBfd2luZG93ID8gX3dpbmRvdy5uYXZpZ2F0b3IgOiBudWxsO1xuX3dpbmRvdyA/IF93aW5kb3cuZG9jdW1lbnQgOiBudWxsO1xudmFyIHR5cGVvZnN0ciA9IF90eXBlb2YoJycpO1xudmFyIHR5cGVvZm9iaiA9IF90eXBlb2Yoe30pO1xudmFyIHR5cGVvZmZuID0gX3R5cGVvZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgdHlwZW9maHRtbGVsZSA9IHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKEhUTUxFbGVtZW50KTtcbnZhciBpbnN0YW5jZVN0ciA9IGZ1bmN0aW9uIGluc3RhbmNlU3RyKG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5pbnN0YW5jZVN0cmluZyAmJiBmbiQ2KG9iai5pbnN0YW5jZVN0cmluZykgPyBvYmouaW5zdGFuY2VTdHJpbmcoKSA6IG51bGw7XG59O1xuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09IHR5cGVvZnN0cjtcbn07XG52YXIgZm4kNiA9IGZ1bmN0aW9uIGZuKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2Zmbjtcbn07XG52YXIgYXJyYXkgPSBmdW5jdGlvbiBhcnJheShvYmopIHtcbiAgcmV0dXJuICFlbGVtZW50T3JDb2xsZWN0aW9uKG9iaikgJiYgKEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiBvYmogIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiBBcnJheSk7XG59O1xudmFyIHBsYWluT2JqZWN0ID0gZnVuY3Rpb24gcGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZm9iaiAmJiAhYXJyYXkob2JqKSAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn07XG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gb2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2ZvYmo7XG59O1xudmFyIG51bWJlciQxID0gZnVuY3Rpb24gbnVtYmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSBfdHlwZW9mKDEpICYmICFpc05hTihvYmopO1xufTtcbnZhciBpbnRlZ2VyID0gZnVuY3Rpb24gaW50ZWdlcihvYmopIHtcbiAgcmV0dXJuIG51bWJlciQxKG9iaikgJiYgTWF0aC5mbG9vcihvYmopID09PSBvYmo7XG59O1xudmFyIGh0bWxFbGVtZW50ID0gZnVuY3Rpb24gaHRtbEVsZW1lbnQob2JqKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9maHRtbGVsZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGwgIT0gb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9XG59O1xudmFyIGVsZW1lbnRPckNvbGxlY3Rpb24gPSBmdW5jdGlvbiBlbGVtZW50T3JDb2xsZWN0aW9uKG9iaikge1xuICByZXR1cm4gZWxlbWVudChvYmopIHx8IGNvbGxlY3Rpb24ob2JqKTtcbn07XG52YXIgZWxlbWVudCA9IGZ1bmN0aW9uIGVsZW1lbnQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29sbGVjdGlvbicgJiYgb2JqLl9wcml2YXRlLnNpbmdsZTtcbn07XG52YXIgY29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNvbGxlY3Rpb24ob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29sbGVjdGlvbicgJiYgIW9iai5fcHJpdmF0ZS5zaW5nbGU7XG59O1xudmFyIGNvcmUgPSBmdW5jdGlvbiBjb3JlKG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvcmUnO1xufTtcbnZhciBzdHlsZXNoZWV0ID0gZnVuY3Rpb24gc3R5bGVzaGVldChvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdzdHlsZXNoZWV0Jztcbn07XG52YXIgZXZlbnQgPSBmdW5jdGlvbiBldmVudChvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdldmVudCc7XG59O1xudmFyIGVtcHR5U3RyaW5nID0gZnVuY3Rpb24gZW1wdHlTdHJpbmcob2JqKSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAvLyBudWxsIGlzIGVtcHR5XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAob2JqID09PSAnJyB8fCBvYmoubWF0Y2goL15cXHMrJC8pKSB7XG4gICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBlbXB0eVxuICB9XG4gIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG59O1xudmFyIGRvbUVsZW1lbnQgPSBmdW5jdGlvbiBkb21FbGVtZW50KG9iaikge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBib3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94KG9iaikge1xuICByZXR1cm4gcGxhaW5PYmplY3Qob2JqKSAmJiBudW1iZXIkMShvYmoueDEpICYmIG51bWJlciQxKG9iai54MikgJiYgbnVtYmVyJDEob2JqLnkxKSAmJiBudW1iZXIkMShvYmoueTIpO1xufTtcbnZhciBwcm9taXNlID0gZnVuY3Rpb24gcHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iamVjdChvYmopICYmIGZuJDYob2JqLnRoZW4pO1xufTtcbnZhciBtcyA9IGZ1bmN0aW9uIG1zKCkge1xuICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL21zaWV8dHJpZGVudHxlZGdlL2kpO1xufTsgLy8gcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRldGVjdCB0aGlzLi4uXG5cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gbWVtb2l6ZShmbiwga2V5Rm4pIHtcbiAgaWYgKCFrZXlGbikge1xuICAgIGtleUZuID0gZnVuY3Rpb24ga2V5Rm4oKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzLmpvaW4oJyQnKTtcbiAgICB9O1xuICB9XG4gIHZhciBfbWVtb2l6ZWRGbiA9IGZ1bmN0aW9uIG1lbW9pemVkRm4oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGsgPSBrZXlGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB2YXIgY2FjaGUgPSBfbWVtb2l6ZWRGbi5jYWNoZTtcbiAgICBpZiAoIShyZXQgPSBjYWNoZVtrXSkpIHtcbiAgICAgIHJldCA9IGNhY2hlW2tdID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIF9tZW1vaXplZEZuLmNhY2hlID0ge307XG4gIHJldHVybiBfbWVtb2l6ZWRGbjtcbn07XG5cbnZhciBjYW1lbDJkYXNoID0gbWVtb2l6ZShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufSk7XG52YXIgZGFzaDJjYW1lbCA9IG1lbW9pemUoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLygtXFx3KS9nLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2WzFdLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufSk7XG52YXIgcHJlcGVuZENhbWVsID0gbWVtb2l6ZShmdW5jdGlvbiAocHJlZml4LCBzdHIpIHtcbiAgcmV0dXJuIHByZWZpeCArIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn0sIGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICByZXR1cm4gcHJlZml4ICsgJyQnICsgc3RyO1xufSk7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIGlmIChlbXB0eVN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG52YXIgZW5kc1dpdGggPSBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHN1ZmZpeCkge1xuICByZXR1cm4gc3RyaW5nLnNsaWNlKC0xICogc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeDtcbn07XG5cbnZhciBudW1iZXIgPSAnKD86Wy0rXT8oPzooPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8pKSc7XG52YXIgcmdiYSA9ICdyZ2JbYV0/XFxcXCgoJyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0/KSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpKT9cXFxcKSc7XG52YXIgcmdiYU5vQmFja1JlZnMgPSAncmdiW2FdP1xcXFwoKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICcpKT9cXFxcKSc7XG52YXIgaHNsYSA9ICdoc2xbYV0/XFxcXCgoJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdKSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpKT9cXFxcKSc7XG52YXIgaHNsYU5vQmFja1JlZnMgPSAnaHNsW2FdP1xcXFwoKD86JyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICcpKT9cXFxcKSc7XG52YXIgaGV4MyA9ICdcXFxcI1swLTlhLWZBLUZdezN9JztcbnZhciBoZXg2ID0gJ1xcXFwjWzAtOWEtZkEtRl17Nn0nO1xuXG52YXIgYXNjZW5kaW5nID0gZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgZGVzY2VuZGluZyA9IGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gLTEgKiBhc2NlbmRpbmcoYSwgYik7XG59O1xuXG52YXIgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCkgOiBmdW5jdGlvbiAodGd0KSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb2JqID0gYXJnc1tpXTtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgayA9IGtleXNbal07XG4gICAgICB0Z3Rba10gPSBvYmpba107XG4gICAgfVxuICB9XG4gIHJldHVybiB0Z3Q7XG59O1xuXG4vLyBnZXQgW3IsIGcsIGJdIGZyb20gI2FiYyBvciAjYWFiYmNjXG52YXIgaGV4MnR1cGxlID0gZnVuY3Rpb24gaGV4MnR1cGxlKGhleCkge1xuICBpZiAoIShoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHx8IGhleFswXSAhPT0gJyMnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gIHZhciByLCBnLCBiO1xuICB2YXIgYmFzZSA9IDE2O1xuICBpZiAoc2hvcnRIZXgpIHtcbiAgICByID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzFdLCBiYXNlKTtcbiAgICBnID0gcGFyc2VJbnQoaGV4WzJdICsgaGV4WzJdLCBiYXNlKTtcbiAgICBiID0gcGFyc2VJbnQoaGV4WzNdICsgaGV4WzNdLCBiYXNlKTtcbiAgfSBlbHNlIHtcbiAgICByID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzJdLCBiYXNlKTtcbiAgICBnID0gcGFyc2VJbnQoaGV4WzNdICsgaGV4WzRdLCBiYXNlKTtcbiAgICBiID0gcGFyc2VJbnQoaGV4WzVdICsgaGV4WzZdLCBiYXNlKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIGhzbCgwLCAwLCAwKSBvciBoc2xhKDAsIDAsIDAsIDApXG52YXIgaHNsMnR1cGxlID0gZnVuY3Rpb24gaHNsMnR1cGxlKGhzbCkge1xuICB2YXIgcmV0O1xuICB2YXIgaCwgcywgbCwgYSwgciwgZywgYjtcbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgaWYgKHQgPiAxKSB0IC09IDE7XG4gICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIHJldHVybiBwO1xuICB9XG4gIHZhciBtID0gbmV3IFJlZ0V4cCgnXicgKyBoc2xhICsgJyQnKS5leGVjKGhzbCk7XG4gIGlmIChtKSB7XG4gICAgLy8gZ2V0IGh1ZVxuICAgIGggPSBwYXJzZUludChtWzFdKTtcbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggPSAoMzYwIC0gLTEgKiBoICUgMzYwKSAlIDM2MDtcbiAgICB9IGVsc2UgaWYgKGggPiAzNjApIHtcbiAgICAgIGggPSBoICUgMzYwO1xuICAgIH1cbiAgICBoIC89IDM2MDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgcyA9IHBhcnNlRmxvYXQobVsyXSk7XG4gICAgaWYgKHMgPCAwIHx8IHMgPiAxMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cbiAgICBzID0gcyAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgbCA9IHBhcnNlRmxvYXQobVszXSk7XG4gICAgaWYgKGwgPCAwIHx8IGwgPiAxMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGxpZ2h0bmVzcyBpcyBbMCwgMTAwXVxuICAgIGwgPSBsIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICBhID0gbVs0XTtcbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhID0gcGFyc2VGbG9hdChhKTtcbiAgICAgIGlmIChhIDwgMCB8fCBhID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGFscGhhIGlzIFswLCAxXVxuICAgIH1cblxuICAgIC8vIG5vdywgY29udmVydCB0byByZ2JcbiAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBNYXRoLnJvdW5kKGwgKiAyNTUpOyAvLyBhY2hyb21hdGljXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgciA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpKTtcbiAgICAgIGcgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCkpO1xuICAgICAgYiA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpKTtcbiAgICB9XG4gICAgcmV0ID0gW3IsIGcsIGIsIGFdO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gcmdiKDAsIDAsIDApIG9yIHJnYmEoMCwgMCwgMCwgMClcbnZhciByZ2IydHVwbGUgPSBmdW5jdGlvbiByZ2IydHVwbGUocmdiKSB7XG4gIHZhciByZXQ7XG4gIHZhciBtID0gbmV3IFJlZ0V4cCgnXicgKyByZ2JhICsgJyQnKS5leGVjKHJnYik7XG4gIGlmIChtKSB7XG4gICAgcmV0ID0gW107XG4gICAgdmFyIGlzUGN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG1baV07XG4gICAgICBpZiAoY2hhbm5lbFtjaGFubmVsLmxlbmd0aCAtIDFdID09PSAnJScpIHtcbiAgICAgICAgaXNQY3RbaV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoY2hhbm5lbCk7XG4gICAgICBpZiAoaXNQY3RbaV0pIHtcbiAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwgLyAxMDAgKiAyNTU7IC8vIG5vcm1hbGlzZSB0byBbMCwgMjU1XVxuICAgICAgfVxuICAgICAgaWYgKGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpbnZhbGlkIGNoYW5uZWwgdmFsdWVcblxuICAgICAgcmV0LnB1c2goTWF0aC5mbG9vcihjaGFubmVsKSk7XG4gICAgfVxuICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgaWYgKGF0TGVhc3RPbmVJc1BjdCAmJiAhYWxsQXJlUGN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBtdXN0IGFsbCBiZSBwZXJjZW50IHZhbHVlcyBpZiBvbmUgaXNcblxuICAgIHZhciBhbHBoYSA9IG1bNF07XG4gICAgaWYgKGFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gcGFyc2VGbG9hdChhbHBoYSk7XG4gICAgICBpZiAoYWxwaGEgPCAwIHx8IGFscGhhID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuICAgICAgcmV0LnB1c2goYWxwaGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbnZhciBjb2xvcm5hbWUydHVwbGUgPSBmdW5jdGlvbiBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHtcbiAgcmV0dXJuIGNvbG9yc1tjb2xvci50b0xvd2VyQ2FzZSgpXTtcbn07XG52YXIgY29sb3IydHVwbGUgPSBmdW5jdGlvbiBjb2xvcjJ0dXBsZShjb2xvcikge1xuICByZXR1cm4gKGFycmF5KGNvbG9yKSA/IGNvbG9yIDogbnVsbCkgfHwgY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB8fCBoZXgydHVwbGUoY29sb3IpIHx8IHJnYjJ0dXBsZShjb2xvcikgfHwgaHNsMnR1cGxlKGNvbG9yKTtcbn07XG52YXIgY29sb3JzID0ge1xuICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICB0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdLFxuICAvLyBOQiBhbHBoYSA9PT0gMFxuXG4gIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gIGJsYWNrOiBbMCwgMCwgMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gIGJsdWU6IFswLCAwLCAyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgbGltZTogWzAsIDI1NSwgMF0sXG4gIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgbmF2eTogWzAsIDAsIDEyOF0sXG4gIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gIHNsYXRlZ3JheTogWzExMiwgMTI4LCAxNDRdLFxuICBzbGF0ZWdyZXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDUwXVxufTtcblxuLy8gc2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgKG1hcCBtYXkgbm90IGJlIGJ1aWx0KVxudmFyIHNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcChvcHRpb25zKSB7XG4gIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgIH1cbiAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gZXh0ZW5kIHRoZSBtYXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgIG9ialtrZXldID0gb3B0aW9ucy52YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGdldHMgdGhlIHZhbHVlIGluIGEgbWFwIGV2ZW4gaWYgaXQncyBub3QgYnVpbHQgaW4gcGxhY2VzXG52YXIgZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwKG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIGdldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgfVxuICAgIG9iaiA9IG9ialtrZXldO1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cbnZhciBpc09iamVjdF8xO1xudmFyIGhhc1JlcXVpcmVkSXNPYmplY3Q7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJc09iamVjdCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZElzT2JqZWN0KSByZXR1cm4gaXNPYmplY3RfMTtcblx0aGFzUmVxdWlyZWRJc09iamVjdCA9IDE7XG5cdGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcblx0fVxuXG5cdGlzT2JqZWN0XzEgPSBpc09iamVjdDtcblx0cmV0dXJuIGlzT2JqZWN0XzE7XG59XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cbnZhciBfZnJlZUdsb2JhbDtcbnZhciBoYXNSZXF1aXJlZF9mcmVlR2xvYmFsO1xuXG5mdW5jdGlvbiByZXF1aXJlX2ZyZWVHbG9iYWwgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfZnJlZUdsb2JhbCkgcmV0dXJuIF9mcmVlR2xvYmFsO1xuXHRoYXNSZXF1aXJlZF9mcmVlR2xvYmFsID0gMTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cblx0X2ZyZWVHbG9iYWwgPSBmcmVlR2xvYmFsO1xuXHRyZXR1cm4gX2ZyZWVHbG9iYWw7XG59XG5cbnZhciBfcm9vdDtcbnZhciBoYXNSZXF1aXJlZF9yb290O1xuXG5mdW5jdGlvbiByZXF1aXJlX3Jvb3QgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfcm9vdCkgcmV0dXJuIF9yb290O1xuXHRoYXNSZXF1aXJlZF9yb290ID0gMTtcblx0dmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlX2ZyZWVHbG9iYWwoKTtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXHR2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuXHQvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cblx0dmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cblx0X3Jvb3QgPSByb290O1xuXHRyZXR1cm4gX3Jvb3Q7XG59XG5cbnZhciBub3dfMTtcbnZhciBoYXNSZXF1aXJlZE5vdztcblxuZnVuY3Rpb24gcmVxdWlyZU5vdyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE5vdykgcmV0dXJuIG5vd18xO1xuXHRoYXNSZXF1aXJlZE5vdyA9IDE7XG5cdHZhciByb290ID0gcmVxdWlyZV9yb290KCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuXHQgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMi40LjBcblx0ICogQGNhdGVnb3J5IERhdGVcblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG5cdCAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcblx0ICogfSwgXy5ub3coKSk7XG5cdCAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG5cdCAqL1xuXHR2YXIgbm93ID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcblx0fTtcblxuXHRub3dfMSA9IG5vdztcblx0cmV0dXJuIG5vd18xO1xufVxuXG4vKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cblxudmFyIF90cmltbWVkRW5kSW5kZXg7XG52YXIgaGFzUmVxdWlyZWRfdHJpbW1lZEVuZEluZGV4O1xuXG5mdW5jdGlvbiByZXF1aXJlX3RyaW1tZWRFbmRJbmRleCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF90cmltbWVkRW5kSW5kZXgpIHJldHVybiBfdHJpbW1lZEVuZEluZGV4O1xuXHRoYXNSZXF1aXJlZF90cmltbWVkRW5kSW5kZXggPSAxO1xuXHR2YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2Vcblx0ICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuXHQgKi9cblx0ZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuXHQgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cblx0ICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9XG5cblx0X3RyaW1tZWRFbmRJbmRleCA9IHRyaW1tZWRFbmRJbmRleDtcblx0cmV0dXJuIF90cmltbWVkRW5kSW5kZXg7XG59XG5cbnZhciBfYmFzZVRyaW07XG52YXIgaGFzUmVxdWlyZWRfYmFzZVRyaW07XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYmFzZVRyaW0gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYmFzZVRyaW0pIHJldHVybiBfYmFzZVRyaW07XG5cdGhhc1JlcXVpcmVkX2Jhc2VUcmltID0gMTtcblx0dmFyIHRyaW1tZWRFbmRJbmRleCA9IHJlcXVpcmVfdHJpbW1lZEVuZEluZGV4KCk7XG5cblx0LyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xuXHR2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG5cdCAgcmV0dXJuIHN0cmluZ1xuXHQgICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcblx0ICAgIDogc3RyaW5nO1xuXHR9XG5cblx0X2Jhc2VUcmltID0gYmFzZVRyaW07XG5cdHJldHVybiBfYmFzZVRyaW07XG59XG5cbnZhciBfU3ltYm9sO1xudmFyIGhhc1JlcXVpcmVkX1N5bWJvbDtcblxuZnVuY3Rpb24gcmVxdWlyZV9TeW1ib2wgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfU3ltYm9sKSByZXR1cm4gX1N5bWJvbDtcblx0aGFzUmVxdWlyZWRfU3ltYm9sID0gMTtcblx0dmFyIHJvb3QgPSByZXF1aXJlX3Jvb3QoKTtcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdF9TeW1ib2wgPSBTeW1ib2w7XG5cdHJldHVybiBfU3ltYm9sO1xufVxuXG52YXIgX2dldFJhd1RhZztcbnZhciBoYXNSZXF1aXJlZF9nZXRSYXdUYWc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfZ2V0UmF3VGFnICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2dldFJhd1RhZykgcmV0dXJuIF9nZXRSYXdUYWc7XG5cdGhhc1JlcXVpcmVkX2dldFJhd1RhZyA9IDE7XG5cdHZhciBTeW1ib2wgPSByZXF1aXJlX1N5bWJvbCgpO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcblx0ICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG5cdCAqIG9mIHZhbHVlcy5cblx0ICovXG5cdHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuXHQgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcblx0ICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG5cdCAgdHJ5IHtcblx0ICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcblx0ICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG5cdCAgfSBjYXRjaCAoZSkge31cblxuXHQgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcblx0ICBpZiAodW5tYXNrZWQpIHtcblx0ICAgIGlmIChpc093bikge1xuXHQgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0X2dldFJhd1RhZyA9IGdldFJhd1RhZztcblx0cmV0dXJuIF9nZXRSYXdUYWc7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblxudmFyIF9vYmplY3RUb1N0cmluZztcbnZhciBoYXNSZXF1aXJlZF9vYmplY3RUb1N0cmluZztcblxuZnVuY3Rpb24gcmVxdWlyZV9vYmplY3RUb1N0cmluZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9vYmplY3RUb1N0cmluZykgcmV0dXJuIF9vYmplY3RUb1N0cmluZztcblx0aGFzUmVxdWlyZWRfb2JqZWN0VG9TdHJpbmcgPSAxO1xuXHR2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG5cdCAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuXHQgKiBvZiB2YWx1ZXMuXG5cdCAqL1xuXHR2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuXHQgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcblx0fVxuXG5cdF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXHRyZXR1cm4gX29iamVjdFRvU3RyaW5nO1xufVxuXG52YXIgX2Jhc2VHZXRUYWc7XG52YXIgaGFzUmVxdWlyZWRfYmFzZUdldFRhZztcblxuZnVuY3Rpb24gcmVxdWlyZV9iYXNlR2V0VGFnICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Jhc2VHZXRUYWcpIHJldHVybiBfYmFzZUdldFRhZztcblx0aGFzUmVxdWlyZWRfYmFzZUdldFRhZyA9IDE7XG5cdHZhciBTeW1ib2wgPSByZXF1aXJlX1N5bWJvbCgpLFxuXHQgICAgZ2V0UmF3VGFnID0gcmVxdWlyZV9nZXRSYXdUYWcoKSxcblx0ICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZV9vYmplY3RUb1N0cmluZygpO1xuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG5cdCAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcblx0ICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuXHQgIH1cblx0ICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG5cdCAgICA/IGdldFJhd1RhZyh2YWx1ZSlcblx0ICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuXHR9XG5cblx0X2Jhc2VHZXRUYWcgPSBiYXNlR2V0VGFnO1xuXHRyZXR1cm4gX2Jhc2VHZXRUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cbnZhciBpc09iamVjdExpa2VfMTtcbnZhciBoYXNSZXF1aXJlZElzT2JqZWN0TGlrZTtcblxuZnVuY3Rpb24gcmVxdWlyZUlzT2JqZWN0TGlrZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZElzT2JqZWN0TGlrZSkgcmV0dXJuIGlzT2JqZWN0TGlrZV8xO1xuXHRoYXNSZXF1aXJlZElzT2JqZWN0TGlrZSA9IDE7XG5cdGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcblx0fVxuXG5cdGlzT2JqZWN0TGlrZV8xID0gaXNPYmplY3RMaWtlO1xuXHRyZXR1cm4gaXNPYmplY3RMaWtlXzE7XG59XG5cbnZhciBpc1N5bWJvbF8xO1xudmFyIGhhc1JlcXVpcmVkSXNTeW1ib2w7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJc1N5bWJvbCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZElzU3ltYm9sKSByZXR1cm4gaXNTeW1ib2xfMTtcblx0aGFzUmVxdWlyZWRJc1N5bWJvbCA9IDE7XG5cdHZhciBiYXNlR2V0VGFnID0gcmVxdWlyZV9iYXNlR2V0VGFnKCksXG5cdCAgICBpc09iamVjdExpa2UgPSByZXF1aXJlSXNPYmplY3RMaWtlKCk7XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNTeW1ib2woJ2FiYycpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG5cdCAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuXHR9XG5cblx0aXNTeW1ib2xfMSA9IGlzU3ltYm9sO1xuXHRyZXR1cm4gaXNTeW1ib2xfMTtcbn1cblxudmFyIHRvTnVtYmVyXzE7XG52YXIgaGFzUmVxdWlyZWRUb051bWJlcjtcblxuZnVuY3Rpb24gcmVxdWlyZVRvTnVtYmVyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVG9OdW1iZXIpIHJldHVybiB0b051bWJlcl8xO1xuXHRoYXNSZXF1aXJlZFRvTnVtYmVyID0gMTtcblx0dmFyIGJhc2VUcmltID0gcmVxdWlyZV9iYXNlVHJpbSgpLFxuXHQgICAgaXNPYmplY3QgPSByZXF1aXJlSXNPYmplY3QoKSxcblx0ICAgIGlzU3ltYm9sID0gcmVxdWlyZUlzU3ltYm9sKCk7XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBOQU4gPSAwIC8gMDtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuXHR2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG5cdC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG5cdHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKDMuMik7XG5cdCAqIC8vID0+IDMuMlxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuXHQgKiAvLyA9PiA1ZS0zMjRcblx0ICpcblx0ICogXy50b051bWJlcihJbmZpbml0eSk7XG5cdCAqIC8vID0+IEluZmluaXR5XG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoJzMuMicpO1xuXHQgKiAvLyA9PiAzLjJcblx0ICovXG5cdGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gTkFOO1xuXHQgIH1cblx0ICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG5cdCAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG5cdCAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcblx0ICB9XG5cdCAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG5cdCAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcblx0ICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcblx0ICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuXHQgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG5cdH1cblxuXHR0b051bWJlcl8xID0gdG9OdW1iZXI7XG5cdHJldHVybiB0b051bWJlcl8xO1xufVxuXG52YXIgZGVib3VuY2VfMTtcbnZhciBoYXNSZXF1aXJlZERlYm91bmNlO1xuXG5mdW5jdGlvbiByZXF1aXJlRGVib3VuY2UgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWREZWJvdW5jZSkgcmV0dXJuIGRlYm91bmNlXzE7XG5cdGhhc1JlcXVpcmVkRGVib3VuY2UgPSAxO1xuXHR2YXIgaXNPYmplY3QgPSByZXF1aXJlSXNPYmplY3QoKSxcblx0ICAgIG5vdyA9IHJlcXVpcmVOb3coKSxcblx0ICAgIHRvTnVtYmVyID0gcmVxdWlyZVRvTnVtYmVyKCk7XG5cblx0LyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuXHR2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0dmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuXHQgICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuXHQgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcblx0ICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuXHQgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cblx0ICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG5cdCAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcblx0ICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuXHQgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuXHQgKiBpbnZvY2F0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG5cdCAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG5cdCAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cblx0ICpcblx0ICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG5cdCAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cblx0ICpcblx0ICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG5cdCAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuXHQgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cblx0ICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG5cdCAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG5cdCAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG5cdCAqXG5cdCAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuXHQgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG5cdCAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuXHQgKiAgICd0cmFpbGluZyc6IGZhbHNlXG5cdCAqIH0pKTtcblx0ICpcblx0ICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cblx0ICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG5cdCAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcblx0ICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuXHQgKlxuXHQgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuXHQgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcblx0ICovXG5cdGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcblx0ICB2YXIgbGFzdEFyZ3MsXG5cdCAgICAgIGxhc3RUaGlzLFxuXHQgICAgICBtYXhXYWl0LFxuXHQgICAgICByZXN1bHQsXG5cdCAgICAgIHRpbWVySWQsXG5cdCAgICAgIGxhc3RDYWxsVGltZSxcblx0ICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuXHQgICAgICBsZWFkaW5nID0gZmFsc2UsXG5cdCAgICAgIG1heGluZyA9IGZhbHNlLFxuXHQgICAgICB0cmFpbGluZyA9IHRydWU7XG5cblx0ICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgIH1cblx0ICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcblx0ICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcblx0ICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcblx0ICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuXHQgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcblx0ICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG5cdCAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuXHQgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuXHQgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcblx0ICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcblx0ICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcblx0ICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG5cdCAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG5cdCAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuXHQgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcblx0ICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuXHQgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuXHQgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcblx0ICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuXHQgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG5cdCAgICByZXR1cm4gbWF4aW5nXG5cdCAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcblx0ICAgICAgOiB0aW1lV2FpdGluZztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuXHQgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcblx0ICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG5cdCAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuXHQgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcblx0ICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cblx0ICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG5cdCAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuXHQgICAgdmFyIHRpbWUgPSBub3coKTtcblx0ICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcblx0ICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcblx0ICAgIH1cblx0ICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuXHQgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuXHQgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuXHQgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuXHQgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG5cdCAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcblx0ICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG5cdCAgICB9XG5cdCAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjYW5jZWwoKSB7XG5cdCAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcblx0ICAgIH1cblx0ICAgIGxhc3RJbnZva2VUaW1lID0gMDtcblx0ICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuXHQgICAgdmFyIHRpbWUgPSBub3coKSxcblx0ICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG5cdCAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcblx0ICAgIGxhc3RUaGlzID0gdGhpcztcblx0ICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cblx0ICAgIGlmIChpc0ludm9raW5nKSB7XG5cdCAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAobWF4aW5nKSB7XG5cdCAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cblx0ICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG5cdCAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcblx0ICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblx0ICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuXHQgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuXHQgIHJldHVybiBkZWJvdW5jZWQ7XG5cdH1cblxuXHRkZWJvdW5jZV8xID0gZGVib3VuY2U7XG5cdHJldHVybiBkZWJvdW5jZV8xO1xufVxuXG52YXIgZGVib3VuY2VFeHBvcnRzID0gcmVxdWlyZURlYm91bmNlKCk7XG52YXIgZGVib3VuY2UgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZGVib3VuY2VFeHBvcnRzKTtcblxudmFyIHBlcmZvcm1hbmNlJDEgPSBfd2luZG93ID8gX3dpbmRvdy5wZXJmb3JtYW5jZSA6IG51bGw7XG52YXIgcG5vdyA9IHBlcmZvcm1hbmNlJDEgJiYgcGVyZm9ybWFuY2UkMS5ub3cgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZSQxLm5vdygpO1xufSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59O1xudmFyIHJhZiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF93aW5kb3cpIHtcbiAgICBpZiAoX3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgX3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF93aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF93aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBfd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX3dpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBfd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmbihwbm93KCkpO1xuICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICB9XG4gIH07XG59KCk7XG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSB7XG4gIHJldHVybiByYWYoZm4pO1xufTtcbnZhciBwZXJmb3JtYW5jZU5vdyA9IHBub3c7XG5cbnZhciBERUZBVUxUX0hBU0hfU0VFRCA9IDkyNjE7XG52YXIgSyA9IDY1NTk5OyAvLyAzNyBhbHNvIHdvcmtzIHByZXR0eSB3ZWxsXG52YXIgREVGQVVMVF9IQVNIX1NFRURfQUxUID0gNTM4MTtcbnZhciBoYXNoSXRlcmFibGVJbnRzID0gZnVuY3Rpb24gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvcikge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRUQ7XG4gIC8vIHNkYm0vc3RyaW5nLWhhc2hcbiAgdmFyIGhhc2ggPSBzZWVkO1xuICB2YXIgZW50cnk7XG4gIGZvciAoOzspIHtcbiAgICBlbnRyeSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGhhc2ggPSBoYXNoICogSyArIGVudHJ5LnZhbHVlIHwgMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn07XG52YXIgaGFzaEludCA9IGZ1bmN0aW9uIGhhc2hJbnQobnVtKSB7XG4gIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0hBU0hfU0VFRDtcbiAgLy8gc2RibS9zdHJpbmctaGFzaFxuICByZXR1cm4gc2VlZCAqIEsgKyBudW0gfCAwO1xufTtcbnZhciBoYXNoSW50QWx0ID0gZnVuY3Rpb24gaGFzaEludEFsdChudW0pIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEX0FMVDtcbiAgLy8gZGpiMi9zdHJpbmctaGFzaFxuICByZXR1cm4gKHNlZWQgPDwgNSkgKyBzZWVkICsgbnVtIHwgMDtcbn07XG52YXIgY29tYmluZUhhc2hlcyA9IGZ1bmN0aW9uIGNvbWJpbmVIYXNoZXMoaGFzaDEsIGhhc2gyKSB7XG4gIHJldHVybiBoYXNoMSAqIDB4MjAwMDAwICsgaGFzaDI7XG59O1xudmFyIGNvbWJpbmVIYXNoZXNBcnJheSA9IGZ1bmN0aW9uIGNvbWJpbmVIYXNoZXNBcnJheShoYXNoZXMpIHtcbiAgcmV0dXJuIGhhc2hlc1swXSAqIDB4MjAwMDAwICsgaGFzaGVzWzFdO1xufTtcbnZhciBoYXNoQXJyYXlzID0gZnVuY3Rpb24gaGFzaEFycmF5cyhoYXNoZXMxLCBoYXNoZXMyKSB7XG4gIHJldHVybiBbaGFzaEludChoYXNoZXMxWzBdLCBoYXNoZXMyWzBdKSwgaGFzaEludEFsdChoYXNoZXMxWzFdLCBoYXNoZXMyWzFdKV07XG59O1xudmFyIGhhc2hJbnRzQXJyYXkgPSBmdW5jdGlvbiBoYXNoSW50c0FycmF5KGludHMsIHNlZWQpIHtcbiAgdmFyIGVudHJ5ID0ge1xuICAgIHZhbHVlOiAwLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbmd0aCA9IGludHMubGVuZ3RoO1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gaW50c1tpKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvciwgc2VlZCk7XG59O1xudmFyIGhhc2hTdHJpbmcgPSBmdW5jdGlvbiBoYXNoU3RyaW5nKHN0ciwgc2VlZCkge1xuICB2YXIgZW50cnkgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbn07XG52YXIgaGFzaFN0cmluZ3MgPSBmdW5jdGlvbiBoYXNoU3RyaW5ncygpIHtcbiAgcmV0dXJuIGhhc2hTdHJpbmdzQXJyYXkoYXJndW1lbnRzKTtcbn07XG52YXIgaGFzaFN0cmluZ3NBcnJheSA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzQXJyYXkoc3Rycykge1xuICB2YXIgaGFzaDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0ciA9IHN0cnNbaV07XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0ciwgaGFzaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNoO1xufTtcblxuZnVuY3Rpb24gcm90YXRlUG9pbnQoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgYW5nbGVEZWdyZWVzKSB7XG4gIHZhciBhbmdsZVJhZGlhbnMgPSBhbmdsZURlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcm90YXRlZFggPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpICogKHggLSBjZW50ZXJYKSAtIE1hdGguc2luKGFuZ2xlUmFkaWFucykgKiAoeSAtIGNlbnRlclkpICsgY2VudGVyWDtcbiAgdmFyIHJvdGF0ZWRZID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKSAqICh4IC0gY2VudGVyWCkgKyBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpICogKHkgLSBjZW50ZXJZKSArIGNlbnRlclk7XG4gIHJldHVybiB7XG4gICAgeDogcm90YXRlZFgsXG4gICAgeTogcm90YXRlZFlcbiAgfTtcbn1cbnZhciBtb3ZlUG9pbnRCeUJveEFzcGVjdCA9IGZ1bmN0aW9uIG1vdmVQb2ludEJ5Qm94QXNwZWN0KHgsIHksIGJveFgsIGJveFksIHNrZXdYLCBza2V3WSkge1xuICByZXR1cm4ge1xuICAgIHg6ICh4IC0gYm94WCkgKiBza2V3WCArIGJveFgsXG4gICAgeTogKHkgLSBib3hZKSAqIHNrZXdZICsgYm94WVxuICB9O1xufTtcbmZ1bmN0aW9uIHJvdGF0ZVBvc0FuZFNrZXdCeUJveChwb3MsIGJveCwgYW5nbGVEZWdyZWVzKSB7XG4gIGlmIChhbmdsZURlZ3JlZXMgPT09IDApIHJldHVybiBwb3M7XG4gIHZhciBjZW50ZXJYID0gKGJveC54MSArIGJveC54MikgLyAyO1xuICB2YXIgY2VudGVyWSA9IChib3gueTEgKyBib3gueTIpIC8gMjtcbiAgdmFyIHNrZXdYID0gYm94LncgLyBib3guaDtcbiAgdmFyIHNrZXdZID0gMSAvIHNrZXdYO1xuICB2YXIgcm90YXRlZCA9IHJvdGF0ZVBvaW50KHBvcy54LCBwb3MueSwgY2VudGVyWCwgY2VudGVyWSwgYW5nbGVEZWdyZWVzKTtcbiAgdmFyIHNrZXdlZCA9IG1vdmVQb2ludEJ5Qm94QXNwZWN0KHJvdGF0ZWQueCwgcm90YXRlZC55LCBjZW50ZXJYLCBjZW50ZXJZLCBza2V3WCwgc2tld1kpO1xuICByZXR1cm4ge1xuICAgIHg6IHNrZXdlZC54LFxuICAgIHk6IHNrZXdlZC55XG4gIH07XG59XG5cbnZhciB3YXJuaW5nc0VuYWJsZWQgPSB0cnVlO1xudmFyIHdhcm5TdXBwb3J0ZWQgPSBjb25zb2xlLndhcm4gIT0gbnVsbDtcbnZhciB0cmFjZVN1cHBvcnRlZCA9IGNvbnNvbGUudHJhY2UgIT0gbnVsbDtcbnZhciBNQVhfSU5UJDEgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIHRydWVpZnkgPSBmdW5jdGlvbiB0cnVlaWZ5KCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZmFsc2lmeSA9IGZ1bmN0aW9uIGZhbHNpZnkoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgemVyb2lmeSA9IGZ1bmN0aW9uIHplcm9pZnkoKSB7XG4gIHJldHVybiAwO1xufTtcbnZhciBub29wJDEgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59O1xudmFyIHdhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoZW5hYmxlZCkge1xuICBpZiAoZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2FybmluZ3NFbmFibGVkID0gISFlbmFibGVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3YXJuaW5nc0VuYWJsZWQ7XG4gIH1cbn07XG52YXIgd2FybiA9IGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmICghd2FybmluZ3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2FyblN1cHBvcnRlZCkge1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgaWYgKHRyYWNlU3VwcG9ydGVkKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHJldHVybiBleHRlbmQoe30sIG9iaik7XG59O1xuXG4vLyBnZXRzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcmd1bWVudFxudmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChhcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gY2xvbmUob2JqKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xudmFyIGNvcHlBcnJheSA9IGZ1bmN0aW9uIGNvcHlBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFyci5zbGljZSgpO1xufTtcbnZhciB1dWlkID0gZnVuY3Rpb24gdXVpZChhLCBiIC8qIHBsYWNlaG9sZGVycyAqLykge1xuICBmb3IgKFxuICAvLyBsb29wIDopXG4gIGIgPSBhID0gJyc7XG4gIC8vIGIgLSByZXN1bHQgLCBhIC0gbnVtZXJpYyBsZXRpYWJsZVxuICBhKysgPCAzNjtcbiAgLy9cbiAgYiArPSBhICogNTEgJiA1MiAvLyBpZiBcImFcIiBpcyBub3QgOSBvciAxNCBvciAxOSBvciAyNFxuICA/XG4gIC8vICByZXR1cm4gYSByYW5kb20gbnVtYmVyIG9yIDRcbiAgKGEgXiAxNSAvLyBpZiBcImFcIiBpcyBub3QgMTVcbiAgP1xuICAvLyBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIgZnJvbSAwIHRvIDE1XG4gIDggXiBNYXRoLnJhbmRvbSgpICogKGEgXiAyMCA/IDE2IDogNCkgLy8gdW5sZXNzIFwiYVwiIGlzIDIwLCBpbiB3aGljaCBjYXNlIGEgcmFuZG9tIG51bWJlciBmcm9tIDggdG8gMTFcbiAgOiA0IC8vICBvdGhlcndpc2UgNFxuICApLnRvU3RyaW5nKDE2KSA6ICctJyAvLyAgaW4gb3RoZXIgY2FzZXMgKGlmIFwiYVwiIGlzIDksMTQsMTksMjQpIGluc2VydCBcIi1cIlxuICApO1xuICByZXR1cm4gYjtcbn07XG52YXIgX3N0YXRpY0VtcHR5T2JqZWN0ID0ge307XG52YXIgc3RhdGljRW1wdHlPYmplY3QgPSBmdW5jdGlvbiBzdGF0aWNFbXB0eU9iamVjdCgpIHtcbiAgcmV0dXJuIF9zdGF0aWNFbXB0eU9iamVjdDtcbn07XG52YXIgZGVmYXVsdHMkZyA9IGZ1bmN0aW9uIGRlZmF1bHRzKF9kZWZhdWx0cykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKF9kZWZhdWx0cyk7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0cykge1xuICAgIHZhciBmaWxsZWRPcHRzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBvcHRWYWwgPSBvcHRzID09IG51bGwgPyB1bmRlZmluZWQgOiBvcHRzW2tleV07XG4gICAgICBmaWxsZWRPcHRzW2tleV0gPSBvcHRWYWwgPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0c1trZXldIDogb3B0VmFsO1xuICAgIH1cbiAgICByZXR1cm4gZmlsbGVkT3B0cztcbiAgfTtcbn07XG52YXIgcmVtb3ZlRnJvbUFycmF5ID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFyciwgZWxlLCBvbmVDb3B5KSB7XG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoYXJyW2ldID09PSBlbGUpIHtcbiAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59O1xudmFyIGNsZWFyQXJyYXkgPSBmdW5jdGlvbiBjbGVhckFycmF5KGFycikge1xuICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgpO1xufTtcbnZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChhcnIsIG90aGVyQXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBvdGhlckFycltpXTtcbiAgICBhcnIucHVzaChlbCk7XG4gIH1cbn07XG52YXIgZ2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cbiAgcmV0dXJuIG9ialtwcm9wTmFtZV07XG59O1xudmFyIHNldFByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpIHtcbiAgaWYgKHByZWZpeCkge1xuICAgIHByb3BOYW1lID0gcHJlcGVuZENhbWVsKHByZWZpeCwgcHJvcE5hbWUpOyAvLyBlLmcuIChsYWJlbFdpZHRoLCBzb3VyY2UpID0+IHNvdXJjZUxhYmVsV2lkdGhcbiAgfVxuICBvYmpbcHJvcE5hbWVdID0gdmFsdWU7XG59O1xuXG4vKiBnbG9iYWwgTWFwICovXG52YXIgT2JqZWN0TWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JqZWN0TWFwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RNYXApO1xuICAgIHRoaXMuX29iaiA9IHt9O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoT2JqZWN0TWFwLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICB0aGlzLl9vYmpba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHRoaXMuX29ialtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fb2JqID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpba2V5XTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBNYXAkMSA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnID8gTWFwIDogT2JqZWN0TWFwO1xuXG4vKiBnbG9iYWwgU2V0ICovXG5cbnZhciB1bmRlZiA9IFwidW5kZWZpbmVkXCIgO1xudmFyIE9iamVjdFNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdFNldChhcnJheU9yT2JqZWN0U2V0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFNldCk7XG4gICAgdGhpcy5fb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIGlmIChhcnJheU9yT2JqZWN0U2V0ICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnI7XG4gICAgICBpZiAoYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZyAhPSBudWxsICYmIGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcoKSA9PT0gdGhpcy5pbnN0YW5jZVN0cmluZygpKSB7XG4gICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQudG9BcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkKGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoT2JqZWN0U2V0LCBbe1xuICAgIGtleTogXCJpbnN0YW5jZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICAgIHJldHVybiAnc2V0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWwpIHtcbiAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuICAgICAgaWYgKG9bdmFsXSAhPT0gMSkge1xuICAgICAgICBvW3ZhbF0gPSAxO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUodmFsKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuX29iajtcbiAgICAgIGlmIChvW3ZhbF0gPT09IDEpIHtcbiAgICAgICAgb1t2YWxdID0gMDtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyh2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpbdmFsXSA9PT0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9vYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5oYXMoa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBTZXQkMSA9ICh0eXBlb2YgU2V0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoU2V0KSkgIT09IHVuZGVmID8gU2V0IDogT2JqZWN0U2V0O1xuXG4vLyByZXByZXNlbnRzIGEgbm9kZSBvciBhbiBlZGdlXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIEVsZW1lbnQoY3ksIHBhcmFtcykge1xuICB2YXIgcmVzdG9yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgaWYgKGN5ID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgIWNvcmUoY3kpKSB7XG4gICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UgYW5kIHBhcmFtZXRlcnMgc2V0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBncm91cCA9IHBhcmFtcy5ncm91cDtcblxuICAvLyB0cnkgdG8gYXV0b21hdGljYWxseSBpbmZlciB0aGUgZ3JvdXAgaWYgdW5zcGVjaWZpZWRcbiAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICBpZiAocGFyYW1zLmRhdGEgJiYgcGFyYW1zLmRhdGEuc291cmNlICE9IG51bGwgJiYgcGFyYW1zLmRhdGEudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgIGdyb3VwID0gJ2VkZ2VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSAnbm9kZXMnO1xuICAgIH1cbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGdyb3VwXG4gIGlmIChncm91cCAhPT0gJ25vZGVzJyAmJiBncm91cCAhPT0gJ2VkZ2VzJykge1xuICAgIGVycm9yKCdBbiBlbGVtZW50IG11c3QgYmUgb2YgdHlwZSBgbm9kZXNgIG9yIGBlZGdlc2A7IHlvdSBzcGVjaWZpZWQgYCcgKyBncm91cCArICdgJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG4gIHRoaXMubGVuZ3RoID0gMTtcbiAgdGhpc1swXSA9IHRoaXM7XG5cbiAgLy8gTk9URTogd2hlbiBzb21ldGhpbmcgaXMgYWRkZWQgaGVyZSwgYWRkIGFsc28gdG8gZWxlLmpzb24oKVxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBzaW5nbGU6IHRydWUsXG4gICAgLy8gaW5kaWNhdGVzIHRoaXMgaXMgYW4gZWxlbWVudFxuICAgIGRhdGE6IHBhcmFtcy5kYXRhIHx8IHt9LFxuICAgIC8vIGRhdGEgb2JqZWN0XG4gICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbiB8fCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgLy8gKHgsIHkpIHBvc2l0aW9uIHBhaXJcbiAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCxcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5vZGVzIGNhbGN1bGF0ZWQgYnkgdGhlIHJlbmRlcmVyIHdoZW4gc2V0IHRvIHNwZWNpYWwgJ2F1dG8nIHZhbHVlXG4gICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLFxuICAgIGF1dG9QYWRkaW5nOiB1bmRlZmluZWQsXG4gICAgY29tcG91bmRCb3VuZHNDbGVhbjogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgY29tcG91bmQgZGltZW5zaW9ucyBuZWVkIHRvIGJlIHJlY2FsY3VsYXRlZCB0aGUgbmV4dCB0aW1lIGRpbWVuc2lvbnMgYXJlIHJlYWRcbiAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgIGdyb3VwOiBncm91cCxcbiAgICAvLyBzdHJpbmc7ICdub2Rlcycgb3IgJ2VkZ2VzJ1xuICAgIHN0eWxlOiB7fSxcbiAgICAvLyBwcm9wZXJ0aWVzIGFzIHNldCBieSB0aGUgc3R5bGVcbiAgICByc3R5bGU6IHt9LFxuICAgIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICBzdHlsZUN4dHM6IFtdLFxuICAgIC8vIGFwcGxpZWQgc3R5bGUgY29udGV4dHMgZnJvbSB0aGUgc3R5bGVyXG4gICAgc3R5bGVLZXlzOiB7fSxcbiAgICAvLyBwZXItZ3JvdXAga2V5cyBvZiBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICByZW1vdmVkOiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgaXQncyBpbnNpZGUgdGhlIHZpczsgdHJ1ZSBpZiByZW1vdmVkIChzZXQgdHJ1ZSBoZXJlIHNpbmNlIHdlIGNhbGwgcmVzdG9yZSlcbiAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RlZFxuICAgIHNlbGVjdGFibGU6IHBhcmFtcy5zZWxlY3RhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICBsb2NrZWQ6IHBhcmFtcy5sb2NrZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBsb2NrZWQgKGNhbm5vdCBiZSBtb3ZlZClcbiAgICBncmFiYmVkOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGdyYWJiZWQgYnkgdGhlIG1vdXNlOyByZW5kZXJlciBzZXRzIHRoaXMgcHJpdmF0ZWx5XG4gICAgZ3JhYmJhYmxlOiBwYXJhbXMuZ3JhYmJhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLmdyYWJiYWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSBncmFiYmVkXG4gICAgcGFubmFibGU6IHBhcmFtcy5wYW5uYWJsZSA9PT0gdW5kZWZpbmVkID8gZ3JvdXAgPT09ICdlZGdlcycgPyB0cnVlIDogZmFsc2UgOiBwYXJhbXMucGFubmFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBoYXMgcGFzc3Rocm91Z2ggcGFubmluZyBlbmFibGVkXG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFjdGl2ZSBmcm9tIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjbGFzc2VzOiBuZXcgU2V0JDEoKSxcbiAgICAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgcXVldWU6IFtdXG4gICAgfSxcbiAgICByc2NyYXRjaDoge30sXG4gICAgLy8gb2JqZWN0IGluIHdoaWNoIHRoZSByZW5kZXJlciBjYW4gc3RvcmUgaW5mb3JtYXRpb25cbiAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSxcbiAgICAvLyBzY3JhdGNoIG9iamVjdHNcbiAgICBlZGdlczogW10sXG4gICAgLy8gYXJyYXkgb2YgY29ubmVjdGVkIGVkZ2VzXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgcGFyZW50OiBwYXJhbXMucGFyZW50ICYmIHBhcmFtcy5wYXJlbnQuaXNOb2RlKCkgPyBwYXJhbXMucGFyZW50IDogbnVsbCxcbiAgICAvLyBwYXJlbnQgcmVmXG4gICAgdHJhdmVyc2FsQ2FjaGU6IHt9LFxuICAgIC8vIGNhY2hlIG9mIG91dHB1dCBvZiB0cmF2ZXJzYWwgZnVuY3Rpb25zXG4gICAgYmFja2dyb3VuZGluZzogZmFsc2UsXG4gICAgLy8gd2hldGhlciBiYWNrZ3JvdW5kIGltYWdlcyBhcmUgbG9hZGluZ1xuICAgIGJiQ2FjaGU6IG51bGwsXG4gICAgLy8gY2FjaGUgb2YgdGhlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgYmJDYWNoZVNoaWZ0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgLy8gc2hpZnQgYXBwbGllZCB0byBjYWNoZWQgYmIgdG8gYmUgYXBwbGllZCBvbiBuZXh0IGdldFxuICAgIGJvZHlCb3VuZHM6IG51bGwsXG4gICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgdy9vIG92ZXJsYXlcbiAgICBvdmVybGF5Qm91bmRzOiBudWxsLFxuICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlbGVtZW50IGJvZHksIGluY2x1ZGluZyBvdmVybGF5XG4gICAgbGFiZWxCb3VuZHM6IHtcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBsYWJlbHNcbiAgICAgIGFsbDogbnVsbCxcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIG1haW46IG51bGxcbiAgICB9LFxuICAgIGFycm93Qm91bmRzOiB7XG4gICAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWRnZSBhcnJvd3NcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICdtaWQtc291cmNlJzogbnVsbCxcbiAgICAgICdtaWQtdGFyZ2V0JzogbnVsbFxuICAgIH1cbiAgfTtcbiAgaWYgKF9wLnBvc2l0aW9uLnggPT0gbnVsbCkge1xuICAgIF9wLnBvc2l0aW9uLnggPSAwO1xuICB9XG4gIGlmIChfcC5wb3NpdGlvbi55ID09IG51bGwpIHtcbiAgICBfcC5wb3NpdGlvbi55ID0gMDtcbiAgfVxuXG4gIC8vIHJlbmRlcmVkUG9zaXRpb24gb3ZlcnJpZGVzIGlmIHNwZWNpZmllZFxuICBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24pIHtcbiAgICB2YXIgcnBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBfcC5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IChycG9zLnggLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTogKHJwb3MueSAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICB9XG4gIHZhciBjbGFzc2VzID0gW107XG4gIGlmIChhcnJheShwYXJhbXMuY2xhc3NlcykpIHtcbiAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXM7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSkge1xuICAgIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICBpZiAoIWNscyB8fCBjbHMgPT09ICcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgX3AuY2xhc3Nlcy5hZGQoY2xzKTtcbiAgfVxuICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgaWYgKHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlKSB7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgdmFyIGJ5cGFzcyA9IHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzO1xuICBpZiAoYnlwYXNzKSB7XG4gICAgd2FybignU2V0dGluZyBhIGBzdHlsZWAgYnlwYXNzIGF0IGVsZW1lbnQgY3JlYXRpb24gc2hvdWxkIGJlIGRvbmUgb25seSB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5LiAgVHJ5IHRvIHVzZSB0aGUgc3R5bGVzaGVldCBpbnN0ZWFkLicpO1xuICAgIHRoaXMuc3R5bGUoYnlwYXNzKTtcbiAgfVxufTtcblxudmFyIGRlZmluZVNlYXJjaCA9IGZ1bmN0aW9uIGRlZmluZVNlYXJjaChwYXJhbXMpIHtcbiAgcGFyYW1zID0ge1xuICAgIGJmczogcGFyYW1zLmJmcyB8fCAhcGFyYW1zLmRmcyxcbiAgICBkZnM6IHBhcmFtcy5kZnMgfHwgIXBhcmFtcy5iZnNcbiAgfTtcblxuICAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2hGbihyb290cywgZm4sIGRpcmVjdGVkKSB7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKHBsYWluT2JqZWN0KHJvb3RzKSAmJiAhZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykpIHtcbiAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cyB8fCBvcHRpb25zLnJvb3Q7XG4gICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfVxuICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhZm4kNihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgIGZuID0gZm4kNihmbikgPyBmbiA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHYgPSByb290cyA9IHN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgIHZhciBWID0ge307XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBmb3VuZDtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgLy8gZW5xdWV1ZSB2XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmkgPSB2W2ldO1xuICAgICAgdmFyIHZpSWQgPSB2aS5pZCgpO1xuICAgICAgaWYgKHZpLmlzTm9kZSgpKSB7XG4gICAgICAgIFEudW5zaGlmdCh2aSk7XG4gICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgVlt2aUlkXSA9IHRydWU7XG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh2aSk7XG4gICAgICAgIH1cbiAgICAgICAgaWQyZGVwdGhbdmlJZF0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIHYgPSBwYXJhbXMuYmZzID8gUS5zaGlmdCgpIDogUS5wb3AoKTtcbiAgICAgICAgdmFyIHZJZCA9IHYuaWQoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5kZnMpIHtcbiAgICAgICAgICBpZiAoVlt2SWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgVlt2SWRdID0gdHJ1ZTtcbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoW3ZJZF07XG4gICAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5W3ZJZF07XG4gICAgICAgIHZhciBzcmMgPSBwcmV2RWRnZSAhPSBudWxsID8gcHJldkVkZ2Uuc291cmNlKCkgOiBudWxsO1xuICAgICAgICB2YXIgdGd0ID0gcHJldkVkZ2UgIT0gbnVsbCA/IHByZXZFZGdlLnRhcmdldCgpIDogbnVsbDtcbiAgICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHYuc2FtZShzcmMpID8gdGd0WzBdIDogc3JjWzBdO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICByZXQgPSBmbih2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuICAgICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICAgIHJldHVybiAxOyAvLyBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7IC8vIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuICghZGlyZWN0ZWQgfHwgZS5zb3VyY2UoKS5zYW1lKHYpKSAmJiBlZGdlcy5oYXMoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB2d0VkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbX2kyXTtcbiAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAhbi5zYW1lKHYpICYmIG5vZGVzLmhhcyhuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgd0lkID0gdy5pZCgpO1xuICAgICAgICAgIGlmICh3Lmxlbmd0aCAhPT0gMCAmJiAhVlt3SWRdKSB7XG4gICAgICAgICAgICB3ID0gd1swXTtcbiAgICAgICAgICAgIFEucHVzaCh3KTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgICAgIFZbd0lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0ZWRCeVt3SWRdID0gZTtcbiAgICAgICAgICAgIGlkMmRlcHRoW3dJZF0gPSBpZDJkZXB0aFt2SWRdICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfcmV0O1xuICAgIHdoaWxlIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgICBpZiAoX3JldCA9PT0gMSkgYnJlYWs7XG4gICAgfVxuICAgIHZhciBjb25uZWN0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb25uZWN0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBub2RlID0gY29ubmVjdGVkTm9kZXNbX2ldO1xuICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRCeVtub2RlLmlkKCldO1xuICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgICBjb25uZWN0ZWRFbGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBjeS5jb2xsZWN0aW9uKGNvbm5lY3RlZEVsZXMpLFxuICAgICAgZm91bmQ6IGN5LmNvbGxlY3Rpb24oZm91bmQpXG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xudmFyIGVsZXNmbiR2ID0ge1xuICBicmVhZHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgYmZzOiB0cnVlXG4gIH0pLFxuICBkZXB0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goe1xuICAgIGRmczogdHJ1ZVxuICB9KVxufTtcblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5lbGVzZm4kdi5iZnMgPSBlbGVzZm4kdi5icmVhZHRoRmlyc3RTZWFyY2g7XG5lbGVzZm4kdi5kZnMgPSBlbGVzZm4kdi5kZXB0aEZpcnN0U2VhcmNoO1xuXG52YXIgaGVhcCQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGhlYXAkMSA9IGhlYXAkMi5leHBvcnRzO1xuXG52YXIgaGFzUmVxdWlyZWRIZWFwJDE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIZWFwJDEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIZWFwJDEpIHJldHVybiBoZWFwJDIuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRIZWFwJDEgPSAxO1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdC8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcblx0XHQoZnVuY3Rpb24oKSB7XG5cdFx0ICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cblx0XHQgIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuXHRcdCAgLypcblx0XHQgIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG5cdFx0ICAgKi9cblxuXHRcdCAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHQgICAgaWYgKHggPCB5KSB7XG5cdFx0ICAgICAgcmV0dXJuIC0xO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmICh4ID4geSkge1xuXHRcdCAgICAgIHJldHVybiAxO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiAwO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cblx0XHQgIFxuXHRcdCAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuXHRcdCAgXG5cdFx0ICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG5cdFx0ICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuXHRcdCAgICovXG5cblx0XHQgIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG5cdFx0ICAgIHZhciBtaWQ7XG5cdFx0ICAgIGlmIChsbyA9PSBudWxsKSB7XG5cdFx0ICAgICAgbG8gPSAwO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKGxvIDwgMCkge1xuXHRcdCAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAoaGkgPT0gbnVsbCkge1xuXHRcdCAgICAgIGhpID0gYS5sZW5ndGg7XG5cdFx0ICAgIH1cblx0XHQgICAgd2hpbGUgKGxvIDwgaGkpIHtcblx0XHQgICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcblx0XHQgICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG5cdFx0ICAgICAgICBoaSA9IG1pZDtcblx0XHQgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgbG8gPSBtaWQgKyAxO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuXHRcdCAgICovXG5cblx0XHQgIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIGFycmF5LnB1c2goaXRlbSk7XG5cdFx0ICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtIDEsIGNtcCk7XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG5cdFx0ICAgKi9cblxuXHRcdCAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcblx0XHQgICAgdmFyIGxhc3RlbHQsIHJldHVybml0ZW07XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuXHRcdCAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG5cdFx0ICAgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuXHRcdCAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcblx0XHQgICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiByZXR1cm5pdGVtO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuXHRcdCAgXG5cdFx0ICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcblx0XHQgIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuXHRcdCAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuXHRcdCAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcblx0XHQgICAgICBpZiBpdGVtID4gYXJyYXlbMF1cblx0XHQgICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcblx0XHQgICAqL1xuXG5cdFx0ICBoZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcblx0XHQgICAgdmFyIHJldHVybml0ZW07XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuXHRcdCAgICBhcnJheVswXSA9IGl0ZW07XG5cdFx0ICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG5cdFx0ICAgIHJldHVybiByZXR1cm5pdGVtO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuXHRcdCAgICovXG5cblx0XHQgIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuXHRcdCAgICB2YXIgX3JlZjtcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG5cdFx0ICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG5cdFx0ICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gaXRlbTtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG5cdFx0ICAgKi9cblxuXHRcdCAgaGVhcGlmeSA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcblx0XHQgICAgdmFyIGksIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcblx0XHQgICAgICBfcmVzdWx0czEgPSBbXTtcblx0XHQgICAgICBmb3IgKHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vcihhcnJheS5sZW5ndGggLyAyKTsgMCA8PSBfcmVmID8gX2ogPCBfcmVmIDogX2ogPiBfcmVmOyAwIDw9IF9yZWYgPyBfaisrIDogX2otLSl7IF9yZXN1bHRzMS5wdXNoKF9qKTsgfVxuXHRcdCAgICAgIHJldHVybiBfcmVzdWx0czE7XG5cdFx0ICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcblx0XHQgICAgX3Jlc3VsdHMgPSBbXTtcblx0XHQgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuXHRcdCAgICAgIGkgPSBfcmVmMVtfaV07XG5cdFx0ICAgICAgX3Jlc3VsdHMucHVzaChfc2lmdHVwKGFycmF5LCBpLCBjbXApKTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gX3Jlc3VsdHM7XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuXHRcdCAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG5cdFx0ICAgKi9cblxuXHRcdCAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcblx0XHQgICAgdmFyIHBvcztcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuXHRcdCAgICBpZiAocG9zID09PSAtMSkge1xuXHRcdCAgICAgIHJldHVybjtcblx0XHQgICAgfVxuXHRcdCAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcblx0XHQgICAgcmV0dXJuIF9zaWZ0dXAoYXJyYXksIHBvcywgY21wKTtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIEZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG5cdFx0ICAgKi9cblxuXHRcdCAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG5cdFx0ICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuXHRcdCAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcblx0XHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHRcdCAgICB9XG5cdFx0ICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xuXHRcdCAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG5cdFx0ICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuXHRcdCAgICAgIGVsZW0gPSBfcmVmW19pXTtcblx0XHQgICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG5cdFx0ICAgKi9cblxuXHRcdCAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuXHRcdCAgICB2YXIgZWxlbSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChuICogMTAgPD0gYXJyYXkubGVuZ3RoKSB7XG5cdFx0ICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuXHRcdCAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcblx0XHQgICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG5cdFx0ICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG5cdFx0ICAgICAgICBlbGVtID0gX3JlZltfaV07XG5cdFx0ICAgICAgICBpZiAoY21wKGVsZW0sIGxvcykgPCAwKSB7XG5cdFx0ICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG5cdFx0ICAgICAgICAgIHJlc3VsdC5wb3AoKTtcblx0XHQgICAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9XG5cdFx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0XHQgICAgfVxuXHRcdCAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuXHRcdCAgICBfcmVzdWx0cyA9IFtdO1xuXHRcdCAgICBmb3IgKF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcblx0XHQgICAgICBfcmVzdWx0cy5wdXNoKGhlYXBwb3AoYXJyYXksIGNtcCkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiBfcmVzdWx0cztcblx0XHQgIH07XG5cblx0XHQgIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcblx0XHQgICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuXHRcdCAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcblx0XHQgICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcblx0XHQgICAgICBwYXJlbnQgPSBhcnJheVtwYXJlbnRwb3NdO1xuXHRcdCAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcblx0XHQgICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG5cdFx0ICAgICAgICBwb3MgPSBwYXJlbnRwb3M7XG5cdFx0ICAgICAgICBjb250aW51ZTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgYnJlYWs7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuXHRcdCAgfTtcblxuXHRcdCAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuXHRcdCAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcblx0XHQgICAgc3RhcnRwb3MgPSBwb3M7XG5cdFx0ICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuXHRcdCAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuXHRcdCAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcblx0XHQgICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcblx0XHQgICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcblx0XHQgICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XG5cdFx0ICAgICAgcG9zID0gY2hpbGRwb3M7XG5cdFx0ICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcblx0XHQgICAgfVxuXHRcdCAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcblx0XHQgICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcblx0XHQgIH07XG5cblx0XHQgIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG5cdFx0ICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG5cdFx0ICAgIEhlYXAucG9wID0gaGVhcHBvcDtcblxuXHRcdCAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuXHRcdCAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuXHRcdCAgICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG5cdFx0ICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cblx0XHQgICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG5cdFx0ICAgIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG5cdFx0ICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG5cdFx0ICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG5cdFx0ICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuXHRcdCAgICB9XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcblx0XHQgICAgICByZXR1cm4gaGVhcHB1c2godGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHJldHVybiBoZWFwcG9wKHRoaXMubm9kZXMsIHRoaXMuY21wKTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG5cdFx0ICAgICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZih4KSAhPT0gLTE7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcblx0XHQgICAgICByZXR1cm4gaGVhcHJlcGxhY2UodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG5cdFx0ICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgcmV0dXJuIGhlYXBpZnkodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG5cdFx0ICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0odGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgdmFyIGhlYXA7XG5cdFx0ICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG5cdFx0ICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG5cdFx0ICAgICAgcmV0dXJuIGhlYXA7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKDApO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xuXG5cdFx0ICAgIHJldHVybiBIZWFwO1xuXG5cdFx0ICB9KSgpO1xuXG5cdFx0ICAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRcdCAgICB7XG5cdFx0ICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRcdCAgICB9XG5cdFx0ICB9KSh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHQgICAgcmV0dXJuIEhlYXA7XG5cdFx0ICB9KTtcblxuXHRcdH0pLmNhbGwoaGVhcCQxKTsgXG5cdH0gKGhlYXAkMikpO1xuXHRyZXR1cm4gaGVhcCQyLmV4cG9ydHM7XG59XG5cbnZhciBoZWFwO1xudmFyIGhhc1JlcXVpcmVkSGVhcDtcblxuZnVuY3Rpb24gcmVxdWlyZUhlYXAgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIZWFwKSByZXR1cm4gaGVhcDtcblx0aGFzUmVxdWlyZWRIZWFwID0gMTtcblx0aGVhcCA9IHJlcXVpcmVIZWFwJDEoKTtcblx0cmV0dXJuIGhlYXA7XG59XG5cbnZhciBoZWFwRXhwb3J0cyA9IHJlcXVpcmVIZWFwKCk7XG52YXIgSGVhcCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhoZWFwRXhwb3J0cyk7XG5cbnZhciBkaWprc3RyYURlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIHJvb3Q6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kdSA9IHtcbiAgZGlqa3N0cmE6IGZ1bmN0aW9uIGRpamtzdHJhKG9wdGlvbnMpIHtcbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgIHdlaWdodDogYXJnc1sxXSxcbiAgICAgICAgZGlyZWN0ZWQ6IGFyZ3NbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBfZGlqa3N0cmFEZWZhdWx0cyA9IGRpamtzdHJhRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICByb290ID0gX2RpamtzdHJhRGVmYXVsdHMucm9vdCxcbiAgICAgIHdlaWdodCA9IF9kaWprc3RyYURlZmF1bHRzLndlaWdodCxcbiAgICAgIGRpcmVjdGVkID0gX2RpamtzdHJhRGVmYXVsdHMuZGlyZWN0ZWQ7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICB2YXIgc291cmNlID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0gOiByb290WzBdO1xuICAgIHZhciBkaXN0ID0ge307XG4gICAgdmFyIHByZXYgPSB7fTtcbiAgICB2YXIga25vd25EaXN0ID0ge307XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgICB9KTtcbiAgICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3Qobm9kZSkge1xuICAgICAgcmV0dXJuIGRpc3Rbbm9kZS5pZCgpXTtcbiAgICB9O1xuICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24gc2V0RGlzdChub2RlLCBkKSB7XG4gICAgICBkaXN0W25vZGUuaWQoKV0gPSBkO1xuICAgICAgUS51cGRhdGVJdGVtKG5vZGUpO1xuICAgIH07XG4gICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QoYSkgLSBnZXREaXN0KGIpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBkaXN0W25vZGUuaWQoKV0gPSBub2RlLnNhbWUoc291cmNlKSA/IDAgOiBJbmZpbml0eTtcbiAgICAgIFEucHVzaChub2RlKTtcbiAgICB9XG4gICAgdmFyIGRpc3RCZXR3ZWVuID0gZnVuY3Rpb24gZGlzdEJldHdlZW4odSwgdikge1xuICAgICAgdmFyIHV2cyA9IChkaXJlY3RlZCA/IHUuZWRnZXNUbyh2KSA6IHUuZWRnZXNXaXRoKHYpKS5pbnRlcnNlY3QoZWRnZXMpO1xuICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXZzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IHV2c1tfaV07XG4gICAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgICAgIGlmIChfd2VpZ2h0IDwgc21hbGxlc3REaXN0YW5jZSB8fCAhc21hbGxlc3RFZGdlKSB7XG4gICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IF93ZWlnaHQ7XG4gICAgICAgICAgc21hbGxlc3RFZGdlID0gZWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG4gICAgd2hpbGUgKFEuc2l6ZSgpID4gMCkge1xuICAgICAgdmFyIHUgPSBRLnBvcCgpO1xuICAgICAgdmFyIHNtYWxsZXRzRGlzdCA9IGdldERpc3QodSk7XG4gICAgICB2YXIgdWlkID0gdS5pZCgpO1xuICAgICAga25vd25EaXN0W3VpZF0gPSBzbWFsbGV0c0Rpc3Q7XG4gICAgICBpZiAoc21hbGxldHNEaXN0ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBuZWlnaGJvcnMgPSB1Lm5laWdoYm9yaG9vZCgpLmludGVyc2VjdChub2Rlcyk7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuZWlnaGJvcnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgdiA9IG5laWdoYm9yc1tfaTJdO1xuICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgICB2YXIgdkRpc3QgPSBkaXN0QmV0d2Vlbih1LCB2KTtcbiAgICAgICAgdmFyIGFsdCA9IHNtYWxsZXRzRGlzdCArIHZEaXN0LmRpc3Q7XG4gICAgICAgIGlmIChhbHQgPCBnZXREaXN0KHYpKSB7XG4gICAgICAgICAgc2V0RGlzdCh2LCBhbHQpO1xuICAgICAgICAgIHByZXZbdmlkXSA9IHtcbiAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICB9IC8vIHdoaWxlXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24gZGlzdGFuY2VUbyhub2RlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBzdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuICAgICAgICByZXR1cm4ga25vd25EaXN0W3RhcmdldC5pZCgpXTtcbiAgICAgIH0sXG4gICAgICBwYXRoVG86IGZ1bmN0aW9uIHBhdGhUbyhub2RlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBzdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuICAgICAgICB2YXIgUyA9IFtdO1xuICAgICAgICB2YXIgdSA9IHRhcmdldDtcbiAgICAgICAgdmFyIHVpZCA9IHUuaWQoKTtcbiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUy51bnNoaWZ0KHRhcmdldCk7XG4gICAgICAgICAgd2hpbGUgKHByZXZbdWlkXSkge1xuICAgICAgICAgICAgdmFyIHAgPSBwcmV2W3VpZF07XG4gICAgICAgICAgICBTLnVuc2hpZnQocC5lZGdlKTtcbiAgICAgICAgICAgIFMudW5zaGlmdChwLm5vZGUpO1xuICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgIHVpZCA9IHUuaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZXMuc3Bhd24oUyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxudmFyIGVsZXNmbiR0ID0ge1xuICAvLyBrcnVza2FsJ3MgYWxnb3JpdGhtIChmaW5kcyBtaW4gc3Bhbm5pbmcgdHJlZSwgYXNzdW1pbmcgdW5kaXJlY3RlZCBncmFwaClcbiAgLy8gaW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGtydXNrYWw6IGZ1bmN0aW9uIGtydXNrYWwod2VpZ2h0Rm4pIHtcbiAgICB3ZWlnaHRGbiA9IHdlaWdodEZuIHx8IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBmb3Jlc3QgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBBID0gbm9kZXM7IC8vIGFzc3VtZXMgYnlHcm91cCgpIGNyZWF0ZXMgbmV3IGNvbGxlY3Rpb25zIHRoYXQgY2FuIGJlIHNhZmVseSBtdXRhdGVkXG5cbiAgICB2YXIgZmluZFNldEluZGV4ID0gZnVuY3Rpb24gZmluZFNldEluZGV4KGVsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZXMgPSBmb3Jlc3RbaV07XG4gICAgICAgIGlmIChlbGVzLmhhcyhlbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RhcnQgd2l0aCBvbmUgZm9yZXN0IHBlciBub2RlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBmb3Jlc3RbaV0gPSB0aGlzLnNwYXduKG5vZGVzW2ldKTtcbiAgICB9XG4gICAgdmFyIFMgPSBlZGdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gd2VpZ2h0Rm4oYSkgLSB3ZWlnaHRGbihiKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgUy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gU1tfaV07XG4gICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICB2YXIgc2V0VUluZGV4ID0gZmluZFNldEluZGV4KHUpO1xuICAgICAgdmFyIHNldFZJbmRleCA9IGZpbmRTZXRJbmRleCh2KTtcbiAgICAgIHZhciBzZXRVID0gZm9yZXN0W3NldFVJbmRleF07XG4gICAgICB2YXIgc2V0ViA9IGZvcmVzdFtzZXRWSW5kZXhdO1xuICAgICAgaWYgKHNldFVJbmRleCAhPT0gc2V0VkluZGV4KSB7XG4gICAgICAgIEEubWVyZ2UoZWRnZSk7XG5cbiAgICAgICAgLy8gY29tYmluZSBmb3Jlc3RzIGZvciB1IGFuZCB2XG4gICAgICAgIHNldFUubWVyZ2Uoc2V0Vik7XG4gICAgICAgIGZvcmVzdC5zcGxpY2Uoc2V0VkluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEE7XG4gIH1cbn07XG5cbnZhciBhU3RhckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIHJvb3Q6IG51bGwsXG4gIGdvYWw6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgaGV1cmlzdGljOiBmdW5jdGlvbiBoZXVyaXN0aWMoZWRnZSkge1xuICAgIHJldHVybiAwO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRzID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgYVN0YXI6IGZ1bmN0aW9uIGFTdGFyKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIF9hU3RhckRlZmF1bHRzID0gYVN0YXJEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIHJvb3QgPSBfYVN0YXJEZWZhdWx0cy5yb290LFxuICAgICAgZ29hbCA9IF9hU3RhckRlZmF1bHRzLmdvYWwsXG4gICAgICBoZXVyaXN0aWMgPSBfYVN0YXJEZWZhdWx0cy5oZXVyaXN0aWMsXG4gICAgICBkaXJlY3RlZCA9IF9hU3RhckRlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgd2VpZ2h0ID0gX2FTdGFyRGVmYXVsdHMud2VpZ2h0O1xuICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdO1xuICAgIGdvYWwgPSBjeS5jb2xsZWN0aW9uKGdvYWwpWzBdO1xuICAgIHZhciBzaWQgPSByb290LmlkKCk7XG4gICAgdmFyIHRpZCA9IGdvYWwuaWQoKTtcbiAgICB2YXIgZ1Njb3JlID0ge307XG4gICAgdmFyIGZTY29yZSA9IHt9O1xuICAgIHZhciBjbG9zZWRTZXRJZHMgPSB7fTtcbiAgICB2YXIgb3BlblNldCA9IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZlNjb3JlW2EuaWQoKV0gLSBmU2NvcmVbYi5pZCgpXTtcbiAgICB9KTtcbiAgICB2YXIgb3BlblNldElkcyA9IG5ldyBTZXQkMSgpO1xuICAgIHZhciBjYW1lRnJvbSA9IHt9O1xuICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcbiAgICB2YXIgYWRkVG9PcGVuU2V0ID0gZnVuY3Rpb24gYWRkVG9PcGVuU2V0KGVsZSwgaWQpIHtcbiAgICAgIG9wZW5TZXQucHVzaChlbGUpO1xuICAgICAgb3BlblNldElkcy5hZGQoaWQpO1xuICAgIH07XG4gICAgdmFyIGNNaW4sIGNNaW5JZDtcbiAgICB2YXIgcG9wRnJvbU9wZW5TZXQgPSBmdW5jdGlvbiBwb3BGcm9tT3BlblNldCgpIHtcbiAgICAgIGNNaW4gPSBvcGVuU2V0LnBvcCgpO1xuICAgICAgY01pbklkID0gY01pbi5pZCgpO1xuICAgICAgb3BlblNldElkc1tcImRlbGV0ZVwiXShjTWluSWQpO1xuICAgIH07XG4gICAgdmFyIGlzSW5PcGVuU2V0ID0gZnVuY3Rpb24gaXNJbk9wZW5TZXQoaWQpIHtcbiAgICAgIHJldHVybiBvcGVuU2V0SWRzLmhhcyhpZCk7XG4gICAgfTtcbiAgICBhZGRUb09wZW5TZXQocm9vdCwgc2lkKTtcbiAgICBnU2NvcmVbc2lkXSA9IDA7XG4gICAgZlNjb3JlW3NpZF0gPSBoZXVyaXN0aWMocm9vdCk7XG5cbiAgICAvLyBDb3VudGVyXG4gICAgdmFyIHN0ZXBzID0gMDtcblxuICAgIC8vIE1haW4gbG9vcFxuICAgIHdoaWxlIChvcGVuU2V0LnNpemUoKSA+IDApIHtcbiAgICAgIHBvcEZyb21PcGVuU2V0KCk7XG4gICAgICBzdGVwcysrO1xuXG4gICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBvdXIgZ29hbCwgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgaWYgKGNNaW5JZCA9PT0gdGlkKSB7XG4gICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgIHZhciBwYXRoTm9kZSA9IGdvYWw7XG4gICAgICAgIHZhciBwYXRoTm9kZUlkID0gdGlkO1xuICAgICAgICB2YXIgcGF0aEVkZ2UgPSBjYW1lRnJvbUVkZ2VbcGF0aE5vZGVJZF07XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQocGF0aE5vZGUpO1xuICAgICAgICAgIGlmIChwYXRoRWRnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoLnVuc2hpZnQocGF0aEVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoTm9kZSA9IGNhbWVGcm9tW3BhdGhOb2RlSWRdO1xuICAgICAgICAgIGlmIChwYXRoTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aE5vZGVJZCA9IHBhdGhOb2RlLmlkKCk7XG4gICAgICAgICAgcGF0aEVkZ2UgPSBjYW1lRnJvbUVkZ2VbcGF0aE5vZGVJZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgICAgICBkaXN0YW5jZTogZ1Njb3JlW2NNaW5JZF0sXG4gICAgICAgICAgcGF0aDogdGhpcy5zcGF3bihwYXRoKSxcbiAgICAgICAgICBzdGVwczogc3RlcHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNNaW4gdG8gcHJvY2Vzc2VkIG5vZGVzXG4gICAgICBjbG9zZWRTZXRJZHNbY01pbklkXSA9IHRydWU7XG5cbiAgICAgIC8vIFVwZGF0ZSBzY29yZXMgZm9yIG5laWdoYm9ycyBvZiBjTWluXG4gICAgICAvLyBUYWtlIGludG8gYWNjb3VudCBpZiBncmFwaCBpcyBkaXJlY3RlZCBvciBub3RcbiAgICAgIHZhciB2d0VkZ2VzID0gY01pbi5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07XG5cbiAgICAgICAgLy8gZWRnZSBtdXN0IGJlIGluIHNldCBvZiBjYWxsaW5nIGVsZXNcbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZS5pZCgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY01pbiBtdXN0IGJlIHRoZSBzb3VyY2Ugb2YgZWRnZSBpZiBkaXJlY3RlZFxuICAgICAgICBpZiAoZGlyZWN0ZWQgJiYgZS5kYXRhKCdzb3VyY2UnKSAhPT0gY01pbklkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdTcmMgPSBlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgd1RndCA9IGUudGFyZ2V0KCk7XG4gICAgICAgIHZhciB3ID0gd1NyYy5pZCgpICE9PSBjTWluSWQgPyB3U3JjIDogd1RndDtcbiAgICAgICAgdmFyIHdpZCA9IHcuaWQoKTtcblxuICAgICAgICAvLyBub2RlIG11c3QgYmUgaW4gc2V0IG9mIGNhbGxpbmcgZWxlc1xuICAgICAgICBpZiAoIXRoaXMuaGFzRWxlbWVudFdpdGhJZCh3aWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub2RlIGlzIGluIGNsb3NlZFNldCwgaWdub3JlIGl0XG4gICAgICAgIGlmIChjbG9zZWRTZXRJZHNbd2lkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmV3IHRlbnRhdGl2ZSBzY29yZSBmb3Igbm9kZSB3XG4gICAgICAgIHZhciB0ZW1wU2NvcmUgPSBnU2NvcmVbY01pbklkXSArIHdlaWdodChlKTtcblxuICAgICAgICAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcblxuICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG4gICAgICAgIGlmICghaXNJbk9wZW5TZXQod2lkKSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGFkZFRvT3BlblNldCh3LCB3aWQpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHcgYWxyZWFkeSBpbiBvcGVuU2V0LCBidXQgd2l0aCBncmVhdGVyIGdTY29yZVxuICAgICAgICBpZiAodGVtcFNjb3JlIDwgZ1Njb3JlW3dpZF0pIHtcbiAgICAgICAgICBnU2NvcmVbd2lkXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICBmU2NvcmVbd2lkXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICBjYW1lRnJvbVt3aWRdID0gY01pbjtcbiAgICAgICAgICBjYW1lRnJvbUVkZ2Vbd2lkXSA9IGU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRW5kIG9mIG5laWdoYm9ycyB1cGRhdGVcbiAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcblxuICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICBkaXN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgfTtcbiAgfVxufTsgLy8gZWxlc2ZuXG5cbnZhciBmbG95ZFdhcnNoYWxsRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRyID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24gZmxveWRXYXJzaGFsbChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBfZmxveWRXYXJzaGFsbERlZmF1bHQgPSBmbG95ZFdhcnNoYWxsRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICB3ZWlnaHQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQud2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQuZGlyZWN0ZWQ7XG4gICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG4gICAgdmFyIE4gPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIE5zcSA9IE4gKiBOO1xuICAgIHZhciBpbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICB9O1xuICAgIHZhciBhdEluZGV4ID0gZnVuY3Rpb24gYXRJbmRleChpKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgdmFyIGRpc3QgPSBuZXcgQXJyYXkoTnNxKTtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IE5zcTsgbisrKSB7XG4gICAgICB2YXIgaiA9IG4gJSBOO1xuICAgICAgdmFyIGkgPSAobiAtIGopIC8gTjtcbiAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgIGRpc3Rbbl0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzdFtuXSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgbWF0cml4IHVzZWQgZm9yIHBhdGggcmVjb25zdHJ1Y3Rpb25cbiAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgIHZhciBuZXh0ID0gbmV3IEFycmF5KE5zcSk7XG4gICAgdmFyIGVkZ2VOZXh0ID0gbmV3IEFycmF5KE5zcSk7XG5cbiAgICAvLyBQcm9jZXNzIGVkZ2VzXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaV07XG4gICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBleGNsdWRlIGxvb3BzXG5cbiAgICAgIHZhciBzID0gaW5kZXhPZihzcmMpO1xuICAgICAgdmFyIHQgPSBpbmRleE9mKHRndCk7XG4gICAgICB2YXIgc3QgPSBzICogTiArIHQ7IC8vIHNvdXJjZSB0byB0YXJnZXQgaW5kZXhcbiAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgIGlmIChkaXN0W3N0XSA+IF93ZWlnaHQpIHtcbiAgICAgICAgZGlzdFtzdF0gPSBfd2VpZ2h0O1xuICAgICAgICBuZXh0W3N0XSA9IHQ7XG4gICAgICAgIGVkZ2VOZXh0W3N0XSA9IGVkZ2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHByb2Nlc3MgJ3JldmVyc2VkJyBlZGdlXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIHZhciB0cyA9IHQgKiBOICsgczsgLy8gdGFyZ2V0IHRvIHNvdXJjZSBpbmRleFxuXG4gICAgICAgIGlmICghZGlyZWN0ZWQgJiYgZGlzdFt0c10gPiBfd2VpZ2h0KSB7XG4gICAgICAgICAgZGlzdFt0c10gPSBfd2VpZ2h0O1xuICAgICAgICAgIG5leHRbdHNdID0gcztcbiAgICAgICAgICBlZGdlTmV4dFt0c10gPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBOOyBrKyspIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47IF9pMisrKSB7XG4gICAgICAgIHZhciBpayA9IF9pMiAqIE4gKyBrO1xuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgTjsgX2orKykge1xuICAgICAgICAgIHZhciBpaiA9IF9pMiAqIE4gKyBfajtcbiAgICAgICAgICB2YXIga2ogPSBrICogTiArIF9qO1xuICAgICAgICAgIGlmIChkaXN0W2lrXSArIGRpc3Rba2pdIDwgZGlzdFtpal0pIHtcbiAgICAgICAgICAgIGRpc3RbaWpdID0gZGlzdFtpa10gKyBkaXN0W2tqXTtcbiAgICAgICAgICAgIG5leHRbaWpdID0gbmV4dFtpa107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBnZXRBcmdFbGUgPSBmdW5jdGlvbiBnZXRBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyhlbGUpID8gY3kuZmlsdGVyKGVsZSkgOiBlbGUpWzBdO1xuICAgIH07XG4gICAgdmFyIGluZGV4T2ZBcmdFbGUgPSBmdW5jdGlvbiBpbmRleE9mQXJnRWxlKGVsZSkge1xuICAgICAgcmV0dXJuIGluZGV4T2YoZ2V0QXJnRWxlKGVsZSkpO1xuICAgIH07XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiBkaXN0YW5jZShmcm9tLCB0bykge1xuICAgICAgICB2YXIgaSA9IGluZGV4T2ZBcmdFbGUoZnJvbSk7XG4gICAgICAgIHZhciBqID0gaW5kZXhPZkFyZ0VsZSh0byk7XG4gICAgICAgIHJldHVybiBkaXN0W2kgKiBOICsgal07XG4gICAgICB9LFxuICAgICAgcGF0aDogZnVuY3Rpb24gcGF0aChmcm9tLCB0bykge1xuICAgICAgICB2YXIgaSA9IGluZGV4T2ZBcmdFbGUoZnJvbSk7XG4gICAgICAgIHZhciBqID0gaW5kZXhPZkFyZ0VsZSh0byk7XG4gICAgICAgIHZhciBmcm9tTm9kZSA9IGF0SW5kZXgoaSk7XG4gICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21Ob2RlLmNvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dFtpICogTiArIGpdID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICB2YXIgcHJldiA9IGk7XG4gICAgICAgIHZhciBlZGdlO1xuICAgICAgICBwYXRoLm1lcmdlKGZyb21Ob2RlKTtcbiAgICAgICAgd2hpbGUgKGkgIT09IGopIHtcbiAgICAgICAgICBwcmV2ID0gaTtcbiAgICAgICAgICBpID0gbmV4dFtpICogTiArIGpdO1xuICAgICAgICAgIGVkZ2UgPSBlZGdlTmV4dFtwcmV2ICogTiArIGldO1xuICAgICAgICAgIHBhdGgubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgcGF0aC5tZXJnZShhdEluZGV4KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH0gLy8gZmxveWRXYXJzaGFsbFxufTsgLy8gZWxlc2ZuXG5cbnZhciBiZWxsbWFuRm9yZERlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICByb290OiBudWxsXG59KTtcbnZhciBlbGVzZm4kcSA9IHtcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGJlbGxtYW5Gb3JkOiBmdW5jdGlvbiBiZWxsbWFuRm9yZChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2JlbGxtYW5Gb3JkRGVmYXVsdHMgPSBiZWxsbWFuRm9yZERlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgd2VpZ2h0ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgIHJvb3QgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy5yb290O1xuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXMsXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXM7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBpbmZvTWFwID0gbmV3IE1hcCQxKCk7XG4gICAgdmFyIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUgPSBmYWxzZTtcbiAgICB2YXIgbmVnYXRpdmVXZWlnaHRDeWNsZXMgPSBbXTtcbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTsgLy8gaW4gY2FzZSBzZWxlY3RvciBwYXNzZWRcblxuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgIHZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhub2RlKSB7XG4gICAgICB2YXIgb2JqID0gaW5mb01hcC5nZXQobm9kZS5pZCgpKTtcbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpbmZvTWFwLnNldChub2RlLmlkKCksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdmFyIGdldE5vZGVGcm9tVG8gPSBmdW5jdGlvbiBnZXROb2RlRnJvbVRvKHRvKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyh0bykgPyBjeS4kKHRvKSA6IHRvKVswXTtcbiAgICB9O1xuICAgIHZhciBkaXN0YW5jZVRvID0gZnVuY3Rpb24gZGlzdGFuY2VUbyh0bykge1xuICAgICAgcmV0dXJuIGdldEluZm8oZ2V0Tm9kZUZyb21Ubyh0bykpLmRpc3Q7XG4gICAgfTtcbiAgICB2YXIgcGF0aFRvID0gZnVuY3Rpb24gcGF0aFRvKHRvKSB7XG4gICAgICB2YXIgdGhpc1N0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiByb290O1xuICAgICAgdmFyIGVuZCA9IGdldE5vZGVGcm9tVG8odG8pO1xuICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgIHZhciBub2RlID0gZW5kO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNwYXduKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9nZXRJbmZvID0gZ2V0SW5mbyhub2RlKSxcbiAgICAgICAgICBlZGdlID0gX2dldEluZm8uZWRnZSxcbiAgICAgICAgICBwcmVkID0gX2dldEluZm8ucHJlZDtcbiAgICAgICAgcGF0aC51bnNoaWZ0KG5vZGVbMF0pO1xuICAgICAgICBpZiAobm9kZS5zYW1lKHRoaXNTdGFydCkgJiYgcGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gcHJlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVzLnNwYXduKHBhdGgpO1xuICAgIH07XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbnMgeyBkaXN0LCBwcmVkLCBlZGdlIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgaW5mbyA9IGdldEluZm8obm9kZSk7XG4gICAgICBpZiAobm9kZS5zYW1lKHJvb3QpKSB7XG4gICAgICAgIGluZm8uZGlzdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvLmRpc3QgPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIGluZm8ucHJlZCA9IG51bGw7XG4gICAgICBpbmZvLmVkZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEVkZ2VzIHJlbGF4YXRpb25cbiAgICB2YXIgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG4gICAgdmFyIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQobm9kZTEsIG5vZGUyLCBlZGdlLCBpbmZvMSwgaW5mbzIsIHdlaWdodCkge1xuICAgICAgdmFyIGRpc3QgPSBpbmZvMS5kaXN0ICsgd2VpZ2h0O1xuICAgICAgaWYgKGRpc3QgPCBpbmZvMi5kaXN0ICYmICFlZGdlLnNhbWUoaW5mbzEuZWRnZSkpIHtcbiAgICAgICAgaW5mbzIuZGlzdCA9IGRpc3Q7XG4gICAgICAgIGluZm8yLnByZWQgPSBub2RlMTtcbiAgICAgICAgaW5mbzIuZWRnZSA9IGVkZ2U7XG4gICAgICAgIHJlcGxhY2VkRWRnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgbnVtTm9kZXM7IF9pKyspIHtcbiAgICAgIHJlcGxhY2VkRWRnZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBudW1FZGdlczsgZSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZV07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgICAgdmFyIHNyY0luZm8gPSBnZXRJbmZvKHNyYyk7XG4gICAgICAgIHZhciB0Z3RJbmZvID0gZ2V0SW5mbyh0Z3QpO1xuICAgICAgICBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChzcmMsIHRndCwgZWRnZSwgc3JjSW5mbywgdGd0SW5mbywgX3dlaWdodCk7XG5cbiAgICAgICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgd2UgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgJ3JldmVyc2UnIGVkZ2VcbiAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHRndCwgc3JjLCBlZGdlLCB0Z3RJbmZvLCBzcmNJbmZvLCBfd2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyZXBsYWNlZEVkZ2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXBsYWNlZEVkZ2UpIHtcbiAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGVzXG4gICAgICB2YXIgbmVnYXRpdmVXZWlnaHRDeWNsZUlkcyA9IFtdO1xuICAgICAgZm9yICh2YXIgX2UgPSAwOyBfZSA8IG51bUVkZ2VzOyBfZSsrKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IGVkZ2VzW19lXTtcbiAgICAgICAgdmFyIF9zcmMgPSBfZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIF90Z3QgPSBfZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIF93ZWlnaHQyID0gd2VpZ2h0Rm4oX2VkZ2UpO1xuICAgICAgICB2YXIgc3JjRGlzdCA9IGdldEluZm8oX3NyYykuZGlzdDtcbiAgICAgICAgdmFyIHRndERpc3QgPSBnZXRJbmZvKF90Z3QpLmRpc3Q7XG4gICAgICAgIGlmIChzcmNEaXN0ICsgX3dlaWdodDIgPCB0Z3REaXN0IHx8ICFkaXJlY3RlZCAmJiB0Z3REaXN0ICsgX3dlaWdodDIgPCBzcmNEaXN0KSB7XG4gICAgICAgICAgaWYgKCFoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlKSB7XG4gICAgICAgICAgICB3YXJuKCdHcmFwaCBjb250YWlucyBhIG5lZ2F0aXZlIHdlaWdodCBjeWNsZSBmb3IgQmVsbG1hbi1Gb3JkJyk7XG4gICAgICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZmluZE5lZ2F0aXZlV2VpZ2h0Q3ljbGVzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIG5lZ2F0aXZlTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzcmNEaXN0ICsgX3dlaWdodDIgPCB0Z3REaXN0KSB7XG4gICAgICAgICAgICAgIG5lZ2F0aXZlTm9kZXMucHVzaChfc3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlyZWN0ZWQgJiYgdGd0RGlzdCArIF93ZWlnaHQyIDwgc3JjRGlzdCkge1xuICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGVzLnB1c2goX3RndCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtTmVnYXRpdmVOb2RlcyA9IG5lZ2F0aXZlTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBudW1OZWdhdGl2ZU5vZGVzOyBuKyspIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmVnYXRpdmVOb2Rlc1tuXTtcbiAgICAgICAgICAgICAgdmFyIGN5Y2xlID0gW3N0YXJ0XTtcbiAgICAgICAgICAgICAgY3ljbGUucHVzaChnZXRJbmZvKHN0YXJ0KS5lZGdlKTtcbiAgICAgICAgICAgICAgdmFyIF9ub2RlID0gZ2V0SW5mbyhzdGFydCkucHJlZDtcbiAgICAgICAgICAgICAgd2hpbGUgKGN5Y2xlLmluZGV4T2YoX25vZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goX25vZGUpO1xuICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goZ2V0SW5mbyhfbm9kZSkuZWRnZSk7XG4gICAgICAgICAgICAgICAgX25vZGUgPSBnZXRJbmZvKF9ub2RlKS5wcmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN5Y2xlID0gY3ljbGUuc2xpY2UoY3ljbGUuaW5kZXhPZihfbm9kZSkpO1xuICAgICAgICAgICAgICB2YXIgc21hbGxlc3RJZCA9IGN5Y2xlWzBdLmlkKCk7XG4gICAgICAgICAgICAgIHZhciBzbWFsbGVzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDI7IGMgPCBjeWNsZS5sZW5ndGg7IGMgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChjeWNsZVtjXS5pZCgpIDwgc21hbGxlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgc21hbGxlc3RJZCA9IGN5Y2xlW2NdLmlkKCk7XG4gICAgICAgICAgICAgICAgICBzbWFsbGVzdEluZGV4ID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3ljbGUgPSBjeWNsZS5zbGljZShzbWFsbGVzdEluZGV4KS5jb25jYXQoY3ljbGUuc2xpY2UoMCwgc21hbGxlc3RJbmRleCkpO1xuICAgICAgICAgICAgICBjeWNsZS5wdXNoKGN5Y2xlWzBdKTtcbiAgICAgICAgICAgICAgdmFyIGN5Y2xlSWQgPSBjeWNsZS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmlkKCk7XG4gICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICBpZiAobmVnYXRpdmVXZWlnaHRDeWNsZUlkcy5pbmRleE9mKGN5Y2xlSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzLnB1c2goZWxlcy5zcGF3bihjeWNsZSkpO1xuICAgICAgICAgICAgICAgIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVJZHMucHVzaChjeWNsZUlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3RhbmNlVG86IGRpc3RhbmNlVG8sXG4gICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUsXG4gICAgICBuZWdhdGl2ZVdlaWdodEN5Y2xlczogbmVnYXRpdmVXZWlnaHRDeWNsZXNcbiAgICB9O1xuICB9IC8vIGJlbGxtYW5Gb3JkXG59OyAvLyBlbGVzZm5cblxudmFyIHNxcnQyID0gTWF0aC5zcXJ0KDIpO1xuXG4vLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbi8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcbnZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uIGNvbGxhcHNlKGVkZ2VJbmRleCwgbm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpIHtcbiAgaWYgKHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIGVycm9yKFwiS2FyZ2VyLVN0ZWluIG11c3QgYmUgcnVuIG9uIGEgY29ubmVjdGVkIChzdWIpZ3JhcGhcIik7XG4gIH1cbiAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbZWRnZUluZGV4XTtcbiAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gIHZhciB0YXJnZXRJbiA9IGVkZ2VJbmZvWzJdO1xuICB2YXIgcGFydGl0aW9uMSA9IG5vZGVNYXBbc291cmNlSW5dO1xuICB2YXIgcGFydGl0aW9uMiA9IG5vZGVNYXBbdGFyZ2V0SW5dO1xuICB2YXIgbmV3RWRnZXMgPSByZW1haW5pbmdFZGdlczsgLy8gcmUtdXNlIGFycmF5XG5cbiAgLy8gRGVsZXRlIGFsbCBlZGdlcyBiZXR3ZWVuIHBhcnRpdGlvbjEgYW5kIHBhcnRpdGlvbjJcbiAgZm9yICh2YXIgaSA9IG5ld0VkZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXdFZGdlc1tpXTtcbiAgICB2YXIgc3JjID0gZWRnZVsxXTtcbiAgICB2YXIgdGd0ID0gZWRnZVsyXTtcbiAgICBpZiAobm9kZU1hcFtzcmNdID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbdGd0XSA9PT0gcGFydGl0aW9uMiB8fCBub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICBuZXdFZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWxsIGVkZ2VzIHBvaW50aW5nIHRvIHBhcnRpdGlvbjIgc2hvdWxkIG5vdyBwb2ludCB0byBwYXJ0aXRpb24xXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZXdFZGdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX2VkZ2UgPSBuZXdFZGdlc1tfaV07XG4gICAgaWYgKF9lZGdlWzFdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAvLyBDaGVjayBzb3VyY2VcbiAgICAgIG5ld0VkZ2VzW19pXSA9IF9lZGdlLnNsaWNlKCk7IC8vIGNvcHlcbiAgICAgIG5ld0VkZ2VzW19pXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgfSBlbHNlIGlmIChfZWRnZVsyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG4gICAgICBuZXdFZGdlc1tfaV1bMl0gPSBwYXJ0aXRpb24xO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVNYXAubGVuZ3RoOyBfaTIrKykge1xuICAgIGlmIChub2RlTWFwW19pMl0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgIG5vZGVNYXBbX2kyXSA9IHBhcnRpdGlvbjE7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdFZGdlcztcbn07XG5cbi8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xudmFyIGNvbnRyYWN0VW50aWwgPSBmdW5jdGlvbiBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcywgc2l6ZSwgc2l6ZUxpbWl0KSB7XG4gIHdoaWxlIChzaXplID4gc2l6ZUxpbWl0KSB7XG4gICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICB2YXIgZWRnZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKTtcblxuICAgIC8vIENvbGxhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcbiAgICByZW1haW5pbmdFZGdlcyA9IGNvbGxhcHNlKGVkZ2VJbmRleCwgbWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKTtcbiAgICBzaXplLS07XG4gIH1cbiAgcmV0dXJuIHJlbWFpbmluZ0VkZ2VzO1xufTtcbnZhciBlbGVzZm4kcCA9IHtcbiAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gIGthcmdlclN0ZWluOiBmdW5jdGlvbiBrYXJnZXJTdGVpbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG4gICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICB9KTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgIHZhciBudW1JdGVyID0gTWF0aC5jZWlsKE1hdGgucG93KE1hdGgubG9nKG51bU5vZGVzKSAvIE1hdGguTE4yLCAyKSk7XG4gICAgdmFyIHN0b3BTaXplID0gTWF0aC5mbG9vcihudW1Ob2RlcyAvIHNxcnQyKTtcbiAgICBpZiAobnVtTm9kZXMgPCAyKSB7XG4gICAgICBlcnJvcignQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlci1TdGVpbiBhbGdvcml0aG0nKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gTm93IHN0b3JlIGVkZ2UgZGVzdGluYXRpb24gYXMgaW5kZXhlc1xuICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG4gICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgZWRnZUluZGV4ZXMucHVzaChbaSwgbm9kZXMuaW5kZXhPZihlLnNvdXJjZSgpKSwgbm9kZXMuaW5kZXhPZihlLnRhcmdldCgpKV0pO1xuICAgIH1cblxuICAgIC8vIFdlIHdpbGwgc3RvcmUgdGhlIGJlc3QgY3V0IGZvdW5kIGhlcmVcbiAgICB2YXIgbWluQ3V0U2l6ZSA9IEluZmluaXR5O1xuICAgIHZhciBtaW5DdXRFZGdlSW5kZXhlcyA9IFtdO1xuICAgIHZhciBtaW5DdXROb2RlTWFwID0gbmV3IEFycmF5KG51bU5vZGVzKTtcblxuICAgIC8vIEluaXRpYWwgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgIHZhciBtZXRhTm9kZU1hcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIG1ldGFOb2RlTWFwMiA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIGNvcHlOb2Rlc01hcCA9IGZ1bmN0aW9uIGNvcHlOb2Rlc01hcChmcm9tLCB0bykge1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTm9kZXM7IF9pMysrKSB7XG4gICAgICAgIHRvW19pM10gPSBmcm9tW19pM107XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIE1haW4gbG9vcFxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgLy8gUmVzZXQgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtTm9kZXM7IF9pNCsrKSB7XG4gICAgICAgIG1ldGFOb2RlTWFwW19pNF0gPSBfaTQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnRyYWN0IHVudGlsIHN0b3AgcG9pbnQgKHN0b3BTaXplIG5vZGVzKVxuICAgICAgdmFyIGVkZ2VzU3RhdGUgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlSW5kZXhlcy5zbGljZSgpLCBudW1Ob2Rlcywgc3RvcFNpemUpO1xuICAgICAgdmFyIGVkZ2VzU3RhdGUyID0gZWRnZXNTdGF0ZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGFwc2VkIG5vZGVzIHN0YXRlXG4gICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1ldGFOb2RlTWFwMik7XG5cbiAgICAgIC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcbiAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwMiwgZWRnZXNTdGF0ZTIsIHN0b3BTaXplLCAyKTtcblxuICAgICAgLy8gSXMgYW55IG9mIHRoZSAyIHJlc3VsdHMgdGhlIGJlc3QgY3V0IHNvIGZhcj9cbiAgICAgIGlmIChyZXMxLmxlbmd0aCA8PSByZXMyLmxlbmd0aCAmJiByZXMxLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczEubGVuZ3RoO1xuICAgICAgICBtaW5DdXRFZGdlSW5kZXhlcyA9IHJlczE7XG4gICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcCwgbWluQ3V0Tm9kZU1hcCk7XG4gICAgICB9IGVsc2UgaWYgKHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMi5sZW5ndGg7XG4gICAgICAgIG1pbkN1dEVkZ2VJbmRleGVzID0gcmVzMjtcbiAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwMiwgbWluQ3V0Tm9kZU1hcCk7XG4gICAgICB9XG4gICAgfSAvLyBlbmQgb2YgbWFpbiBsb29wXG5cbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgdmFyIGN1dCA9IHRoaXMuc3Bhd24obWluQ3V0RWRnZUluZGV4ZXMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZWRnZXNbZVswXV07XG4gICAgfSkpO1xuICAgIHZhciBwYXJ0aXRpb24xID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBwYXJ0aXRpb24yID0gdGhpcy5zcGF3bigpO1xuXG4gICAgLy8gdHJhdmVyc2UgbWV0YU5vZGVNYXAgZm9yIGJlc3QgY3V0XG4gICAgdmFyIHdpdG5lc3NOb2RlUGFydGl0aW9uID0gbWluQ3V0Tm9kZU1hcFswXTtcbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBtaW5DdXROb2RlTWFwLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBwYXJ0aXRpb25JZCA9IG1pbkN1dE5vZGVNYXBbX2k1XTtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbX2k1XTtcbiAgICAgIGlmIChwYXJ0aXRpb25JZCA9PT0gd2l0bmVzc05vZGVQYXJ0aXRpb24pIHtcbiAgICAgICAgcGFydGl0aW9uMS5tZXJnZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRpdGlvbjIubWVyZ2Uobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0IGNvbXBvbmVudHMgY29ycmVzcG9uZGluZyB0byBlYWNoIGRpc2pvaW50IHN1YnNldCBvZiBub2Rlc1xuICAgIHZhciBjb25zdHJ1Y3RDb21wb25lbnQgPSBmdW5jdGlvbiBjb25zdHJ1Y3RDb21wb25lbnQoc3Vic2V0KSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuc3Bhd24oKTtcbiAgICAgIHN1YnNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcbiAgICAgICAgbm9kZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgZWRnZSBpcyB3aXRoaW4gY2FsbGluZyBjb2xsZWN0aW9uIGFuZCBlZGdlIGlzIG5vdCBpbiBjdXRcbiAgICAgICAgICBpZiAoX3RoaXMuY29udGFpbnMoZWRnZSkgJiYgIWN1dC5jb250YWlucyhlZGdlKSkge1xuICAgICAgICAgICAgY29tcG9uZW50Lm1lcmdlKGVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtjb25zdHJ1Y3RDb21wb25lbnQocGFydGl0aW9uMSksIGNvbnN0cnVjdENvbXBvbmVudChwYXJ0aXRpb24yKV07XG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGN1dDogY3V0LFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgIC8vIG4uYi4gcGFydGl0aW9ucyBhcmUgaW5jbHVkZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBvbGQgYXBpIHNwZWNcbiAgICAgIC8vIChjb3VsZCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24pXG4gICAgICBwYXJ0aXRpb24xOiBwYXJ0aXRpb24xLFxuICAgICAgcGFydGl0aW9uMjogcGFydGl0aW9uMlxuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTsgLy8gZWxlc2ZuXG5cbnZhciBfTWF0aCRoeXBvdDtcbnZhciBjb3B5UG9zaXRpb24gPSBmdW5jdGlvbiBjb3B5UG9zaXRpb24ocCkge1xuICByZXR1cm4ge1xuICAgIHg6IHAueCxcbiAgICB5OiBwLnlcbiAgfTtcbn07XG52YXIgbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24kMSA9IGZ1bmN0aW9uIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbikge1xuICByZXR1cm4ge1xuICAgIHg6IHAueCAqIHpvb20gKyBwYW4ueCxcbiAgICB5OiBwLnkgKiB6b29tICsgcGFuLnlcbiAgfTtcbn07XG52YXIgcmVuZGVyZWRUb01vZGVsUG9zaXRpb24gPSBmdW5jdGlvbiByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAocC54IC0gcGFuLngpIC8gem9vbSxcbiAgICB5OiAocC55IC0gcGFuLnkpIC8gem9vbVxuICB9O1xufTtcbnZhciBhcnJheTJwb2ludCA9IGZ1bmN0aW9uIGFycmF5MnBvaW50KGFycikge1xuICByZXR1cm4ge1xuICAgIHg6IGFyclswXSxcbiAgICB5OiBhcnJbMV1cbiAgfTtcbn07XG52YXIgbWluID0gZnVuY3Rpb24gbWluKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbih2YWwsIG1pbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59O1xudmFyIG1heCA9IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KHZhbCwgbWF4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn07XG52YXIgbWVhbiA9IGZ1bmN0aW9uIG1lYW4oYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcbiAgdmFyIG4gPSAwO1xuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIHRvdGFsICs9IHZhbDtcbiAgICAgIG4rKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvdGFsIC8gbjtcbn07XG52YXIgbWVkaWFuID0gZnVuY3Rpb24gbWVkaWFuKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBjb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc29ydCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIGluY2x1ZGVIb2xlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgaWYgKGNvcHkpIHtcbiAgICBhcnIgPSBhcnIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgIGFyci5zcGxpY2UoZW5kLCBhcnIubGVuZ3RoIC0gZW5kKTtcbiAgICB9XG4gICAgaWYgKGJlZ2luID4gMCkge1xuICAgICAgYXJyLnNwbGljZSgwLCBiZWdpbik7XG4gICAgfVxuICB9XG5cbiAgLy8gYWxsIG5vbiBmaW5pdGUgKGUuZy4gSW5maW5pdHksIE5hTikgZWxlbWVudHMgbXVzdCBiZSAtSW5maW5pdHkgc28gdGhleSBnbyB0byB0aGUgc3RhcnRcbiAgdmFyIG9mZiA9IDA7IC8vIG9mZnNldCBmcm9tIG5vbi1maW5pdGUgdmFsdWVzXG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdiA9IGFycltpXTtcbiAgICBpZiAoaW5jbHVkZUhvbGVzKSB7XG4gICAgICBpZiAoIWlzRmluaXRlKHYpKSB7XG4gICAgICAgIGFycltpXSA9IC1JbmZpbml0eTtcbiAgICAgICAgb2ZmKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3QgcmVtb3ZlIGl0IGlmIHdlIGRvbid0IHdhbnQgdG8gY29uc2lkZXIgaG9sZXNcbiAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGlmIChzb3J0KSB7XG4gICAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTsgLy8gcmVxdWlyZXMgY29weSA9IHRydWUgaWYgeW91IGRvbid0IHdhbnQgdG8gY2hhbmdlIHRoZSBvcmlnXG4gIH1cbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHJldHVybiBhcnJbbWlkICsgMSArIG9mZl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChhcnJbbWlkIC0gMSArIG9mZl0gKyBhcnJbbWlkICsgb2ZmXSkgLyAyO1xuICB9XG59O1xudmFyIGRlZzJyYWQgPSBmdW5jdGlvbiBkZWcycmFkKGRlZykge1xuICByZXR1cm4gTWF0aC5QSSAqIGRlZyAvIDE4MDtcbn07XG52YXIgZ2V0QW5nbGVGcm9tRGlzcCA9IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKGRpc3BZLCBkaXNwWCkgLSBNYXRoLlBJIC8gMjtcbn07XG52YXIgbG9nMiA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbiAobikge1xuICByZXR1cm4gTWF0aC5sb2cobikgLyBNYXRoLmxvZygyKTtcbn07XG52YXIgc2lnbnVtID0gZnVuY3Rpb24gc2lnbnVtKHgpIHtcbiAgaWYgKHggPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoeCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgZGlzdCA9IGZ1bmN0aW9uIGRpc3QocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3FkaXN0KHAxLCBwMikpO1xufTtcbnZhciBzcWRpc3QgPSBmdW5jdGlvbiBzcWRpc3QocDEsIHAyKSB7XG4gIHZhciBkeCA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkgPSBwMi55IC0gcDEueTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufTtcbnZhciBpblBsYWNlU3VtTm9ybWFsaXplID0gZnVuY3Rpb24gaW5QbGFjZVN1bU5vcm1hbGl6ZSh2KSB7XG4gIHZhciBsZW5ndGggPSB2Lmxlbmd0aDtcblxuICAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgdmFyIHRvdGFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRvdGFsICs9IHZbaV07XG4gIH1cblxuICAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW5ndGg7IF9pKyspIHtcbiAgICB2W19pXSA9IHZbX2ldIC8gdG90YWw7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZSNRdWFkcmF0aWNfY3VydmVzXG52YXIgcWJlemllckF0ID0gZnVuY3Rpb24gcWJlemllckF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogcDAgKyAyICogKDEgLSB0KSAqIHQgKiBwMSArIHQgKiB0ICogcDI7XG59O1xudmFyIHFiZXppZXJQdEF0ID0gZnVuY3Rpb24gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4ge1xuICAgIHg6IHFiZXppZXJBdChwMC54LCBwMS54LCBwMi54LCB0KSxcbiAgICB5OiBxYmV6aWVyQXQocDAueSwgcDEueSwgcDIueSwgdClcbiAgfTtcbn07XG52YXIgbGluZUF0ID0gZnVuY3Rpb24gbGluZUF0KHAwLCBwMSwgdCwgZCkge1xuICB2YXIgdmVjID0ge1xuICAgIHg6IHAxLnggLSBwMC54LFxuICAgIHk6IHAxLnkgLSBwMC55XG4gIH07XG4gIHZhciB2ZWNEaXN0ID0gZGlzdChwMCwgcDEpO1xuICB2YXIgbm9ybVZlYyA9IHtcbiAgICB4OiB2ZWMueCAvIHZlY0Rpc3QsXG4gICAgeTogdmVjLnkgLyB2ZWNEaXN0XG4gIH07XG4gIHQgPSB0ID09IG51bGwgPyAwIDogdDtcbiAgZCA9IGQgIT0gbnVsbCA/IGQgOiB0ICogdmVjRGlzdDtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMC54ICsgbm9ybVZlYy54ICogZCxcbiAgICB5OiBwMC55ICsgbm9ybVZlYy55ICogZFxuICB9O1xufTtcbnZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKG1pbiwgdmFsLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWwpKTtcbn07XG5cbi8vIG1ha2VzIGEgZnVsbCBiYiAoeDEsIHkxLCB4MiwgeTIsIHcsIGgpIGZyb20gaW1wbGljaXQgcGFyYW1zXG52YXIgbWFrZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gbWFrZUJvdW5kaW5nQm94KGJiKSB7XG4gIGlmIChiYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBJbmZpbml0eSxcbiAgICAgIHkxOiBJbmZpbml0eSxcbiAgICAgIHgyOiAtSW5maW5pdHksXG4gICAgICB5MjogLUluZmluaXR5LFxuICAgICAgdzogMCxcbiAgICAgIGg6IDBcbiAgICB9O1xuICB9IGVsc2UgaWYgKGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCkge1xuICAgIGlmIChiYi54MiAhPSBudWxsICYmIGJiLnkyICE9IG51bGwgJiYgYmIueDIgPj0gYmIueDEgJiYgYmIueTIgPj0gYmIueTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDIsXG4gICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgdzogYmIueDIgLSBiYi54MSxcbiAgICAgICAgaDogYmIueTIgLSBiYi55MVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGJiLncgIT0gbnVsbCAmJiBiYi5oICE9IG51bGwgJiYgYmIudyA+PSAwICYmIGJiLmggPj0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MSArIGJiLncsXG4gICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgIHc6IGJiLncsXG4gICAgICAgIGg6IGJiLmhcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xudmFyIGNvcHlCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGNvcHlCb3VuZGluZ0JveChiYikge1xuICByZXR1cm4ge1xuICAgIHgxOiBiYi54MSxcbiAgICB4MjogYmIueDIsXG4gICAgdzogYmIudyxcbiAgICB5MTogYmIueTEsXG4gICAgeTI6IGJiLnkyLFxuICAgIGg6IGJiLmhcbiAgfTtcbn07XG52YXIgY2xlYXJCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGNsZWFyQm91bmRpbmdCb3goYmIpIHtcbiAgYmIueDEgPSBJbmZpbml0eTtcbiAgYmIueTEgPSBJbmZpbml0eTtcbiAgYmIueDIgPSAtSW5maW5pdHk7XG4gIGJiLnkyID0gLUluZmluaXR5O1xuICBiYi53ID0gMDtcbiAgYmIuaCA9IDA7XG59O1xudmFyIHVwZGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgLy8gdXBkYXRlIGJiMSB3aXRoIGJiMiBib3VuZHNcblxuICBiYjEueDEgPSBNYXRoLm1pbihiYjEueDEsIGJiMi54MSk7XG4gIGJiMS54MiA9IE1hdGgubWF4KGJiMS54MiwgYmIyLngyKTtcbiAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG4gIGJiMS55MSA9IE1hdGgubWluKGJiMS55MSwgYmIyLnkxKTtcbiAgYmIxLnkyID0gTWF0aC5tYXgoYmIxLnkyLCBiYjIueTIpO1xuICBiYjEuaCA9IGJiMS55MiAtIGJiMS55MTtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50ID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCB4LCB5KSB7XG4gIGJiLngxID0gTWF0aC5taW4oYmIueDEsIHgpO1xuICBiYi54MiA9IE1hdGgubWF4KGJiLngyLCB4KTtcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLnkxID0gTWF0aC5taW4oYmIueTEsIHkpO1xuICBiYi55MiA9IE1hdGgubWF4KGJiLnkyLCB5KTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3goYmIpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIGJiLngxIC09IHBhZGRpbmc7XG4gIGJiLngyICs9IHBhZGRpbmc7XG4gIGJiLnkxIC09IHBhZGRpbmc7XG4gIGJiLnkyICs9IHBhZGRpbmc7XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgcmV0dXJuIGJiO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveFNpZGVzID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYikge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWzBdO1xuICB2YXIgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0O1xuICBpZiAocGFkZGluZy5sZW5ndGggPT09IDEpIHtcbiAgICB0b3AgPSByaWdodCA9IGJvdHRvbSA9IGxlZnQgPSBwYWRkaW5nWzBdO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAyKSB7XG4gICAgdG9wID0gYm90dG9tID0gcGFkZGluZ1swXTtcbiAgICBsZWZ0ID0gcmlnaHQgPSBwYWRkaW5nWzFdO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIF9wYWRkaW5nID0gX3NsaWNlZFRvQXJyYXkocGFkZGluZywgNCk7XG4gICAgdG9wID0gX3BhZGRpbmdbMF07XG4gICAgcmlnaHQgPSBfcGFkZGluZ1sxXTtcbiAgICBib3R0b20gPSBfcGFkZGluZ1syXTtcbiAgICBsZWZ0ID0gX3BhZGRpbmdbM107XG4gIH1cbiAgYmIueDEgLT0gbGVmdDtcbiAgYmIueDIgKz0gcmlnaHQ7XG4gIGJiLnkxIC09IHRvcDtcbiAgYmIueTIgKz0gYm90dG9tO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIHJldHVybiBiYjtcbn07XG5cbi8vIGFzc2lnbiB0aGUgdmFsdWVzIG9mIGJiMiBpbnRvIGJiMVxudmFyIGFzc2lnbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYXNzaWduQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgYmIxLngxID0gYmIyLngxO1xuICBiYjEueTEgPSBiYjIueTE7XG4gIGJiMS54MiA9IGJiMi54MjtcbiAgYmIxLnkyID0gYmIyLnkyO1xuICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG59O1xudmFyIGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiBib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiMSwgYmIyKSB7XG4gIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICBpZiAoYmIxLngxID4gYmIyLngyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChiYjIueDEgPiBiYjEueDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjYXNlOiBvbmUgYmIgdG8gbGVmdCBvZiBvdGhlclxuICBpZiAoYmIxLngyIDwgYmIyLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChiYjIueDIgPCBiYjEueDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjYXNlOiBvbmUgYmIgYWJvdmUgb3RoZXJcbiAgaWYgKGJiMS55MiA8IGJiMi55MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYmIyLnkyIDwgYmIxLnkxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG4gIGlmIChiYjEueTEgPiBiYjIueTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJiMi55MSA+IGJiMS55Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgbXVzdCBoYXZlIHNvbWUgb3ZlcmxhcFxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGluQm91bmRpbmdCb3goYmIsIHgsIHkpIHtcbiAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG59O1xudmFyIHBvaW50SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHBvaW50SW5Cb3VuZGluZ0JveChiYiwgcHQpIHtcbiAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIsIHB0LngsIHB0LnkpO1xufTtcbnZhciBib3VuZGluZ0JveEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBib3VuZGluZ0JveEluQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIxLCBiYjIueDEsIGJiMi55MSkgJiYgaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MiwgYmIyLnkyKTtcbn07XG52YXIgaHlwb3QgPSAoX01hdGgkaHlwb3QgPSBNYXRoLmh5cG90KSAhPT0gbnVsbCAmJiBfTWF0aCRoeXBvdCAhPT0gdW5kZWZpbmVkID8gX01hdGgkaHlwb3QgOiBmdW5jdGlvbiAoeCwgeSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufTtcbmZ1bmN0aW9uIGluZmxhdGVQb2x5Z29uKHBvbHlnb24sIGQpIHtcbiAgaWYgKHBvbHlnb24ubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBhdCBsZWFzdCAzIHZlcnRpY2VzJyk7XG4gIH1cbiAgLy8gSGVscGVyc1xuICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYS54ICsgYi54LFxuICAgICAgeTogYS55ICsgYi55XG4gICAgfTtcbiAgfTtcbiAgdmFyIHN1YiA9IGZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGEueCAtIGIueCxcbiAgICAgIHk6IGEueSAtIGIueVxuICAgIH07XG4gIH07XG4gIHZhciBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHYsIHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdi54ICogcyxcbiAgICAgIHk6IHYueSAqIHNcbiAgICB9O1xuICB9O1xuICB2YXIgY3Jvc3MgPSBmdW5jdGlvbiBjcm9zcyh1LCB2KSB7XG4gICAgcmV0dXJuIHUueCAqIHYueSAtIHUueSAqIHYueDtcbiAgfTtcbiAgdmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2KSB7XG4gICAgdmFyIGxlbiA9IGh5cG90KHYueCwgdi55KTtcbiAgICByZXR1cm4gbGVuID09PSAwID8ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9IDoge1xuICAgICAgeDogdi54IC8gbGVuLFxuICAgICAgeTogdi55IC8gbGVuXG4gICAgfTtcbiAgfTtcbiAgLy8gU2lnbmVkIGFyZWEgKHBvc2l0aXZlID0gQ0NXKVxuICB2YXIgc2lnbmVkQXJlYSA9IGZ1bmN0aW9uIHNpZ25lZEFyZWEocHRzKSB7XG4gICAgdmFyIEEgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHB0c1tpXSxcbiAgICAgICAgcSA9IHB0c1soaSArIDEpICUgcHRzLmxlbmd0aF07XG4gICAgICBBICs9IHAueCAqIHEueSAtIHEueCAqIHAueTtcbiAgICB9XG4gICAgcmV0dXJuIEEgLyAyO1xuICB9O1xuICAvLyBMaW5l4oCTbGluZSBpbnRlcnNlY3Rpb24gKGluZmluaXRlIGxpbmVzKVxuICB2YXIgaW50ZXJzZWN0TGluZXMgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lcyhwMSwgcDIsIHAzLCBwNCkge1xuICAgIHZhciByID0gc3ViKHAyLCBwMSk7XG4gICAgdmFyIHMgPSBzdWIocDQsIHAzKTtcbiAgICB2YXIgZGVub20gPSBjcm9zcyhyLCBzKTtcbiAgICBpZiAoTWF0aC5hYnMoZGVub20pIDwgMWUtOSkge1xuICAgICAgLy8gUGFyYWxsZWwgb3IgbmVhcmx5IHNvIOKAlCBmYWxsYmFjayB0byBtaWRwb2ludFxuICAgICAgcmV0dXJuIGFkZChwMSwgc2NhbGUociwgMC41KSk7XG4gICAgfVxuICAgIHZhciB0ID0gY3Jvc3Moc3ViKHAzLCBwMSksIHMpIC8gZGVub207XG4gICAgcmV0dXJuIGFkZChwMSwgc2NhbGUociwgdCkpO1xuICB9O1xuXG4gIC8vIE1ha2UgYSBzaGFsbG93IGNvcHkgYW5kIGVuZm9yY2UgQ0NXXG4gIHZhciBwdHMgPSBwb2x5Z29uLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwLngsXG4gICAgICB5OiBwLnlcbiAgICB9O1xuICB9KTtcbiAgaWYgKHNpZ25lZEFyZWEocHRzKSA8IDApIHB0cy5yZXZlcnNlKCk7XG4gIHZhciBuID0gcHRzLmxlbmd0aDtcbiAgLy8gQ29tcHV0ZSBvdXR3YXJkIG5vcm1hbHMgZm9yIGVhY2ggZWRnZVxuICB2YXIgbm9ybWFscyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBwID0gcHRzW2ldLFxuICAgICAgcSA9IHB0c1soaSArIDEpICUgbl07XG4gICAgdmFyIGVkZ2UgPSBzdWIocSwgcCk7XG4gICAgLy8gRm9yIENDVyBwb2x5Z29uLCBpbndhcmQgbm9ybWFsID0gKC1lZGdlLnksIGVkZ2UueClcbiAgICAvLyBzbyBvdXR3YXJkIG5vcm1hbCA9IChlZGdlLnksIC1lZGdlLngpXG4gICAgdmFyIG91dCA9IG5vcm1hbGl6ZSh7XG4gICAgICB4OiBlZGdlLnksXG4gICAgICB5OiAtZWRnZS54XG4gICAgfSk7XG4gICAgbm9ybWFscy5wdXNoKG91dCk7XG4gIH1cblxuICAvLyBCdWlsZCBvZmZzZXQgZWRnZXNcbiAgdmFyIG9mZnNldEVkZ2VzID0gbm9ybWFscy5tYXAoZnVuY3Rpb24gKG5ybSwgaSkge1xuICAgIHZhciBwMSA9IGFkZChwdHNbaV0sIHNjYWxlKG5ybSwgZCkpO1xuICAgIHZhciBwMiA9IGFkZChwdHNbKGkgKyAxKSAlIG5dLCBzY2FsZShucm0sIGQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcDE6IHAxLFxuICAgICAgcDI6IHAyXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gSW50ZXJzZWN0IGNvbnNlY3V0aXZlIG9mZnNldCBlZGdlc1xuICB2YXIgaW5mbGF0ZWQgPSBbXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjsgX2kyKyspIHtcbiAgICB2YXIgcHJldkVkZ2UgPSBvZmZzZXRFZGdlc1soX2kyIC0gMSArIG4pICUgbl07XG4gICAgdmFyIGN1cnJFZGdlID0gb2Zmc2V0RWRnZXNbX2kyXTtcbiAgICB2YXIgaXAgPSBpbnRlcnNlY3RMaW5lcyhwcmV2RWRnZS5wMSwgcHJldkVkZ2UucDIsIGN1cnJFZGdlLnAxLCBjdXJyRWRnZS5wMik7XG4gICAgaW5mbGF0ZWQucHVzaChpcCk7XG4gIH1cbiAgcmV0dXJuIGluZmxhdGVkO1xufVxuZnVuY3Rpb24gbWl0ZXJCb3gocHRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBzdHJva2VXaWR0aCkge1xuICB2YXIgdHB0cyA9IHRyYW5zZm9ybVBvaW50cyhwdHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgb2Zmc2V0UG9pbnRzID0gaW5mbGF0ZVBvbHlnb24odHB0cywgc3Ryb2tlV2lkdGgpO1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgb2Zmc2V0UG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHB0KSB7XG4gICAgcmV0dXJuIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgcHQueCwgcHQueSk7XG4gIH0pO1xuICByZXR1cm4gYmI7XG59XG52YXIgcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiAnYXV0byc7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSByYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpIDogcmFkaXVzO1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIGNvcm5lclJhZGl1cyA9IE1hdGgubWluKGNvcm5lclJhZGl1cywgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgdmFyIGRvV2lkdGggPSBjb3JuZXJSYWRpdXMgIT09IGhhbGZXaWR0aCxcbiAgICBkb0hlaWdodCA9IGNvcm5lclJhZGl1cyAhPT0gaGFsZkhlaWdodDtcblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICB2YXIgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3Agc2VnbWVudCwgbGVmdCB0byByaWdodFxuICBpZiAoZG9XaWR0aCkge1xuICAgIHZhciB0b3BTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCAtIHBhZGRpbmc7XG4gICAgdmFyIHRvcEVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgdmFyIHRvcEVuZFkgPSB0b3BTdGFydFk7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBSaWdodCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gIGlmIChkb0hlaWdodCkge1xuICAgIHZhciByaWdodFN0YXJ0WCA9IG5vZGVYICsgaGFsZldpZHRoICsgcGFkZGluZztcbiAgICB2YXIgcmlnaHRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICB2YXIgcmlnaHRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSk7XG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAgaWYgKGRvV2lkdGgpIHtcbiAgICB2YXIgYm90dG9tU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRZID0gYm90dG9tU3RhcnRZO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVN0YXJ0WCwgYm90dG9tU3RhcnRZLCBib3R0b21FbmRYLCBib3R0b21FbmRZLCBmYWxzZSk7XG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gIGlmIChkb0hlaWdodCkge1xuICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIGFyYyBzZWdtZW50c1xuICB2YXIgYXJjSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3AgTGVmdFxuICB7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgdG9wTGVmdENlbnRlclgsIHRvcExlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSB0b3BMZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcExlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRvcCBSaWdodFxuICB7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BSaWdodENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBSaWdodFxuICB7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gYm90dG9tUmlnaHRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tUmlnaHRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBMZWZ0XG4gIHtcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21MZWZ0Q2VudGVyWCwgYm90dG9tTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IGJvdHRvbUxlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tTGVmdENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xufTtcbnZhciBpbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uIGluTGluZVZpY2luaXR5KHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKSB7XG4gIHZhciB0ID0gdG9sZXJhbmNlO1xuICB2YXIgeDEgPSBNYXRoLm1pbihseDEsIGx4Mik7XG4gIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICB2YXIgeTIgPSBNYXRoLm1heChseTEsIGx5Mik7XG4gIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdCAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbn07XG52YXIgaW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uIGluQmV6aWVyVmljaW5pdHkoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gIHZhciBiYiA9IHtcbiAgICB4MTogTWF0aC5taW4oeDEsIHgzLCB4MikgLSB0b2xlcmFuY2UsXG4gICAgeDI6IE1hdGgubWF4KHgxLCB4MywgeDIpICsgdG9sZXJhbmNlLFxuICAgIHkxOiBNYXRoLm1pbih5MSwgeTMsIHkyKSAtIHRvbGVyYW5jZSxcbiAgICB5MjogTWF0aC5tYXgoeTEsIHkzLCB5MikgKyB0b2xlcmFuY2VcbiAgfTtcblxuICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgaWYgKHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55Mikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgc29sdmVRdWFkcmF0aWMgPSBmdW5jdGlvbiBzb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCB2YWwpIHtcbiAgYyAtPSB2YWw7XG4gIHZhciByID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGlmIChyIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgc3FydFIgPSBNYXRoLnNxcnQocik7XG4gIHZhciBkZW5vbSA9IDIgKiBhO1xuICB2YXIgcm9vdDEgPSAoLWIgKyBzcXJ0UikgLyBkZW5vbTtcbiAgdmFyIHJvb3QyID0gKC1iIC0gc3FydFIpIC8gZGVub207XG4gIHJldHVybiBbcm9vdDEsIHJvb3QyXTtcbn07XG52YXIgc29sdmVDdWJpYyA9IGZ1bmN0aW9uIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcmVzdWx0KSB7XG4gIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX2Z1bmN0aW9uI1RoZV9uYXR1cmVfb2ZfdGhlX3Jvb3RzXG5cbiAgdmFyIGVwc2lsb24gPSAwLjAwMDAxO1xuXG4gIC8vIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gd2hpbGUga2VlcGluZyB0aGUgb3ZlcmFsbCBleHByZXNzaW9uIGNsb3NlIGluIHZhbHVlXG4gIGlmIChhID09PSAwKSB7XG4gICAgYSA9IGVwc2lsb247XG4gIH1cbiAgYiAvPSBhO1xuICBjIC89IGE7XG4gIGQgLz0gYTtcbiAgdmFyIGRpc2NyaW1pbmFudCwgcSwgciwgZHVtMSwgcywgdCwgdGVybTEsIHIxMztcbiAgcSA9ICgzLjAgKiBjIC0gYiAqIGIpIC8gOS4wO1xuICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgciAvPSA1NC4wO1xuICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgcmVzdWx0WzFdID0gMDtcbiAgdGVybTEgPSBiIC8gMy4wO1xuICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgIHMgPSByICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgcyA9IHMgPCAwID8gLU1hdGgucG93KC1zLCAxLjAgLyAzLjApIDogTWF0aC5wb3cocywgMS4wIC8gMy4wKTtcbiAgICB0ID0gciAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHQgPSB0IDwgMCA/IC1NYXRoLnBvdygtdCwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHQsIDEuMCAvIDMuMCk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcyArIHQ7XG4gICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgdGVybTEgPSBNYXRoLnNxcnQoMy4wKSAqICgtdCArIHMpIC8gMjtcbiAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG4gIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICByMTMgPSByIDwgMCA/IC1NYXRoLnBvdygtciwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHIsIDEuMCAvIDMuMCk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgMi4wICogcjEzO1xuICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgIHJldHVybjtcbiAgfVxuICBxID0gLXE7XG4gIGR1bTEgPSBxICogcSAqIHE7XG4gIGR1bTEgPSBNYXRoLmFjb3MociAvIE1hdGguc3FydChkdW0xKSk7XG4gIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gIHJlc3VsdFsyXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjApO1xuICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmV0dXJuO1xufTtcbnZhciBzcWRpc3RUb1F1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uIHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZVxuICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG5cbiAgLy8gVGhpcyBnaXZlcyB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSByZXN1bHRpbmcgY3ViaWMgZXF1YXRpb25cbiAgLy8gd2hvc2Ugcm9vdHMgdGVsbCB1cyB3aGVyZSBhIHBvc3NpYmxlIG1pbmltdW0gaXNcbiAgLy8gKENvZWZmaWNpZW50cyBhcmUgZGl2aWRlZCBieSA0KVxuXG4gIHZhciBhID0gMS4wICogeDEgKiB4MSAtIDQgKiB4MSAqIHgyICsgMiAqIHgxICogeDMgKyA0ICogeDIgKiB4MiAtIDQgKiB4MiAqIHgzICsgeDMgKiB4MyArIHkxICogeTEgLSA0ICogeTEgKiB5MiArIDIgKiB5MSAqIHkzICsgNCAqIHkyICogeTIgLSA0ICogeTIgKiB5MyArIHkzICogeTM7XG4gIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4MyArIDkgKiB5MSAqIHkyIC0gMyAqIHkxICogeTEgLSAzICogeTEgKiB5MyAtIDYgKiB5MiAqIHkyICsgMyAqIHkyICogeTM7XG4gIHZhciBjID0gMS4wICogMyAqIHgxICogeDEgLSA2ICogeDEgKiB4MiArIHgxICogeDMgLSB4MSAqIHggKyAyICogeDIgKiB4MiArIDIgKiB4MiAqIHggLSB4MyAqIHggKyAzICogeTEgKiB5MSAtIDYgKiB5MSAqIHkyICsgeTEgKiB5MyAtIHkxICogeSArIDIgKiB5MiAqIHkyICsgMiAqIHkyICogeSAtIHkzICogeTtcbiAgdmFyIGQgPSAxLjAgKiB4MSAqIHgyIC0geDEgKiB4MSArIHgxICogeCAtIHgyICogeCArIHkxICogeTIgLSB5MSAqIHkxICsgeTEgKiB5IC0geTIgKiB5O1xuXG4gIC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcblxuICB2YXIgcm9vdHMgPSBbXTtcblxuICAvLyBVc2UgdGhlIGN1YmljIHNvbHZpbmcgYWxnb3JpdGhtXG4gIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcbiAgdmFyIHBhcmFtcyA9IFtdO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGQgJiYgcm9vdHNbaW5kZXhdID49IDAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICB9XG4gIH1cbiAgcGFyYW1zLnB1c2goMS4wKTtcbiAgcGFyYW1zLnB1c2goMC4wKTtcbiAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICB2YXIgY3VyWCwgY3VyWSwgZGlzdFNxdWFyZWQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB4MztcbiAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxICsgMiAqICgxLjAgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeTIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcbiAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTtcbiAgICAvLyBkZWJ1ZygnZGlzdGFuY2UgZm9yIHBhcmFtICcgKyBwYXJhbXNbaV0gKyBcIjogXCIgKyBNYXRoLnNxcnQoZGlzdFNxdWFyZWQpKTtcbiAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG59O1xudmFyIHNxZGlzdFRvRmluaXRlTGluZSA9IGZ1bmN0aW9uIHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgdmFyIGxpbmUgPSBbeDIgLSB4MSwgeTIgLSB5MV07XG4gIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuICBpZiAoZG90UHJvZHVjdCA8IDApIHtcbiAgICByZXR1cm4gaHlwU3E7XG4gIH1cbiAgaWYgKGFkalNxID4gbGluZVNxKSB7XG4gICAgcmV0dXJuICh4IC0geDIpICogKHggLSB4MikgKyAoeSAtIHkyKSAqICh5IC0geTIpO1xuICB9XG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcbnZhciBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSB7XG4gIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgdmFyIHkzO1xuXG4gIC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcbiAgdmFyIHVwID0gMDtcbiAgLy8gbGV0IGRvd24gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyICsgMV07XG4gICAgfVxuICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIDsgZWxzZSBpZiAoeDEgPj0geCAmJiB4ID49IHgyIHx8IHgxIDw9IHggJiYgeCA8PSB4Mikge1xuICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuICAgICAgaWYgKHkzID4geSkge1xuICAgICAgICB1cCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiggeTMgPCB5ICl7XG4gICAgICAvLyBkb3duKys7XG4gICAgICAvLyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICBpZiAodXAgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIHBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcblxuICAvLyBHaXZlcyBuZWdhdGl2ZSBhbmdsZVxuICB2YXIgYW5nbGU7XG4gIGlmIChkaXJlY3Rpb25bMF0gIT0gbnVsbCkge1xuICAgIGFuZ2xlID0gTWF0aC5hdGFuKGRpcmVjdGlvblsxXSAvIGRpcmVjdGlvblswXSk7XG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYW5nbGUgPSBkaXJlY3Rpb247XG4gIH1cbiAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXG4gIC8vICAgIGNvbnNvbGUubG9nKFwiYmFzZTogXCIgKyBiYXNlUG9pbnRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3MgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gKz0gY2VudGVyWDtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gIH1cbiAgdmFyIHBvaW50cztcbiAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IGV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcbiAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgfVxuICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG59O1xudmFyIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVycykge1xuICB2YXIgY3V0UG9seWdvblBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCAqIDIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcm5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29ybmVyID0gY29ybmVyc1tpXTtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMF0gPSBjb3JuZXIuc3RhcnRYO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAxXSA9IGNvcm5lci5zdGFydFk7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDJdID0gY29ybmVyLnN0b3BYO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAzXSA9IGNvcm5lci5zdG9wWTtcbiAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3coY29ybmVyLmN4IC0geCwgMikgKyBNYXRoLnBvdyhjb3JuZXIuY3kgLSB5LCAyKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IE1hdGgucG93KGNvcm5lci5yYWRpdXMsIDIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRQb2x5Z29uUG9pbnRzKTtcbn07XG52YXIgam9pbkxpbmVzID0gZnVuY3Rpb24gam9pbkxpbmVzKGxpbmVTZXQpIHtcbiAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICB2YXIgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKykge1xuICAgIGN1cnJlbnRMaW5lU3RhcnRYID0gbGluZVNldFtpICogNF07XG4gICAgY3VycmVudExpbmVTdGFydFkgPSBsaW5lU2V0W2kgKiA0ICsgMV07XG4gICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFtpICogNCArIDJdO1xuICAgIGN1cnJlbnRMaW5lRW5kWSA9IGxpbmVTZXRbaSAqIDQgKyAzXTtcbiAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsoaSArIDEpICogNF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WzFdO1xuICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgfVxuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLCBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLCB0cnVlKTtcbiAgICB2ZXJ0aWNlc1tpICogMl0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgfVxuICByZXR1cm4gdmVydGljZXM7XG59O1xudmFyIGV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbiBleHBhbmRQb2x5Z29uKHBvaW50cywgcGFkKSB7XG4gIHZhciBleHBhbmRlZExpbmVTZXQgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICB2YXIgY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSwgbmV4dFBvaW50WCwgbmV4dFBvaW50WTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY3VycmVudFBvaW50WCA9IHBvaW50c1tpICogMl07XG4gICAgY3VycmVudFBvaW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudCBsaW5lOiBbY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WV0gdG8gW25leHRQb2ludFgsIG5leHRQb2ludFldXG5cbiAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuXG4gICAgdmFyIG9mZnNldFggPSBuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WTtcbiAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIG9mZnNldExlbmd0aCA9IE1hdGguc3FydChvZmZzZXRYICogb2Zmc2V0WCArIG9mZnNldFkgKiBvZmZzZXRZKTtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAyXSA9IG5leHRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgfVxuICByZXR1cm4gZXhwYW5kZWRMaW5lU2V0O1xufTtcbnZhciBpbnRlcnNlY3RMaW5lRWxsaXBzZSA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVFbGxpcHNlKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cykge1xuICB2YXIgZGlzcFggPSBjZW50ZXJYIC0geDtcbiAgdmFyIGRpc3BZID0gY2VudGVyWSAtIHk7XG4gIGRpc3BYIC89IGVsbGlwc2VXcmFkaXVzO1xuICBkaXNwWSAvPSBlbGxpcHNlSHJhZGl1cztcbiAgdmFyIGxlbiA9IE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSk7XG4gIHZhciBuZXdMZW5ndGggPSBsZW4gLSAxO1xuICBpZiAobmV3TGVuZ3RoIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuUHJvcG9ydGlvbiA9IG5ld0xlbmd0aCAvIGxlbjtcbiAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG59O1xudmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICB4IC09IGNlbnRlclg7XG4gIHkgLT0gY2VudGVyWTtcbiAgeCAvPSB3aWR0aCAvIDIgKyBwYWRkaW5nO1xuICB5IC89IGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICByZXR1cm4geCAqIHggKyB5ICogeSA8PSAxO1xufTtcblxuLy8gUmV0dXJucyBpbnRlcnNlY3Rpb25zIG9mIGluY3JlYXNpbmcgZGlzdGFuY2UgZnJvbSBsaW5lJ3Mgc3RhcnQgcG9pbnRcbnZhciBpbnRlcnNlY3RMaW5lQ2lyY2xlID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZUNpcmNsZSh4MSwgeTEsIHgyLCB5MiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XG4gIC8vIENhbGN1bGF0ZSBkLCBkaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgdmFyIGQgPSBbeDIgLSB4MSwgeTIgLSB5MV07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgZiA9IFt4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWV07XG4gIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICB2YXIgYyA9IGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0gLSByYWRpdXMgKiByYWRpdXM7XG4gIHZhciBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgdmFyIHRNaW4gPSBNYXRoLm1pbih0MSwgdDIpO1xuICB2YXIgdE1heCA9IE1hdGgubWF4KHQxLCB0Mik7XG4gIHZhciBpblJhbmdlUGFyYW1zID0gW107XG4gIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICB9XG4gIGlmICh0TWF4ID49IDAgJiYgdE1heCA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICB9XG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGluUmFuZ2VQYXJhbXNbMF0gPT0gaW5SYW5nZVBhcmFtc1sxXSkge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgfVxufTtcbnZhciBtaWRPZlRocmVlID0gZnVuY3Rpb24gbWlkT2ZUaHJlZShhLCBiLCBjKSB7XG4gIGlmIChiIDw9IGEgJiYgYSA8PSBjIHx8IGMgPD0gYSAmJiBhIDw9IGIpIHtcbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlIGlmIChhIDw9IGIgJiYgYiA8PSBjIHx8IGMgPD0gYiAmJiBiIDw9IGEpIHtcbiAgICByZXR1cm4gYjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYztcbiAgfVxufTtcblxuLy8gKHgxLHkxKT0+KHgyLHkyKSBpbnRlcnNlY3Qgd2l0aCAoeDMseTMpPT4oeDQseTQpXG52YXIgZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiBmaW5pdGVMaW5lc0ludGVyc2VjdCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGluZmluaXRlTGluZXMpIHtcbiAgdmFyIGR4MTMgPSB4MSAtIHgzO1xuICB2YXIgZHgyMSA9IHgyIC0geDE7XG4gIHZhciBkeDQzID0geDQgLSB4MztcbiAgdmFyIGR5MTMgPSB5MSAtIHkzO1xuICB2YXIgZHkyMSA9IHkyIC0geTE7XG4gIHZhciBkeTQzID0geTQgLSB5MztcbiAgdmFyIHVhX3QgPSBkeDQzICogZHkxMyAtIGR5NDMgKiBkeDEzO1xuICB2YXIgdWJfdCA9IGR4MjEgKiBkeTEzIC0gZHkyMSAqIGR4MTM7XG4gIHZhciB1X2IgPSBkeTQzICogZHgyMSAtIGR4NDMgKiBkeTIxO1xuICBpZiAodV9iICE9PSAwKSB7XG4gICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICB2YXIgdWIgPSB1Yl90IC8gdV9iO1xuICAgIHZhciBmbHB0VGhyZXNob2xkID0gMC4wMDE7XG4gICAgdmFyIF9taW4gPSAwIC0gZmxwdFRocmVzaG9sZDtcbiAgICB2YXIgX21heCA9IDEgKyBmbHB0VGhyZXNob2xkO1xuICAgIGlmIChfbWluIDw9IHVhICYmIHVhIDw9IF9tYXggJiYgX21pbiA8PSB1YiAmJiB1YiA8PSBfbWF4KSB7XG4gICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcbiAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG5cbiAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICBpZiAobWlkT2ZUaHJlZSh4MSwgeDIsIHg0KSA9PT0geDQpIHtcbiAgICAgICAgcmV0dXJuIFt4NCwgeTRdO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBzdGFydCBwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4MykgPT09IHgzKSB7XG4gICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDMsIHg0LCB4MikgPT09IHgyKSB7XG4gICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGFyYWxsZWwsIG5vbi1jb2luY2lkZW50XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59O1xudmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gIHZhciB4ID0gY2VudGVyWDtcbiAgdmFyIHkgPSBjZW50ZXJZO1xuICByZXQucHVzaCh7XG4gICAgeDogeCArIGhhbGZXICogcG9pbnRzWzBdLFxuICAgIHk6IHkgKyBoYWxmSCAqIHBvaW50c1sxXVxuICB9KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgcmV0LnB1c2goe1xuICAgICAgeDogeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSxcbiAgICAgIHk6IHkgKyBoYWxmSCAqIHBvaW50c1tpICogMiArIDFdXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKVxuLy8gaW50ZXJzZWN0IGEgbm9kZSBwb2x5Z29uIChwdHMgdHJhbnNmb3JtZWQpXG4vL1xuLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSApXG4vLyBpbnRlcnNlY3QgdGhlIHBvaW50cyAobm8gdHJhbnNmb3JtKVxudmFyIHBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICB2YXIgaW50ZXJzZWN0aW9uO1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICB2YXIgZG9UcmFuc2Zvcm0gPSB0cnVlO1xuICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgIGRvVHJhbnNmb3JtID0gZmFsc2U7XG4gIH1cbiAgdmFyIHBvaW50cztcbiAgaWYgKGRvVHJhbnNmb3JtKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IGJhc2VQb2ludHNbaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gICAgfVxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IGV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcbiAgICAgIHBvaW50cyA9IGpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gYmFzZVBvaW50cztcbiAgfVxuICB2YXIgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFk7XG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHBvaW50cy5sZW5ndGggLyAyOyBfaTMrKykge1xuICAgIGN1cnJlbnRYID0gcG9pbnRzW19pMyAqIDJdO1xuICAgIGN1cnJlbnRZID0gcG9pbnRzW19pMyAqIDIgKyAxXTtcbiAgICBpZiAoX2kzIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1soX2kzICsgMSkgKiAyXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWyhfaTMgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFggPSBwb2ludHNbMF07XG4gICAgICBuZXh0WSA9IHBvaW50c1sxXTtcbiAgICB9XG4gICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFkpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn07XG52YXIgcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZywgY29ybmVycykge1xuICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICB2YXIgaW50ZXJzZWN0aW9uO1xuICB2YXIgbGluZXMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGggKiAyKTtcbiAgY29ybmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb3JuZXIsIGkpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMl0gPSBjb3JuZXIuc3RhcnRYO1xuICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPSBjb3JuZXIuc3RhcnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lc1tpICogNCAtIDJdID0gY29ybmVyLnN0YXJ0WDtcbiAgICAgIGxpbmVzW2kgKiA0IC0gMV0gPSBjb3JuZXIuc3RhcnRZO1xuICAgIH1cbiAgICBsaW5lc1tpICogNF0gPSBjb3JuZXIuc3RvcFg7XG4gICAgbGluZXNbaSAqIDQgKyAxXSA9IGNvcm5lci5zdG9wWTtcbiAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGNvcm5lci5jeCwgY29ybmVyLmN5LCBjb3JuZXIucmFkaXVzKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aCAvIDQ7IGkrKykge1xuICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGxpbmVzW2kgKiA0XSwgbGluZXNbaSAqIDQgKyAxXSwgbGluZXNbaSAqIDQgKyAyXSwgbGluZXNbaSAqIDQgKyAzXSwgZmFsc2UpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAyKSB7XG4gICAgdmFyIGxvd2VzdEludGVyc2VjdGlvbiA9IFtpbnRlcnNlY3Rpb25zWzBdLCBpbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB2YXIgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3cobG93ZXN0SW50ZXJzZWN0aW9uWzBdIC0geCwgMikgKyBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMV0gLSB5LCAyKTtcbiAgICBmb3IgKHZhciBfaTQgPSAxOyBfaTQgPCBpbnRlcnNlY3Rpb25zLmxlbmd0aCAvIDI7IF9pNCsrKSB7XG4gICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3coaW50ZXJzZWN0aW9uc1tfaTQgKiAyXSAtIHgsIDIpICsgTWF0aC5wb3coaW50ZXJzZWN0aW9uc1tfaTQgKiAyICsgMV0gLSB5LCAyKTtcbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gbG93ZXN0U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIGxvd2VzdEludGVyc2VjdGlvblswXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMl07XG4gICAgICAgIGxvd2VzdEludGVyc2VjdGlvblsxXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdO1xuICAgICAgICBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3dlc3RJbnRlcnNlY3Rpb247XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59O1xudmFyIHNob3J0ZW5JbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbiwgb2Zmc2V0LCBhbW91bnQpIHtcbiAgdmFyIGRpc3AgPSBbaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV1dO1xuICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KGRpc3BbMF0gKiBkaXNwWzBdICsgZGlzcFsxXSAqIGRpc3BbMV0pO1xuICB2YXIgbGVuUmF0aW8gPSAobGVuZ3RoIC0gYW1vdW50KSAvIGxlbmd0aDtcbiAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgfVxuICByZXR1cm4gW29mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdXTtcbn07XG52YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24gZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIHBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucyk7XG4gIHBvaW50cyA9IGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpO1xuICByZXR1cm4gcG9pbnRzO1xufTtcbnZhciBmaXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbiBmaXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKSB7XG4gIHZhciB4LCB5O1xuICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgdmFyIG1pblggPSBJbmZpbml0eSxcbiAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgbWF4WCA9IC1JbmZpbml0eSxcbiAgICBtYXhZID0gLUluZmluaXR5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICB4ID0gcG9pbnRzWzIgKiBpXTtcbiAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV07XG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICB9XG5cbiAgLy8gc3RyZXRjaCBmYWN0b3JzXG4gIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICB2YXIgc3kgPSAyIC8gKG1heFkgLSBtaW5ZKTtcbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgc2lkZXM7IF9pNSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogX2k1XSA9IHBvaW50c1syICogX2k1XSAqIHN4O1xuICAgIHkgPSBwb2ludHNbMiAqIF9pNSArIDFdID0gcG9pbnRzWzIgKiBfaTUgKyAxXSAqIHN5O1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfVxuICBpZiAobWluWSA8IC0xKSB7XG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgc2lkZXM7IF9pNisrKSB7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBfaTYgKyAxXSA9IHBvaW50c1syICogX2k2ICsgMV0gKyAoLTEgLSBtaW5ZKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvaW50cztcbn07XG52YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgaW5jcmVtZW50ID0gMS4wIC8gc2lkZXMgKiAyICogTWF0aC5QSTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBzaWRlcyAlIDIgPT09IDAgPyBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbiAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG4gIHZhciBwb2ludHMgPSBuZXcgQXJyYXkoc2lkZXMgKiAyKTtcbiAgdmFyIGN1cnJlbnRBbmdsZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG4gICAgcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7IC8vIHhcbiAgICBwb2ludHNbMiAqIGkgKyAxXSA9IE1hdGguc2luKC1jdXJyZW50QW5nbGUpOyAvLyB5XG4gIH1cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbi8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxudmFyIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbn07XG5cbi8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXNcbnZhciBnZXRSb3VuZFBvbHlnb25SYWRpdXMgPSBmdW5jdGlvbiBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gTWF0aC5taW4od2lkdGggLyAxMCwgaGVpZ2h0IC8gMTAsIDgpO1xufTtcbnZhciBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGggPSBmdW5jdGlvbiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSB7XG4gIHJldHVybiA4O1xufTtcbnZhciBiZXppZXJQdHNUb1F1YWRDb2VmZiA9IGZ1bmN0aW9uIGJlemllclB0c1RvUXVhZENvZWZmKHAwLCBwMSwgcDIpIHtcbiAgcmV0dXJuIFtwMCAtIDIgKiBwMSArIHAyLCAyICogKHAxIC0gcDApLCBwMF07XG59O1xuXG4vLyBnZXQgY3VydmUgd2lkdGgsIGhlaWdodCwgYW5kIGNvbnRyb2wgcG9pbnQgcG9zaXRpb24gb2Zmc2V0cyBhcyBhIHBlcmNlbnRhZ2Ugb2Ygbm9kZSBoZWlnaHQgLyB3aWR0aFxudmFyIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzID0gZnVuY3Rpb24gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIGhlaWdodE9mZnNldDogTWF0aC5taW4oMTUsIDAuMDUgKiBoZWlnaHQpLFxuICAgIHdpZHRoT2Zmc2V0OiBNYXRoLm1pbigxMDAsIDAuMjUgKiB3aWR0aCksXG4gICAgY3RybFB0T2Zmc2V0UGN0OiAwLjA1XG4gIH07XG59O1xuXG4vLyBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbSAoU0FUKSB0byBkZXRlcm1pbmUgaWYgdHdvIHBvbHlnb25zIGludGVyc2VjdC4gXG4vLyBUaGUgZnVuY3Rpb24gdGFrZXMgdHdvIHBvbHlnb25zIGFzIGlucHV0IGFuZCByZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIFxuLy8gd2hldGhlciB0aGUgdHdvIHBvbHlnb25zIGludGVyc2VjdC5cbmZ1bmN0aW9uIHNhdFBvbHlnb25JbnRlcnNlY3Rpb24ocG9seTEsIHBvbHkyKSB7XG4gIGZ1bmN0aW9uIGdldEF4ZXMocG9seWdvbikge1xuICAgIHZhciBheGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcDEgPSBwb2x5Z29uW2ldO1xuICAgICAgdmFyIHAyID0gcG9seWdvblsoaSArIDEpICUgcG9seWdvbi5sZW5ndGhdO1xuICAgICAgdmFyIGVkZ2UgPSB7XG4gICAgICAgIHg6IHAyLnggLSBwMS54LFxuICAgICAgICB5OiBwMi55IC0gcDEueVxuICAgICAgfTtcbiAgICAgIHZhciBub3JtYWwgPSB7XG4gICAgICAgIHg6IC1lZGdlLnksXG4gICAgICAgIHk6IGVkZ2UueFxuICAgICAgfTtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQobm9ybWFsLnggKiBub3JtYWwueCArIG5vcm1hbC55ICogbm9ybWFsLnkpO1xuICAgICAgYXhlcy5wdXNoKHtcbiAgICAgICAgeDogbm9ybWFsLnggLyBsZW5ndGgsXG4gICAgICAgIHk6IG5vcm1hbC55IC8gbGVuZ3RoXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF4ZXM7XG4gIH1cbiAgZnVuY3Rpb24gcHJvamVjdChwb2x5Z29uLCBheGlzKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvbHlnb24pLFxuICAgICAgX3N0ZXA7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwb2ludCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHBvaW50LnggKiBheGlzLnggKyBwb2ludC55ICogYXhpcy55O1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHByb2plY3Rpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG92ZXJsYXBzKHByb2oxLCBwcm9qMikge1xuICAgIHJldHVybiAhKHByb2oxLm1heCA8IHByb2oyLm1pbiB8fCBwcm9qMi5tYXggPCBwcm9qMS5taW4pO1xuICB9XG4gIHZhciBheGVzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShnZXRBeGVzKHBvbHkxKSksIF90b0NvbnN1bWFibGVBcnJheShnZXRBeGVzKHBvbHkyKSkpO1xuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGF4ZXMpLFxuICAgIF9zdGVwMjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIGF4aXMgPSBfc3RlcDIudmFsdWU7XG4gICAgICB2YXIgcHJvajEgPSBwcm9qZWN0KHBvbHkxLCBheGlzKTtcbiAgICAgIHZhciBwcm9qMiA9IHByb2plY3QocG9seTIsIGF4aXMpO1xuICAgICAgaWYgKCFvdmVybGFwcyhwcm9qMSwgcHJvajIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gb3ZlcmxhcCwgc28gdGhlIHBvbHlnb25zIGRvIG5vdCBpbnRlcnNlY3RcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG4gIHJldHVybiB0cnVlOyAvLyBwb2x5Z29ucyBpbnRlcnNlY3Rcbn1cblxudmFyIHBhZ2VSYW5rRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgZGFtcGluZ0ZhY3RvcjogMC44LFxuICBwcmVjaXNpb246IDAuMDAwMDAxLFxuICBpdGVyYXRpb25zOiAyMDAsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufSk7XG52YXIgZWxlc2ZuJG8gPSB7XG4gIHBhZ2VSYW5rOiBmdW5jdGlvbiBwYWdlUmFuayhvcHRpb25zKSB7XG4gICAgdmFyIF9wYWdlUmFua0RlZmF1bHRzID0gcGFnZVJhbmtEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIGRhbXBpbmdGYWN0b3IgPSBfcGFnZVJhbmtEZWZhdWx0cy5kYW1waW5nRmFjdG9yLFxuICAgICAgcHJlY2lzaW9uID0gX3BhZ2VSYW5rRGVmYXVsdHMucHJlY2lzaW9uLFxuICAgICAgaXRlcmF0aW9ucyA9IF9wYWdlUmFua0RlZmF1bHRzLml0ZXJhdGlvbnMsXG4gICAgICB3ZWlnaHQgPSBfcGFnZVJhbmtEZWZhdWx0cy53ZWlnaHQ7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtTm9kZXNTcWQgPSBudW1Ob2RlcyAqIG51bU5vZGVzO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgIC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cbiAgICB2YXIgbWF0cml4ID0gbmV3IEFycmF5KG51bU5vZGVzU3FkKTtcbiAgICB2YXIgY29sdW1uU3VtID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgYWRkaXRpb25hbFByb2IgPSAoMSAtIGRhbXBpbmdGYWN0b3IpIC8gbnVtTm9kZXM7XG5cbiAgICAvLyBDcmVhdGUgbnVsbCBtYXRyaXhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICB2YXIgbiA9IGkgKiBudW1Ob2RlcyArIGo7XG4gICAgICAgIG1hdHJpeFtuXSA9IDA7XG4gICAgICB9XG4gICAgICBjb2x1bW5TdW1baV0gPSAwO1xuICAgIH1cblxuICAgIC8vIE5vdywgcHJvY2VzcyBlZGdlc1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1FZGdlczsgX2krKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaV07XG4gICAgICB2YXIgc3JjSWQgPSBlZGdlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgdmFyIHRndElkID0gZWRnZS5kYXRhKCd0YXJnZXQnKTtcblxuICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBsb29wcyBpbiB0aGUgbWF0cml4XG4gICAgICBpZiAoc3JjSWQgPT09IHRndElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHMgPSBub2Rlcy5pbmRleE9mSWQoc3JjSWQpO1xuICAgICAgdmFyIHQgPSBub2Rlcy5pbmRleE9mSWQodGd0SWQpO1xuICAgICAgdmFyIHcgPSB3ZWlnaHQoZWRnZSk7XG4gICAgICB2YXIgX24gPSB0ICogbnVtTm9kZXMgKyBzO1xuXG4gICAgICAvLyBVcGRhdGUgbWF0cml4XG4gICAgICBtYXRyaXhbX25dICs9IHc7XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG4gICAgICBjb2x1bW5TdW1bc10gKz0gdztcbiAgICB9XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBwcm9iYWJpbGl0eSBiYXNlZCBvbiBkYW1waW5nIGZhY3RvclxuICAgIC8vIEFsc28sIHRha2UgaW50byBhY2NvdW50IGNvbHVtbnMgdGhhdCBoYXZlIHN1bSA9IDBcbiAgICB2YXIgcCA9IDEuMCAvIG51bU5vZGVzICsgYWRkaXRpb25hbFByb2I7IC8vIFNob3J0aGFuZFxuXG4gICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG51bU5vZGVzOyBfaisrKSB7XG4gICAgICBpZiAoY29sdW1uU3VtW19qXSA9PT0gMCkge1xuICAgICAgICAvLyBObyAnbGlua3MnIG91dCBmcm9tIG5vZGUganRoLCBhc3N1bWUgZXF1YWwgcHJvYmFiaWxpdHkgZm9yIGVhY2ggcG9zc2libGUgbm9kZVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBudW1Ob2RlczsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX24yID0gX2kyICogbnVtTm9kZXMgKyBfajtcbiAgICAgICAgICBtYXRyaXhbX24yXSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vZGUganRoIGhhcyBvdXRnb2luZyBsaW5rLCBjb21wdXRlIG5vcm1hbGl6ZWQgcHJvYmFiaWxpdGllc1xuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgX24zID0gX2kzICogbnVtTm9kZXMgKyBfajtcbiAgICAgICAgICBtYXRyaXhbX24zXSA9IG1hdHJpeFtfbjNdIC8gY29sdW1uU3VtW19qXSArIGFkZGl0aW9uYWxQcm9iO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBkb21pbmFudCBlaWdlbnZlY3RvciB1c2luZyBwb3dlciBtZXRob2RcbiAgICB2YXIgZWlnZW52ZWN0b3IgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciB0ZW1wID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgcHJldmlvdXM7XG5cbiAgICAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG51bU5vZGVzOyBfaTQrKykge1xuICAgICAgZWlnZW52ZWN0b3JbX2k0XSA9IDE7XG4gICAgfVxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDwgaXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgICAvLyBUZW1wIGFycmF5IHdpdGggYWxsIDAnc1xuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbnVtTm9kZXM7IF9pNSsrKSB7XG4gICAgICAgIHRlbXBbX2k1XSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGx5IG1hdHJpeCB3aXRoIHByZXZpb3VzIHJlc3VsdFxuICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbnVtTm9kZXM7IF9pNisrKSB7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG51bU5vZGVzOyBfajIrKykge1xuICAgICAgICAgIHZhciBfbjQgPSBfaTYgKiBudW1Ob2RlcyArIF9qMjtcbiAgICAgICAgICB0ZW1wW19pNl0gKz0gbWF0cml4W19uNF0gKiBlaWdlbnZlY3RvcltfajJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpblBsYWNlU3VtTm9ybWFsaXplKHRlbXApO1xuICAgICAgcHJldmlvdXMgPSBlaWdlbnZlY3RvcjtcbiAgICAgIGVpZ2VudmVjdG9yID0gdGVtcDtcbiAgICAgIHRlbXAgPSBwcmV2aW91cztcbiAgICAgIHZhciBkaWZmID0gMDtcbiAgICAgIC8vIENvbXB1dGUgZGlmZmVyZW5jZSAoc3F1YXJlZCBtb2R1bGUpIG9mIGJvdGggdmVjdG9yc1xuICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgbnVtTm9kZXM7IF9pNysrKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IHByZXZpb3VzW19pN10gLSBlaWdlbnZlY3RvcltfaTddO1xuICAgICAgICBkaWZmICs9IGRlbHRhICogZGVsdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSBkZXNpcmVkIHRocmVzaG9sZCwgc3RvcCBpdGVyYXRpbmdcbiAgICAgIGlmIChkaWZmIDwgcHJlY2lzaW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICB2YXIgcmVzID0ge1xuICAgICAgcmFuazogZnVuY3Rpb24gcmFuayhub2RlKSB7XG4gICAgICAgIG5vZGUgPSBjeS5jb2xsZWN0aW9uKG5vZGUpWzBdO1xuICAgICAgICByZXR1cm4gZWlnZW52ZWN0b3Jbbm9kZXMuaW5kZXhPZihub2RlKV07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIHBhZ2VSYW5rXG59OyAvLyBlbGVzZm5cblxudmFyIGRlZmF1bHRzJGYgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIGFscGhhOiAwXG59KTtcbnZhciBlbGVzZm4kbiA9IHtcbiAgZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMkZihvcHRpb25zKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICBpZiAoIW9wdGlvbnMuZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4RGVncmVlID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuICAgICAgICBvcHRpb25zLnJvb3QgPSBub2RlO1xuICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKTtcbiAgICAgICAgaWYgKG1heERlZ3JlZSA8IGN1cnJEZWdyZWUuZGVncmVlKSB7XG4gICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWdyZWU6IGZ1bmN0aW9uIGRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgaWYgKG1heERlZ3JlZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhEZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbmRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBvdXRkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4SW5kZWdyZWUgPSAwO1xuICAgICAgdmFyIG1heE91dGRlZ3JlZSA9IDA7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnVtTm9kZXM7IF9pKyspIHtcbiAgICAgICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuICAgICAgICB2YXIgaWQgPSBfbm9kZS5pZCgpO1xuXG4gICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuICAgICAgICBvcHRpb25zLnJvb3QgPSBfbm9kZTtcbiAgICAgICAgdmFyIF9jdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuICAgICAgICBpZiAobWF4SW5kZWdyZWUgPCBfY3VyckRlZ3JlZS5pbmRlZ3JlZSkgbWF4SW5kZWdyZWUgPSBfY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA8IF9jdXJyRGVncmVlLm91dGRlZ3JlZSkgbWF4T3V0ZGVncmVlID0gX2N1cnJEZWdyZWUub3V0ZGVncmVlO1xuICAgICAgICBpbmRlZ3JlZXNbaWRdID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgIG91dGRlZ3JlZXNbaWRdID0gX2N1cnJEZWdyZWUub3V0ZGVncmVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uIGluZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heEluZGVncmVlO1xuICAgICAgICB9LFxuICAgICAgICBvdXRkZWdyZWU6IGZ1bmN0aW9uIG91dGRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXRkZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhPdXRkZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvLyBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZFxuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlclxuICAvLyBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIlxuICAvLyBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgZGVncmVlQ2VudHJhbGl0eTogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJGYob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHJvb3QgPSBfb3B0aW9ucy5yb290LFxuICAgICAgd2VpZ2h0ID0gX29wdGlvbnMud2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQgPSBfb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgIGFscGhhID0gX29wdGlvbnMuYWxwaGE7XG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07XG4gICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgdmFyIGNvbm5FZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oY2FsbGluZ0VsZXMpO1xuICAgICAgdmFyIGsgPSBjb25uRWRnZXMubGVuZ3RoO1xuICAgICAgdmFyIHMgPSAwO1xuXG4gICAgICAvLyBOb3csIHN1bSBlZGdlIHdlaWdodHNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgKz0gd2VpZ2h0KGNvbm5FZGdlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWdyZWU6IE1hdGgucG93KGssIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzLCBhbHBoYSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgIHZhciBpbmNvbWluZyA9IGVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS50YXJnZXQoKS5zYW1lKHJvb3QpICYmIGNhbGxpbmdFbGVzLmhhcyhlZGdlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG91dGdvaW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnNvdXJjZSgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIga19pbiA9IGluY29taW5nLmxlbmd0aDtcbiAgICAgIHZhciBrX291dCA9IG91dGdvaW5nLmxlbmd0aDtcbiAgICAgIHZhciBzX2luID0gMDtcbiAgICAgIHZhciBzX291dCA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGluY29taW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jb21pbmcubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBzX2luICs9IHdlaWdodChpbmNvbWluZ1tfaTJdKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93LCBzdW0gb3V0Z29pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBvdXRnb2luZy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHNfb3V0ICs9IHdlaWdodChvdXRnb2luZ1tfaTNdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBNYXRoLnBvdyhrX2luLCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19pbiwgYWxwaGEpLFxuICAgICAgICBvdXRkZWdyZWU6IE1hdGgucG93KGtfb3V0LCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19vdXQsIGFscGhhKVxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gZGVncmVlQ2VudHJhbGl0eVxufTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuZWxlc2ZuJG4uZGMgPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5O1xuZWxlc2ZuJG4uZGNuID0gZWxlc2ZuJG4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxudmFyIGRlZmF1bHRzJGUgPSBkZWZhdWx0cyRnKHtcbiAgaGFybW9uaWM6IHRydWUsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KCkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIHJvb3Q6IG51bGxcbn0pO1xudmFyIGVsZXNmbiRtID0ge1xuICBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQob3B0aW9ucykge1xuICAgIHZhciBfZGVmYXVsdHMgPSBkZWZhdWx0cyRlKG9wdGlvbnMpLFxuICAgICAgaGFybW9uaWMgPSBfZGVmYXVsdHMuaGFybW9uaWMsXG4gICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMud2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMuZGlyZWN0ZWQ7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBjbG9zZW5lc3NlcyA9IHt9O1xuICAgIHZhciBtYXhDbG9zZW5lc3MgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgZncgPSB0aGlzLmZsb3lkV2Fyc2hhbGwoe1xuICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICB9KTtcblxuICAgIC8vIENvbXB1dGUgY2xvc2VuZXNzIGZvciBldmVyeSBub2RlIGFuZCBmaW5kIHRoZSBtYXhpbXVtIGNsb3NlbmVzc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyQ2xvc2VuZXNzID0gMDtcbiAgICAgIHZhciBub2RlX2kgPSBub2Rlc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICB2YXIgZCA9IGZ3LmRpc3RhbmNlKG5vZGVfaSwgbm9kZXNbal0pO1xuICAgICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSAxIC8gZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXJtb25pYykge1xuICAgICAgICBjdXJyQ2xvc2VuZXNzID0gMSAvIGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG4gICAgICBpZiAobWF4Q2xvc2VuZXNzIDwgY3VyckNsb3NlbmVzcykge1xuICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuICAgICAgY2xvc2VuZXNzZXNbbm9kZV9pLmlkKCldID0gY3VyckNsb3NlbmVzcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb3NlbmVzczogZnVuY3Rpb24gY2xvc2VuZXNzKG5vZGUpIHtcbiAgICAgICAgaWYgKG1heENsb3NlbmVzcyA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpWzBdLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9zZW5lc3Nlc1tub2RlXSAvIG1heENsb3NlbmVzcztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgY2xvc2VuZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gY2xvc2VuZXNzQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0czIgPSBkZWZhdWx0cyRlKG9wdGlvbnMpLFxuICAgICAgcm9vdCA9IF9kZWZhdWx0czIucm9vdCxcbiAgICAgIHdlaWdodCA9IF9kZWZhdWx0czIud2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMyLmRpcmVjdGVkLFxuICAgICAgaGFybW9uaWMgPSBfZGVmYXVsdHMyLmhhcm1vbmljO1xuICAgIHJvb3QgPSB0aGlzLmZpbHRlcihyb290KVswXTtcblxuICAgIC8vIHdlIG5lZWQgZGlzdGFuY2UgZnJvbSB0aGlzIG5vZGUgdG8gZXZlcnkgb3RoZXIgbm9kZVxuICAgIHZhciBkaWprc3RyYSA9IHRoaXMuZGlqa3N0cmEoe1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgfSk7XG4gICAgdmFyIHRvdGFsRGlzdGFuY2UgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgICAgaWYgKCFuLnNhbWUocm9vdCkpIHtcbiAgICAgICAgdmFyIGQgPSBkaWprc3RyYS5kaXN0YW5jZVRvKG4pO1xuICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFybW9uaWMgPyB0b3RhbERpc3RhbmNlIDogMSAvIHRvdGFsRGlzdGFuY2U7XG4gIH0gLy8gY2xvc2VuZXNzQ2VudHJhbGl0eVxufTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuZWxlc2ZuJG0uY2MgPSBlbGVzZm4kbS5jbG9zZW5lc3NDZW50cmFsaXR5O1xuZWxlc2ZuJG0uY2NuID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4kbS5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxudmFyIGRlZmF1bHRzJGQgPSBkZWZhdWx0cyRnKHtcbiAgd2VpZ2h0OiBudWxsLFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRsID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHRoZSBhbGdvcml0aG0gaW4gdGhlIHBhcGVyIFwiT24gVmFyaWFudHMgb2YgU2hvcnRlc3QtUGF0aCBCZXR3ZWVubmVzcyBDZW50cmFsaXR5IGFuZCB0aGVpciBHZW5lcmljIENvbXB1dGF0aW9uXCIgYnkgVWxyaWsgQnJhbmRlc1xuICBiZXR3ZWVubmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIGJldHdlZW5uZXNzQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRzJGQob3B0aW9ucyksXG4gICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQ7XG4gICAgdmFyIHdlaWdodGVkID0gd2VpZ2h0ICE9IG51bGw7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gc3RhcnRpbmdcbiAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgQSA9IHt9O1xuICAgIHZhciBfQyA9IHt9O1xuICAgIHZhciBtYXggPSAwO1xuICAgIHZhciBDID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICAgICAgX0Nba2V5XSA9IHZhbDtcbiAgICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX0Nba2V5XTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQSBjb250YWlucyB0aGUgbmVpZ2hib3Job29kcyBvZiBldmVyeSBub2RlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdiA9IFZbaV07XG4gICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgIEFbdmlkXSA9IHYub3V0Z29lcnMoKS5ub2RlcygpOyAvLyBnZXQgb3V0Z29lcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQVt2aWRdID0gdi5vcGVuTmVpZ2hib3Job29kKCkubm9kZXMoKTsgLy8gZ2V0IG5laWdoYm9ycyBvZiBldmVyeSBub2RlXG4gICAgICB9XG4gICAgICBDLnNldCh2aWQsIDApO1xuICAgIH1cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBzaWQgPSBWW3NdLmlkKCk7XG4gICAgICB2YXIgUyA9IFtdOyAvLyBzdGFja1xuICAgICAgdmFyIFAgPSB7fTtcbiAgICAgIHZhciBnID0ge307XG4gICAgICB2YXIgZCA9IHt9O1xuICAgICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZFthXSAtIGRbYl07XG4gICAgICB9KTsgLy8gcXVldWVcblxuICAgICAgLy8gaW5pdCBkaWN0aW9uYXJpZXNcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBWLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3ZpZCA9IFZbX2ldLmlkKCk7XG4gICAgICAgIFBbX3ZpZF0gPSBbXTtcbiAgICAgICAgZ1tfdmlkXSA9IDA7XG4gICAgICAgIGRbX3ZpZF0gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIGdbc2lkXSA9IDE7IC8vIHNpZ21hXG4gICAgICBkW3NpZF0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgIFEucHVzaChzaWQpO1xuICAgICAgd2hpbGUgKCFRLmVtcHR5KCkpIHtcbiAgICAgICAgdmFyIF92ID0gUS5wb3AoKTtcbiAgICAgICAgUy5wdXNoKF92KTtcbiAgICAgICAgaWYgKHdlaWdodGVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBBW192XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHcgPSBBW192XVtqXTtcbiAgICAgICAgICAgIHZhciB2RWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoX3YpO1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodkVsZS5lZGdlc1RvKHcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZWRnZSA9IHZFbGUuZWRnZXNUbyh3KVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSB3LmVkZ2VzVG8odkVsZSlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodChlZGdlKTtcbiAgICAgICAgICAgIHcgPSB3LmlkKCk7XG4gICAgICAgICAgICBpZiAoZFt3XSA+IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBkW3ddID0gZFtfdl0gKyBlZGdlV2VpZ2h0O1xuICAgICAgICAgICAgICBpZiAoUS5ub2Rlcy5pbmRleE9mKHcpIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vaWYgdyBpcyBub3QgaW4gUVxuICAgICAgICAgICAgICAgIFEucHVzaCh3KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gaWYgdyBpcyBpbiBRXG4gICAgICAgICAgICAgICAgUS51cGRhdGVJdGVtKHcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGdbd10gPSAwO1xuICAgICAgICAgICAgICBQW3ddID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFt3XSA9PSBkW192XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW192XTtcbiAgICAgICAgICAgICAgUFt3XS5wdXNoKF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IEFbX3ZdLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgdmFyIF93ID0gQVtfdl1bX2pdLmlkKCk7XG4gICAgICAgICAgICBpZiAoZFtfd10gPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgUS5wdXNoKF93KTtcbiAgICAgICAgICAgICAgZFtfd10gPSBkW192XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFtfd10gPT0gZFtfdl0gKyAxKSB7XG4gICAgICAgICAgICAgIGdbX3ddID0gZ1tfd10gKyBnW192XTtcbiAgICAgICAgICAgICAgUFtfd10ucHVzaChfdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZSA9IHt9O1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgVi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGVbVltfaTJdLmlkKCldID0gMDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF93MiA9IFMucG9wKCk7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IFBbX3cyXS5sZW5ndGg7IF9qMisrKSB7XG4gICAgICAgICAgdmFyIF92MiA9IFBbX3cyXVtfajJdO1xuICAgICAgICAgIGVbX3YyXSA9IGVbX3YyXSArIGdbX3YyXSAvIGdbX3cyXSAqICgxICsgZVtfdzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3cyICE9IFZbc10uaWQoKSkge1xuICAgICAgICAgIEMuc2V0KF93MiwgQy5nZXQoX3cyKSArIGVbX3cyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiBiZXR3ZWVubmVzcyhub2RlKSB7XG4gICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKTtcbiAgICAgIH0sXG4gICAgICBiZXR3ZWVubmVzc05vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGJldHdlZW5uZXNzTm9ybWFsaXplZChub2RlKSB7XG4gICAgICAgIGlmIChtYXggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKSAvIG1heDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWxpYXNcbiAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxufTsgLy8gZWxlc2ZuXG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuZWxlc2ZuJGwuYmMgPSBlbGVzZm4kbC5iZXR3ZWVubmVzc0NlbnRyYWxpdHk7XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5dG9zY2FwZS9jeXRvc2NhcGUuanMtbWFya292LWNsdXN0ZXJcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGRlZmF1bHRzJGMgPSBkZWZhdWx0cyRnKHtcbiAgZXhwYW5kRmFjdG9yOiAyLFxuICAvLyBhZmZlY3RzIHRpbWUgb2YgY29tcHV0YXRpb24gYW5kIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgdG8gc29tZSBleHRlbnQ6IE0gKiBNXG4gIGluZmxhdGVGYWN0b3I6IDIsXG4gIC8vIGFmZmVjdHMgY2x1c3RlciBncmFudWxhcml0eSAodGhlIGdyZWF0ZXIgdGhlIHZhbHVlLCB0aGUgbW9yZSBjbHVzdGVycyk6IE0oaSxqKSAvIEUoailcbiAgbXVsdEZhY3RvcjogMSxcbiAgLy8gb3B0aW9uYWwgc2VsZiBsb29wcyBmb3IgZWFjaCBub2RlLiBVc2UgYSBuZXV0cmFsIHZhbHVlIHRvIGltcHJvdmUgY2x1c3RlciBjb21wdXRhdGlvbnMuXG4gIG1heEl0ZXJhdGlvbnM6IDIwLFxuICAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIG9mIHRoZSBNQ0wgYWxnb3JpdGhtIGluIGEgc2luZ2xlIHJ1blxuICBhdHRyaWJ1dGVzOiBbXG4gIC8vIGF0dHJpYnV0ZXMvZmVhdHVyZXMgdXNlZCB0byBncm91cCBub2RlcywgaWUuIHNpbWlsYXJpdHkgdmFsdWVzIGJldHdlZW4gbm9kZXNcbiAgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfV1cbn0pO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgc2V0T3B0aW9ucyQzID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBkZWZhdWx0cyRjKG9wdGlvbnMpO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGdldFNpbWlsYXJpdHkkMSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkoZWRnZSwgYXR0cmlidXRlcykge1xuICB2YXIgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSBhdHRyaWJ1dGVzW2ldKGVkZ2UpO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn07XG52YXIgYWRkTG9vcHMgPSBmdW5jdGlvbiBhZGRMb29wcyhNLCBuLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBNW2kgKiBuICsgaV0gPSB2YWw7XG4gIH1cbn07XG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKE0sIG4pIHtcbiAgdmFyIHN1bTtcbiAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbjsgY29sKyspIHtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG47IHJvdysrKSB7XG4gICAgICBzdW0gKz0gTVtyb3cgKiBuICsgY29sXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX3JvdyA9IDA7IF9yb3cgPCBuOyBfcm93KyspIHtcbiAgICAgIE1bX3JvdyAqIG4gKyBjb2xdID0gTVtfcm93ICogbiArIGNvbF0gLyBzdW07XG4gICAgfVxuICB9XG59O1xuXG4vLyBUT0RPOiBibG9ja2VkIG1hdHJpeCBtdWx0aXBsaWNhdGlvbj9cbnZhciBtbXVsdCA9IGZ1bmN0aW9uIG1tdWx0KEEsIEIsIG4pIHtcbiAgdmFyIEMgPSBuZXcgQXJyYXkobiAqIG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBDW2kgKiBuICsgal0gPSAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgQ1tpICogbiArIF9qXSArPSBBW2kgKiBuICsga10gKiBCW2sgKiBuICsgX2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gQztcbn07XG52YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKE0sIG4sIGV4cGFuZEZhY3RvciAvKiogcG93ZXIgKiovKSB7XG4gIHZhciBfTSA9IE0uc2xpY2UoMCk7XG4gIGZvciAodmFyIHAgPSAxOyBwIDwgZXhwYW5kRmFjdG9yOyBwKyspIHtcbiAgICBNID0gbW11bHQoTSwgX00sIG4pO1xuICB9XG4gIHJldHVybiBNO1xufTtcbnZhciBpbmZsYXRlID0gZnVuY3Rpb24gaW5mbGF0ZShNLCBuLCBpbmZsYXRlRmFjdG9yIC8qKiByICoqLykge1xuICB2YXIgX00gPSBuZXcgQXJyYXkobiAqIG4pO1xuXG4gIC8vIE0oaSxqKSBeIGluZmxhdGVQb3dlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4gKiBuOyBpKyspIHtcbiAgICBfTVtpXSA9IE1hdGgucG93KE1baV0sIGluZmxhdGVGYWN0b3IpO1xuICB9XG4gIG5vcm1hbGl6ZShfTSwgbik7XG4gIHJldHVybiBfTTtcbn07XG52YXIgaGFzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgcm91bmRGYWN0b3IpIHtcbiAgLy8gQ2hlY2sgdGhhdCBib3RoIG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgKGksailcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMjsgaSsrKSB7XG4gICAgdmFyIHYxID0gTWF0aC5yb3VuZChNW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpOyAvLyB0cnVuY2F0ZSB0byAncm91bmRGYWN0b3InIGRlY2ltYWwgcGxhY2VzXG4gICAgdmFyIHYyID0gTWF0aC5yb3VuZChfTVtpXSAqIE1hdGgucG93KDEwLCByb3VuZEZhY3RvcikpIC8gTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKTtcbiAgICBpZiAodjEgIT09IHYyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBhc3NpZ24kMiA9IGZ1bmN0aW9uIGFzc2lnbihNLCBuLCBub2RlcywgY3kpIHtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGNsdXN0ZXIgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgLy8gUm93LXdpc2UgYXR0cmFjdG9ycyBhbmQgZWxlbWVudHMgdGhhdCB0aGV5IGF0dHJhY3QgYmVsb25nIGluIHNhbWUgY2x1c3RlclxuICAgICAgaWYgKE1hdGgucm91bmQoTVtpICogbiArIGpdICogMTAwMCkgLyAxMDAwID4gMCkge1xuICAgICAgICBjbHVzdGVyLnB1c2gobm9kZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2x1c3Rlci5sZW5ndGggIT09IDApIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goY3kuY29sbGVjdGlvbihjbHVzdGVyKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgaXNEdXBsaWNhdGUgPSBmdW5jdGlvbiBpc0R1cGxpY2F0ZShjMSwgYzIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjMS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghYzJbaV0gfHwgYzFbaV0uaWQoKSAhPT0gYzJbaV0uaWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgcmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpICE9IGogJiYgaXNEdXBsaWNhdGUoY2x1c3RlcnNbaV0sIGNsdXN0ZXJzW2pdKSkge1xuICAgICAgICBjbHVzdGVycy5zcGxpY2UoaiwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgbWFya292Q2x1c3RlcmluZyA9IGZ1bmN0aW9uIG1hcmtvdkNsdXN0ZXJpbmcob3B0aW9ucykge1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gIC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTpcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDMob3B0aW9ucyk7XG5cbiAgLy8gTWFwIGVhY2ggbm9kZSB0byBpdHMgcG9zaXRpb24gaW4gbm9kZSBhcnJheVxuICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHN0b2NoYXN0aWMgbWF0cml4IE0gZnJvbSBpbnB1dCBncmFwaCBHIChzaG91bGQgYmUgc3ltbWV0cmljL3VuZGlyZWN0ZWQpXG4gIHZhciBuID0gbm9kZXMubGVuZ3RoLFxuICAgIG4yID0gbiAqIG47XG4gIHZhciBNID0gbmV3IEFycmF5KG4yKSxcbiAgICBfTTtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgTVtfaV0gPSAwO1xuICB9XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgIHZhciBfaTIgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgIHZhciBqID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICB2YXIgc2ltID0gZ2V0U2ltaWxhcml0eSQxKGVkZ2UsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgTVtfaTIgKiBuICsgal0gKz0gc2ltOyAvLyBHIHNob3VsZCBiZSBzeW1tZXRyaWMgYW5kIHVuZGlyZWN0ZWRcbiAgICBNW2ogKiBuICsgX2kyXSArPSBzaW07XG4gIH1cblxuICAvLyBCZWdpbiBNYXJrb3YgY2x1c3RlciBhbGdvcml0aG1cblxuICAvLyBTdGVwIDE6IEFkZCBzZWxmIGxvb3BzIHRvIGVhY2ggbm9kZSwgaWUuIGFkZCBtdWx0RmFjdG9yIHRvIG1hdHJpeCBkaWFnb25hbFxuICBhZGRMb29wcyhNLCBuLCBvcHRzLm11bHRGYWN0b3IpO1xuXG4gIC8vIFN0ZXAgMjogTSA9IG5vcm1hbGl6ZSggTSApO1xuICBub3JtYWxpemUoTSwgbik7XG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuXG4gICAgLy8gU3RlcCAzOlxuICAgIF9NID0gZXhwYW5kKE0sIG4sIG9wdHMuZXhwYW5kRmFjdG9yKTtcblxuICAgIC8vIFN0ZXAgNDpcbiAgICBNID0gaW5mbGF0ZShfTSwgbiwgb3B0cy5pbmZsYXRlRmFjdG9yKTtcblxuICAgIC8vIFN0ZXAgNTogY2hlY2sgdG8gc2VlIGlmIH5zdGVhZHkgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZFxuICAgIGlmICghaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgNCkpIHtcbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cblxuICAvLyBCdWlsZCBjbHVzdGVycyBmcm9tIG1hdHJpeFxuICB2YXIgY2x1c3RlcnMgPSBhc3NpZ24kMihNLCBuLCBub2RlcywgY3kpO1xuXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGUgY2x1c3RlcnMgZHVlIHRvIHN5bW1ldHJ5IG9mIGdyYXBoIGFuZCBNIG1hdHJpeFxuICBjbHVzdGVycyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIG1hcmtvdkNsdXN0ZXJpbmckMSA9IHtcbiAgbWFya292Q2x1c3RlcmluZzogbWFya292Q2x1c3RlcmluZyxcbiAgbWNsOiBtYXJrb3ZDbHVzdGVyaW5nXG59O1xuXG4vLyBDb21tb24gZGlzdGFuY2UgbWV0cmljcyBmb3IgY2x1c3RlcmluZyBhbGdvcml0aG1zXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IaWVyYXJjaGljYWxfY2x1c3RlcmluZyNNZXRyaWNcblxudmFyIGlkZW50aXR5JDEgPSBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufTtcbnZhciBhYnNEaWZmID0gZnVuY3Rpb24gYWJzRGlmZihwLCBxKSB7XG4gIHJldHVybiBNYXRoLmFicyhxIC0gcCk7XG59O1xudmFyIGFkZEFic0RpZmYgPSBmdW5jdGlvbiBhZGRBYnNEaWZmKHRvdGFsLCBwLCBxKSB7XG4gIHJldHVybiB0b3RhbCArIGFic0RpZmYocCwgcSk7XG59O1xudmFyIGFkZFNxdWFyZWREaWZmID0gZnVuY3Rpb24gYWRkU3F1YXJlZERpZmYodG90YWwsIHAsIHEpIHtcbiAgcmV0dXJuIHRvdGFsICsgTWF0aC5wb3cocSAtIHAsIDIpO1xufTtcbnZhciBzcXJ0ID0gZnVuY3Rpb24gc3FydCh4KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoeCk7XG59O1xudmFyIG1heEFic0RpZmYgPSBmdW5jdGlvbiBtYXhBYnNEaWZmKGN1cnJlbnRNYXgsIHAsIHEpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRNYXgsIGFic0RpZmYocCwgcSkpO1xufTtcbnZhciBnZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgaW5pdCwgdmlzaXQpIHtcbiAgdmFyIHBvc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGlkZW50aXR5JDE7XG4gIHZhciByZXQgPSBpbml0O1xuICB2YXIgcCwgcTtcbiAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgbGVuZ3RoOyBkaW0rKykge1xuICAgIHAgPSBnZXRQKGRpbSk7XG4gICAgcSA9IGdldFEoZGltKTtcbiAgICByZXQgPSB2aXNpdChyZXQsIHAsIHEpO1xuICB9XG4gIHJldHVybiBwb3N0KHJldCk7XG59O1xudmFyIGRpc3RhbmNlcyA9IHtcbiAgZXVjbGlkZWFuOiBmdW5jdGlvbiBldWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRTcXVhcmVkRGlmZiwgc3FydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBzaW5nbGUgYXR0ciBjYXNlLCBtb3JlIGVmZmljaWVudCB0byBhdm9pZCBzcXJ0XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgICB9XG4gIH0sXG4gIHNxdWFyZWRFdWNsaWRlYW46IGZ1bmN0aW9uIHNxdWFyZWRFdWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYpO1xuICB9LFxuICBtYW5oYXR0YW46IGZ1bmN0aW9uIG1hbmhhdHRhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiBtYXgobGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgLUluZmluaXR5LCBtYXhBYnNEaWZmKTtcbiAgfVxufTtcblxuLy8gaW4gY2FzZSB0aGUgdXNlciBhY2NpZGVudGFsbHkgZG9lc24ndCB1c2UgY2FtZWwgY2FzZVxuZGlzdGFuY2VzWydzcXVhcmVkLWV1Y2xpZGVhbiddID0gZGlzdGFuY2VzWydzcXVhcmVkRXVjbGlkZWFuJ107XG5kaXN0YW5jZXNbJ3NxdWFyZWRldWNsaWRlYW4nXSA9IGRpc3RhbmNlc1snc3F1YXJlZEV1Y2xpZGVhbiddO1xuZnVuY3Rpb24gY2x1c3RlcmluZ0Rpc3RhbmNlIChtZXRob2QsIGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKSB7XG4gIHZhciBpbXBsO1xuICBpZiAoZm4kNihtZXRob2QpKSB7XG4gICAgaW1wbCA9IG1ldGhvZDtcbiAgfSBlbHNlIHtcbiAgICBpbXBsID0gZGlzdGFuY2VzW21ldGhvZF0gfHwgZGlzdGFuY2VzLmV1Y2xpZGVhbjtcbiAgfVxuICBpZiAobGVuZ3RoID09PSAwICYmIGZuJDYobWV0aG9kKSkge1xuICAgIHJldHVybiBpbXBsKG5vZGVQLCBub2RlUSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGltcGwobGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpO1xuICB9XG59XG5cbnZhciBkZWZhdWx0cyRiID0gZGVmYXVsdHMkZyh7XG4gIGs6IDIsXG4gIG06IDIsXG4gIHNlbnNpdGl2aXR5VGhyZXNob2xkOiAwLjAwMDEsXG4gIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgbWF4SXRlcmF0aW9uczogMTAsXG4gIGF0dHJpYnV0ZXM6IFtdLFxuICB0ZXN0TW9kZTogZmFsc2UsXG4gIHRlc3RDZW50cm9pZHM6IG51bGxcbn0pO1xudmFyIHNldE9wdGlvbnMkMiA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gZGVmYXVsdHMkYihvcHRpb25zKTtcbn07XG5cbnZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdCh0eXBlLCBub2RlLCBjZW50cm9pZCwgYXR0cmlidXRlcywgbW9kZSkge1xuICB2YXIgbm9Ob2RlUCA9IG1vZGUgIT09ICdrTWVkb2lkcyc7XG4gIHZhciBnZXRQID0gbm9Ob2RlUCA/IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGNlbnRyb2lkW2ldO1xuICB9IDogZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlc1tpXShjZW50cm9pZCk7XG4gIH07XG4gIHZhciBnZXRRID0gZnVuY3Rpb24gZ2V0UShpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obm9kZSk7XG4gIH07XG4gIHZhciBub2RlUCA9IGNlbnRyb2lkO1xuICB2YXIgbm9kZVEgPSBub2RlO1xuICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKHR5cGUsIGF0dHJpYnV0ZXMubGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpO1xufTtcbnZhciByYW5kb21DZW50cm9pZHMgPSBmdW5jdGlvbiByYW5kb21DZW50cm9pZHMobm9kZXMsIGssIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG5kaW0gPSBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgdmFyIG1pbiA9IG5ldyBBcnJheShuZGltKTtcbiAgdmFyIG1heCA9IG5ldyBBcnJheShuZGltKTtcbiAgdmFyIGNlbnRyb2lkcyA9IG5ldyBBcnJheShrKTtcbiAgdmFyIGNlbnRyb2lkID0gbnVsbDtcblxuICAvLyBGaW5kIG1pbiwgbWF4IHZhbHVlcyBmb3IgZWFjaCBhdHRyaWJ1dGUgZGltZW5zaW9uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmRpbTsgaSsrKSB7XG4gICAgbWluW2ldID0gbm9kZXMubWluKGF0dHJpYnV0ZXNbaV0pLnZhbHVlO1xuICAgIG1heFtpXSA9IG5vZGVzLm1heChhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgfVxuXG4gIC8vIEJ1aWxkIGsgY2VudHJvaWRzLCBlYWNoIHJlcHJlc2VudGVkIGFzIGFuIG4tZGltIGZlYXR1cmUgdmVjdG9yXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgazsgYysrKSB7XG4gICAgY2VudHJvaWQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmRpbTsgX2krKykge1xuICAgICAgY2VudHJvaWRbX2ldID0gTWF0aC5yYW5kb20oKSAqIChtYXhbX2ldIC0gbWluW19pXSkgKyBtaW5bX2ldOyAvLyByYW5kb20gaW5pdGlhbCB2YWx1ZVxuICAgIH1cbiAgICBjZW50cm9pZHNbY10gPSBjZW50cm9pZDtcbiAgfVxuICByZXR1cm4gY2VudHJvaWRzO1xufTtcbnZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgZGlzdGFuY2UsIGF0dHJpYnV0ZXMsIHR5cGUpIHtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbnRyb2lkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXN0ID0gZ2V0RGlzdChkaXN0YW5jZSwgbm9kZSwgY2VudHJvaWRzW2ldLCBhdHRyaWJ1dGVzLCB0eXBlKTtcbiAgICBpZiAoZGlzdCA8IG1pbikge1xuICAgICAgbWluID0gZGlzdDtcbiAgICAgIGluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcbnZhciBidWlsZENsdXN0ZXIgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXIoY2VudHJvaWQsIG5vZGVzLCBhc3NpZ25tZW50KSB7XG4gIHZhciBjbHVzdGVyID0gW107XG4gIHZhciBub2RlID0gbnVsbDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICBpZiAoYXNzaWdubWVudFtub2RlLmlkKCldID09PSBjZW50cm9pZCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIk5vZGUgXCIgKyBub2RlLmlkKCkgKyBcIiBpcyBhc3NvY2lhdGVkIHdpdGggbWVkb2lkICM6IFwiICsgbSk7XG4gICAgICBjbHVzdGVyLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbHVzdGVyO1xufTtcbnZhciBoYXZlVmFsdWVzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZVZhbHVlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gIHJldHVybiBNYXRoLmFicyh2MiAtIHYxKSA8PSBzZW5zaXRpdml0eVRocmVzaG9sZDtcbn07XG52YXIgaGF2ZU1hdHJpY2VzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZU1hdHJpY2VzQ29udmVyZ2VkKHYxLCB2Miwgc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdjFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnModjFbaV1bal0gLSB2MltpXVtqXSk7XG4gICAgICBpZiAoZGlmZiA+IHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHNlZW5CZWZvcmUgPSBmdW5jdGlvbiBzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIG4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAobm9kZSA9PT0gbWVkb2lkc1tpXSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciByYW5kb21NZWRvaWRzID0gZnVuY3Rpb24gcmFuZG9tTWVkb2lkcyhub2Rlcywgaykge1xuICB2YXIgbWVkb2lkcyA9IG5ldyBBcnJheShrKTtcblxuICAvLyBGb3Igc21hbGwgZGF0YSBzZXRzLCB0aGUgcHJvYmFiaWxpdHkgb2YgbWVkb2lkIGNvbmZsaWN0IGlzIGdyZWF0ZXIsXG4gIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgc2VlbiBvciBjaG9zZSB0aGlzIG5vZGUgYmVmb3JlLlxuICBpZiAobm9kZXMubGVuZ3RoIDwgNTApIHtcbiAgICAvLyBSYW5kb21seSBzZWxlY3QgayBtZWRvaWRzIGZyb20gdGhlIG4gbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcblxuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBjaG9zZW4gdGhpcyBub2RlIHRvIGJlIGEgbWVkb2lkLCBkb24ndCBjaG9vc2UgaXQgYWdhaW4gKGZvciBzbWFsbCBkYXRhIHNldHMpLlxuICAgICAgLy8gSW5zdGVhZCBjaG9vc2UgYSBkaWZmZXJlbnQgcmFuZG9tIG5vZGUuXG4gICAgICB3aGlsZSAoc2VlbkJlZm9yZShub2RlLCBtZWRvaWRzLCBpKSkge1xuICAgICAgICBub2RlID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgICB9XG4gICAgICBtZWRvaWRzW2ldID0gbm9kZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVsYXRpdmVseSBsYXJnZSBkYXRhIHNldCwgc28gcHJldHR5IHNhZmUgdG8gbm90IGNoZWNrIGFuZCBqdXN0IHNlbGVjdCByYW5kb20gbm9kZXNcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrOyBfaTIrKykge1xuICAgICAgbWVkb2lkc1tfaTJdID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWRvaWRzO1xufTtcbnZhciBmaW5kQ29zdCA9IGZ1bmN0aW9uIGZpbmRDb3N0KHBvdGVudGlhbE5ld01lZG9pZCwgY2x1c3RlciwgYXR0cmlidXRlcykge1xuICB2YXIgY29zdCA9IDA7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgY2x1c3Rlci5sZW5ndGg7IG4rKykge1xuICAgIGNvc3QgKz0gZ2V0RGlzdCgnbWFuaGF0dGFuJywgY2x1c3RlcltuXSwgcG90ZW50aWFsTmV3TWVkb2lkLCBhdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgfVxuICByZXR1cm4gY29zdDtcbn07XG52YXIga01lYW5zID0gZnVuY3Rpb24ga01lYW5zKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBub2RlID0gbnVsbDtcblxuICAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06ICMgb2YgY2x1c3RlcnMsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTtcblxuICAvLyBCZWdpbiBrLW1lYW5zIGFsZ29yaXRobVxuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgdmFyIGNlbnRyb2lkcztcblxuICAvLyBTdGVwIDE6IEluaXRpYWxpemUgY2VudHJvaWQgcG9zaXRpb25zXG4gIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBzZWVkZWQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gICAgICBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNlbnRyb2lkcyA9IG9wdHMudGVzdENlbnRyb2lkcztcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICB9XG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgY2VudHJvaWRcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcbiAgICAgIGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9IGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lYW5zJyk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAzOiBGb3IgZWFjaCBvZiB0aGUgayBjbHVzdGVycywgdXBkYXRlIGl0cyBjZW50cm9pZFxuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9wdHMuazsgYysrKSB7XG4gICAgICAvLyBHZXQgYWxsIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgY2x1c3RlclxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIoYywgbm9kZXMsIGFzc2lnbm1lbnQpO1xuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY2VudHJvaWRzIGJ5IGNhbGN1bGF0aW5nIGF2ZyBvZiBhbGwgbm9kZXMgd2l0aGluIHRoZSBjbHVzdGVyLlxuICAgICAgdmFyIG5kaW0gPSBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRzW2NdOyAvLyBbIGRpbV8xLCBkaW1fMiwgZGltXzMsIC4uLiAsIGRpbV9uIF1cbiAgICAgIHZhciBuZXdDZW50cm9pZCA9IG5ldyBBcnJheShuZGltKTtcbiAgICAgIHZhciBzdW0gPSBuZXcgQXJyYXkobmRpbSk7XG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG5kaW07IGQrKykge1xuICAgICAgICBzdW1bZF0gPSAwLjA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3Rlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBjbHVzdGVyW2ldO1xuICAgICAgICAgIHN1bVtkXSArPSBvcHRzLmF0dHJpYnV0ZXNbZF0obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2VudHJvaWRbZF0gPSBzdW1bZF0gLyBjbHVzdGVyLmxlbmd0aDtcblxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgYWxnb3JpdGhtIGhhcyBjb252ZXJnZWQsIGkuZS4gd2hlbiBjZW50cm9pZHMgbm8gbG9uZ2VyIGNoYW5nZVxuICAgICAgICBpZiAoIWhhdmVWYWx1ZXNDb252ZXJnZWQobmV3Q2VudHJvaWRbZF0sIGNlbnRyb2lkW2RdLCBvcHRzLnNlbnNpdGl2aXR5VGhyZXNob2xkKSkge1xuICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjZW50cm9pZHNbY10gPSBuZXdDZW50cm9pZDtcbiAgICAgIGNsdXN0ZXJzW2NdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICB9XG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIga01lZG9pZHMgPSBmdW5jdGlvbiBrTWVkb2lkcyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgbm9kZSA9IG51bGw7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQyKG9wdGlvbnMpO1xuXG4gIC8vIEJlZ2luIGstbWVkb2lkcyBhbGdvcml0aG1cbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIHZhciBtZWRvaWRzO1xuICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICB2YXIgY3VyQ29zdDtcbiAgdmFyIG1pbkNvc3RzID0gbmV3IEFycmF5KG9wdHMuayk7IC8vIG1pbmltdW0gY29zdCBjb25maWd1cmF0aW9uIGZvciBlYWNoIGNsdXN0ZXJcblxuICAvLyBTdGVwIDE6IEluaXRpYWxpemUgayBtZWRvaWRzXG4gIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSA7IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1lZG9pZHMgPSBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lZG9pZHMgPSByYW5kb21NZWRvaWRzKG5vZGVzLCBvcHRzLmspO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgfVxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIC8vIFN0ZXAgMjogQXNzaWduIG5vZGVzIHRvIHRoZSBuZWFyZXN0IG1lZG9pZFxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgbWVkb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgICB9XG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuICAgIC8vIFN0ZXAgMzogRm9yIGVhY2ggbWVkb2lkIG0sIGFuZCBmb3IgZWFjaCBub2RlIGFzc29jaWF0ZWQgd2l0aCBtZWRpb2QgbSxcbiAgICAvLyBzZWxlY3QgdGhlIG5vZGUgd2l0aCB0aGUgbG93ZXN0IGNvbmZpZ3VyYXRpb24gY29zdCBhcyBuZXcgbWVkb2lkLlxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbWVkb2lkcy5sZW5ndGg7IG0rKykge1xuICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIG1lZG9pZFxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIobSwgbm9kZXMsIGFzc2lnbm1lbnQpO1xuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWluQ29zdHNbbV0gPSBmaW5kQ29zdChtZWRvaWRzW21dLCBjbHVzdGVyLCBvcHRzLmF0dHJpYnV0ZXMpOyAvLyBvcmlnaW5hbCBjb3N0XG5cbiAgICAgIC8vIFNlbGVjdCBkaWZmZXJlbnQgbWVkb2lkIGlmIGl0cyBjb25maWd1cmF0aW9uIGhhcyB0aGUgbG93ZXN0IGNvc3RcbiAgICAgIGZvciAodmFyIF9uID0gMDsgX24gPCBjbHVzdGVyLmxlbmd0aDsgX24rKykge1xuICAgICAgICBjdXJDb3N0ID0gZmluZENvc3QoY2x1c3Rlcltfbl0sIGNsdXN0ZXIsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChjdXJDb3N0IDwgbWluQ29zdHNbbV0pIHtcbiAgICAgICAgICBtaW5Db3N0c1ttXSA9IGN1ckNvc3Q7XG4gICAgICAgICAgbWVkb2lkc1ttXSA9IGNsdXN0ZXJbX25dO1xuICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbHVzdGVyc1ttXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgfVxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIHVwZGF0ZUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpIHtcbiAgdmFyIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbnRyb2lkcy5sZW5ndGg7IGMrKykge1xuICAgICAgd2VpZ2h0W25dW2NdID0gTWF0aC5wb3coVVtuXVtjXSwgb3B0cy5tKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IGNlbnRyb2lkcy5sZW5ndGg7IF9jKyspIHtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgICAgbnVtZXJhdG9yID0gMDtcbiAgICAgIGRlbm9taW5hdG9yID0gMDtcbiAgICAgIGZvciAodmFyIF9uMiA9IDA7IF9uMiA8IG5vZGVzLmxlbmd0aDsgX24yKyspIHtcbiAgICAgICAgbnVtZXJhdG9yICs9IHdlaWdodFtfbjJdW19jXSAqIG9wdHMuYXR0cmlidXRlc1tkaW1dKG5vZGVzW19uMl0pO1xuICAgICAgICBkZW5vbWluYXRvciArPSB3ZWlnaHRbX24yXVtfY107XG4gICAgICB9XG4gICAgICBjZW50cm9pZHNbX2NdW2RpbV0gPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICB9XG4gIH1cbn07XG52YXIgdXBkYXRlTWVtYmVyc2hpcCA9IGZ1bmN0aW9uIHVwZGF0ZU1lbWJlcnNoaXAoVSwgX1UsIGNlbnRyb2lkcywgbm9kZXMsIG9wdHMpIHtcbiAgLy8gU2F2ZSBwcmV2aW91cyBzdGVwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVS5sZW5ndGg7IGkrKykge1xuICAgIF9VW2ldID0gVVtpXS5zbGljZSgpO1xuICB9XG4gIHZhciBzdW0sIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG4gIHZhciBwb3cgPSAyIC8gKG9wdHMubSAtIDEpO1xuICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbnRyb2lkcy5sZW5ndGg7IGMrKykge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNlbnRyb2lkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBhZ2FpbnN0IGFsbCBvdGhlciBjZW50cm9pZHNcbiAgICAgICAgbnVtZXJhdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2NdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgZGVub21pbmF0b3IgPSBnZXREaXN0KG9wdHMuZGlzdGFuY2UsIG5vZGVzW25dLCBjZW50cm9pZHNba10sIG9wdHMuYXR0cmlidXRlcywgJ2NtZWFucycpO1xuICAgICAgICBzdW0gKz0gTWF0aC5wb3cobnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIHBvdyk7XG4gICAgICB9XG4gICAgICBVW25dW2NdID0gMSAvIHN1bTtcbiAgICB9XG4gIH1cbn07XG52YXIgYXNzaWduJDEgPSBmdW5jdGlvbiBhc3NpZ24obm9kZXMsIFUsIG9wdHMsIGN5KSB7XG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICBmb3IgKHZhciBjID0gMDsgYyA8IGNsdXN0ZXJzLmxlbmd0aDsgYysrKSB7XG4gICAgY2x1c3RlcnNbY10gPSBbXTtcbiAgfVxuICB2YXIgbWF4O1xuICB2YXIgaW5kZXg7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgVS5sZW5ndGg7IG4rKykge1xuICAgIC8vIGZvciBlYWNoIG5vZGUgKFUgaXMgTiB4IEMgbWF0cml4KVxuICAgIG1heCA9IC1JbmZpbml0eTtcbiAgICBpbmRleCA9IC0xO1xuICAgIC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoZSBub2RlIGlzIG1vc3QgbGlrZWx5IHRvIGJlbG9uZyBpblxuICAgIGZvciAodmFyIF9jMiA9IDA7IF9jMiA8IFVbMF0ubGVuZ3RoOyBfYzIrKykge1xuICAgICAgaWYgKFVbbl1bX2MyXSA+IG1heCkge1xuICAgICAgICBtYXggPSBVW25dW19jMl07XG4gICAgICAgIGluZGV4ID0gX2MyO1xuICAgICAgfVxuICAgIH1cbiAgICBjbHVzdGVyc1tpbmRleF0ucHVzaChub2Rlc1tuXSk7XG4gIH1cblxuICAvLyBUdXJuIGV2ZXJ5IGFycmF5IGludG8gYSBjb2xsZWN0aW9uIG9mIG5vZGVzXG4gIGZvciAodmFyIF9jMyA9IDA7IF9jMyA8IGNsdXN0ZXJzLmxlbmd0aDsgX2MzKyspIHtcbiAgICBjbHVzdGVyc1tfYzNdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyc1tfYzNdKTtcbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIGZ1enp5Q01lYW5zID0gZnVuY3Rpb24gZnV6enlDTWVhbnMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7XG5cbiAgLy8gQmVnaW4gZnV6enkgYy1tZWFucyBhbGdvcml0aG1cbiAgdmFyIGNsdXN0ZXJzO1xuICB2YXIgY2VudHJvaWRzO1xuICB2YXIgVTtcbiAgdmFyIF9VO1xuICB2YXIgd2VpZ2h0O1xuXG4gIC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBsZXRpYWJsZXMuXG4gIF9VID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICBfVVtpXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG4gIFUgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZXMubGVuZ3RoOyBfaTMrKykge1xuICAgIC8vIE4geCBDIG1hdHJpeFxuICAgIFVbX2kzXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3B0cy5rOyBqKyspIHtcbiAgICAgIFVbX2k0XVtqXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0b3RhbCArPSBVW19pNF1bal07XG4gICAgfVxuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBvcHRzLms7IF9qKyspIHtcbiAgICAgIFVbX2k0XVtfal0gPSBVW19pNF1bX2pdIC8gdG90YWw7XG4gICAgfVxuICB9XG4gIGNlbnRyb2lkcyA9IG5ldyBBcnJheShvcHRzLmspO1xuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBvcHRzLms7IF9pNSsrKSB7XG4gICAgY2VudHJvaWRzW19pNV0gPSBuZXcgQXJyYXkob3B0cy5hdHRyaWJ1dGVzLmxlbmd0aCk7XG4gIH1cbiAgd2VpZ2h0ID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG5vZGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICB3ZWlnaHRbX2k2XSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG4gIC8vIGVuZCBpbml0IEZDTVxuXG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuXG4gICAgLy8gU3RlcCAyOiBDYWxjdWxhdGUgdGhlIGNlbnRyb2lkcyBmb3IgZWFjaCBzdGVwLlxuICAgIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpO1xuXG4gICAgLy8gU3RlcCAzOiBVcGRhdGUgdGhlIHBhcnRpdGlvbiBtYXRyaXggVS5cbiAgICB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKTtcblxuICAgIC8vIFN0ZXAgNDogQ2hlY2sgZm9yIGNvbnZlcmdlbmNlLlxuICAgIGlmICghaGF2ZU1hdHJpY2VzQ29udmVyZ2VkKFUsIF9VLCBvcHRzLnNlbnNpdGl2aXR5VGhyZXNob2xkKSkge1xuICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgfVxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIC8vIEFzc2lnbiBub2RlcyB0byBjbHVzdGVycyB3aXRoIGhpZ2hlc3QgcHJvYmFiaWxpdHkuXG4gIGNsdXN0ZXJzID0gYXNzaWduJDEobm9kZXMsIFUsIG9wdHMsIGN5KTtcbiAgcmV0dXJuIHtcbiAgICBjbHVzdGVyczogY2x1c3RlcnMsXG4gICAgZGVncmVlT2ZNZW1iZXJzaGlwOiBVXG4gIH07XG59O1xudmFyIGtDbHVzdGVyaW5nID0ge1xuICBrTWVhbnM6IGtNZWFucyxcbiAga01lZG9pZHM6IGtNZWRvaWRzLFxuICBmdXp6eUNNZWFuczogZnV6enlDTWVhbnMsXG4gIGZjbTogZnV6enlDTWVhbnNcbn07XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5dG9zY2FwZS9jeXRvc2NhcGUuanMtaGllcmFyY2hpY2FsXG5cbnZhciBkZWZhdWx0cyRhID0gZGVmYXVsdHMkZyh7XG4gIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgLy8gZGlzdGFuY2UgbWV0cmljIHRvIGNvbXBhcmUgbm9kZXNcbiAgbGlua2FnZTogJ21pbicsXG4gIC8vIGxpbmthZ2UgY3JpdGVyaW9uIDogaG93IHRvIGRldGVybWluZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjbHVzdGVycyBvZiBub2Rlc1xuICBtb2RlOiAndGhyZXNob2xkJyxcbiAgLy8gbW9kZTondGhyZXNob2xkJyA9PiBjbHVzdGVycyBtdXN0IGJlIHRocmVzaG9sZCBkaXN0YW5jZSBhcGFydFxuICB0aHJlc2hvbGQ6IEluZmluaXR5LFxuICAvLyB0aGUgZGlzdGFuY2UgdGhyZXNob2xkXG4gIC8vIG1vZGU6J2RlbmRyb2dyYW0nID0+IHRoZSBub2RlcyBhcmUgb3JnYW5pc2VkIGFzIGxlYXZlcyBpbiBhIHRyZWUgKHNpYmxpbmdzIGFyZSBjbG9zZSksIG1lcmdpbmcgbWFrZXMgY2x1c3RlcnNcbiAgYWRkRGVuZHJvZ3JhbTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gYWRkIHRoZSBkZW5kcm9ncmFtIHRvIHRoZSBncmFwaCBmb3Igdml6XG4gIGRlbmRyb2dyYW1EZXB0aDogMCxcbiAgLy8gZGVwdGggYXQgd2hpY2ggZGVuZHJvZ3JhbSBicmFuY2hlcyBhcmUgbWVyZ2VkIGludG8gdGhlIHJldHVybmVkIGNsdXN0ZXJzXG4gIGF0dHJpYnV0ZXM6IFtdIC8vIGFycmF5IG9mIGF0dHIgZnVuY3Rpb25zXG59KTtcbnZhciBsaW5rYWdlQWxpYXNlcyA9IHtcbiAgJ3NpbmdsZSc6ICdtaW4nLFxuICAnY29tcGxldGUnOiAnbWF4J1xufTtcbnZhciBzZXRPcHRpb25zJDEgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBkZWZhdWx0cyRhKG9wdGlvbnMpO1xuICB2YXIgcHJlZmVycmVkQWxpYXMgPSBsaW5rYWdlQWxpYXNlc1tvcHRzLmxpbmthZ2VdO1xuICBpZiAocHJlZmVycmVkQWxpYXMgIT0gbnVsbCkge1xuICAgIG9wdHMubGlua2FnZSA9IHByZWZlcnJlZEFsaWFzO1xuICB9XG4gIHJldHVybiBvcHRzO1xufTtcbnZhciBtZXJnZUNsb3Nlc3QgPSBmdW5jdGlvbiBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cykge1xuICAvLyBGaW5kIHR3byBjbG9zZXN0IGNsdXN0ZXJzIGZyb20gY2FjaGVkIG1pbnNcbiAgdmFyIG1pbktleSA9IDA7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgdmFyIGRpc3Q7XG4gIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcbiAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG4xLCBuMikge1xuICAgIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2Uob3B0cy5kaXN0YW5jZSwgYXR0cnMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4xKTtcbiAgICB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4yKTtcbiAgICB9LCBuMSwgbjIpO1xuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGNsdXN0ZXJzW2ldLmtleTtcbiAgICB2YXIgX2Rpc3QgPSBkaXN0c1trZXldW21pbnNba2V5XV07XG4gICAgaWYgKF9kaXN0IDwgbWluKSB7XG4gICAgICBtaW5LZXkgPSBrZXk7XG4gICAgICBtaW4gPSBfZGlzdDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdHMubW9kZSA9PT0gJ3RocmVzaG9sZCcgJiYgbWluID49IG9wdHMudGhyZXNob2xkIHx8IG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nICYmIGNsdXN0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYzEgPSBpbmRleFttaW5LZXldO1xuICB2YXIgYzIgPSBpbmRleFttaW5zW21pbktleV1dO1xuICB2YXIgbWVyZ2VkO1xuXG4gIC8vIE1lcmdlIHR3byBjbG9zZXN0IGNsdXN0ZXJzXG4gIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgIG1lcmdlZCA9IHtcbiAgICAgIGxlZnQ6IGMxLFxuICAgICAgcmlnaHQ6IGMyLFxuICAgICAga2V5OiBjMS5rZXlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1lcmdlZCA9IHtcbiAgICAgIHZhbHVlOiBjMS52YWx1ZS5jb25jYXQoYzIudmFsdWUpLFxuICAgICAga2V5OiBjMS5rZXlcbiAgICB9O1xuICB9XG4gIGNsdXN0ZXJzW2MxLmluZGV4XSA9IG1lcmdlZDtcbiAgY2x1c3RlcnMuc3BsaWNlKGMyLmluZGV4LCAxKTtcbiAgaW5kZXhbYzEua2V5XSA9IG1lcmdlZDtcblxuICAvLyBVcGRhdGUgZGlzdGFuY2VzIHdpdGggbmV3IG1lcmdlZCBjbHVzdGVyXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBjbHVzdGVycy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgY3VyID0gY2x1c3RlcnNbX2ldO1xuICAgIGlmIChjMS5rZXkgPT09IGN1ci5rZXkpIHtcbiAgICAgIGRpc3QgPSBJbmZpbml0eTtcbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21pbicpIHtcbiAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuICAgICAgaWYgKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPiBkaXN0c1tjMi5rZXldW2N1ci5rZXldKSB7XG4gICAgICAgIGRpc3QgPSBkaXN0c1tjMi5rZXldW2N1ci5rZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWF4Jykge1xuICAgICAgZGlzdCA9IGRpc3RzW2MxLmtleV1bY3VyLmtleV07XG4gICAgICBpZiAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSA8IGRpc3RzW2MyLmtleV1bY3VyLmtleV0pIHtcbiAgICAgICAgZGlzdCA9IGRpc3RzW2MyLmtleV1bY3VyLmtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtZWFuJykge1xuICAgICAgZGlzdCA9IChkaXN0c1tjMS5rZXldW2N1ci5rZXldICogYzEuc2l6ZSArIGRpc3RzW2MyLmtleV1bY3VyLmtleV0gKiBjMi5zaXplKSAvIChjMS5zaXplICsgYzIuc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlLCBjMS52YWx1ZSk7ZWxzZSBkaXN0ID0gZ2V0RGlzdChjdXIudmFsdWVbMF0sIGMxLnZhbHVlWzBdKTtcbiAgICB9XG4gICAgZGlzdHNbYzEua2V5XVtjdXIua2V5XSA9IGRpc3RzW2N1ci5rZXldW2MxLmtleV0gPSBkaXN0OyAvLyBkaXN0YW5jZSBtYXRyaXggaXMgc3ltbWV0cmljXG4gIH1cblxuICAvLyBVcGRhdGUgY2FjaGVkIG1pbnNcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2x1c3RlcnMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBrZXkxID0gY2x1c3RlcnNbX2kyXS5rZXk7XG4gICAgaWYgKG1pbnNba2V5MV0gPT09IGMxLmtleSB8fCBtaW5zW2tleTFdID09PSBjMi5rZXkpIHtcbiAgICAgIHZhciBfbWluID0ga2V5MTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGtleTIgPSBjbHVzdGVyc1tqXS5rZXk7XG4gICAgICAgIGlmIChkaXN0c1trZXkxXVtrZXkyXSA8IGRpc3RzW2tleTFdW19taW5dKSB7XG4gICAgICAgICAgX21pbiA9IGtleTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1pbnNba2V5MV0gPSBfbWluO1xuICAgIH1cbiAgICBjbHVzdGVyc1tfaTJdLmluZGV4ID0gX2kyO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgbWV0YSBkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcbiAgYzEua2V5ID0gYzIua2V5ID0gYzEuaW5kZXggPSBjMi5pbmRleCA9IG51bGw7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBfZ2V0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihyb290LCBhcnIsIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuO1xuICBpZiAocm9vdC52YWx1ZSkge1xuICAgIGFyci5wdXNoKHJvb3QudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChyb290LmxlZnQpIF9nZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGFycik7XG4gICAgaWYgKHJvb3QucmlnaHQpIF9nZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCBhcnIpO1xuICB9XG59O1xudmFyIF9idWlsZERlbmRyb2dyYW0gPSBmdW5jdGlvbiBidWlsZERlbmRyb2dyYW0ocm9vdCwgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gJyc7XG4gIGlmIChyb290LmxlZnQgJiYgcm9vdC5yaWdodCkge1xuICAgIHZhciBsZWZ0U3RyID0gX2J1aWxkRGVuZHJvZ3JhbShyb290LmxlZnQsIGN5KTtcbiAgICB2YXIgcmlnaHRTdHIgPSBfYnVpbGREZW5kcm9ncmFtKHJvb3QucmlnaHQsIGN5KTtcbiAgICB2YXIgbm9kZSA9IGN5LmFkZCh7XG4gICAgICBncm91cDogJ25vZGVzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGxlZnRTdHIgKyAnLCcgKyByaWdodFN0clxuICAgICAgfVxuICAgIH0pO1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc291cmNlOiBsZWZ0U3RyLFxuICAgICAgICB0YXJnZXQ6IG5vZGUuaWQoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc291cmNlOiByaWdodFN0cixcbiAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZS5pZCgpO1xuICB9IGVsc2UgaWYgKHJvb3QudmFsdWUpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZS5pZCgpO1xuICB9XG59O1xudmFyIF9idWlsZENsdXN0ZXJzRnJvbVRyZWUgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdCwgaywgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gW107XG4gIHZhciBsZWZ0ID0gW10sXG4gICAgcmlnaHQgPSBbXSxcbiAgICBsZWF2ZXMgPSBbXTtcbiAgaWYgKGsgPT09IDApIHtcbiAgICAvLyBkb24ndCBjdXQgdHJlZSwgc2ltcGx5IHJldHVybiBhbGwgbm9kZXMgYXMgMSBzaW5nbGUgY2x1c3RlclxuICAgIGlmIChyb290LmxlZnQpIF9nZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgIGlmIChyb290LnJpZ2h0KSBfZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgcmlnaHQpO1xuICAgIGxlYXZlcyA9IGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24obGVhdmVzKV07XG4gIH0gZWxzZSBpZiAoayA9PT0gMSkge1xuICAgIC8vIGN1dCBhdCByb290XG5cbiAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgLy8gbGVhZiBub2RlXG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24ocm9vdC52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocm9vdC5sZWZ0KSBfZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBsZWZ0KTtcbiAgICAgIGlmIChyb290LnJpZ2h0KSBfZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgcmlnaHQpO1xuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKGxlZnQpLCBjeS5jb2xsZWN0aW9uKHJpZ2h0KV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24ocm9vdC52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocm9vdC5sZWZ0KSBsZWZ0ID0gX2J1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LmxlZnQsIGsgLSAxLCBjeSk7XG4gICAgICBpZiAocm9vdC5yaWdodCkgcmlnaHQgPSBfYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QucmlnaHQsIGsgLSAxLCBjeSk7XG4gICAgICByZXR1cm4gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcgPSBmdW5jdGlvbiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOiBsaW5rYWdlIHR5cGUsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMShvcHRpb25zKTtcbiAgdmFyIGF0dHJzID0gb3B0cy5hdHRyaWJ1dGVzO1xuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07XG5cbiAgLy8gQmVnaW4gaGllcmFyY2hpY2FsIGFsZ29yaXRobVxuICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgdmFyIGRpc3RzID0gW107IC8vIGRpc3RhbmNlcyBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuICB2YXIgbWlucyA9IFtdOyAvLyBjbG9zZXN0IGNsdXN0ZXIgZm9yIGVhY2ggY2x1c3RlclxuICB2YXIgaW5kZXggPSBbXTsgLy8gaGFzaCBvZiBhbGwgY2x1c3RlcnMgYnkga2V5XG5cbiAgLy8gSW4gYWdnbG9tZXJhdGl2ZSAoYm90dG9tLXVwKSBjbHVzdGVyaW5nLCBlYWNoIG5vZGUgc3RhcnRzIGFzIGl0cyBvd24gY2x1c3RlclxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIGNsdXN0ZXIgPSB7XG4gICAgICB2YWx1ZTogb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgPyBub2Rlc1tuXSA6IFtub2Rlc1tuXV0sXG4gICAgICBrZXk6IG4sXG4gICAgICBpbmRleDogblxuICAgIH07XG4gICAgY2x1c3RlcnNbbl0gPSBjbHVzdGVyO1xuICAgIGluZGV4W25dID0gY2x1c3RlcjtcbiAgICBkaXN0c1tuXSA9IFtdO1xuICAgIG1pbnNbbl0gPSAwO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICB2YXIgZGlzdCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgICAgICAvLyBtb2RlcyBzdG9yZSBjbHVzdGVyIHZhbHVlcyBkaWZmZXJlbnRseVxuICAgICAgICBkaXN0ID0gaSA9PT0gaiA/IEluZmluaXR5IDogZ2V0RGlzdChjbHVzdGVyc1tpXS52YWx1ZSwgY2x1c3RlcnNbal0udmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWVbMF0sIGNsdXN0ZXJzW2pdLnZhbHVlWzBdKTtcbiAgICAgIH1cbiAgICAgIGRpc3RzW2ldW2pdID0gZGlzdDtcbiAgICAgIGRpc3RzW2pdW2ldID0gZGlzdDtcbiAgICAgIGlmIChkaXN0IDwgZGlzdHNbaV1bbWluc1tpXV0pIHtcbiAgICAgICAgbWluc1tpXSA9IGo7IC8vIENhY2hlIG1pbnM6IGNsb3Nlc3QgY2x1c3RlciB0byBjbHVzdGVyIGkgaXMgY2x1c3RlciBqXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgY2xvc2VzdCBwYWlyIG9mIGNsdXN0ZXJzIGFuZCBtZXJnZSB0aGVtIGludG8gYSBzaW5nbGUgY2x1c3Rlci5cbiAgLy8gVXBkYXRlIGRpc3RhbmNlcyBiZXR3ZWVuIG5ldyBjbHVzdGVyIGFuZCBlYWNoIG9mIHRoZSBvbGQgY2x1c3RlcnMsIGFuZCBsb29wIHVudGlsIHRocmVzaG9sZCByZWFjaGVkLlxuICB2YXIgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuICB3aGlsZSAobWVyZ2VkKSB7XG4gICAgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuICB9XG4gIHZhciByZXRDbHVzdGVycztcblxuICAvLyBEZW5kcm9ncmFtIG1vZGUgYnVpbGRzIHRoZSBoaWVyYXJjaHkgYW5kIGFkZHMgaW50ZXJtZWRpYXJ5IG5vZGVzICsgZWRnZXNcbiAgLy8gaW4gYWRkaXRpb24gdG8gcmV0dXJuaW5nIHRoZSBjbHVzdGVycy5cbiAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgcmV0Q2x1c3RlcnMgPSBfYnVpbGRDbHVzdGVyc0Zyb21UcmVlKGNsdXN0ZXJzWzBdLCBvcHRzLmRlbmRyb2dyYW1EZXB0aCwgY3kpO1xuICAgIGlmIChvcHRzLmFkZERlbmRyb2dyYW0pIF9idWlsZERlbmRyb2dyYW0oY2x1c3RlcnNbMF0sIGN5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZWd1bGFyIG1vZGUgc2ltcGx5IHJldHVybnMgdGhlIGNsdXN0ZXJzXG5cbiAgICByZXRDbHVzdGVycyA9IG5ldyBBcnJheShjbHVzdGVycy5sZW5ndGgpO1xuICAgIGNsdXN0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGNsdXN0ZXIsIGkpIHtcbiAgICAgIC8vIENsZWFuIHVwIG1ldGEgZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG4gICAgICBjbHVzdGVyLmtleSA9IGNsdXN0ZXIuaW5kZXggPSBudWxsO1xuICAgICAgcmV0Q2x1c3RlcnNbaV0gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIudmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXRDbHVzdGVycztcbn07XG52YXIgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxID0ge1xuICBoaWVyYXJjaGljYWxDbHVzdGVyaW5nOiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nLFxuICBoY2E6IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmdcbn07XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5dG9zY2FwZS9jeXRvc2NhcGUuanMtYWZmaW5pdHktcHJvcGFnYXRpb25cblxudmFyIGRlZmF1bHRzJDkgPSBkZWZhdWx0cyRnKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBhdHRyaWJ1dGVzIGJldHdlZW4gdHdvIG5vZGVzXG4gIHByZWZlcmVuY2U6ICdtZWRpYW4nLFxuICAvLyBzdWl0YWJpbGl0eSBvZiBhIGRhdGEgcG9pbnQgdG8gc2VydmUgYXMgYW4gZXhlbXBsYXJcbiAgZGFtcGluZzogMC44LFxuICAvLyBkYW1waW5nIGZhY3RvciBiZXR3ZWVuIFswLjUsIDEpXG4gIG1heEl0ZXJhdGlvbnM6IDEwMDAsXG4gIC8vIG1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW5cbiAgbWluSXRlcmF0aW9uczogMTAwLFxuICAvLyBtaW4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuIGluIG9yZGVyIGZvciBjbHVzdGVyaW5nIHRvIHN0b3BcbiAgYXR0cmlidXRlczogWy8vIGZ1bmN0aW9ucyB0byBxdWFudGlmeSB0aGUgc2ltaWxhcml0eSBiZXR3ZWVuIGFueSB0d28gcG9pbnRzXG4gICAgLy8gZS5nLiBub2RlID0+IG5vZGUuZGF0YSgnd2VpZ2h0JylcbiAgXVxufSk7XG52YXIgc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgZG1wID0gb3B0aW9ucy5kYW1waW5nO1xuICB2YXIgcHJlZiA9IG9wdGlvbnMucHJlZmVyZW5jZTtcbiAgaWYgKCEoMC41IDw9IGRtcCAmJiBkbXAgPCAxKSkge1xuICAgIGVycm9yKFwiRGFtcGluZyBtdXN0IHJhbmdlIG9uIFswLjUsIDEpLiAgR290OiBcIi5jb25jYXQoZG1wKSk7XG4gIH1cbiAgdmFyIHZhbGlkUHJlZnMgPSBbJ21lZGlhbicsICdtZWFuJywgJ21pbicsICdtYXgnXTtcbiAgaWYgKCEodmFsaWRQcmVmcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHByZWY7XG4gIH0pIHx8IG51bWJlciQxKHByZWYpKSkge1xuICAgIGVycm9yKFwiUHJlZmVyZW5jZSBtdXN0IGJlIG9uZSBvZiBbXCIuY29uY2F0KHZhbGlkUHJlZnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gXCInXCIuY29uY2F0KHAsIFwiJ1wiKTtcbiAgICB9KS5qb2luKCcsICcpLCBcIl0gb3IgYSBudW1iZXIuICBHb3Q6IFwiKS5jb25jYXQocHJlZikpO1xuICB9XG4gIHJldHVybiBkZWZhdWx0cyQ5KG9wdGlvbnMpO1xufTtcblxudmFyIGdldFNpbWlsYXJpdHkgPSBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KHR5cGUsIG4xLCBuMiwgYXR0cmlidXRlcykge1xuICB2YXIgYXR0ciA9IGZ1bmN0aW9uIGF0dHIobiwgaSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKG4pO1xuICB9O1xuXG4gIC8vIG5iIG5lZ2F0aXZlIGJlY2F1c2Ugc2ltaWxhcml0eSBzaG91bGQgaGF2ZSBhbiBpbnZlcnNlIHJlbGF0aW9uc2hpcCB0byBkaXN0YW5jZVxuICByZXR1cm4gLWNsdXN0ZXJpbmdEaXN0YW5jZSh0eXBlLCBhdHRyaWJ1dGVzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXR0cihuMSwgaSk7XG4gIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHIobjIsIGkpO1xuICB9LCBuMSwgbjIpO1xufTtcbnZhciBnZXRQcmVmZXJlbmNlID0gZnVuY3Rpb24gZ2V0UHJlZmVyZW5jZShTLCBwcmVmZXJlbmNlKSB7XG4gIC8vIGxhcmdlciBwcmVmZXJlbmNlID0gZ3JlYXRlciAjIG9mIGNsdXN0ZXJzXG4gIHZhciBwID0gbnVsbDtcbiAgaWYgKHByZWZlcmVuY2UgPT09ICdtZWRpYW4nKSB7XG4gICAgcCA9IG1lZGlhbihTKTtcbiAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWVhbicpIHtcbiAgICBwID0gbWVhbihTKTtcbiAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWluJykge1xuICAgIHAgPSBtaW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21heCcpIHtcbiAgICBwID0gbWF4KFMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEN1c3RvbSBwcmVmZXJlbmNlIG51bWJlciwgYXMgc2V0IGJ5IHVzZXJcbiAgICBwID0gcHJlZmVyZW5jZTtcbiAgfVxuICByZXR1cm4gcDtcbn07XG52YXIgZmluZEV4ZW1wbGFycyA9IGZ1bmN0aW9uIGZpbmRFeGVtcGxhcnMobiwgUiwgQSkge1xuICB2YXIgaW5kaWNlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGlmIChSW2kgKiBuICsgaV0gKyBBW2kgKiBuICsgaV0gPiAwKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRpY2VzO1xufTtcbnZhciBhc3NpZ25DbHVzdGVycyA9IGZ1bmN0aW9uIGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycykge1xuICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGVpID0gMDsgZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBlaSsrKSB7XG4gICAgICB2YXIgZSA9IGV4ZW1wbGFyc1tlaV07XG4gICAgICBpZiAoU1tpICogbiArIGVdID4gbWF4KSB7XG4gICAgICAgIGluZGV4ID0gZTtcbiAgICAgICAgbWF4ID0gU1tpICogbiArIGVdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBjbHVzdGVycy5wdXNoKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgX2VpID0gMDsgX2VpIDwgZXhlbXBsYXJzLmxlbmd0aDsgX2VpKyspIHtcbiAgICBjbHVzdGVyc1tleGVtcGxhcnNbX2VpXV0gPSBleGVtcGxhcnNbX2VpXTtcbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihuLCBTLCBleGVtcGxhcnMpIHtcbiAgdmFyIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcbiAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGV4ZW1wbGFycy5sZW5ndGg7IGVpKyspIHtcbiAgICB2YXIgaWkgPSBbXTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNsdXN0ZXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICBpZiAoY2x1c3RlcnNbY10gPT09IGV4ZW1wbGFyc1tlaV0pIHtcbiAgICAgICAgaWkucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1heEkgPSAtMTtcbiAgICB2YXIgbWF4U3VtID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpaS5sZW5ndGg7IGorKykge1xuICAgICAgICBzdW0gKz0gU1tpaVtqXSAqIG4gKyBpaVtpXV07XG4gICAgICB9XG4gICAgICBpZiAoc3VtID4gbWF4U3VtKSB7XG4gICAgICAgIG1heEkgPSBpO1xuICAgICAgICBtYXhTdW0gPSBzdW07XG4gICAgICB9XG4gICAgfVxuICAgIGV4ZW1wbGFyc1tlaV0gPSBpaVttYXhJXTtcbiAgfVxuICBjbHVzdGVycyA9IGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycyk7XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIGFmZmluaXR5UHJvcGFnYXRpb24ob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIE1hcCBlYWNoIG5vZGUgdG8gaXRzIHBvc2l0aW9uIGluIG5vZGUgYXJyYXlcbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gIH1cblxuICAvLyBCZWdpbiBhZmZpbml0eSBwcm9wYWdhdGlvbiBhbGdvcml0aG1cblxuICB2YXIgbjsgLy8gbnVtYmVyIG9mIGRhdGEgcG9pbnRzXG4gIHZhciBuMjsgLy8gc2l6ZSBvZiBtYXRyaWNlc1xuICB2YXIgUzsgLy8gc2ltaWxhcml0eSBtYXRyaXggKDFEIGFycmF5KVxuICB2YXIgcDsgLy8gcHJlZmVyZW5jZS9zdWl0YWJpbGl0eSBvZiBhIGRhdGEgcG9pbnQgdG8gc2VydmUgYXMgYW4gZXhlbXBsYXJcbiAgdmFyIFI7IC8vIHJlc3BvbnNpYmlsaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG4gIHZhciBBOyAvLyBhdmFpbGFiaWxpdHkgbWF0cml4ICgxRCBhcnJheSlcblxuICBuID0gbm9kZXMubGVuZ3RoO1xuICBuMiA9IG4gKiBuO1xuXG4gIC8vIEluaXRpYWxpemUgYW5kIGJ1aWxkIFMgc2ltaWxhcml0eSBtYXRyaXhcbiAgUyA9IG5ldyBBcnJheShuMik7XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMjsgX2krKykge1xuICAgIFNbX2ldID0gLUluZmluaXR5OyAvLyBmb3IgY2FzZXMgd2hlcmUgdHdvIGRhdGEgcG9pbnRzIHNob3VsZG4ndCBiZSBsaW5rZWQgdG9nZXRoZXJcbiAgfVxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuOyBfaTIrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoX2kyICE9PSBqKSB7XG4gICAgICAgIFNbX2kyICogbiArIGpdID0gZ2V0U2ltaWxhcml0eShvcHRzLmRpc3RhbmNlLCBub2Rlc1tfaTJdLCBub2Rlc1tqXSwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQbGFjZSBwcmVmZXJlbmNlcyBvbiB0aGUgZGlhZ29uYWwgb2YgU1xuICBwID0gZ2V0UHJlZmVyZW5jZShTLCBvcHRzLnByZWZlcmVuY2UpO1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuOyBfaTMrKykge1xuICAgIFNbX2kzICogbiArIF9pM10gPSBwO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuICBSID0gbmV3IEFycmF5KG4yKTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbjI7IF9pNCsrKSB7XG4gICAgUltfaTRdID0gMC4wO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcbiAgQSA9IG5ldyBBcnJheShuMik7XG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG4yOyBfaTUrKykge1xuICAgIEFbX2k1XSA9IDAuMDtcbiAgfVxuICB2YXIgb2xkID0gbmV3IEFycmF5KG4pO1xuICB2YXIgUnAgPSBuZXcgQXJyYXkobik7XG4gIHZhciBzZSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbjsgX2k2KyspIHtcbiAgICBvbGRbX2k2XSA9IDAuMDtcbiAgICBScFtfaTZdID0gMC4wO1xuICAgIHNlW19pNl0gPSAwO1xuICB9XG4gIHZhciBlID0gbmV3IEFycmF5KG4gKiBvcHRzLm1pbkl0ZXJhdGlvbnMpO1xuICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBlLmxlbmd0aDsgX2k3KyspIHtcbiAgICBlW19pN10gPSAwO1xuICB9XG4gIHZhciBpdGVyO1xuICBmb3IgKGl0ZXIgPSAwOyBpdGVyIDwgb3B0cy5tYXhJdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAvLyBtYWluIGFsZ29yaXRobWljIGxvb3BcblxuICAgIC8vIFVwZGF0ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IG47IF9pOCsrKSB7XG4gICAgICB2YXIgbWF4ID0gLUluZmluaXR5LFxuICAgICAgICBtYXgyID0gLUluZmluaXR5LFxuICAgICAgICBtYXhJID0gLTEsXG4gICAgICAgIEFTID0gMC4wO1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgb2xkW19qXSA9IFJbX2k4ICogbiArIF9qXTtcbiAgICAgICAgQVMgPSBBW19pOCAqIG4gKyBfal0gKyBTW19pOCAqIG4gKyBfal07XG4gICAgICAgIGlmIChBUyA+PSBtYXgpIHtcbiAgICAgICAgICBtYXgyID0gbWF4O1xuICAgICAgICAgIG1heCA9IEFTO1xuICAgICAgICAgIG1heEkgPSBfajtcbiAgICAgICAgfSBlbHNlIGlmIChBUyA+IG1heDIpIHtcbiAgICAgICAgICBtYXgyID0gQVM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG47IF9qMisrKSB7XG4gICAgICAgIFJbX2k4ICogbiArIF9qMl0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoU1tfaTggKiBuICsgX2oyXSAtIG1heCkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2oyXTtcbiAgICAgIH1cbiAgICAgIFJbX2k4ICogbiArIG1heEldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIG1heEldIC0gbWF4MikgKyBvcHRzLmRhbXBpbmcgKiBvbGRbbWF4SV07XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIEEgYXZhaWxhYmlsaXR5IG1hdHJpeFxuICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IG47IF9pOSsrKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IG47IF9qMysrKSB7XG4gICAgICAgIG9sZFtfajNdID0gQVtfajMgKiBuICsgX2k5XTtcbiAgICAgICAgUnBbX2ozXSA9IE1hdGgubWF4KDAsIFJbX2ozICogbiArIF9pOV0pO1xuICAgICAgICBzdW0gKz0gUnBbX2ozXTtcbiAgICAgIH1cbiAgICAgIHN1bSAtPSBScFtfaTldO1xuICAgICAgUnBbX2k5XSA9IFJbX2k5ICogbiArIF9pOV07XG4gICAgICBzdW0gKz0gUnBbX2k5XTtcbiAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IG47IF9qNCsrKSB7XG4gICAgICAgIEFbX2o0ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiBNYXRoLm1pbigwLCBzdW0gLSBScFtfajRdKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajRdO1xuICAgICAgfVxuICAgICAgQVtfaTkgKiBuICsgX2k5XSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChzdW0gLSBScFtfaTldKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfaTldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBjb252ZXJnZW5jZVxuICAgIHZhciBLID0gMDtcbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG47IF9pMTArKykge1xuICAgICAgdmFyIEUgPSBBW19pMTAgKiBuICsgX2kxMF0gKyBSW19pMTAgKiBuICsgX2kxMF0gPiAwID8gMSA6IDA7XG4gICAgICBlW2l0ZXIgJSBvcHRzLm1pbkl0ZXJhdGlvbnMgKiBuICsgX2kxMF0gPSBFO1xuICAgICAgSyArPSBFO1xuICAgIH1cbiAgICBpZiAoSyA+IDAgJiYgKGl0ZXIgPj0gb3B0cy5taW5JdGVyYXRpb25zIC0gMSB8fCBpdGVyID09IG9wdHMubWF4SXRlcmF0aW9ucyAtIDEpKSB7XG4gICAgICB2YXIgX3N1bSA9IDA7XG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IG47IF9pMTErKykge1xuICAgICAgICBzZVtfaTExXSA9IDA7XG4gICAgICAgIGZvciAodmFyIF9qNSA9IDA7IF9qNSA8IG9wdHMubWluSXRlcmF0aW9uczsgX2o1KyspIHtcbiAgICAgICAgICBzZVtfaTExXSArPSBlW19qNSAqIG4gKyBfaTExXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VbX2kxMV0gPT09IDAgfHwgc2VbX2kxMV0gPT09IG9wdHMubWluSXRlcmF0aW9ucykge1xuICAgICAgICAgIF9zdW0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9zdW0gPT09IG4pIHtcbiAgICAgICAgLy8gdGhlbiB3ZSBoYXZlIGNvbnZlcmdlbmNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZW50aWZ5IGV4ZW1wbGFycyAoY2x1c3RlciBjZW50ZXJzKVxuICB2YXIgZXhlbXBsYXJzSW5kaWNlcyA9IGZpbmRFeGVtcGxhcnMobiwgUiwgQSk7XG5cbiAgLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzXG4gIHZhciBjbHVzdGVySW5kaWNlcyA9IGFzc2lnbihuLCBTLCBleGVtcGxhcnNJbmRpY2VzKTtcbiAgdmFyIGNsdXN0ZXJzID0ge307XG4gIGZvciAodmFyIGMgPSAwOyBjIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IGMrKykge1xuICAgIGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbY11dID0gW107XG4gIH1cbiAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBub2Rlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgIHZhciBwb3MgPSBpZDJwb3NpdGlvbltub2Rlc1tfaTEyXS5pZCgpXTtcbiAgICB2YXIgY2x1c3RlckluZGV4ID0gY2x1c3RlckluZGljZXNbcG9zXTtcbiAgICBpZiAoY2x1c3RlckluZGV4ICE9IG51bGwpIHtcbiAgICAgIC8vIHRoZSBub2RlIG1heSBoYXZlIG5vdCBiZWVuIGFzc2lnbmVkIGEgY2x1c3RlciBpZiBubyB2YWxpZCBhdHRyaWJ1dGVzIHdlcmUgc3BlY2lmaWVkXG4gICAgICBjbHVzdGVyc1tjbHVzdGVySW5kZXhdLnB1c2gobm9kZXNbX2kxMl0pO1xuICAgIH1cbiAgfVxuICB2YXIgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGgpO1xuICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IF9jKyspIHtcbiAgICByZXRDbHVzdGVyc1tfY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbX2NdXSk7XG4gIH1cbiAgcmV0dXJuIHJldENsdXN0ZXJzO1xufTtcbnZhciBhZmZpbml0eVByb3BhZ2F0aW9uJDEgPSB7XG4gIGFmZmluaXR5UHJvcGFnYXRpb246IGFmZmluaXR5UHJvcGFnYXRpb24sXG4gIGFwOiBhZmZpbml0eVByb3BhZ2F0aW9uXG59O1xuXG52YXIgaGllcmhvbHplckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIHJvb3Q6IHVuZGVmaW5lZCxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kayA9IHtcbiAgaGllcmhvbHplcjogZnVuY3Rpb24gaGllcmhvbHplcihvcHRpb25zKSB7XG4gICAgaWYgKCFwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICByb290OiBhcmdzWzBdLFxuICAgICAgICBkaXJlY3RlZDogYXJnc1sxXVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9oaWVyaG9semVyRGVmYXVsdHMgPSBoaWVyaG9semVyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICByb290ID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5yb290LFxuICAgICAgZGlyZWN0ZWQgPSBfaGllcmhvbHplckRlZmF1bHRzLmRpcmVjdGVkO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgZGZsYWcgPSBmYWxzZTtcbiAgICB2YXIgb2RkSW47XG4gICAgdmFyIG9kZE91dDtcbiAgICB2YXIgc3RhcnRWZXJ0ZXg7XG4gICAgaWYgKHJvb3QpIHN0YXJ0VmVydGV4ID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0uaWQoKSA6IHJvb3RbMF0uaWQoKTtcbiAgICB2YXIgbm9kZXMgPSB7fTtcbiAgICB2YXIgZWRnZXMgPSB7fTtcbiAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgdmFyIGluZCA9IGVsZS5pbmRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICB2YXIgb3V0ZCA9IGVsZS5vdXRkZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgdmFyIGQxID0gaW5kIC0gb3V0ZDtcbiAgICAgICAgICB2YXIgZDIgPSBvdXRkIC0gaW5kO1xuICAgICAgICAgIGlmIChkMSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAob2RkSW4pIGRmbGFnID0gdHJ1ZTtlbHNlIG9kZEluID0gaWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkMiA9PSAxKSB7XG4gICAgICAgICAgICBpZiAob2RkT3V0KSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRPdXQgPSBpZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGQyID4gMSB8fCBkMSA+IDEpIHtcbiAgICAgICAgICAgIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgZWxlLm91dGdvZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNFZGdlKCkpIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZXNbaWRdID0gW3VuZGVmaW5lZCwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICB2YXIgZCA9IGVsZS5kZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgaWYgKGQgJSAyKSB7XG4gICAgICAgICAgICBpZiAoIW9kZEluKSBvZGRJbiA9IGlkO2Vsc2UgaWYgKCFvZGRPdXQpIG9kZE91dCA9IGlkO2Vsc2UgZGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlc1tpZF0gPSBbZWxlLnNvdXJjZSgpLmlkKCksIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBmb3VuZDogZmFsc2UsXG4gICAgICB0cmFpbDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoZGZsYWcpIHJldHVybiByZXN1bHQ7ZWxzZSBpZiAob2RkT3V0ICYmIG9kZEluKSB7XG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4ICYmIG9kZEluICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICBzdGFydFZlcnRleCA9IG9kZE91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXN0YXJ0VmVydGV4KSBzdGFydFZlcnRleCA9IGVsZXNbMF0uaWQoKTtcbiAgICB9XG4gICAgdmFyIHdhbGsgPSBmdW5jdGlvbiB3YWxrKHYpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHY7XG4gICAgICB2YXIgc3VidG91ciA9IFt2XTtcbiAgICAgIHZhciBhZGosIGFkalRhaWwsIGFkakhlYWQ7XG4gICAgICB3aGlsZSAobm9kZXNbY3VycmVudE5vZGVdLmxlbmd0aCkge1xuICAgICAgICBhZGogPSBub2Rlc1tjdXJyZW50Tm9kZV0uc2hpZnQoKTtcbiAgICAgICAgYWRqVGFpbCA9IGVkZ2VzW2Fkal1bMF07XG4gICAgICAgIGFkakhlYWQgPSBlZGdlc1thZGpdWzFdO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUgIT0gYWRqSGVhZCkge1xuICAgICAgICAgIG5vZGVzW2FkakhlYWRdID0gbm9kZXNbYWRqSGVhZF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpIZWFkO1xuICAgICAgICB9IGVsc2UgaWYgKCFkaXJlY3RlZCAmJiBjdXJyZW50Tm9kZSAhPSBhZGpUYWlsKSB7XG4gICAgICAgICAgbm9kZXNbYWRqVGFpbF0gPSBub2Rlc1thZGpUYWlsXS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9IGFkajtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IGFkalRhaWw7XG4gICAgICAgIH1cbiAgICAgICAgc3VidG91ci51bnNoaWZ0KGFkaik7XG4gICAgICAgIHN1YnRvdXIudW5zaGlmdChjdXJyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VidG91cjtcbiAgICB9O1xuICAgIHZhciB0cmFpbCA9IFtdO1xuICAgIHZhciBzdWJ0b3VyID0gW107XG4gICAgc3VidG91ciA9IHdhbGsoc3RhcnRWZXJ0ZXgpO1xuICAgIHdoaWxlIChzdWJ0b3VyLmxlbmd0aCAhPSAxKSB7XG4gICAgICBpZiAobm9kZXNbc3VidG91clswXV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJ0b3VyID0gd2FsayhzdWJ0b3VyLnNoaWZ0KCkpLmNvbmNhdChzdWJ0b3VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpOyAvLyBmaW5hbCBub2RlXG5cbiAgICBmb3IgKHZhciBkIGluIG5vZGVzKSB7XG4gICAgICBpZiAobm9kZXNbZF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5mb3VuZCA9IHRydWU7XG4gICAgcmVzdWx0LnRyYWlsID0gdGhpcy5zcGF3bih0cmFpbCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQgPSBmdW5jdGlvbiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkKCkge1xuICB2YXIgZWxlcyA9IHRoaXM7XG4gIHZhciBub2RlcyA9IHt9O1xuICB2YXIgaWQgPSAwO1xuICB2YXIgZWRnZUNvdW50ID0gMDtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciB2aXNpdGVkRWRnZXMgPSB7fTtcbiAgdmFyIGJ1aWxkQ29tcG9uZW50ID0gZnVuY3Rpb24gYnVpbGRDb21wb25lbnQoeCwgeSkge1xuICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICB2YXIgY3V0c2V0ID0gW107XG4gICAgdmFyIGNvbXBvbmVudCA9IGVsZXMuc3Bhd24oKTtcbiAgICB3aGlsZSAoc3RhY2tbaV0ueCAhPSB4IHx8IHN0YWNrW2ldLnkgIT0geSkge1xuICAgICAgY3V0c2V0LnB1c2goc3RhY2sucG9wKCkuZWRnZSk7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGN1dHNldC5wdXNoKHN0YWNrLnBvcCgpLmVkZ2UpO1xuICAgIGN1dHNldC5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBlZGdlLmNvbm5lY3RlZE5vZGVzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgICAgY29tcG9uZW50Lm1lcmdlKGVkZ2UpO1xuICAgICAgY29ubmVjdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZCgpO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgICAgIGlmICghbm9kZXNbbm9kZUlkXS5jdXRWZXJ0ZXgpIHtcbiAgICAgICAgICBjb21wb25lbnQubWVyZ2UoY29ubmVjdGVkRWRnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShjb25uZWN0ZWRFZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIH07XG4gIHZhciBfYmljb25uZWN0ZWRTZWFyY2ggPSBmdW5jdGlvbiBiaWNvbm5lY3RlZFNlYXJjaChyb290LCBjdXJyZW50Tm9kZSwgcGFyZW50KSB7XG4gICAgaWYgKHJvb3QgPT09IHBhcmVudCkgZWRnZUNvdW50ICs9IDE7XG4gICAgbm9kZXNbY3VycmVudE5vZGVdID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgbG93OiBpZCsrLFxuICAgICAgY3V0VmVydGV4OiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGVkZ2VzID0gZWxlcy5nZXRFbGVtZW50QnlJZChjdXJyZW50Tm9kZSkuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgaWYgKGVkZ2VzLnNpemUoKSA9PT0gMCkge1xuICAgICAgY29tcG9uZW50cy5wdXNoKGVsZXMuc3Bhd24oZWxlcy5nZXRFbGVtZW50QnlJZChjdXJyZW50Tm9kZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNvdXJjZUlkLCB0YXJnZXRJZCwgb3RoZXJOb2RlSWQsIGVkZ2VJZDtcbiAgICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgc291cmNlSWQgPSBlZGdlLnNvdXJjZSgpLmlkKCk7XG4gICAgICAgIHRhcmdldElkID0gZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgICBvdGhlck5vZGVJZCA9IHNvdXJjZUlkID09PSBjdXJyZW50Tm9kZSA/IHRhcmdldElkIDogc291cmNlSWQ7XG4gICAgICAgIGlmIChvdGhlck5vZGVJZCAhPT0gcGFyZW50KSB7XG4gICAgICAgICAgZWRnZUlkID0gZWRnZS5pZCgpO1xuICAgICAgICAgIGlmICghdmlzaXRlZEVkZ2VzW2VkZ2VJZF0pIHtcbiAgICAgICAgICAgIHZpc2l0ZWRFZGdlc1tlZGdlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICB4OiBjdXJyZW50Tm9kZSxcbiAgICAgICAgICAgICAgeTogb3RoZXJOb2RlSWQsXG4gICAgICAgICAgICAgIGVkZ2U6IGVkZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShvdGhlck5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgICAgIF9iaWNvbm5lY3RlZFNlYXJjaChyb290LCBvdGhlck5vZGVJZCwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmxvdyA9IE1hdGgubWluKG5vZGVzW2N1cnJlbnROb2RlXS5sb3csIG5vZGVzW290aGVyTm9kZUlkXS5sb3cpO1xuICAgICAgICAgICAgaWYgKG5vZGVzW2N1cnJlbnROb2RlXS5pZCA8PSBub2Rlc1tvdGhlck5vZGVJZF0ubG93KSB7XG4gICAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5jdXRWZXJ0ZXggPSB0cnVlO1xuICAgICAgICAgICAgICBidWlsZENvbXBvbmVudChjdXJyZW50Tm9kZSwgb3RoZXJOb2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2Rlc1tjdXJyZW50Tm9kZV0ubG93ID0gTWF0aC5taW4obm9kZXNbY3VycmVudE5vZGVdLmxvdywgbm9kZXNbb3RoZXJOb2RlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgbm9kZUlkID0gZWxlLmlkKCk7XG4gICAgICBpZiAoIShub2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgIGVkZ2VDb3VudCA9IDA7XG4gICAgICAgIF9iaWNvbm5lY3RlZFNlYXJjaChub2RlSWQsIG5vZGVJZCk7XG4gICAgICAgIG5vZGVzW25vZGVJZF0uY3V0VmVydGV4ID0gZWRnZUNvdW50ID4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgY3V0VmVydGljZXMgPSBPYmplY3Qua2V5cyhub2RlcykuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBub2Rlc1tpZF0uY3V0VmVydGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGVsZXMuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjdXQ6IGVsZXMuc3Bhd24oY3V0VmVydGljZXMpLFxuICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgfTtcbn07XG52YXIgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCQxID0ge1xuICBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICBodGJjOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICBodGI6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQsXG4gIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWRDb21wb25lbnRzOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkXG59O1xuXG52YXIgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQgPSBmdW5jdGlvbiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCgpIHtcbiAgdmFyIGVsZXMgPSB0aGlzO1xuICB2YXIgbm9kZXMgPSB7fTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBjdXQgPSBlbGVzLnNwYXduKGVsZXMpO1xuICB2YXIgX3N0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoID0gZnVuY3Rpb24gc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2goc291cmNlTm9kZUlkKSB7XG4gICAgc3RhY2sucHVzaChzb3VyY2VOb2RlSWQpO1xuICAgIG5vZGVzW3NvdXJjZU5vZGVJZF0gPSB7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBsb3c6IGluZGV4KyssXG4gICAgICBleHBsb3JlZDogZmFsc2VcbiAgICB9O1xuICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IGVsZXMuZ2V0RWxlbWVudEJ5SWQoc291cmNlTm9kZUlkKS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICBjb25uZWN0ZWRFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICB2YXIgdGFyZ2V0Tm9kZUlkID0gZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgaWYgKHRhcmdldE5vZGVJZCAhPT0gc291cmNlTm9kZUlkKSB7XG4gICAgICAgIGlmICghKHRhcmdldE5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgICBfc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2godGFyZ2V0Tm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGVzW3RhcmdldE5vZGVJZF0uZXhwbG9yZWQpIHtcbiAgICAgICAgICBub2Rlc1tzb3VyY2VOb2RlSWRdLmxvdyA9IE1hdGgubWluKG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93LCBub2Rlc1t0YXJnZXROb2RlSWRdLmxvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobm9kZXNbc291cmNlTm9kZUlkXS5pbmRleCA9PT0gbm9kZXNbc291cmNlTm9kZUlkXS5sb3cpIHtcbiAgICAgIHZhciBjb21wb25lbnROb2RlcyA9IGVsZXMuc3Bhd24oKTtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBjb21wb25lbnROb2Rlcy5tZXJnZShlbGVzLmdldEVsZW1lbnRCeUlkKG5vZGVJZCkpO1xuICAgICAgICBub2Rlc1tub2RlSWRdLmxvdyA9IG5vZGVzW3NvdXJjZU5vZGVJZF0uaW5kZXg7XG4gICAgICAgIG5vZGVzW25vZGVJZF0uZXhwbG9yZWQgPSB0cnVlO1xuICAgICAgICBpZiAobm9kZUlkID09PSBzb3VyY2VOb2RlSWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvbXBvbmVudEVkZ2VzID0gY29tcG9uZW50Tm9kZXMuZWRnZXNXaXRoKGNvbXBvbmVudE5vZGVzKTtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnROb2Rlcy5tZXJnZShjb21wb25lbnRFZGdlcyk7XG4gICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgIGN1dCA9IGN1dC5kaWZmZXJlbmNlKGNvbXBvbmVudCk7XG4gICAgfVxuICB9O1xuICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBub2RlSWQgPSBlbGUuaWQoKTtcbiAgICAgIGlmICghKG5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgX3N0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKG5vZGVJZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjdXQ6IGN1dCxcbiAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gIH07XG59O1xudmFyIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDEgPSB7XG4gIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgdHNjOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgdHNjYzogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50czogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWRcbn07XG5cbnZhciBlbGVzZm4kaiA9IHt9O1xuW2VsZXNmbiR2LCBlbGVzZm4kdSwgZWxlc2ZuJHQsIGVsZXNmbiRzLCBlbGVzZm4kciwgZWxlc2ZuJHEsIGVsZXNmbiRwLCBlbGVzZm4kbywgZWxlc2ZuJG4sIGVsZXNmbiRtLCBlbGVzZm4kbCwgbWFya292Q2x1c3RlcmluZyQxLCBrQ2x1c3RlcmluZywgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxLCBhZmZpbml0eVByb3BhZ2F0aW9uJDEsIGVsZXNmbiRrLCBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkJDEsIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChlbGVzZm4kaiwgcHJvcHMpO1xufSk7XG5cbi8qIVxuRW1iZWRkYWJsZSBNaW5pbXVtIFN0cmljdGx5LUNvbXBsaWFudCBQcm9taXNlcy9BKyAxLjEuMSBUaGVuYWJsZVxuQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgUmFsZiBTLiBFbmdlbHNjaGFsbCAoaHR0cDovL2VuZ2Vsc2NoYWxsLmNvbSlcbkxpY2Vuc2VkIHVuZGVyIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiovXG5cbi8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbnZhciBTVEFURV9QRU5ESU5HID0gMDsgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG52YXIgU1RBVEVfRlVMRklMTEVEID0gMTsgLyogIFtQcm9taXNlcy9BKyAyLjEuMl0gICovXG52YXIgU1RBVEVfUkVKRUNURUQgPSAyOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xudmFyIF9hcGkgPSBmdW5jdGlvbiBhcGkoZXhlY3V0b3IpIHtcbiAgLyogIG9wdGlvbmFsbHkgc3VwcG9ydCBub24tY29uc3RydWN0b3IvcGxhaW4tZnVuY3Rpb24gY2FsbCAgKi9cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9hcGkpKSByZXR1cm4gbmV3IF9hcGkoZXhlY3V0b3IpO1xuXG4gIC8qICBpbml0aWFsaXplIG9iamVjdCAgKi9cbiAgdGhpcy5pZCA9ICdUaGVuYWJsZS8xLjAuNyc7XG4gIHRoaXMuc3RhdGUgPSBTVEFURV9QRU5ESU5HOyAvKiAgaW5pdGlhbCBzdGF0ZSAgKi9cbiAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7IC8qICBpbml0aWFsIHZhbHVlICAqLyAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG4gIHRoaXMucmVqZWN0UmVhc29uID0gdW5kZWZpbmVkOyAvKiAgaW5pdGlhbCByZWFzb24gKi8gLyogIFtQcm9taXNlcy9BKyAxLjUsIDIuMS4zLjJdICAqL1xuICB0aGlzLm9uRnVsZmlsbGVkID0gW107IC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuICB0aGlzLm9uUmVqZWN0ZWQgPSBbXTsgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgLyogIHByb3ZpZGUgb3B0aW9uYWwgaW5mb3JtYXRpb24taGlkaW5nIHByb3h5ICAqL1xuICB0aGlzLnByb3h5ID0ge1xuICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKHRoaXMpXG4gIH07XG5cbiAgLyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgPT09ICdmdW5jdGlvbicpIGV4ZWN1dG9yLmNhbGwodGhpcywgdGhpcy5mdWxmaWxsLmJpbmQodGhpcyksIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xufTtcblxuLyogIHByb21pc2UgQVBJIG1ldGhvZHMgICovXG5fYXBpLnByb3RvdHlwZSA9IHtcbiAgLyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG4gIGZ1bGZpbGw6IGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9GVUxGSUxMRUQsICdmdWxmaWxsVmFsdWUnLCB2YWx1ZSk7XG4gIH0sXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfUkVKRUNURUQsICdyZWplY3RSZWFzb24nLCB2YWx1ZSk7XG4gIH0sXG4gIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBjdXJyID0gdGhpcztcbiAgICB2YXIgbmV4dCA9IG5ldyBfYXBpKCk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuICAgIGN1cnIub25GdWxmaWxsZWQucHVzaChyZXNvbHZlcihvbkZ1bGZpbGxlZCwgbmV4dCwgJ2Z1bGZpbGwnKSk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuICAgIGN1cnIub25SZWplY3RlZC5wdXNoKHJlc29sdmVyKG9uUmVqZWN0ZWQsIG5leHQsICdyZWplY3QnKSk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgcmV0dXJuIG5leHQucHJveHk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG4gIH1cbn07XG5cbi8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cbnZhciBkZWxpdmVyID0gZnVuY3Rpb24gZGVsaXZlcihjdXJyLCBzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1BFTkRJTkcpIHtcbiAgICBjdXJyLnN0YXRlID0gc3RhdGU7IC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG4gICAgY3VycltuYW1lXSA9IHZhbHVlOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjIsIDIuMS4zLjJdICAqL1xuICAgIGV4ZWN1dGUoY3Vycik7XG4gIH1cbiAgcmV0dXJuIGN1cnI7XG59O1xuXG4vKiAgZXhlY3V0ZSBhbGwgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUoY3Vycikge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfRlVMRklMTEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvbkZ1bGZpbGxlZCcsIGN1cnIuZnVsZmlsbFZhbHVlKTtlbHNlIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9SRUpFQ1RFRCkgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCAnb25SZWplY3RlZCcsIGN1cnIucmVqZWN0UmVhc29uKTtcbn07XG5cbi8qICBleGVjdXRlIHBhcnRpY3VsYXIgc2V0IG9mIGhhbmRsZXJzICAqL1xudmFyIGV4ZWN1dGVfaGFuZGxlcnMgPSBmdW5jdGlvbiBleGVjdXRlX2hhbmRsZXJzKGN1cnIsIG5hbWUsIHZhbHVlKSB7XG4gIC8qIGdsb2JhbCBzZXRJbW1lZGlhdGU6IHRydWUgKi9cbiAgLyogZ2xvYmFsIHNldFRpbWVvdXQ6IHRydWUgKi9cblxuICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICBpZiAoY3VycltuYW1lXS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAvKiAgaXRlcmF0ZSBvdmVyIGFsbCBoYW5kbGVycywgZXhhY3RseSBvbmNlICAqL1xuICB2YXIgaGFuZGxlcnMgPSBjdXJyW25hbWVdO1xuICBjdXJyW25hbWVdID0gW107IC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG4gIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSBoYW5kbGVyc1tpXSh2YWx1ZSk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuICB9O1xuXG4gIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjIuNCwgMy4xXSAgKi9cbiAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHNldEltbWVkaWF0ZShmdW5jKTtlbHNlIHNldFRpbWVvdXQoZnVuYywgMCk7XG59O1xuXG4vKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cbnZhciByZXNvbHZlciA9IGZ1bmN0aW9uIHJlc29sdmVyKGNiLCBuZXh0LCBtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIC8qICBbUHJvbWlzZXMvQSsgMi4yLjEsIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgbmV4dFttZXRob2RdLmNhbGwobmV4dCwgdmFsdWUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL2Vsc2Uge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNiKHZhbHVlKTtcbiAgICAgIH0gLyogIFtQcm9taXNlcy9BKyAyLjIuMi4xLCAyLjIuMy4xLCAyLjIuNSwgMy4yXSAgKi8gY2F0Y2ggKGUpIHtcbiAgICAgICAgbmV4dC5yZWplY3QoZSk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMl0gICovXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9yZXNvbHZlKG5leHQsIHJlc3VsdCk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMV0gICovXG4gICAgfVxuICB9O1xufTtcblxuLyogIFwiUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVwiICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuM10gICovXG52YXIgX3Jlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHgpIHtcbiAgLyogIHNhbml0eSBjaGVjayBhcmd1bWVudHMgICovIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICBpZiAocHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4KSB7XG4gICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgc3VyZ2ljYWxseSBjaGVjayBmb3IgYSBcInRoZW5cIiBtZXRob2RcbiAgICAobWFpbmx5IHRvIGp1c3QgY2FsbCB0aGUgXCJnZXR0ZXJcIiBvZiBcInRoZW5cIiBvbmx5IG9uY2UpICAqL1xuICB2YXIgdGhlbjtcbiAgaWYgKF90eXBlb2YoeCkgPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdGhlbiA9IHgudGhlbjtcbiAgICB9IC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMSwgMy41XSAgKi8gY2F0Y2ggKGUpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KGUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8qICBoYW5kbGUgb3duIFRoZW5hYmxlcyAgICBbUHJvbWlzZXMvQSsgMi4zLjJdXG4gICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgLyogIGNhbGwgcmV0cmlldmVkIFwidGhlblwiIG1ldGhvZCAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgdGhlbi5jYWxsKHgsIC8qICByZXNvbHZlUHJvbWlzZSAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjFdICAqL1xuICAgICAgZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBpZiAoeSA9PT0geCkgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2NpcmN1bGFyIHRoZW5hYmxlIGNoYWluJykpO2Vsc2UgX3Jlc29sdmUocHJvbWlzZSwgeSk7XG4gICAgICB9LCAvKiAgcmVqZWN0UHJvbWlzZSAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghcmVzb2x2ZWQpIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7IC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy40XSAgKi9cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG4gIHByb21pc2UuZnVsZmlsbCh4KTsgLyogIFtQcm9taXNlcy9BKyAyLjMuNCwgMi4zLjMuNF0gICovXG59O1xuXG4vLyBzbyB3ZSBhbHdheXMgaGF2ZSBQcm9taXNlLmFsbCgpXG5fYXBpLmFsbCA9IGZ1bmN0aW9uIChwcykge1xuICByZXR1cm4gbmV3IF9hcGkoZnVuY3Rpb24gKHJlc29sdmVBbGwsIHJlamVjdEFsbCkge1xuICAgIHZhciB2YWxzID0gbmV3IEFycmF5KHBzLmxlbmd0aCk7XG4gICAgdmFyIGRvbmVDb3VudCA9IDA7XG4gICAgdmFyIGZ1bGZpbGwgPSBmdW5jdGlvbiBmdWxmaWxsKGksIHZhbCkge1xuICAgICAgdmFsc1tpXSA9IHZhbDtcbiAgICAgIGRvbmVDb3VudCsrO1xuICAgICAgaWYgKGRvbmVDb3VudCA9PT0gcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmVBbGwodmFscyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9IHAgIT0gbnVsbCAmJiBwLnRoZW4gIT0gbnVsbDtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmVqZWN0QWxsKGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHA7XG4gICAgICAgICAgZnVsZmlsbChpLCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KShpKTtcbiAgICB9XG4gIH0pO1xufTtcbl9hcGkucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBfYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXNvbHZlKHZhbCk7XG4gIH0pO1xufTtcbl9hcGkucmVqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gbmV3IF9hcGkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdCh2YWwpO1xuICB9KTtcbn07XG52YXIgUHJvbWlzZSQxID0gdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gUHJvbWlzZSA6IF9hcGk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIEFuaW1hdGlvbih0YXJnZXQsIG9wdHMsIG9wdHMyKSB7XG4gIHZhciBpc0NvcmUgPSBjb3JlKHRhcmdldCk7XG4gIHZhciBpc0VsZSA9ICFpc0NvcmU7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSBleHRlbmQoe1xuICAgIGR1cmF0aW9uOiAxMDAwXG4gIH0sIG9wdHMsIG9wdHMyKTtcbiAgX3AudGFyZ2V0ID0gdGFyZ2V0O1xuICBfcC5zdHlsZSA9IF9wLnN0eWxlIHx8IF9wLmNzcztcbiAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gIF9wLmhvb2tlZCA9IGZhbHNlO1xuICBfcC5hcHBseWluZyA9IGZhbHNlO1xuICBfcC5wcm9ncmVzcyA9IDA7XG4gIF9wLmNvbXBsZXRlcyA9IFtdO1xuICBfcC5mcmFtZXMgPSBbXTtcbiAgaWYgKF9wLmNvbXBsZXRlICYmIGZuJDYoX3AuY29tcGxldGUpKSB7XG4gICAgX3AuY29tcGxldGVzLnB1c2goX3AuY29tcGxldGUpO1xuICB9XG4gIGlmIChpc0VsZSkge1xuICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgICBfcC5zdGFydFBvc2l0aW9uID0gX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICB4OiBwb3MueCxcbiAgICAgIHk6IHBvcy55XG4gICAgfTtcbiAgICBfcC5zdGFydFN0eWxlID0gX3Auc3RhcnRTdHlsZSB8fCB0YXJnZXQuY3koKS5zdHlsZSgpLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUodGFyZ2V0LCBfcC5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzQ29yZSkge1xuICAgIHZhciBwYW4gPSB0YXJnZXQucGFuKCk7XG4gICAgX3Auc3RhcnRQYW4gPSB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfTtcbiAgICBfcC5zdGFydFpvb20gPSB0YXJnZXQuem9vbSgpO1xuICB9XG5cbiAgLy8gZm9yIGZ1dHVyZSB0aW1lbGluZS9hbmltYXRpb25zIGltcGxcbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcbn07XG52YXIgYW5pZm4gPSBBbmltYXRpb24ucHJvdG90eXBlO1xuZXh0ZW5kKGFuaWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2FuaW1hdGlvbic7XG4gIH0sXG4gIGhvb2s6IGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoIV9wLmhvb2tlZCkge1xuICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgdmFyIHE7XG4gICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG4gICAgICBpZiAoX3AucXVldWUpIHtcbiAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgfVxuICAgICAgcS5wdXNoKHRoaXMpO1xuXG4gICAgICAvLyBhZGQgdG8gdGhlIGFuaW1hdGlvbiBsb29wIHBvb2xcbiAgICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKF9wLnRhcmdldCkpIHtcbiAgICAgICAgX3AudGFyZ2V0LmN5KCkuYWRkVG9BbmltYXRpb25Qb29sKF9wLnRhcmdldCk7XG4gICAgICB9XG4gICAgICBfcC5ob29rZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgLy8gYXV0b3Jld2luZFxuICAgIGlmIChfcC5wcm9ncmVzcyA9PT0gMSkge1xuICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIH1cbiAgICBfcC5wbGF5aW5nID0gdHJ1ZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcbiAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBzdGFydCB0aGUgYW5pbWF0aW9uLi4uXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGxheWluZzogZnVuY3Rpb24gcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgYXBwbHkgdGhlIGFuaW1hdGlvbiBhdCB0aGlzIHByb2dyZXNzXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYXBwbHlpbmc6IGZ1bmN0aW9uIGFwcGx5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZXdpbmQ6IGZ1bmN0aW9uIHJld2luZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygwKTtcbiAgfSxcbiAgZmFzdGZvcndhcmQ6IGZ1bmN0aW9uIGZhc3Rmb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDEpO1xuICB9LFxuICB0aW1lOiBmdW5jdGlvbiB0aW1lKHQpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcyAqIF9wLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyh0IC8gX3AuZHVyYXRpb24pO1xuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKHApIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcbiAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIF9wLnByb2dyZXNzID0gcDtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29tcGxldGVkOiBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucHJvZ3Jlc3MgPT09IDE7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG4gICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gICAgX3AucHJvZ3Jlc3MgPSAxIC0gX3AucHJvZ3Jlc3M7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgICB2YXIgX3BhID0gX3BbYV07XG4gICAgICBpZiAoX3BhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3BbYV0gPSBfcFtiXTtcbiAgICAgIF9wW2JdID0gX3BhO1xuICAgIH07XG4gICAgc3dhcCgnem9vbScsICdzdGFydFpvb20nKTtcbiAgICBzd2FwKCdwYW4nLCAnc3RhcnRQYW4nKTtcbiAgICBzd2FwKCdwb3NpdGlvbicsICdzdGFydFBvc2l0aW9uJyk7XG5cbiAgICAvLyBzd2FwIHN0eWxlc1xuICAgIGlmIChfcC5zdHlsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IF9wLnN0eWxlW2ldO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHN0YXJ0U3R5bGVQcm9wID0gX3Auc3RhcnRTdHlsZVtuYW1lXTtcbiAgICAgICAgX3Auc3RhcnRTdHlsZVtuYW1lXSA9IHByb3A7XG4gICAgICAgIF9wLnN0eWxlW2ldID0gc3RhcnRTdHlsZVByb3A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UodHlwZSkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGFycjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgYXJyID0gX3AuZnJhbWVzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBhcnIgPSBfcC5jb21wbGV0ZXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFyci5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuYW5pZm4uY29tcGxldGUgPSBhbmlmbi5jb21wbGV0ZWQ7XG5hbmlmbi5ydW4gPSBhbmlmbi5wbGF5O1xuYW5pZm4ucnVubmluZyA9IGFuaWZuLnBsYXlpbmc7XG5cbnZhciBkZWZpbmUkMyA9IHtcbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uIGFuaW1hdGVkKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudC5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8vIGFuaW1hdGVkXG5cbiAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9LFxuICAvLyBjbGVhclF1ZXVlXG5cbiAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG4gIC8vIGRlbGF5XG5cbiAgZGVsYXlBbmltYXRpb246IGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUFuaW1hdGlvbkltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgLy8gZGVsYXlcblxuICBhbmltYXRpb246IGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggPT09IDA7XG4gICAgICBpZiAocHJvcGVydGllc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuICAgICAgaWYgKHByb3BlcnRpZXMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNDAwO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChwcm9wZXJ0aWVzLmR1cmF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA2MDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVzKSB7XG4gICAgICAgIHByb3BlcnRpZXMuc3R5bGUgPSBzdHlsZS5nZXRQcm9wc0xpc3QocHJvcGVydGllcy5zdHlsZSB8fCBwcm9wZXJ0aWVzLmNzcyk7XG4gICAgICAgIHByb3BlcnRpZXMuY3NzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlcyAmJiBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICB2YXIgcnBvcyA9IHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHJwb3MsIHpvb20sIHBhbik7XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBwYW5CeSBpZiBzZXRcbiAgICAgIGlmIChpc0NvcmUgJiYgcHJvcGVydGllcy5wYW5CeSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBwYW5CeSA9IHByb3BlcnRpZXMucGFuQnk7XG4gICAgICAgIHZhciBjeVBhbiA9IGN5LnBhbigpO1xuICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHtcbiAgICAgICAgICB4OiBjeVBhbi54ICsgcGFuQnkueCxcbiAgICAgICAgICB5OiBjeVBhbi55ICsgcGFuQnkueVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gY2VudGVyIGlmIHNldFxuICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuICAgICAgaWYgKGlzQ29yZSAmJiBjZW50ZXIgIT0gbnVsbCkge1xuICAgICAgICB2YXIgY2VudGVyUGFuID0gY3kuZ2V0Q2VudGVyUGFuKGNlbnRlci5lbGVzLCBwcm9wZXJ0aWVzLnpvb20pO1xuICAgICAgICBpZiAoY2VudGVyUGFuICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGNlbnRlclBhbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gJiB6b29tIHcvIGZpdCBpZiBzZXRcbiAgICAgIGlmIChpc0NvcmUgJiYgcHJvcGVydGllcy5maXQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZml0ID0gcHJvcGVydGllcy5maXQ7XG4gICAgICAgIHZhciBmaXRWcCA9IGN5LmdldEZpdFZpZXdwb3J0KGZpdC5lbGVzIHx8IGZpdC5ib3VuZGluZ0JveCwgZml0LnBhZGRpbmcpO1xuICAgICAgICBpZiAoZml0VnAgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gZml0VnAucGFuO1xuICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IGZpdFZwLnpvb207XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgem9vbSAoJiBwb3RlbnRpYWxseSBwYW4pIHcvIHpvb20gb2JqIGlmIHNldFxuICAgICAgaWYgKGlzQ29yZSAmJiBwbGFpbk9iamVjdChwcm9wZXJ0aWVzLnpvb20pKSB7XG4gICAgICAgIHZhciB2cCA9IGN5LmdldFpvb21lZFZpZXdwb3J0KHByb3BlcnRpZXMuem9vbSk7XG4gICAgICAgIGlmICh2cCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHZwLnpvb21lZCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gdnAuem9vbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB2cC5wYW47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IG51bGw7IC8vIGFuIGluYXZhbGlkIHpvb20gKGUuZy4gbm8gZGVsdGEpIGdldHMgYXV0b21hdGljYWxseSBkZXN0cm95ZWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICB9O1xuICB9LFxuICAvLyBhbmltYXRlXG5cbiAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZUltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hbnVhbGx5IGhvb2sgYW5kIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgcXVldWUgPSBlbGUuYW5pbWF0ZWQoKSAmJiAocHJvcGVydGllcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnRpZXMucXVldWUpO1xuICAgICAgICB2YXIgYW5pID0gZWxlLmFuaW1hdGlvbihwcm9wZXJ0aWVzLCBxdWV1ZSA/IHtcbiAgICAgICAgICBxdWV1ZTogdHJ1ZVxuICAgICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH07XG4gIH0sXG4gIC8vIGFuaW1hdGVcblxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdG9wSW1wbChjbGVhclF1ZXVlLCBqdW1wVG9FbmQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGFuaXMgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbmlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IGFuaXNbal07XG4gICAgICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgICAgICAgIGlmIChqdW1wVG9FbmQpIHtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqdW1wVG9FbmQpIHtcbiAgICAgICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGhhdmUgdG8gbm90aWZ5ICh0aGUgYW5pbWF0aW9uIGxvb3AgZG9lc24ndCBkbyBpdCBmb3IgdXMgb24gYHN0b3BgKVxuICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3Bcbn07IC8vIGRlZmluZVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxudmFyIGlzQXJyYXlfMTtcbnZhciBoYXNSZXF1aXJlZElzQXJyYXk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJc0FycmF5ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSXNBcnJheSkgcmV0dXJuIGlzQXJyYXlfMTtcblx0aGFzUmVxdWlyZWRJc0FycmF5ID0gMTtcblx0dmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5cdGlzQXJyYXlfMSA9IGlzQXJyYXk7XG5cdHJldHVybiBpc0FycmF5XzE7XG59XG5cbnZhciBfaXNLZXk7XG52YXIgaGFzUmVxdWlyZWRfaXNLZXk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaXNLZXkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaXNLZXkpIHJldHVybiBfaXNLZXk7XG5cdGhhc1JlcXVpcmVkX2lzS2V5ID0gMTtcblx0dmFyIGlzQXJyYXkgPSByZXF1aXJlSXNBcnJheSgpLFxuXHQgICAgaXNTeW1ib2wgPSByZXF1aXJlSXNTeW1ib2woKTtcblxuXHQvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG5cdHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuXHQgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcblx0ICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuXHQgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcblx0ICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG5cdH1cblxuXHRfaXNLZXkgPSBpc0tleTtcblx0cmV0dXJuIF9pc0tleTtcbn1cblxudmFyIGlzRnVuY3Rpb25fMTtcbnZhciBoYXNSZXF1aXJlZElzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIHJlcXVpcmVJc0Z1bmN0aW9uICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSXNGdW5jdGlvbikgcmV0dXJuIGlzRnVuY3Rpb25fMTtcblx0aGFzUmVxdWlyZWRJc0Z1bmN0aW9uID0gMTtcblx0dmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlX2Jhc2VHZXRUYWcoKSxcblx0ICAgIGlzT2JqZWN0ID0gcmVxdWlyZUlzT2JqZWN0KCk7XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG5cdCAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcblx0ICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG5cdCAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5pc0Z1bmN0aW9uKF8pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdCAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG5cdCAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG5cdCAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuXHQgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG5cdH1cblxuXHRpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uO1xuXHRyZXR1cm4gaXNGdW5jdGlvbl8xO1xufVxuXG52YXIgX2NvcmVKc0RhdGE7XG52YXIgaGFzUmVxdWlyZWRfY29yZUpzRGF0YTtcblxuZnVuY3Rpb24gcmVxdWlyZV9jb3JlSnNEYXRhICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2NvcmVKc0RhdGEpIHJldHVybiBfY29yZUpzRGF0YTtcblx0aGFzUmVxdWlyZWRfY29yZUpzRGF0YSA9IDE7XG5cdHZhciByb290ID0gcmVxdWlyZV9yb290KCk7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuXHR2YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5cdF9jb3JlSnNEYXRhID0gY29yZUpzRGF0YTtcblx0cmV0dXJuIF9jb3JlSnNEYXRhO1xufVxuXG52YXIgX2lzTWFza2VkO1xudmFyIGhhc1JlcXVpcmVkX2lzTWFza2VkO1xuXG5mdW5jdGlvbiByZXF1aXJlX2lzTWFza2VkICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2lzTWFza2VkKSByZXR1cm4gX2lzTWFza2VkO1xuXHRoYXNSZXF1aXJlZF9pc01hc2tlZCA9IDE7XG5cdHZhciBjb3JlSnNEYXRhID0gcmVxdWlyZV9jb3JlSnNEYXRhKCk7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cblx0dmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcblx0ICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG5cdH0oKSk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcblx0ICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuXHR9XG5cblx0X2lzTWFza2VkID0gaXNNYXNrZWQ7XG5cdHJldHVybiBfaXNNYXNrZWQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblxudmFyIF90b1NvdXJjZTtcbnZhciBoYXNSZXF1aXJlZF90b1NvdXJjZTtcblxuZnVuY3Rpb24gcmVxdWlyZV90b1NvdXJjZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF90b1NvdXJjZSkgcmV0dXJuIF90b1NvdXJjZTtcblx0aGFzUmVxdWlyZWRfdG9Tb3VyY2UgPSAxO1xuXHR2YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblx0dmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuXHQvKipcblx0ICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG5cdCAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiAoZnVuYyArICcnKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgfVxuXHQgIHJldHVybiAnJztcblx0fVxuXG5cdF90b1NvdXJjZSA9IHRvU291cmNlO1xuXHRyZXR1cm4gX3RvU291cmNlO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZTtcbnZhciBoYXNSZXF1aXJlZF9iYXNlSXNOYXRpdmU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYmFzZUlzTmF0aXZlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Jhc2VJc05hdGl2ZSkgcmV0dXJuIF9iYXNlSXNOYXRpdmU7XG5cdGhhc1JlcXVpcmVkX2Jhc2VJc05hdGl2ZSA9IDE7XG5cdHZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZUlzRnVuY3Rpb24oKSxcblx0ICAgIGlzTWFza2VkID0gcmVxdWlyZV9pc01hc2tlZCgpLFxuXHQgICAgaXNPYmplY3QgPSByZXF1aXJlSXNPYmplY3QoKSxcblx0ICAgIHRvU291cmNlID0gcmVxdWlyZV90b1NvdXJjZSgpO1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG5cdCAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuXHQgKi9cblx0dmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG5cdHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcblx0ICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG5cdHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG5cdHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG5cdCAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcblx0ICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcblx0KTtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG5cdCAqICBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcblx0ICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG5cdCAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuXHR9XG5cblx0X2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZTtcblx0cmV0dXJuIF9iYXNlSXNOYXRpdmU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cblxudmFyIF9nZXRWYWx1ZTtcbnZhciBoYXNSZXF1aXJlZF9nZXRWYWx1ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9nZXRWYWx1ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9nZXRWYWx1ZSkgcmV0dXJuIF9nZXRWYWx1ZTtcblx0aGFzUmVxdWlyZWRfZ2V0VmFsdWUgPSAxO1xuXHRmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuXHQgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuXHR9XG5cblx0X2dldFZhbHVlID0gZ2V0VmFsdWU7XG5cdHJldHVybiBfZ2V0VmFsdWU7XG59XG5cbnZhciBfZ2V0TmF0aXZlO1xudmFyIGhhc1JlcXVpcmVkX2dldE5hdGl2ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9nZXROYXRpdmUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfZ2V0TmF0aXZlKSByZXR1cm4gX2dldE5hdGl2ZTtcblx0aGFzUmVxdWlyZWRfZ2V0TmF0aXZlID0gMTtcblx0dmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmVfYmFzZUlzTmF0aXZlKCksXG5cdCAgICBnZXRWYWx1ZSA9IHJlcXVpcmVfZ2V0VmFsdWUoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG5cdCAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuXHQgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG5cdH1cblxuXHRfZ2V0TmF0aXZlID0gZ2V0TmF0aXZlO1xuXHRyZXR1cm4gX2dldE5hdGl2ZTtcbn1cblxudmFyIF9uYXRpdmVDcmVhdGU7XG52YXIgaGFzUmVxdWlyZWRfbmF0aXZlQ3JlYXRlO1xuXG5mdW5jdGlvbiByZXF1aXJlX25hdGl2ZUNyZWF0ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9uYXRpdmVDcmVhdGUpIHJldHVybiBfbmF0aXZlQ3JlYXRlO1xuXHRoYXNSZXF1aXJlZF9uYXRpdmVDcmVhdGUgPSAxO1xuXHR2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZV9nZXROYXRpdmUoKTtcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cdHZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cblx0X25hdGl2ZUNyZWF0ZSA9IG5hdGl2ZUNyZWF0ZTtcblx0cmV0dXJuIF9uYXRpdmVDcmVhdGU7XG59XG5cbnZhciBfaGFzaENsZWFyO1xudmFyIGhhc1JlcXVpcmVkX2hhc2hDbGVhcjtcblxuZnVuY3Rpb24gcmVxdWlyZV9oYXNoQ2xlYXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaGFzaENsZWFyKSByZXR1cm4gX2hhc2hDbGVhcjtcblx0aGFzUmVxdWlyZWRfaGFzaENsZWFyID0gMTtcblx0dmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmVfbmF0aXZlQ3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGNsZWFyXG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG5cdCAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuXHQgIHRoaXMuc2l6ZSA9IDA7XG5cdH1cblxuXHRfaGFzaENsZWFyID0gaGFzaENsZWFyO1xuXHRyZXR1cm4gX2hhc2hDbGVhcjtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxudmFyIF9oYXNoRGVsZXRlO1xudmFyIGhhc1JlcXVpcmVkX2hhc2hEZWxldGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaGFzaERlbGV0ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9oYXNoRGVsZXRlKSByZXR1cm4gX2hhc2hEZWxldGU7XG5cdGhhc1JlcXVpcmVkX2hhc2hEZWxldGUgPSAxO1xuXHRmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuXHQgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG5cdCAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRfaGFzaERlbGV0ZSA9IGhhc2hEZWxldGU7XG5cdHJldHVybiBfaGFzaERlbGV0ZTtcbn1cblxudmFyIF9oYXNoR2V0O1xudmFyIGhhc1JlcXVpcmVkX2hhc2hHZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaGFzaEdldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9oYXNoR2V0KSByZXR1cm4gX2hhc2hHZXQ7XG5cdGhhc1JlcXVpcmVkX2hhc2hHZXQgPSAxO1xuXHR2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZV9uYXRpdmVDcmVhdGUoKTtcblxuXHQvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG5cdHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZ2V0XG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblx0ICBpZiAobmF0aXZlQ3JlYXRlKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuXHQgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG5cdCAgfVxuXHQgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG5cdH1cblxuXHRfaGFzaEdldCA9IGhhc2hHZXQ7XG5cdHJldHVybiBfaGFzaEdldDtcbn1cblxudmFyIF9oYXNoSGFzO1xudmFyIGhhc1JlcXVpcmVkX2hhc2hIYXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaGFzaEhhcyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9oYXNoSGFzKSByZXR1cm4gX2hhc2hIYXM7XG5cdGhhc1JlcXVpcmVkX2hhc2hIYXMgPSAxO1xuXHR2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZV9uYXRpdmVDcmVhdGUoKTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGhhc1xuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG5cdH1cblxuXHRfaGFzaEhhcyA9IGhhc2hIYXM7XG5cdHJldHVybiBfaGFzaEhhcztcbn1cblxudmFyIF9oYXNoU2V0O1xudmFyIGhhc1JlcXVpcmVkX2hhc2hTZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaGFzaFNldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9oYXNoU2V0KSByZXR1cm4gX2hhc2hTZXQ7XG5cdGhhc1JlcXVpcmVkX2hhc2hTZXQgPSAxO1xuXHR2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZV9uYXRpdmVDcmVhdGUoKTtcblxuXHQvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG5cdHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuXHQvKipcblx0ICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBzZXRcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblx0ICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuXHQgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0X2hhc2hTZXQgPSBoYXNoU2V0O1xuXHRyZXR1cm4gX2hhc2hTZXQ7XG59XG5cbnZhciBfSGFzaDtcbnZhciBoYXNSZXF1aXJlZF9IYXNoO1xuXG5mdW5jdGlvbiByZXF1aXJlX0hhc2ggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfSGFzaCkgcmV0dXJuIF9IYXNoO1xuXHRoYXNSZXF1aXJlZF9IYXNoID0gMTtcblx0dmFyIGhhc2hDbGVhciA9IHJlcXVpcmVfaGFzaENsZWFyKCksXG5cdCAgICBoYXNoRGVsZXRlID0gcmVxdWlyZV9oYXNoRGVsZXRlKCksXG5cdCAgICBoYXNoR2V0ID0gcmVxdWlyZV9oYXNoR2V0KCksXG5cdCAgICBoYXNoSGFzID0gcmVxdWlyZV9oYXNoSGFzKCksXG5cdCAgICBoYXNoU2V0ID0gcmVxdWlyZV9oYXNoU2V0KCk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuXHQgIHRoaXMuY2xlYXIoKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgIH1cblx0fVxuXG5cdC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cblx0SGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5cdEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5cdEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5cdEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5cdEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cblx0X0hhc2ggPSBIYXNoO1xuXHRyZXR1cm4gX0hhc2g7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuXG52YXIgX2xpc3RDYWNoZUNsZWFyO1xudmFyIGhhc1JlcXVpcmVkX2xpc3RDYWNoZUNsZWFyO1xuXG5mdW5jdGlvbiByZXF1aXJlX2xpc3RDYWNoZUNsZWFyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2xpc3RDYWNoZUNsZWFyKSByZXR1cm4gX2xpc3RDYWNoZUNsZWFyO1xuXHRoYXNSZXF1aXJlZF9saXN0Q2FjaGVDbGVhciA9IDE7XG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuXHQgIHRoaXMuX19kYXRhX18gPSBbXTtcblx0ICB0aGlzLnNpemUgPSAwO1xuXHR9XG5cblx0X2xpc3RDYWNoZUNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5cdHJldHVybiBfbGlzdENhY2hlQ2xlYXI7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuXG52YXIgZXFfMTtcbnZhciBoYXNSZXF1aXJlZEVxO1xuXG5mdW5jdGlvbiByZXF1aXJlRXEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRFcSkgcmV0dXJuIGVxXzE7XG5cdGhhc1JlcXVpcmVkRXEgPSAxO1xuXHRmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcblx0ICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcblx0fVxuXG5cdGVxXzEgPSBlcTtcblx0cmV0dXJuIGVxXzE7XG59XG5cbnZhciBfYXNzb2NJbmRleE9mO1xudmFyIGhhc1JlcXVpcmVkX2Fzc29jSW5kZXhPZjtcblxuZnVuY3Rpb24gcmVxdWlyZV9hc3NvY0luZGV4T2YgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYXNzb2NJbmRleE9mKSByZXR1cm4gX2Fzc29jSW5kZXhPZjtcblx0aGFzUmVxdWlyZWRfYXNzb2NJbmRleE9mID0gMTtcblx0dmFyIGVxID0gcmVxdWlyZUVxKCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG5cdCAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cblx0ICovXG5cdGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG5cdCAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0ICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG5cdCAgICAgIHJldHVybiBsZW5ndGg7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fVxuXG5cdF9hc3NvY0luZGV4T2YgPSBhc3NvY0luZGV4T2Y7XG5cdHJldHVybiBfYXNzb2NJbmRleE9mO1xufVxuXG52YXIgX2xpc3RDYWNoZURlbGV0ZTtcbnZhciBoYXNSZXF1aXJlZF9saXN0Q2FjaGVEZWxldGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbGlzdENhY2hlRGVsZXRlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2xpc3RDYWNoZURlbGV0ZSkgcmV0dXJuIF9saXN0Q2FjaGVEZWxldGU7XG5cdGhhc1JlcXVpcmVkX2xpc3RDYWNoZURlbGV0ZSA9IDE7XG5cdHZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlX2Fzc29jSW5kZXhPZigpO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGRlbGV0ZVxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuXHQgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcblx0ICAgIGRhdGEucG9wKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcblx0ICB9XG5cdCAgLS10aGlzLnNpemU7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHRfbGlzdENhY2hlRGVsZXRlID0gbGlzdENhY2hlRGVsZXRlO1xuXHRyZXR1cm4gX2xpc3RDYWNoZURlbGV0ZTtcbn1cblxudmFyIF9saXN0Q2FjaGVHZXQ7XG52YXIgaGFzUmVxdWlyZWRfbGlzdENhY2hlR2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX2xpc3RDYWNoZUdldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9saXN0Q2FjaGVHZXQpIHJldHVybiBfbGlzdENhY2hlR2V0O1xuXHRoYXNSZXF1aXJlZF9saXN0Q2FjaGVHZXQgPSAxO1xuXHR2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZV9hc3NvY0luZGV4T2YoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGdldFxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuXHR9XG5cblx0X2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblx0cmV0dXJuIF9saXN0Q2FjaGVHZXQ7XG59XG5cbnZhciBfbGlzdENhY2hlSGFzO1xudmFyIGhhc1JlcXVpcmVkX2xpc3RDYWNoZUhhcztcblxuZnVuY3Rpb24gcmVxdWlyZV9saXN0Q2FjaGVIYXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbGlzdENhY2hlSGFzKSByZXR1cm4gX2xpc3RDYWNoZUhhcztcblx0aGFzUmVxdWlyZWRfbGlzdENhY2hlSGFzID0gMTtcblx0dmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmVfYXNzb2NJbmRleE9mKCk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgaGFzXG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcblx0ICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcblx0fVxuXG5cdF9saXN0Q2FjaGVIYXMgPSBsaXN0Q2FjaGVIYXM7XG5cdHJldHVybiBfbGlzdENhY2hlSGFzO1xufVxuXG52YXIgX2xpc3RDYWNoZVNldDtcbnZhciBoYXNSZXF1aXJlZF9saXN0Q2FjaGVTZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbGlzdENhY2hlU2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2xpc3RDYWNoZVNldCkgcmV0dXJuIF9saXN0Q2FjaGVTZXQ7XG5cdGhhc1JlcXVpcmVkX2xpc3RDYWNoZVNldCA9IDE7XG5cdHZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlX2Fzc29jSW5kZXhPZigpO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIHNldFxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcblx0ICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgICsrdGhpcy5zaXplO1xuXHQgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0X2xpc3RDYWNoZVNldCA9IGxpc3RDYWNoZVNldDtcblx0cmV0dXJuIF9saXN0Q2FjaGVTZXQ7XG59XG5cbnZhciBfTGlzdENhY2hlO1xudmFyIGhhc1JlcXVpcmVkX0xpc3RDYWNoZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9MaXN0Q2FjaGUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfTGlzdENhY2hlKSByZXR1cm4gX0xpc3RDYWNoZTtcblx0aGFzUmVxdWlyZWRfTGlzdENhY2hlID0gMTtcblx0dmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZV9saXN0Q2FjaGVDbGVhcigpLFxuXHQgICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZV9saXN0Q2FjaGVEZWxldGUoKSxcblx0ICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmVfbGlzdENhY2hlR2V0KCksXG5cdCAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlX2xpc3RDYWNoZUhhcygpLFxuXHQgICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZV9saXN0Q2FjaGVTZXQoKTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG5cdCAgdGhpcy5jbGVhcigpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcblx0ICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgfVxuXHR9XG5cblx0Ly8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5cdExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcblx0TGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5cdExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuXHRMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcblx0TGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cblx0X0xpc3RDYWNoZSA9IExpc3RDYWNoZTtcblx0cmV0dXJuIF9MaXN0Q2FjaGU7XG59XG5cbnZhciBfTWFwO1xudmFyIGhhc1JlcXVpcmVkX01hcDtcblxuZnVuY3Rpb24gcmVxdWlyZV9NYXAgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfTWFwKSByZXR1cm4gX01hcDtcblx0aGFzUmVxdWlyZWRfTWFwID0gMTtcblx0dmFyIGdldE5hdGl2ZSA9IHJlcXVpcmVfZ2V0TmF0aXZlKCksXG5cdCAgICByb290ID0gcmVxdWlyZV9yb290KCk7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuXHR2YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuXHRfTWFwID0gTWFwO1xuXHRyZXR1cm4gX01hcDtcbn1cblxudmFyIF9tYXBDYWNoZUNsZWFyO1xudmFyIGhhc1JlcXVpcmVkX21hcENhY2hlQ2xlYXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbWFwQ2FjaGVDbGVhciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9tYXBDYWNoZUNsZWFyKSByZXR1cm4gX21hcENhY2hlQ2xlYXI7XG5cdGhhc1JlcXVpcmVkX21hcENhY2hlQ2xlYXIgPSAxO1xuXHR2YXIgSGFzaCA9IHJlcXVpcmVfSGFzaCgpLFxuXHQgICAgTGlzdENhY2hlID0gcmVxdWlyZV9MaXN0Q2FjaGUoKSxcblx0ICAgIE1hcCA9IHJlcXVpcmVfTWFwKCk7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgY2xlYXJcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuXHQgIHRoaXMuc2l6ZSA9IDA7XG5cdCAgdGhpcy5fX2RhdGFfXyA9IHtcblx0ICAgICdoYXNoJzogbmV3IEhhc2gsXG5cdCAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcblx0ICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuXHQgIH07XG5cdH1cblxuXHRfbWFwQ2FjaGVDbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cdHJldHVybiBfbWFwQ2FjaGVDbGVhcjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxudmFyIF9pc0tleWFibGU7XG52YXIgaGFzUmVxdWlyZWRfaXNLZXlhYmxlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2lzS2V5YWJsZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9pc0tleWFibGUpIHJldHVybiBfaXNLZXlhYmxlO1xuXHRoYXNSZXF1aXJlZF9pc0tleWFibGUgPSAxO1xuXHRmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuXHQgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuXHQgICAgOiAodmFsdWUgPT09IG51bGwpO1xuXHR9XG5cblx0X2lzS2V5YWJsZSA9IGlzS2V5YWJsZTtcblx0cmV0dXJuIF9pc0tleWFibGU7XG59XG5cbnZhciBfZ2V0TWFwRGF0YTtcbnZhciBoYXNSZXF1aXJlZF9nZXRNYXBEYXRhO1xuXG5mdW5jdGlvbiByZXF1aXJlX2dldE1hcERhdGEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfZ2V0TWFwRGF0YSkgcmV0dXJuIF9nZXRNYXBEYXRhO1xuXHRoYXNSZXF1aXJlZF9nZXRNYXBEYXRhID0gMTtcblx0dmFyIGlzS2V5YWJsZSA9IHJlcXVpcmVfaXNLZXlhYmxlKCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcblx0ICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcblx0ICByZXR1cm4gaXNLZXlhYmxlKGtleSlcblx0ICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG5cdCAgICA6IGRhdGEubWFwO1xuXHR9XG5cblx0X2dldE1hcERhdGEgPSBnZXRNYXBEYXRhO1xuXHRyZXR1cm4gX2dldE1hcERhdGE7XG59XG5cbnZhciBfbWFwQ2FjaGVEZWxldGU7XG52YXIgaGFzUmVxdWlyZWRfbWFwQ2FjaGVEZWxldGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbWFwQ2FjaGVEZWxldGUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbWFwQ2FjaGVEZWxldGUpIHJldHVybiBfbWFwQ2FjaGVEZWxldGU7XG5cdGhhc1JlcXVpcmVkX21hcENhY2hlRGVsZXRlID0gMTtcblx0dmFyIGdldE1hcERhdGEgPSByZXF1aXJlX2dldE1hcERhdGEoKTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZGVsZXRlXG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG5cdCAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcblx0ICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXHRyZXR1cm4gX21hcENhY2hlRGVsZXRlO1xufVxuXG52YXIgX21hcENhY2hlR2V0O1xudmFyIGhhc1JlcXVpcmVkX21hcENhY2hlR2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX21hcENhY2hlR2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX21hcENhY2hlR2V0KSByZXR1cm4gX21hcENhY2hlR2V0O1xuXHRoYXNSZXF1aXJlZF9tYXBDYWNoZUdldCA9IDE7XG5cdHZhciBnZXRNYXBEYXRhID0gcmVxdWlyZV9nZXRNYXBEYXRhKCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGdldFxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuXHQgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG5cdH1cblxuXHRfbWFwQ2FjaGVHZXQgPSBtYXBDYWNoZUdldDtcblx0cmV0dXJuIF9tYXBDYWNoZUdldDtcbn1cblxudmFyIF9tYXBDYWNoZUhhcztcbnZhciBoYXNSZXF1aXJlZF9tYXBDYWNoZUhhcztcblxuZnVuY3Rpb24gcmVxdWlyZV9tYXBDYWNoZUhhcyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9tYXBDYWNoZUhhcykgcmV0dXJuIF9tYXBDYWNoZUhhcztcblx0aGFzUmVxdWlyZWRfbWFwQ2FjaGVIYXMgPSAxO1xuXHR2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmVfZ2V0TWFwRGF0YSgpO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgaGFzXG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG5cdCAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcblx0fVxuXG5cdF9tYXBDYWNoZUhhcyA9IG1hcENhY2hlSGFzO1xuXHRyZXR1cm4gX21hcENhY2hlSGFzO1xufVxuXG52YXIgX21hcENhY2hlU2V0O1xudmFyIGhhc1JlcXVpcmVkX21hcENhY2hlU2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX21hcENhY2hlU2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX21hcENhY2hlU2V0KSByZXR1cm4gX21hcENhY2hlU2V0O1xuXHRoYXNSZXF1aXJlZF9tYXBDYWNoZVNldCA9IDE7XG5cdHZhciBnZXRNYXBEYXRhID0gcmVxdWlyZV9nZXRNYXBEYXRhKCk7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBzZXRcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcblx0ICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcblx0ICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuXHQgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuXHQgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0X21hcENhY2hlU2V0ID0gbWFwQ2FjaGVTZXQ7XG5cdHJldHVybiBfbWFwQ2FjaGVTZXQ7XG59XG5cbnZhciBfTWFwQ2FjaGU7XG52YXIgaGFzUmVxdWlyZWRfTWFwQ2FjaGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfTWFwQ2FjaGUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfTWFwQ2FjaGUpIHJldHVybiBfTWFwQ2FjaGU7XG5cdGhhc1JlcXVpcmVkX01hcENhY2hlID0gMTtcblx0dmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlX21hcENhY2hlQ2xlYXIoKSxcblx0ICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZV9tYXBDYWNoZURlbGV0ZSgpLFxuXHQgICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlX21hcENhY2hlR2V0KCksXG5cdCAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmVfbWFwQ2FjaGVIYXMoKSxcblx0ICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZV9tYXBDYWNoZVNldCgpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cblx0ICovXG5cdGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG5cdCAgdGhpcy5jbGVhcigpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcblx0ICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgfVxuXHR9XG5cblx0Ly8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cblx0TWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcblx0TWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuXHRNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5cdE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcblx0TWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5cdF9NYXBDYWNoZSA9IE1hcENhY2hlO1xuXHRyZXR1cm4gX01hcENhY2hlO1xufVxuXG52YXIgbWVtb2l6ZV8xO1xudmFyIGhhc1JlcXVpcmVkTWVtb2l6ZTtcblxuZnVuY3Rpb24gcmVxdWlyZU1lbW9pemUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRNZW1vaXplKSByZXR1cm4gbWVtb2l6ZV8xO1xuXHRoYXNSZXF1aXJlZE1lbW9pemUgPSAxO1xuXHR2YXIgTWFwQ2FjaGUgPSByZXF1aXJlX01hcENhY2hlKCk7XG5cblx0LyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuXHR2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuXHQgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG5cdCAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuXHQgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuXHQgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cblx0ICpcblx0ICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuXHQgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcblx0ICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcblx0ICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcblx0ICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG5cdCAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcblx0ICpcblx0ICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG5cdCAqIHZhbHVlcyhvYmplY3QpO1xuXHQgKiAvLyA9PiBbMSwgMl1cblx0ICpcblx0ICogdmFsdWVzKG90aGVyKTtcblx0ICogLy8gPT4gWzMsIDRdXG5cdCAqXG5cdCAqIG9iamVjdC5hID0gMjtcblx0ICogdmFsdWVzKG9iamVjdCk7XG5cdCAqIC8vID0+IFsxLCAyXVxuXHQgKlxuXHQgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cblx0ICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuXHQgKiB2YWx1ZXMob2JqZWN0KTtcblx0ICogLy8gPT4gWydhJywgJ2InXVxuXHQgKlxuXHQgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuXHQgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuXHQgKi9cblx0ZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuXHQgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgIH1cblx0ICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHQgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuXHQgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cblx0ICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuXHQgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblx0ICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG5cdCAgcmV0dXJuIG1lbW9pemVkO1xuXHR9XG5cblx0Ly8gRXhwb3NlIGBNYXBDYWNoZWAuXG5cdG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuXHRtZW1vaXplXzEgPSBtZW1vaXplO1xuXHRyZXR1cm4gbWVtb2l6ZV8xO1xufVxuXG52YXIgX21lbW9pemVDYXBwZWQ7XG52YXIgaGFzUmVxdWlyZWRfbWVtb2l6ZUNhcHBlZDtcblxuZnVuY3Rpb24gcmVxdWlyZV9tZW1vaXplQ2FwcGVkICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX21lbW9pemVDYXBwZWQpIHJldHVybiBfbWVtb2l6ZUNhcHBlZDtcblx0aGFzUmVxdWlyZWRfbWVtb2l6ZUNhcHBlZCA9IDE7XG5cdHZhciBtZW1vaXplID0gcmVxdWlyZU1lbW9pemUoKTtcblxuXHQvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG5cdHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG5cdCAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcblx0ICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcblx0ICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG5cdCAgICAgIGNhY2hlLmNsZWFyKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4ga2V5O1xuXHQgIH0pO1xuXG5cdCAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRfbWVtb2l6ZUNhcHBlZCA9IG1lbW9pemVDYXBwZWQ7XG5cdHJldHVybiBfbWVtb2l6ZUNhcHBlZDtcbn1cblxudmFyIF9zdHJpbmdUb1BhdGg7XG52YXIgaGFzUmVxdWlyZWRfc3RyaW5nVG9QYXRoO1xuXG5mdW5jdGlvbiByZXF1aXJlX3N0cmluZ1RvUGF0aCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9zdHJpbmdUb1BhdGgpIHJldHVybiBfc3RyaW5nVG9QYXRoO1xuXHRoYXNSZXF1aXJlZF9zdHJpbmdUb1BhdGggPSAxO1xuXHR2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmVfbWVtb2l6ZUNhcHBlZCgpO1xuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblx0dmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cblx0LyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG5cdHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuXHQvKipcblx0ICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuXHQgKi9cblx0dmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuXHQgICAgcmVzdWx0LnB1c2goJycpO1xuXHQgIH1cblx0ICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdCAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fSk7XG5cblx0X3N0cmluZ1RvUGF0aCA9IHN0cmluZ1RvUGF0aDtcblx0cmV0dXJuIF9zdHJpbmdUb1BhdGg7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5cbnZhciBfYXJyYXlNYXA7XG52YXIgaGFzUmVxdWlyZWRfYXJyYXlNYXA7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYXJyYXlNYXAgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYXJyYXlNYXApIHJldHVybiBfYXJyYXlNYXA7XG5cdGhhc1JlcXVpcmVkX2FycmF5TWFwID0gMTtcblx0ZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuXHQgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRfYXJyYXlNYXAgPSBhcnJheU1hcDtcblx0cmV0dXJuIF9hcnJheU1hcDtcbn1cblxudmFyIF9iYXNlVG9TdHJpbmc7XG52YXIgaGFzUmVxdWlyZWRfYmFzZVRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Jhc2VUb1N0cmluZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9iYXNlVG9TdHJpbmcpIHJldHVybiBfYmFzZVRvU3RyaW5nO1xuXHRoYXNSZXF1aXJlZF9iYXNlVG9TdHJpbmcgPSAxO1xuXHR2YXIgU3ltYm9sID0gcmVxdWlyZV9TeW1ib2woKSxcblx0ICAgIGFycmF5TWFwID0gcmVxdWlyZV9hcnJheU1hcCgpLFxuXHQgICAgaXNBcnJheSA9IHJlcXVpcmVJc0FycmF5KCksXG5cdCAgICBpc1N5bWJvbCA9IHJlcXVpcmVJc1N5bWJvbCgpO1xuXG5cdC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuXHR2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuXHQgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcblx0ICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuXHQgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cdCAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcblx0ICB9XG5cdCAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcblx0ICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUluZmluaXR5KSA/ICctMCcgOiByZXN1bHQ7XG5cdH1cblxuXHRfYmFzZVRvU3RyaW5nID0gYmFzZVRvU3RyaW5nO1xuXHRyZXR1cm4gX2Jhc2VUb1N0cmluZztcbn1cblxudmFyIHRvU3RyaW5nXzE7XG52YXIgaGFzUmVxdWlyZWRUb1N0cmluZztcblxuZnVuY3Rpb24gcmVxdWlyZVRvU3RyaW5nICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVG9TdHJpbmcpIHJldHVybiB0b1N0cmluZ18xO1xuXHRoYXNSZXF1aXJlZFRvU3RyaW5nID0gMTtcblx0dmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmVfYmFzZVRvU3RyaW5nKCk7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG5cdCAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnRvU3RyaW5nKG51bGwpO1xuXHQgKiAvLyA9PiAnJ1xuXHQgKlxuXHQgKiBfLnRvU3RyaW5nKC0wKTtcblx0ICogLy8gPT4gJy0wJ1xuXHQgKlxuXHQgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG5cdCAqIC8vID0+ICcxLDIsMydcblx0ICovXG5cdGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG5cdH1cblxuXHR0b1N0cmluZ18xID0gdG9TdHJpbmc7XG5cdHJldHVybiB0b1N0cmluZ18xO1xufVxuXG52YXIgX2Nhc3RQYXRoO1xudmFyIGhhc1JlcXVpcmVkX2Nhc3RQYXRoO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Nhc3RQYXRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Nhc3RQYXRoKSByZXR1cm4gX2Nhc3RQYXRoO1xuXHRoYXNSZXF1aXJlZF9jYXN0UGF0aCA9IDE7XG5cdHZhciBpc0FycmF5ID0gcmVxdWlyZUlzQXJyYXkoKSxcblx0ICAgIGlzS2V5ID0gcmVxdWlyZV9pc0tleSgpLFxuXHQgICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZV9zdHJpbmdUb1BhdGgoKSxcblx0ICAgIHRvU3RyaW5nID0gcmVxdWlyZVRvU3RyaW5nKCk7XG5cblx0LyoqXG5cdCAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG5cdCAqL1xuXHRmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG5cdCAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcblx0fVxuXG5cdF9jYXN0UGF0aCA9IGNhc3RQYXRoO1xuXHRyZXR1cm4gX2Nhc3RQYXRoO1xufVxuXG52YXIgX3RvS2V5O1xudmFyIGhhc1JlcXVpcmVkX3RvS2V5O1xuXG5mdW5jdGlvbiByZXF1aXJlX3RvS2V5ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX3RvS2V5KSByZXR1cm4gX3RvS2V5O1xuXHRoYXNSZXF1aXJlZF90b0tleSA9IDE7XG5cdHZhciBpc1N5bWJvbCA9IHJlcXVpcmVJc1N5bWJvbCgpO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG5cdCAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JbmZpbml0eSkgPyAnLTAnIDogcmVzdWx0O1xuXHR9XG5cblx0X3RvS2V5ID0gdG9LZXk7XG5cdHJldHVybiBfdG9LZXk7XG59XG5cbnZhciBfYmFzZUdldDtcbnZhciBoYXNSZXF1aXJlZF9iYXNlR2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX2Jhc2VHZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYmFzZUdldCkgcmV0dXJuIF9iYXNlR2V0O1xuXHRoYXNSZXF1aXJlZF9iYXNlR2V0ID0gMTtcblx0dmFyIGNhc3RQYXRoID0gcmVxdWlyZV9jYXN0UGF0aCgpLFxuXHQgICAgdG9LZXkgPSByZXF1aXJlX3RvS2V5KCk7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuXHQgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG5cdCAgdmFyIGluZGV4ID0gMCxcblx0ICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cblx0ICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG5cdCAgfVxuXHQgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcblx0fVxuXG5cdF9iYXNlR2V0ID0gYmFzZUdldDtcblx0cmV0dXJuIF9iYXNlR2V0O1xufVxuXG52YXIgZ2V0XzE7XG52YXIgaGFzUmVxdWlyZWRHZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVHZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRHZXQpIHJldHVybiBnZXRfMTtcblx0aGFzUmVxdWlyZWRHZXQgPSAxO1xuXHR2YXIgYmFzZUdldCA9IHJlcXVpcmVfYmFzZUdldCgpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuXHQgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMy43LjBcblx0ICogQGNhdGVnb3J5IE9iamVjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcblx0ICpcblx0ICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcblx0ICogLy8gPT4gM1xuXHQgKlxuXHQgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcblx0ICogLy8gPT4gM1xuXHQgKlxuXHQgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG5cdCAqIC8vID0+ICdkZWZhdWx0J1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXHQgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcblx0fVxuXG5cdGdldF8xID0gZ2V0O1xuXHRyZXR1cm4gZ2V0XzE7XG59XG5cbnZhciBnZXRFeHBvcnRzID0gcmVxdWlyZUdldCgpO1xudmFyIGdldCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXRFeHBvcnRzKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTtcbnZhciBoYXNSZXF1aXJlZF9kZWZpbmVQcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9kZWZpbmVQcm9wZXJ0eSkgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eTtcblx0aGFzUmVxdWlyZWRfZGVmaW5lUHJvcGVydHkgPSAxO1xuXHR2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZV9nZXROYXRpdmUoKTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG5cdCAgICBmdW5jKHt9LCAnJywge30pO1xuXHQgICAgcmV0dXJuIGZ1bmM7XG5cdCAgfSBjYXRjaCAoZSkge31cblx0fSgpKTtcblxuXHRfZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eTtcblx0cmV0dXJuIF9kZWZpbmVQcm9wZXJ0eTtcbn1cblxudmFyIF9iYXNlQXNzaWduVmFsdWU7XG52YXIgaGFzUmVxdWlyZWRfYmFzZUFzc2lnblZhbHVlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Jhc2VBc3NpZ25WYWx1ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9iYXNlQXNzaWduVmFsdWUpIHJldHVybiBfYmFzZUFzc2lnblZhbHVlO1xuXHRoYXNSZXF1aXJlZF9iYXNlQXNzaWduVmFsdWUgPSAxO1xuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX2RlZmluZVByb3BlcnR5KCk7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG5cdCAqIHZhbHVlIGNoZWNrcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG5cdCAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXHQgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcblx0ICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuXHQgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG5cdCAgfVxuXHR9XG5cblx0X2Jhc2VBc3NpZ25WYWx1ZSA9IGJhc2VBc3NpZ25WYWx1ZTtcblx0cmV0dXJuIF9iYXNlQXNzaWduVmFsdWU7XG59XG5cbnZhciBfYXNzaWduVmFsdWU7XG52YXIgaGFzUmVxdWlyZWRfYXNzaWduVmFsdWU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYXNzaWduVmFsdWUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYXNzaWduVmFsdWUpIHJldHVybiBfYXNzaWduVmFsdWU7XG5cdGhhc1JlcXVpcmVkX2Fzc2lnblZhbHVlID0gMTtcblx0dmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmVfYmFzZUFzc2lnblZhbHVlKCksXG5cdCAgICBlcSA9IHJlcXVpcmVFcSgpO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcblx0ICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcblx0ICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcblx0ICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcblx0ICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuXHQgIH1cblx0fVxuXG5cdF9hc3NpZ25WYWx1ZSA9IGFzc2lnblZhbHVlO1xuXHRyZXR1cm4gX2Fzc2lnblZhbHVlO1xufVxuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cblxudmFyIF9pc0luZGV4O1xudmFyIGhhc1JlcXVpcmVkX2lzSW5kZXg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaXNJbmRleCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9pc0luZGV4KSByZXR1cm4gX2lzSW5kZXg7XG5cdGhhc1JlcXVpcmVkX2lzSW5kZXggPSAxO1xuXHR2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuXHR2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuXHQgIHJldHVybiAhIWxlbmd0aCAmJlxuXHQgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcblx0ICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuXHQgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcblx0fVxuXG5cdF9pc0luZGV4ID0gaXNJbmRleDtcblx0cmV0dXJuIF9pc0luZGV4O1xufVxuXG52YXIgX2Jhc2VTZXQ7XG52YXIgaGFzUmVxdWlyZWRfYmFzZVNldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9iYXNlU2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Jhc2VTZXQpIHJldHVybiBfYmFzZVNldDtcblx0aGFzUmVxdWlyZWRfYmFzZVNldCA9IDE7XG5cdHZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmVfYXNzaWduVmFsdWUoKSxcblx0ICAgIGNhc3RQYXRoID0gcmVxdWlyZV9jYXN0UGF0aCgpLFxuXHQgICAgaXNJbmRleCA9IHJlcXVpcmVfaXNJbmRleCgpLFxuXHQgICAgaXNPYmplY3QgPSByZXF1aXJlSXNPYmplY3QoKSxcblx0ICAgIHRvS2V5ID0gcmVxdWlyZV90b0tleSgpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcblx0ICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcblx0ICAgIHJldHVybiBvYmplY3Q7XG5cdCAgfVxuXHQgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuXHQgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuXHQgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cblx0ICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcblx0ICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG5cdCAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuXHQgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG5cdCAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuXHQgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG5cdCAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcblx0ICAgICAgICAgID8gb2JqVmFsdWVcblx0ICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuXHQgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG5cdCAgfVxuXHQgIHJldHVybiBvYmplY3Q7XG5cdH1cblxuXHRfYmFzZVNldCA9IGJhc2VTZXQ7XG5cdHJldHVybiBfYmFzZVNldDtcbn1cblxudmFyIHNldF8xO1xudmFyIGhhc1JlcXVpcmVkU2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlU2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkU2V0KSByZXR1cm4gc2V0XzE7XG5cdGhhc1JlcXVpcmVkU2V0ID0gMTtcblx0dmFyIGJhc2VTZXQgPSByZXF1aXJlX2Jhc2VTZXQoKTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG5cdCAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuXHQgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuXHQgKiBgcGF0aGAgY3JlYXRpb24uXG5cdCAqXG5cdCAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAzLjcuMFxuXHQgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcblx0ICpcblx0ICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcblx0ICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcblx0ICogLy8gPT4gNFxuXHQgKlxuXHQgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcblx0ICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcblx0ICogLy8gPT4gNVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcblx0ICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuXHR9XG5cblx0c2V0XzEgPSBzZXQ7XG5cdHJldHVybiBzZXRfMTtcbn1cblxudmFyIHNldEV4cG9ydHMgPSByZXF1aXJlU2V0KCk7XG52YXIgc2V0ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNldEV4cG9ydHMpO1xuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cblxudmFyIF9jb3B5QXJyYXk7XG52YXIgaGFzUmVxdWlyZWRfY29weUFycmF5O1xuXG5mdW5jdGlvbiByZXF1aXJlX2NvcHlBcnJheSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9jb3B5QXJyYXkpIHJldHVybiBfY29weUFycmF5O1xuXHRoYXNSZXF1aXJlZF9jb3B5QXJyYXkgPSAxO1xuXHRmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG5cdCAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG5cdCAgfVxuXHQgIHJldHVybiBhcnJheTtcblx0fVxuXG5cdF9jb3B5QXJyYXkgPSBjb3B5QXJyYXk7XG5cdHJldHVybiBfY29weUFycmF5O1xufVxuXG52YXIgdG9QYXRoXzE7XG52YXIgaGFzUmVxdWlyZWRUb1BhdGg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVUb1BhdGggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRUb1BhdGgpIHJldHVybiB0b1BhdGhfMTtcblx0aGFzUmVxdWlyZWRUb1BhdGggPSAxO1xuXHR2YXIgYXJyYXlNYXAgPSByZXF1aXJlX2FycmF5TWFwKCksXG5cdCAgICBjb3B5QXJyYXkgPSByZXF1aXJlX2NvcHlBcnJheSgpLFxuXHQgICAgaXNBcnJheSA9IHJlcXVpcmVJc0FycmF5KCksXG5cdCAgICBpc1N5bWJvbCA9IHJlcXVpcmVJc1N5bWJvbCgpLFxuXHQgICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZV9zdHJpbmdUb1BhdGgoKSxcblx0ICAgIHRvS2V5ID0gcmVxdWlyZV90b0tleSgpLFxuXHQgICAgdG9TdHJpbmcgPSByZXF1aXJlVG9TdHJpbmcoKTtcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBVdGlsXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udG9QYXRoKCdhLmIuYycpO1xuXHQgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cblx0ICpcblx0ICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG5cdCAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcblx0ICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuXHQgIH1cblx0ICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG5cdH1cblxuXHR0b1BhdGhfMSA9IHRvUGF0aDtcblx0cmV0dXJuIHRvUGF0aF8xO1xufVxuXG52YXIgdG9QYXRoRXhwb3J0cyA9IHJlcXVpcmVUb1BhdGgoKTtcbnZhciB0b1BhdGggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanModG9QYXRoRXhwb3J0cyk7XG5cbnZhciBkZWZpbmUkMiA9IHtcbiAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgZGF0YTogZnVuY3Rpb24gZGF0YShwYXJhbXMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9LFxuICAgICAgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChzZWxmKSB7fSxcbiAgICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KHNlbGYsIG9iaikge30sXG4gICAgICBvblNldDogZnVuY3Rpb24gb25TZXQoc2VsZikge30sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChzZWxmKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgc2luZ2xlID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZlswXSA6IHNlbGY7XG5cbiAgICAgIC8vIC5kYXRhKCdmb28nLCAuLi4pXG4gICAgICBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIC8vIHNldCBvciBnZXQgcHJvcGVydHlcbiAgICAgICAgdmFyIGlzUGF0aExpa2UgPSBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTE7IC8vIHRoZXJlIG1pZ2h0IGJlIGEgbm9ybWFsIGZpZWxkIHdpdGggYSBkb3QgXG4gICAgICAgIHZhciBwYXRoID0gaXNQYXRoTGlrZSAmJiB0b1BhdGgobmFtZSk7XG5cbiAgICAgICAgLy8gLmRhdGEoJ2ZvbycpXG4gICAgICAgIGlmIChwLmFsbG93R2V0dGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZ2V0XG5cbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0J3MgcGF0aCBhbmQgYSBmaWVsZCB3aXRoIHRoZSBzYW1lIG5hbWUgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKHBhdGggJiYgc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0ID0gZ2V0KHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXSwgcGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgICAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgIH0gZWxzZSBpZiAocC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHNldFxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbbmFtZV07XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gX2RlZmluZVByb3BlcnR5JDEoe30sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIGNoYW5nZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KGVsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCAmJiBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgc2V0KGVsZS5fcHJpdmF0ZVtwLmZpZWxkXSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgICAgIGlmIChwLnVwZGF0ZVN0eWxlKSB7XG4gICAgICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICAgICAgcC5vblNldChzZWxmKTtcbiAgICAgICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLnNldHRpbmdFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcbiAgICAgIH0gZWxzZSBpZiAocC5hbGxvd1NldHRpbmcgJiYgcGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgICAgLy8gZXh0ZW5kXG4gICAgICAgIHZhciBvYmogPSBuYW1lO1xuICAgICAgICB2YXIgaywgdjtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBvYmopO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBrID0ga2V5c1tfaV07XG4gICAgICAgICAgdiA9IG9ialtrXTtcbiAgICAgICAgICB2YXIgX3ZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcbiAgICAgICAgICBpZiAoX3ZhbGlkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgX2VsZSA9IGFsbFtqXTtcbiAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KF9lbGUpKSB7XG4gICAgICAgICAgICAgICAgX2VsZS5fcHJpdmF0ZVtwLmZpZWxkXVtrXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgcC5vblNldChzZWxmKTtcbiAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLmRhdGEoZnVuY3Rpb24oKXsgLi4uIH0pXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dCaW5kaW5nICYmIGZuJDYobmFtZSkpIHtcbiAgICAgICAgLy8gYmluZCB0byBldmVudFxuICAgICAgICB2YXIgZm4gPSBuYW1lO1xuICAgICAgICBzZWxmLm9uKHAuYmluZGluZ0V2ZW50LCBmbik7XG5cbiAgICAgICAgLy8gLmRhdGEoKVxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93R2V0dGluZyAmJiBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0IHdob2xlIG9iamVjdFxuICAgICAgICB2YXIgX3JldDtcbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG4gICAgICAgICAgX3JldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LFxuICAvLyBkYXRhXG5cbiAgLy8gcmVtb3ZlIGRhdGEgZmllbGRcbiAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gcmVtb3ZlRGF0YShwYXJhbXMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogZmFsc2UsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICB9O1xuICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKG5hbWVzKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAvLyAucmVtb3ZlRGF0YSgnZm9vIGJhcicpXG4gICAgICBpZiAoc3RyaW5nKG5hbWVzKSkge1xuICAgICAgICAvLyB0aGVuIGdldCB0aGUgbGlzdCBvZiBrZXlzLCBhbmQgZGVsZXRlIHRoZW1cbiAgICAgICAgdmFyIGtleXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIC8vIGRlbGV0ZSBlYWNoIG5vbi1lbXB0eSBrZXlcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoZW1wdHlTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNba2V5XTsgLy8gbm90IHZhbGlkIGlmIGltbXV0YWJsZVxuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKykge1xuICAgICAgICAgICAgICBhbGxbaV9hXS5fcHJpdmF0ZVtwLmZpZWxkXVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAucmVtb3ZlRGF0YSgpXG4gICAgICB9IGVsc2UgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcblxuICAgICAgICBmb3IgKHZhciBfaV9hID0gMCwgX2xfYSA9IGFsbC5sZW5ndGg7IF9pX2EgPCBfbF9hOyBfaV9hKyspIHtcbiAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbX2lfYV0uX3ByaXZhdGVbcC5maWVsZF07XG4gICAgICAgICAgdmFyIF9rZXlzID0gT2JqZWN0LmtleXMoX3ByaXZhdGVGaWVsZHMpO1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IF9rZXlzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIHZhciBfa2V5ID0gX2tleXNbX2kyXTtcbiAgICAgICAgICAgIHZhciB2YWxpZEtleVRvRGVsZXRlID0gIXAuaW1tdXRhYmxlS2V5c1tfa2V5XTtcbiAgICAgICAgICAgIGlmICh2YWxpZEtleVRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgIF9wcml2YXRlRmllbGRzW19rZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0gLy8gcmVtb3ZlRGF0YVxufTsgLy8gZGVmaW5lXG5cbnZhciBkZWZpbmUkMSA9IHtcbiAgZXZlbnRBbGlhc2VzT246IGZ1bmN0aW9uIGV2ZW50QWxpYXNlc09uKHByb3RvKSB7XG4gICAgdmFyIHAgPSBwcm90bztcbiAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgIHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmID0gcC5yZW1vdmVMaXN0ZW5lcjtcbiAgICBwLnRyaWdnZXIgPSBwLmVtaXQ7XG5cbiAgICAvLyB0aGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFsaWFzIG9mIC5vbigpXG4gICAgcC5wb24gPSBwLnByb21pc2VPbiA9IGZ1bmN0aW9uIChldmVudHMsIHNlbGVjdG9yKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGUpIHtcbiAgICAgICAgICBzZWxmLm9mZi5hcHBseShzZWxmLCBvZmZBcmdzKTtcbiAgICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25BcmdzID0gYXJncy5jb25jYXQoW2NhbGxiYWNrXSk7XG4gICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG4gICAgICAgIHNlbGYub24uYXBwbHkoc2VsZiwgb25BcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn07IC8vIGRlZmluZVxuXG4vLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbi8vICh1c2VmdWwgZm9yIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiB0aGUgY29yZSBhbmQgY29sbGVjdGlvbnMsIGZvciBleGFtcGxlKVxuXG52YXIgZGVmaW5lID0ge307XG5bZGVmaW5lJDMsIGRlZmluZSQyLCBkZWZpbmUkMV0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICBleHRlbmQoZGVmaW5lLCBtKTtcbn0pO1xuXG52YXIgZWxlc2ZuJGkgPSB7XG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpXG59O1xuXG52YXIgZWxlc2ZuJGggPSB7XG4gIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoX2NsYXNzZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKF9jbGFzc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIHNlbGZbMF0uX3ByaXZhdGUuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgcmV0dXJuIHJldC5wdXNoKGNscyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmICghYXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgIF9jbGFzc2VzID0gKF9jbGFzc2VzIHx8ICcnKS5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG4gICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICB2YXIgY2xhc3Nlc1NldCA9IG5ldyBTZXQkMShfY2xhc3Nlcyk7XG5cbiAgICAvLyBjaGVjayBhbmQgdXBkYXRlIGVhY2ggZWxlXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xzID0gX2NsYXNzZXNbaV07XG4gICAgICAgIHZhciBlbGVIYXNDbGFzcyA9IGVsZUNsYXNzZXMuaGFzKGNscyk7XG4gICAgICAgIGlmICghZWxlSGFzQ2xhc3MpIHtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiBlbGUgaGFzIGNsYXNzZXMgb3V0c2lkZSBvZiB0aG9zZSBwYXNzZWRcbiAgICAgIGlmICghY2hhbmdlZEVsZSkge1xuICAgICAgICBjaGFuZ2VkRWxlID0gZWxlQ2xhc3Nlcy5zaXplICE9PSBfY2xhc3Nlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZEVsZSkge1xuICAgICAgICBfcC5jbGFzc2VzID0gY2xhc3Nlc1NldDtcbiAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRydWUpO1xuICB9LFxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzLmhhcyhjbGFzc05hbWUpO1xuICB9LFxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NlcywgdG9nZ2xlKSB7XG4gICAgaWYgKCFhcnJheShjbGFzc2VzKSkge1xuICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0b2dnbGVVbmRlZmQgPSB0b2dnbGUgPT09IHVuZGVmaW5lZDtcbiAgICB2YXIgY2hhbmdlZCA9IFtdOyAvLyBlbGVzIHdobyBoYWQgY2xhc3NlcyBjaGFuZ2VkXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzZWxmLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgICAgdmFyIGVsZUNsYXNzZXMgPSBlbGUuX3ByaXZhdGUuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG4gICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZUNsYXNzZXMuaGFzKGNscyk7XG4gICAgICAgIHZhciBjaGFuZ2VkTm93ID0gZmFsc2U7XG4gICAgICAgIGlmICh0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmICFoYXNDbGFzcykge1xuICAgICAgICAgIGVsZUNsYXNzZXMuYWRkKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgaGFzQ2xhc3MpIHtcbiAgICAgICAgICBlbGVDbGFzc2VzW1wiZGVsZXRlXCJdKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGFuZ2VkRWxlICYmIGNoYW5nZWROb3cpIHtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2goZWxlKTtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgaiBjbGFzc2VzXG4gICAgfSAvLyBmb3IgaSBlbGVzXG5cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoY2xhc3NlcywgZmFsc2UpO1xuICB9LFxuICBmbGFzaENsYXNzOiBmdW5jdGlvbiBmbGFzaENsYXNzKGNsYXNzZXMsIGR1cmF0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICB9XG4gICAgc2VsZi5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoY2xhc3Nlcyk7XG4gICAgfSwgZHVyYXRpb24pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG59O1xuZWxlc2ZuJGguY2xhc3NOYW1lID0gZWxlc2ZuJGguY2xhc3NOYW1lcyA9IGVsZXNmbiRoLmNsYXNzZXM7XG5cbi8vIHRva2VucyBpbiB0aGUgcXVlcnkgbGFuZ3VhZ2VcbnZhciB0b2tlbnMgPSB7XG4gIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJyxcbiAgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gbGV0IG5hbWVzLCBldGNcbiAgY29tcGFyYXRvck9wOiAnPXxcXFxcIT18Pnw+PXw8fDw9fFxcXFwkPXxcXFxcXj18XFxcXCo9JyxcbiAgLy8gYmluYXJ5IGNvbXBhcmlzb24gb3AgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJyxcbiAgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkqJ1wiLFxuICAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICBudW1iZXI6IG51bWJlcixcbiAgLy8gbnVtYmVyIGxpdGVyYWwgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tLSBlLmcuIDAuMTIzNCwgMTIzNCwgMTJlMTIzXG4gIG1ldGE6ICdkZWdyZWV8aW5kZWdyZWV8b3V0ZGVncmVlJyxcbiAgLy8gYWxsb3dlZCBtZXRhZGF0YSBmaWVsZHMgKGkuZS4gYWxsb3dlZCBmdW5jdGlvbnMgdG8gdXNlIGZyb20gQ29sbGVjdGlvbilcbiAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsXG4gIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gIGRlc2NlbmRhbnQ6ICdcXFxccysnLFxuICBjaGlsZDogJ1xcXFxzKz5cXFxccysnLFxuICBzdWJqZWN0OiAnXFxcXCQnLFxuICBncm91cDogJ25vZGV8ZWRnZXxcXFxcKicsXG4gIGRpcmVjdGVkRWRnZTogJ1xcXFxzKy0+XFxcXHMrJyxcbiAgdW5kaXJlY3RlZEVkZ2U6ICdcXFxccys8LT5cXFxccysnXG59O1xudG9rZW5zLnZhcmlhYmxlID0gJyg/OltcXFxcdy0uXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lIGNhbiBoYXZlIGxldHRlcnMsIG51bWJlcnMsIGRhc2hlcywgYW5kIHBlcmlvZHNcbnRva2Vucy5jbGFzc05hbWUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgY2xhc3MgbmFtZSBoYXMgdGhlIHNhbWUgcnVsZXMgYXMgYSB2YXJpYWJsZSBleGNlcHQgaXQgY2FuJ3QgaGF2ZSBhICcuJyBpbiB0aGUgbmFtZVxudG9rZW5zLnZhbHVlID0gdG9rZW5zLnN0cmluZyArICd8JyArIHRva2Vucy5udW1iZXI7IC8vIGEgdmFsdWUgbGl0ZXJhbCwgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlclxudG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgb3BzLCBvcCwgaTtcblxuICAvLyBhZGQgQCB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuICBmb3IgKGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3AgPSBvcHNbaV07XG4gICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfEAnICsgb3A7XG4gIH1cblxuICAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuICBmb3IgKGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3AgPSBvcHNbaV07XG4gICAgaWYgKG9wLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcbiAgICBpZiAob3AgPT09ICc9Jykge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG4gICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfFxcXFwhJyArIG9wO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIE1ha2UgYSBuZXcgcXVlcnkgb2JqZWN0XG4gKlxuICogQHByb3AgdHlwZSB7VHlwZX0gVGhlIHR5cGUgZW51bSAoaW50KSBvZiB0aGUgcXVlcnlcbiAqIEBwcm9wIGNoZWNrcyBMaXN0IG9mIGNoZWNrcyB0byBtYWtlIGFnYWluc3QgYW4gZWxlIHRvIHRlc3QgZm9yIGEgbWF0Y2hcbiAqL1xudmFyIG5ld1F1ZXJ5ID0gZnVuY3Rpb24gbmV3UXVlcnkoKSB7XG4gIHJldHVybiB7XG4gICAgY2hlY2tzOiBbXVxuICB9O1xufTtcblxuLyoqXG4gKiBBIGNoZWNrIHR5cGUgZW51bS1saWtlIG9iamVjdC4gIFVzZXMgaW50ZWdlciB2YWx1ZXMgZm9yIGZhc3QgbWF0Y2goKSBsb29rdXAuXG4gKiBUaGUgb3JkZXJpbmcgZG9lcyBub3QgbWF0dGVyIGFzIGxvbmcgYXMgdGhlIGludHMgYXJlIHVuaXF1ZS5cbiAqL1xudmFyIFR5cGUgPSB7XG4gIC8qKiBFLmcuIG5vZGUgKi9cbiAgR1JPVVA6IDAsXG4gIC8qKiBBIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgKi9cbiAgQ09MTEVDVElPTjogMSxcbiAgLyoqIEEgZmlsdGVyKGVsZSkgZnVuY3Rpb24gKi9cbiAgRklMVEVSOiAyLFxuICAvKiogRS5nLiBbZm9vID4gMV0gKi9cbiAgREFUQV9DT01QQVJFOiAzLFxuICAvKiogRS5nLiBbZm9vXSAqL1xuICBEQVRBX0VYSVNUOiA0LFxuICAvKiogRS5nLiBbP2Zvb10gKi9cbiAgREFUQV9CT09MOiA1LFxuICAvKiogRS5nLiBbW2RlZ3JlZSA+IDJdXSAqL1xuICBNRVRBX0NPTVBBUkU6IDYsXG4gIC8qKiBFLmcuIDpzZWxlY3RlZCAqL1xuICBTVEFURTogNyxcbiAgLyoqIEUuZy4gI2ZvbyAqL1xuICBJRDogOCxcbiAgLyoqIEUuZy4gLmZvbyAqL1xuICBDTEFTUzogOSxcbiAgLyoqIEUuZy4gI2ZvbyA8LT4gI2JhciAqL1xuICBVTkRJUkVDVEVEX0VER0U6IDEwLFxuICAvKiogRS5nLiAjZm9vIC0+ICNiYXIgKi9cbiAgRElSRUNURURfRURHRTogMTEsXG4gIC8qKiBFLmcuICQjZm9vIC0+ICNiYXIgKi9cbiAgTk9ERV9TT1VSQ0U6IDEyLFxuICAvKiogRS5nLiAjZm9vIC0+ICQjYmFyICovXG4gIE5PREVfVEFSR0VUOiAxMyxcbiAgLyoqIEUuZy4gJCNmb28gPC0+ICNiYXIgKi9cbiAgTk9ERV9ORUlHSEJPUjogMTQsXG4gIC8qKiBFLmcuICNmb28gPiAjYmFyICovXG4gIENISUxEOiAxNSxcbiAgLyoqIEUuZy4gI2ZvbyAjYmFyICovXG4gIERFU0NFTkRBTlQ6IDE2LFxuICAvKiogRS5nLiAkI2ZvbyA+ICNiYXIgKi9cbiAgUEFSRU5UOiAxNyxcbiAgLyoqIEUuZy4gJCNmb28gI2JhciAqL1xuICBBTkNFU1RPUjogMTgsXG4gIC8qKiBFLmcuICNmb28gPiAkYmFyID4gI2JheiAqL1xuICBDT01QT1VORF9TUExJVDogMTksXG4gIC8qKiBBbHdheXMgbWF0Y2hlcywgdXNlZnVsIHBsYWNlaG9sZGVyIGZvciBzdWJqZWN0IGluIGBDT01QT1VORF9TUExJVGAgKi9cbiAgVFJVRTogMjBcbn07XG5cbnZhciBzdGF0ZVNlbGVjdG9ycyA9IFt7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5zZWxlY3RlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzZWxlY3RhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5sb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnZpc2libGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmhpZGRlbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnRyYW5zcGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnRyYW5zcGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6ZnJlZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnJlbW92ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmluc2lkZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYW5pbWF0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmFuaW1hdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnBhcmVudCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkbGVzcycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkbGVzcygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpvcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpub25vcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNvbXBvdW5kJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bG9vcCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzaW1wbGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNTaW1wbGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzphY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYWN0aXZlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aW5hY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmFjdGl2ZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYmFja2dyb3VuZGluZygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm5vbmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgfVxufV0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAvLyBuLmIuIHNlbGVjdG9ycyB0aGF0IGFyZSBzdGFydGluZyBzdWJzdHJpbmdzIG9mIG90aGVycyBtdXN0IGhhdmUgdGhlIGxvbmdlciBvbmVzIGZpcnN0XG4gIHJldHVybiBkZXNjZW5kaW5nKGEuc2VsZWN0b3IsIGIuc2VsZWN0b3IpO1xufSk7XG52YXIgbG9va3VwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsVG9GbiA9IHt9O1xuICB2YXIgcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZVNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHMgPSBzdGF0ZVNlbGVjdG9yc1tpXTtcbiAgICBzZWxUb0ZuW3Muc2VsZWN0b3JdID0gcy5tYXRjaGVzO1xuICB9XG4gIHJldHVybiBzZWxUb0ZuO1xufSgpO1xudmFyIHN0YXRlU2VsZWN0b3JNYXRjaGVzID0gZnVuY3Rpb24gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc2VsLCBlbGUpIHtcbiAgcmV0dXJuIGxvb2t1cFtzZWxdKGVsZSk7XG59O1xudmFyIHN0YXRlU2VsZWN0b3JSZWdleCA9ICcoJyArIHN0YXRlU2VsZWN0b3JzLm1hcChmdW5jdGlvbiAocykge1xuICByZXR1cm4gcy5zZWxlY3Rvcjtcbn0pLmpvaW4oJ3wnKSArICcpJztcblxuLy8gd2hlbiBhIHRva2VuIGxpa2UgYSB2YXJpYWJsZSBoYXMgZXNjYXBlZCBtZXRhIGNoYXJhY3RlcnMsIHdlIG5lZWQgdG8gY2xlYW4gdGhlIGJhY2tzbGFzaGVzIG91dFxuLy8gc28gdGhhdCB2YWx1ZXMgZ2V0IGNvbXBhcmVkIHByb3Blcmx5IGluIFNlbGVjdG9yLmZpbHRlcigpXG52YXIgY2xlYW5NZXRhQ2hhcnMgPSBmdW5jdGlvbiBjbGVhbk1ldGFDaGFycyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyksIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgICByZXR1cm4gJDE7XG4gIH0pO1xufTtcbnZhciByZXBsYWNlTGFzdFF1ZXJ5ID0gZnVuY3Rpb24gcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgZXhhbWluaW5nUXVlcnksIHJlcGxhY2VtZW50UXVlcnkpIHtcbiAgc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0gPSByZXBsYWNlbWVudFF1ZXJ5O1xufTtcblxuLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4vLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxlY3RvcltpXVxuLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBtYXRjaCgpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcbnZhciBleHBycyA9IFt7XG4gIG5hbWU6ICdncm91cCcsXG4gIC8vIGp1c3QgdXNlZCBmb3IgaWRlbnRpZnlpbmcgd2hlbiBkZWJ1Z2dpbmdcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnKCcgKyB0b2tlbnMuZ3JvdXAgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYpIHtcbiAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAxKSxcbiAgICAgIGdyb3VwID0gX3JlZjJbMF07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5HUk9VUCxcbiAgICAgIHZhbHVlOiBncm91cCA9PT0gJyonID8gZ3JvdXAgOiBncm91cCArICdzJ1xuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdzdGF0ZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogc3RhdGVTZWxlY3RvclJlZ2V4LFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMykge1xuICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAxKSxcbiAgICAgIHN0YXRlID0gX3JlZjRbMF07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5TVEFURSxcbiAgICAgIHZhbHVlOiBzdGF0ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdpZCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFwjKCcgKyB0b2tlbnMuaWQgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY1KSB7XG4gICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgaWQgPSBfcmVmNlswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLklELFxuICAgICAgdmFsdWU6IGNsZWFuTWV0YUNoYXJzKGlkKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdjbGFzc05hbWUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcLignICsgdG9rZW5zLmNsYXNzTmFtZSArICcpJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjcpIHtcbiAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMSksXG4gICAgICBjbGFzc05hbWUgPSBfcmVmOFswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkNMQVNTLFxuICAgICAgdmFsdWU6IGNsZWFuTWV0YUNoYXJzKGNsYXNzTmFtZSlcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnZGF0YUV4aXN0cycsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjkpIHtcbiAgICB2YXIgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDEpLFxuICAgICAgdmFyaWFibGUgPSBfcmVmMTBbMF07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0VYSVNULFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQ29tcGFyZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFsdWUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjExKSB7XG4gICAgdmFyIF9yZWYxMiA9IF9zbGljZWRUb0FycmF5KF9yZWYxMSwgMyksXG4gICAgICB2YXJpYWJsZSA9IF9yZWYxMlswXSxcbiAgICAgIGNvbXBhcmF0b3JPcCA9IF9yZWYxMlsxXSxcbiAgICAgIHZhbHVlID0gX3JlZjEyWzJdO1xuICAgIHZhciB2YWx1ZUlzU3RyaW5nID0gbmV3IFJlZ0V4cCgnXicgKyB0b2tlbnMuc3RyaW5nICsgJyQnKS5leGVjKHZhbHVlKSAhPSBudWxsO1xuICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0NPTVBBUkUsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQm9vbCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMuYm9vbE9wICsgJylcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTMpIHtcbiAgICB2YXIgX3JlZjE0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEzLCAyKSxcbiAgICAgIGJvb2xPcCA9IF9yZWYxNFswXSxcbiAgICAgIHZhcmlhYmxlID0gX3JlZjE0WzFdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuREFUQV9CT09MLFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbWV0YUNvbXBhcmUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMubWV0YSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy5udW1iZXIgKyAnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTUpIHtcbiAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAzKSxcbiAgICAgIG1ldGEgPSBfcmVmMTZbMF0sXG4gICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTZbMV0sXG4gICAgICBudW1iZXIgPSBfcmVmMTZbMl07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5NRVRBX0NPTVBBUkUsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnMobWV0YSksXG4gICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICduZXh0UXVlcnknLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuc2VwYXJhdG9yLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgdmFyIGN1cnJlbnRTdWJqZWN0ID0gc2VsZWN0b3IuY3VycmVudFN1YmplY3Q7XG4gICAgdmFyIGVkZ2VDb3VudCA9IHNlbGVjdG9yLmVkZ2VDb3VudDtcbiAgICB2YXIgY29tcG91bmRDb3VudCA9IHNlbGVjdG9yLmNvbXBvdW5kQ291bnQ7XG4gICAgdmFyIGxhc3RRID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgaWYgKGN1cnJlbnRTdWJqZWN0ICE9IG51bGwpIHtcbiAgICAgIGxhc3RRLnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICB9XG4gICAgbGFzdFEuZWRnZUNvdW50ID0gZWRnZUNvdW50O1xuICAgIGxhc3RRLmNvbXBvdW5kQ291bnQgPSBjb21wb3VuZENvdW50O1xuICAgIHNlbGVjdG9yLmVkZ2VDb3VudCA9IDA7XG4gICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCA9IDA7XG5cbiAgICAvLyBnbyBvbiB0byBuZXh0IHF1ZXJ5XG4gICAgdmFyIG5leHRRdWVyeSA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCsrXSA9IG5ld1F1ZXJ5KCk7XG4gICAgcmV0dXJuIG5leHRRdWVyeTsgLy8gdGhpcyBpcyB0aGUgbmV3IHF1ZXJ5IHRvIGJlIGZpbGxlZCBieSB0aGUgZm9sbG93aW5nIGV4cHJzXG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RpcmVjdGVkRWRnZScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5ESVJFQ1RFRF9FREdFLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgZWRnZSByYXRoZXIgdGhhbiB0aGUgc291cmNlXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrO1xuXG4gICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNvdXJjZS90YXJnZXRcbiAgICAgIHZhciBzcmNUZ3RRID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfc291cmNlID0gcXVlcnk7XG4gICAgICB2YXIgX3RhcmdldCA9IG5ld1F1ZXJ5KCk7XG4gICAgICBzcmNUZ3RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5OT0RFX1NPVVJDRSxcbiAgICAgICAgc291cmNlOiBfc291cmNlLFxuICAgICAgICB0YXJnZXQ6IF90YXJnZXRcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIHNyY1RndFEpO1xuICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7XG4gICAgICByZXR1cm4gX3RhcmdldDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCB3aXRoIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbnNcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3VuZGlyZWN0ZWRFZGdlJyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLnVuZGlyZWN0ZWRFZGdlLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZVxuICAgICAgdmFyIGVkZ2VRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgIGVkZ2VRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuVU5ESVJFQ1RFRF9FREdFLFxuICAgICAgICBub2RlczogW3NvdXJjZSwgdGFyZ2V0XVxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBlZGdlIHJhdGhlciB0aGFuIHRoZSBzb3VyY2VcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmVpZ2hib3VyaG9vZFxuICAgICAgdmFyIG5ob29kUSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbm9kZSA9IHF1ZXJ5O1xuICAgICAgdmFyIG5laWdoYm9yID0gbmV3UXVlcnkoKTtcbiAgICAgIG5ob29kUS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuTk9ERV9ORUlHSEJPUixcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgbmVpZ2hib3I6IG5laWdoYm9yXG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIG5laWdoYm91cmhvb2QgcmF0aGVyIHRoYW4gdGhlIG5vZGVcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBuaG9vZFEpO1xuICAgICAgcmV0dXJuIG5laWdoYm9yOyAvLyBub3cgcG9wdWxhdGluZyB0aGUgbmVpZ2hib3Igd2l0aCBmb2xsb3dpbmcgZXhwcmVzc2lvbnNcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2NoaWxkJyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLmNoaWxkLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIGRlZmF1bHQ6IGNoaWxkIHF1ZXJ5XG4gICAgICB2YXIgcGFyZW50Q2hpbGRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgY2hpbGQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgcGFyZW50Q2hpbGRRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuQ0hJTEQsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBjaGlsZDogY2hpbGRcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgJz4nIGl0c2VsZlxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIHBhcmVudENoaWxkUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuXG4gICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9jaGlsZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX3BhcmVudCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG4gICAgICBjb21wb3VuZC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuQ09NUE9VTkRfU1BMSVQsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgc3ViamVjdDogc3ViamVjdFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHBvcHVsYXRlIHRoZSBzdWJqZWN0IGFuZCByZXBsYWNlIHRoZSBxIGF0IHRoZSBvbGQgc3BvdCAod2l0aGluIGxlZnQpIHdpdGggVFJVRVxuICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG4gICAgICBxdWVyeS5jaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH1dOyAvLyBjaGVja3MgdW5kZXIgbGVmdCByZWZzIHRoZSBzdWJqZWN0IGltcGxpY2l0bHlcblxuICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG4gICAgICBfcGFyZW50LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9KTsgLy8gcGFyZW50IGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuICAgICAgcmlnaHQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlBBUkVOVCxcbiAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICBwYXJlbnQ6IF9wYXJlbnQsXG4gICAgICAgIGNoaWxkOiBfY2hpbGQgLy8gZW1wdHkgZm9yIG5vd1xuICAgICAgfSk7XG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfY2hpbGQ7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSByaWdodCBzaWRlJ3MgY2hpbGRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IHF1ZXJ5XG4gICAgICAvLyBpbmZvIGZvciBwYXJlbnQgcXVlcnlcbiAgICAgIHZhciBfcGFyZW50MiA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX2NoaWxkMiA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgcGNRQ2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIHBhcmVudDogX3BhcmVudDIsXG4gICAgICAgIGNoaWxkOiBfY2hpbGQyXG4gICAgICB9XTtcblxuICAgICAgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG4gICAgICBfcGFyZW50Mi5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRoZSBwcmV2aW91cyBxdWVyeSBjb250YWlucyB0aGUgY2hlY2tzIGZvciB0aGUgcGFyZW50XG4gICAgICBxdWVyeS5jaGVja3MgPSBwY1FDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9jaGlsZDI7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZFxuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnZGVzY2VuZGFudCcsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5kZXNjZW5kYW50LFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIGRlZmF1bHQ6IGRlc2NlbmRhbnQgcXVlcnlcbiAgICAgIHZhciBhbmNDaFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBkZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBhbmNlc3RvciA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgYW5jQ2hRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuREVTQ0VOREFOVCxcbiAgICAgICAgYW5jZXN0b3I6IGFuY2VzdG9yLFxuICAgICAgICBkZXNjZW5kYW50OiBkZXNjZW5kYW50XG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlICc+JyBpdHNlbGZcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBhbmNDaFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcblxuICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgcmV0dXJuIGRlc2NlbmRhbnQ7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PT0gcXVlcnkpIHtcbiAgICAgIC8vIGNvbXBvdW5kIHNwbGl0IHF1ZXJ5XG4gICAgICB2YXIgY29tcG91bmQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGxlZnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHZhciByaWdodCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc3ViamVjdCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX2Rlc2NlbmRhbnQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9hbmNlc3RvciA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG4gICAgICBjb21wb3VuZC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuQ09NUE9VTkRfU1BMSVQsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgc3ViamVjdDogc3ViamVjdFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHBvcHVsYXRlIHRoZSBzdWJqZWN0IGFuZCByZXBsYWNlIHRoZSBxIGF0IHRoZSBvbGQgc3BvdCAod2l0aGluIGxlZnQpIHdpdGggVFJVRVxuICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG4gICAgICBxdWVyeS5jaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH1dOyAvLyBjaGVja3MgdW5kZXIgbGVmdCByZWZzIHRoZSBzdWJqZWN0IGltcGxpY2l0bHlcblxuICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG4gICAgICBfYW5jZXN0b3IuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH0pOyAvLyBhbmNlc3RvciBpbXBsaWNpdGx5IHJlZnMgdGhlIHN1YmplY3RcbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yLFxuICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudCAvLyBlbXB0eSBmb3Igbm93XG4gICAgICB9KTtcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGxlZnQsIGNvbXBvdW5kKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSByZWYgc2luY2Ugd2UgbW92ZWQgdGhpbmdzIGFyb3VuZCBmb3IgYHF1ZXJ5YFxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGRlc2NlbmRhbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYW5jZXN0b3IgcXVlcnlcbiAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgdmFyIF9hbmNlc3RvcjIgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9kZXNjZW5kYW50MiA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgYWRRQ2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgYW5jZXN0b3I6IF9hbmNlc3RvcjIsXG4gICAgICAgIGRlc2NlbmRhbnQ6IF9kZXNjZW5kYW50MlxuICAgICAgfV07XG5cbiAgICAgIC8vIHRoZSBwYXJlbnQtY2hpbGQgcXVlcnkgdGFrZXMgdGhlIHBsYWNlIG9mIHRoZSBxdWVyeSBwcmV2aW91c2x5IGJlaW5nIHBvcHVsYXRlZFxuICAgICAgX2FuY2VzdG9yMi5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRoZSBwcmV2aW91cyBxdWVyeSBjb250YWlucyB0aGUgY2hlY2tzIGZvciB0aGUgcGFyZW50XG4gICAgICBxdWVyeS5jaGVja3MgPSBhZFFDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50MjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdzdWJqZWN0JyxcbiAgbW9kaWZpZXI6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9PSBxdWVyeSkge1xuICAgICAgd2FybignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3Rvci50b1N0cmluZygpICsgJ2AnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBxdWVyeTtcbiAgICB2YXIgdG9wUSA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgIHZhciB0b3BDaGsgPSB0b3BRLmNoZWNrc1swXTtcbiAgICB2YXIgdG9wVHlwZSA9IHRvcENoayA9PSBudWxsID8gbnVsbCA6IHRvcENoay50eXBlO1xuICAgIGlmICh0b3BUeXBlID09PSBUeXBlLkRJUkVDVEVEX0VER0UpIHtcbiAgICAgIC8vIGRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSB0YXJnZXRcblxuICAgICAgLy8gY2hhbmdlIHRvIHRhcmdldCBub2RlIGNoZWNrXG4gICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9UQVJHRVQ7XG4gICAgfSBlbHNlIGlmICh0b3BUeXBlID09PSBUeXBlLlVORElSRUNURURfRURHRSkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgc2Vjb25kIG5vZGVcblxuICAgICAgLy8gY2hhbmdlIHRvIG5laWdoYm9yIGNoZWNrXG4gICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9ORUlHSEJPUjtcbiAgICAgIHRvcENoay5ub2RlID0gdG9wQ2hrLm5vZGVzWzFdOyAvLyBzZWNvbmQgbm9kZSBpcyBzdWJqZWN0XG4gICAgICB0b3BDaGsubmVpZ2hib3IgPSB0b3BDaGsubm9kZXNbMF07XG5cbiAgICAgIC8vIGNsZWFuIHVwIHVudXNlZCBmaWVsZHMgZm9yIG5ldyB0eXBlXG4gICAgICB0b3BDaGsubm9kZXMgPSBudWxsO1xuICAgIH1cbiAgfVxufV07XG5leHBycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBlLnJlZ2V4T2JqID0gbmV3IFJlZ0V4cCgnXicgKyBlLnJlZ2V4KTtcbn0pO1xuXG4vKipcbiAqIE9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gKiBAcmV0dXJucyBUaGUgbWF0Y2hlZCBleHByZXNzaW9uIGFuZCB0aGUgbmV3bHkgcmVtYWluaW5nIHRleHQgYHsgZXhwciwgbWF0Y2gsIG5hbWUsIHJlbWFpbmluZyB9YFxuICovXG52YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiBjb25zdW1lRXhwcihyZW1haW5pbmcpIHtcbiAgdmFyIGV4cHI7XG4gIHZhciBtYXRjaDtcbiAgdmFyIG5hbWU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgZXhwcnMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgZSA9IGV4cHJzW2pdO1xuICAgIHZhciBuID0gZS5uYW1lO1xuICAgIHZhciBtID0gcmVtYWluaW5nLm1hdGNoKGUucmVnZXhPYmopO1xuICAgIGlmIChtICE9IG51bGwpIHtcbiAgICAgIG1hdGNoID0gbTtcbiAgICAgIGV4cHIgPSBlO1xuICAgICAgbmFtZSA9IG47XG4gICAgICB2YXIgY29uc3VtZWQgPSBtWzBdO1xuICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHI6IGV4cHIsXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgfTtcbn07XG5cbi8qKlxuICogQ29uc3VtZSBhbGwgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlbWFpbmluZyBUaGUgdGV4dCB0byBjb25zdW1lXG4gKiBAcmV0dXJucyBUaGUgdGV4dCB3aXRoIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZFxuICovXG52YXIgY29uc3VtZVdoaXRlc3BhY2UgPSBmdW5jdGlvbiBjb25zdW1lV2hpdGVzcGFjZShyZW1haW5pbmcpIHtcbiAgdmFyIG1hdGNoID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKy8pO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGNvbnN1bWVkLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHJlbWFpbmluZztcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIHN0cmluZyBhbmQgc3RvcmUgdGhlIHBhcnNlZCByZXByZXNlbnRhdGlvbiBpbiB0aGUgU2VsZWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHN0cmluZ1xuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzZWxlY3RvciB3YXMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqL1xudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc2VsZWN0b3IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVtYWluaW5nID0gc2VsZi5pbnB1dFRleHQgPSBzZWxlY3RvcjtcbiAgdmFyIGN1cnJlbnRRdWVyeSA9IHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICBzZWxmLmxlbmd0aCA9IDE7XG4gIHJlbWFpbmluZyA9IGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZyk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG5cbiAgZm9yICg7Oykge1xuICAgIHZhciBleHBySW5mbyA9IGNvbnN1bWVFeHByKHJlbWFpbmluZyk7XG4gICAgaWYgKGV4cHJJbmZvLmV4cHIgPT0gbnVsbCkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYGlzIGludmFsaWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBleHBySW5mby5tYXRjaC5zbGljZSgxKTtcblxuICAgICAgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IGluIGN1cnJlbnRRdWVyeVxuICAgICAgdmFyIHJldCA9IGV4cHJJbmZvLmV4cHIucG9wdWxhdGUoc2VsZiwgY3VycmVudFF1ZXJ5LCBhcmdzKTtcbiAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gZXhpdCBpZiBwb3B1bGF0aW9uIGZhaWxlZFxuICAgICAgfSBlbHNlIGlmIChyZXQgIT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50UXVlcnkgPSByZXQ7IC8vIGNoYW5nZSB0aGUgY3VycmVudCBxdWVyeSB0byBiZSBmaWxsZWQgaWYgdGhlIGV4cHIgc3BlY2lmaWVzXG4gICAgICB9XG4gICAgfVxuICAgIHJlbWFpbmluZyA9IGV4cHJJbmZvLnJlbWFpbmluZztcblxuICAgIC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuICAgIGlmIChyZW1haW5pbmcubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGxhc3RRID0gc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuICBpZiAoc2VsZi5jdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgbGFzdFEuc3ViamVjdCA9IHNlbGYuY3VycmVudFN1YmplY3Q7XG4gIH1cbiAgbGFzdFEuZWRnZUNvdW50ID0gc2VsZi5lZGdlQ291bnQ7XG4gIGxhc3RRLmNvbXBvdW5kQ291bnQgPSBzZWxmLmNvbXBvdW5kQ291bnQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBxID0gc2VsZltpXTtcblxuICAgIC8vIGluIGZ1dHVyZSwgdGhpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBhbGxvd2VkIGlmIHRoZXJlIHdlcmUgb3BlcmF0b3IgcHJlY2VkZW5jZSBhbmQgZGV0ZWN0aW9uIG9mIGludmFsaWQgY29tYmluYXRpb25zXG4gICAgaWYgKHEuY29tcG91bmRDb3VudCA+IDAgJiYgcS5lZGdlQ291bnQgPiAwKSB7XG4gICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgIGlzIGludmFsaWQgYmVjYXVzZSBpdCB1c2VzIGJvdGggYSBjb21wb3VuZCBzZWxlY3RvciBhbmQgYW4gZWRnZSBzZWxlY3RvcicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocS5lZGdlQ291bnQgPiAxKSB7XG4gICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgIGlzIGludmFsaWQgYmVjYXVzZSBpdCB1c2VzIG11bHRpcGxlIGVkZ2Ugc2VsZWN0b3JzJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChxLmVkZ2VDb3VudCA9PT0gMSkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBkZXByZWNhdGVkLiAgRWRnZSBzZWxlY3RvcnMgZG8gbm90IHRha2UgZWZmZWN0IG9uIGNoYW5nZXMgdG8gc291cmNlIGFuZCB0YXJnZXQgbm9kZXMgYWZ0ZXIgYW4gZWRnZSBpcyBhZGRlZCwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuICBVc2UgYSBjbGFzcyBvciBkYXRhIHNlbGVjdG9yIG9uIGVkZ2VzIGluc3RlYWQsIHVwZGF0aW5nIHRoZSBjbGFzcyBvciBkYXRhIG9mIGFuIGVkZ2Ugd2hlbiB5b3VyIGFwcCBkZXRlY3RzIGEgY2hhbmdlIGluIHNvdXJjZSBvciB0YXJnZXQgbm9kZXMuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlOyAvLyBzdWNjZXNzXG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2VsZWN0b3IgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuICBUaGlzIHZhbHVlIHVzZXMgZGVmYXVsdCBmb3JtYXR0aW5nLFxuICogc28gdGhpbmdzIGxpa2Ugc3BhY2luZyBtYXkgZGlmZmVyIGZyb20gdGhlIGlucHV0IHRleHQgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZWxlY3RvciBzdHJpbmdcbiAqL1xudmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIGlmICh0aGlzLnRvU3RyaW5nQ2FjaGUgIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nQ2FjaGU7XG4gIH1cbiAgdmFyIGNsZWFuID0gZnVuY3Rpb24gY2xlYW4ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9O1xuICB2YXIgY2xlYW5WYWwgPSBmdW5jdGlvbiBjbGVhblZhbCh2YWwpIHtcbiAgICBpZiAoc3RyaW5nKHZhbCkpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsICsgJ1wiJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsZWFuKHZhbCk7XG4gICAgfVxuICB9O1xuICB2YXIgc3BhY2UgPSBmdW5jdGlvbiBzcGFjZSh2YWwpIHtcbiAgICByZXR1cm4gJyAnICsgdmFsICsgJyAnO1xuICB9O1xuICB2YXIgY2hlY2tUb1N0cmluZyA9IGZ1bmN0aW9uIGNoZWNrVG9TdHJpbmcoY2hlY2ssIHN1YmplY3QpIHtcbiAgICB2YXIgdHlwZSA9IGNoZWNrLnR5cGUsXG4gICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUeXBlLkdST1VQOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGdyb3VwID0gY2xlYW4odmFsdWUpO1xuICAgICAgICAgIHJldHVybiBncm91cC5zdWJzdHJpbmcoMCwgZ3JvdXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5EQVRBX0NPTVBBUkU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gICAgICAgICAgcmV0dXJuICdbJyArIGZpZWxkICsgc3BhY2UoY2xlYW4ob3BlcmF0b3IpKSArIGNsZWFuVmFsKHZhbHVlKSArICddJztcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkRBVEFfQk9PTDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgICAgIF9maWVsZCA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgIHJldHVybiAnWycgKyBjbGVhbihfb3BlcmF0b3IpICsgX2ZpZWxkICsgJ10nO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuREFUQV9FWElTVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZmllbGQyID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgcmV0dXJuICdbJyArIF9maWVsZDIgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5NRVRBX0NPTVBBUkU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wZXJhdG9yMiA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICAgICAgX2ZpZWxkMyA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgIHJldHVybiAnW1snICsgX2ZpZWxkMyArIHNwYWNlKGNsZWFuKF9vcGVyYXRvcjIpKSArIGNsZWFuVmFsKHZhbHVlKSArICddXSc7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5TVEFURTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLklEOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcjJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuQ0xBU1M6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJy4nICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5QQVJFTlQ6XG4gICAgICBjYXNlIFR5cGUuQ0hJTEQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5wYXJlbnQsIHN1YmplY3QpICsgc3BhY2UoJz4nKSArIHF1ZXJ5VG9TdHJpbmcoY2hlY2suY2hpbGQsIHN1YmplY3QpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuQU5DRVNUT1I6XG4gICAgICBjYXNlIFR5cGUuREVTQ0VOREFOVDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBxdWVyeVRvU3RyaW5nKGNoZWNrLmFuY2VzdG9yLCBzdWJqZWN0KSArICcgJyArIHF1ZXJ5VG9TdHJpbmcoY2hlY2suZGVzY2VuZGFudCwgc3ViamVjdCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5DT01QT1VORF9TUExJVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsaHMgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLmxlZnQsIHN1YmplY3QpO1xuICAgICAgICAgIHZhciBzdWIgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLnN1YmplY3QsIHN1YmplY3QpO1xuICAgICAgICAgIHZhciByaHMgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLnJpZ2h0LCBzdWJqZWN0KTtcbiAgICAgICAgICByZXR1cm4gbGhzICsgKGxocy5sZW5ndGggPiAwID8gJyAnIDogJycpICsgc3ViICsgcmhzO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuVFJVRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIHF1ZXJ5VG9TdHJpbmcgPSBmdW5jdGlvbiBxdWVyeVRvU3RyaW5nKHF1ZXJ5LCBzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgY2hrLCBpKSB7XG4gICAgICByZXR1cm4gc3RyICsgKHN1YmplY3QgPT09IHF1ZXJ5ICYmIGkgPT09IDAgPyAnJCcgOiAnJykgKyBjaGVja1RvU3RyaW5nKGNoaywgc3ViamVjdCk7XG4gICAgfSwgJycpO1xuICB9O1xuICB2YXIgc3RyID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBxdWVyeSA9IHRoaXNbaV07XG4gICAgc3RyICs9IHF1ZXJ5VG9TdHJpbmcocXVlcnksIHF1ZXJ5LnN1YmplY3QpO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgc3RyICs9ICcsICc7XG4gICAgfVxuICB9XG4gIHRoaXMudG9TdHJpbmdDYWNoZSA9IHN0cjtcbiAgcmV0dXJuIHN0cjtcbn07XG52YXIgcGFyc2UkMSA9IHtcbiAgcGFyc2U6IHBhcnNlLFxuICB0b1N0cmluZzogdG9TdHJpbmdcbn07XG5cbnZhciB2YWxDbXAgPSBmdW5jdGlvbiB2YWxDbXAoZmllbGRWYWwsIG9wZXJhdG9yLCB2YWx1ZSkge1xuICB2YXIgbWF0Y2hlcztcbiAgdmFyIGlzRmllbGRTdHIgPSBzdHJpbmcoZmllbGRWYWwpO1xuICB2YXIgaXNGaWVsZE51bSA9IG51bWJlciQxKGZpZWxkVmFsKTtcbiAgdmFyIGlzVmFsU3RyID0gc3RyaW5nKHZhbHVlKTtcbiAgdmFyIGZpZWxkU3RyLCB2YWxTdHI7XG4gIHZhciBjYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgdmFyIG5vdEV4cHIgPSBmYWxzZTtcbiAgdmFyIGlzSW5lcUNtcCA9IGZhbHNlO1xuICBpZiAob3BlcmF0b3IuaW5kZXhPZignIScpID49IDApIHtcbiAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJyEnLCAnJyk7XG4gICAgbm90RXhwciA9IHRydWU7XG4gIH1cbiAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRmllbGRTdHIgfHwgaXNWYWxTdHIgfHwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgZmllbGRTdHIgPSAhaXNGaWVsZFN0ciAmJiAhaXNGaWVsZE51bSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICB2YWxTdHIgPSAnJyArIHZhbHVlO1xuICB9XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgYSBjYXNlIGluc2Vuc2l0aXZlIGNvbXBhcmlzb24sIHRoZW4gd2UncmUgdXNpbmcgYSBTVFJJTkcgY29tcGFyaXNvblxuICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG4gIGlmIChjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBmaWVsZFZhbCA9IGZpZWxkU3RyID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICB2YWx1ZSA9IHZhbFN0ciA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICcqPSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID49IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICckPSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIsIGZpZWxkU3RyLmxlbmd0aCAtIHZhbFN0ci5sZW5ndGgpID49IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdePSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID09PSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPic6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID4gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc+PSc6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPCc6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsIDwgdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc8PSc6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsIDw9IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gYXBwbHkgdGhlIG5vdCBvcCwgYnV0IG51bGwgdmFscyBmb3IgaW5lcXVhbGl0aWVzIHNob3VsZCBhbHdheXMgc3RheSBub24tbWF0Y2hpbmdcbiAgaWYgKG5vdEV4cHIgJiYgKGZpZWxkVmFsICE9IG51bGwgfHwgIWlzSW5lcUNtcCkpIHtcbiAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xudmFyIGJvb2xDbXAgPSBmdW5jdGlvbiBib29sQ21wKGZpZWxkVmFsLCBvcGVyYXRvcikge1xuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgY2FzZSAnPyc6XG4gICAgICByZXR1cm4gZmllbGRWYWwgPyB0cnVlIDogZmFsc2U7XG4gICAgY2FzZSAnISc6XG4gICAgICByZXR1cm4gZmllbGRWYWwgPyBmYWxzZSA6IHRydWU7XG4gICAgY2FzZSAnXic6XG4gICAgICByZXR1cm4gZmllbGRWYWwgPT09IHVuZGVmaW5lZDtcbiAgfVxufTtcbnZhciBleGlzdENtcCA9IGZ1bmN0aW9uIGV4aXN0Q21wKGZpZWxkVmFsKSB7XG4gIHJldHVybiBmaWVsZFZhbCAhPT0gdW5kZWZpbmVkO1xufTtcbnZhciBkYXRhJDEgPSBmdW5jdGlvbiBkYXRhKGVsZSwgZmllbGQpIHtcbiAgcmV0dXJuIGVsZS5kYXRhKGZpZWxkKTtcbn07XG52YXIgbWV0YSA9IGZ1bmN0aW9uIG1ldGEoZWxlLCBmaWVsZCkge1xuICByZXR1cm4gZWxlW2ZpZWxkXSgpO1xufTtcblxuLyoqIEEgbG9va3VwIG9mIGBtYXRjaChjaGVjaywgZWxlKWAgZnVuY3Rpb25zIGJ5IGBUeXBlYCBpbnQgKi9cbnZhciBtYXRjaCA9IFtdO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBmb3IgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBxdWVyeSBUaGUgYHsgdHlwZSwgdmFsdWUsIC4uLiB9YCBxdWVyeSBvYmplY3RcbiAqIEBwYXJhbSBlbGUgVGhlIGVsZW1lbnQgdG8gY29tcGFyZSBhZ2FpbnN0XG4qL1xudmFyIG1hdGNoZXMkMSA9IGZ1bmN0aW9uIG1hdGNoZXMocXVlcnksIGVsZSkge1xuICByZXR1cm4gcXVlcnkuY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGspIHtcbiAgICByZXR1cm4gbWF0Y2hbY2hrLnR5cGVdKGNoaywgZWxlKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5HUk9VUF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZ3JvdXAgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGdyb3VwID09PSAnKicgfHwgZ3JvdXAgPT09IGVsZS5ncm91cCgpO1xufTtcbm1hdGNoW1R5cGUuU1RBVEVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIHN0YXRlU2VsZWN0b3IgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHN0YXRlU2VsZWN0b3JNYXRjaGVzKHN0YXRlU2VsZWN0b3IsIGVsZSk7XG59O1xubWF0Y2hbVHlwZS5JRF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgaWQgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGVsZS5pZCgpID09PSBpZDtcbn07XG5tYXRjaFtUeXBlLkNMQVNTXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBjbHMgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGVsZS5oYXNDbGFzcyhjbHMpO1xufTtcbm1hdGNoW1R5cGUuTUVUQV9DT01QQVJFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChtZXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcbm1hdGNoW1R5cGUuREFUQV9DT01QQVJFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChkYXRhJDEoZWxlLCBmaWVsZCksIG9wZXJhdG9yLCB2YWx1ZSk7XG59O1xubWF0Y2hbVHlwZS5EQVRBX0JPT0xdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcjtcbiAgcmV0dXJuIGJvb2xDbXAoZGF0YSQxKGVsZSwgZmllbGQpLCBvcGVyYXRvcik7XG59O1xubWF0Y2hbVHlwZS5EQVRBX0VYSVNUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkO1xuICAgIGNoZWNrLm9wZXJhdG9yO1xuICByZXR1cm4gZXhpc3RDbXAoZGF0YSQxKGVsZSwgZmllbGQpKTtcbn07XG5tYXRjaFtUeXBlLlVORElSRUNURURfRURHRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgcUEgPSBjaGVjay5ub2Rlc1swXTtcbiAgdmFyIHFCID0gY2hlY2subm9kZXNbMV07XG4gIHZhciBzcmMgPSBlbGUuc291cmNlKCk7XG4gIHZhciB0Z3QgPSBlbGUudGFyZ2V0KCk7XG4gIHJldHVybiBtYXRjaGVzJDEocUEsIHNyYykgJiYgbWF0Y2hlcyQxKHFCLCB0Z3QpIHx8IG1hdGNoZXMkMShxQiwgc3JjKSAmJiBtYXRjaGVzJDEocUEsIHRndCk7XG59O1xubWF0Y2hbVHlwZS5OT0RFX05FSUdIQk9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2subm9kZSwgZWxlKSAmJiBlbGUubmVpZ2hib3Job29kKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMkMShjaGVjay5uZWlnaGJvciwgbik7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuRElSRUNURURfRURHRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnNvdXJjZSwgZWxlLnNvdXJjZSgpKSAmJiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBlbGUudGFyZ2V0KCkpO1xufTtcbm1hdGNoW1R5cGUuTk9ERV9TT1VSQ0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zb3VyY2UsIGVsZSkgJiYgZWxlLm91dGdvZXJzKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMkMShjaGVjay50YXJnZXQsIG4pO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLk5PREVfVEFSR0VUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBlbGUpICYmIGVsZS5pbmNvbWVycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBuKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5DSElMRF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmNoaWxkLCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5wYXJlbnQsIGVsZS5wYXJlbnQoKSk7XG59O1xubWF0Y2hbVHlwZS5QQVJFTlRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5wYXJlbnQsIGVsZSkgJiYgZWxlLmNoaWxkcmVuKCkuc29tZShmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suY2hpbGQsIGMpO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkRFU0NFTkRBTlRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5kZXNjZW5kYW50LCBlbGUpICYmIGVsZS5hbmNlc3RvcnMoKS5zb21lKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5hbmNlc3RvciwgYSk7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuQU5DRVNUT1JdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5hbmNlc3RvciwgZWxlKSAmJiBlbGUuZGVzY2VuZGFudHMoKS5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5kZXNjZW5kYW50LCBkKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5DT01QT1VORF9TUExJVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnN1YmplY3QsIGVsZSkgJiYgbWF0Y2hlcyQxKGNoZWNrLmxlZnQsIGVsZSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnJpZ2h0LCBlbGUpO1xufTtcbm1hdGNoW1R5cGUuVFJVRV0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbm1hdGNoW1R5cGUuQ09MTEVDVElPTl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgY29sbGVjdGlvbiA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gY29sbGVjdGlvbi5oYXMoZWxlKTtcbn07XG5tYXRjaFtUeXBlLkZJTFRFUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmlsdGVyID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBmaWx0ZXIoZWxlKTtcbn07XG5cbi8vIGZpbHRlciBhbiBleGlzdGluZyBjb2xsZWN0aW9uXG52YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGZvciAxIGlkICNmb28gcXVlcmllcywganVzdCBnZXQgdGhlIGVsZW1lbnRcbiAgaWYgKHNlbGYubGVuZ3RoID09PSAxICYmIHNlbGZbMF0uY2hlY2tzLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrc1swXS50eXBlID09PSBUeXBlLklEKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0RWxlbWVudEJ5SWQoc2VsZlswXS5jaGVja3NbMF0udmFsdWUpLmNvbGxlY3Rpb24oKTtcbiAgfVxuICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNlbGVjdG9yRnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcbiAgICAgIGlmIChtYXRjaGVzJDEocXVlcnksIGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGlmIChzZWxmLnRleHQoKSA9PSBudWxsKSB7XG4gICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNlbGVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihzZWxlY3RvckZ1bmN0aW9uKTtcbn07IC8vIGZpbHRlclxuXG4vLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcbiAgICBpZiAobWF0Y2hlcyQxKHF1ZXJ5LCBlbGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTsgLy8gbWF0Y2hlc1xuXG52YXIgbWF0Y2hpbmcgPSB7XG4gIG1hdGNoZXM6IG1hdGNoZXMsXG4gIGZpbHRlcjogZmlsdGVyXG59O1xuXG52YXIgU2VsZWN0b3IgPSBmdW5jdGlvbiBTZWxlY3RvcihzZWxlY3Rvcikge1xuICB0aGlzLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICB0aGlzLmN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgdGhpcy5jb21wb3VuZENvdW50ID0gMDtcbiAgdGhpcy5lZGdlQ291bnQgPSAwO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHN0cmluZyhzZWxlY3RvcikgJiYgc2VsZWN0b3IubWF0Y2goL15cXHMqJC8pKSA7IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgdGhpcy5hZGRRdWVyeSh7XG4gICAgICBjaGVja3M6IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuQ09MTEVDVElPTixcbiAgICAgICAgdmFsdWU6IHNlbGVjdG9yLmNvbGxlY3Rpb24oKVxuICAgICAgfV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChmbiQ2KHNlbGVjdG9yKSkge1xuICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgY2hlY2tzOiBbe1xuICAgICAgICB0eXBlOiBUeXBlLkZJTFRFUixcbiAgICAgICAgdmFsdWU6IHNlbGVjdG9yXG4gICAgICB9XVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHN0cmluZyhzZWxlY3RvcikpIHtcbiAgICBpZiAoIXRoaXMucGFyc2Uoc2VsZWN0b3IpKSB7XG4gICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnJvcignQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJyk7XG4gIH1cbn07XG52YXIgc2VsZm4gPSBTZWxlY3Rvci5wcm90b3R5cGU7XG5bcGFyc2UkMSwgbWF0Y2hpbmddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGV4dGVuZChzZWxmbiwgcCk7XG59KTtcbnNlbGZuLnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlucHV0VGV4dDtcbn07XG5zZWxmbi5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuc2VsZm4uZXEgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gdGhpc1tpXTtcbn07XG5zZWxmbi5zYW1lVGV4dCA9IGZ1bmN0aW9uIChvdGhlclNlbCkge1xuICByZXR1cm4gIXRoaXMuaW52YWxpZCAmJiAhb3RoZXJTZWwuaW52YWxpZCAmJiB0aGlzLnRleHQoKSA9PT0gb3RoZXJTZWwudGV4dCgpO1xufTtcbnNlbGZuLmFkZFF1ZXJ5ID0gZnVuY3Rpb24gKHEpIHtcbiAgdGhpc1t0aGlzLmxlbmd0aCsrXSA9IHE7XG59O1xuc2VsZm4uc2VsZWN0b3IgPSBzZWxmbi50b1N0cmluZztcblxudmFyIGVsZXNmbiRnID0ge1xuICBhbGxBcmU6IGZ1bmN0aW9uIGFsbEFyZShzZWxlY3Rvcikge1xuICAgIHZhciBzZWxPYmogPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgIH0pO1xuICB9LFxuICBpczogZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgIH0pO1xuICB9LFxuICBzb21lOiBmdW5jdGlvbiBzb21lKGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShmbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgc2FtZTogZnVuY3Rpb24gc2FtZShjb2xsZWN0aW9uKSB7XG4gICAgLy8gY2hlYXAgY29sbGVjdGlvbiByZWYgY2hlY2tcbiAgICBpZiAodGhpcyA9PT0gY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBjb2xsZWN0aW9uTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAvLyBjaGVhcCBsZW5ndGggY2hlY2tcbiAgICBpZiAodGhpc0xlbmd0aCAhPT0gY29sbGVjdGlvbkxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWFwIGVsZW1lbnQgcmVmIGNoZWNrXG4gICAgaWYgKHRoaXNMZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdID09PSBjb2xsZWN0aW9uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfSxcbiAgYW55U2FtZTogZnVuY3Rpb24gYW55U2FtZShjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG4gIGFsbEFyZU5laWdoYm9yczogZnVuY3Rpb24gYWxsQXJlTmVpZ2hib3JzKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIG5ob29kID0gdGhpcy5uZWlnaGJvcmhvb2QoKTtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gbmhvb2QuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY29sbGVjdGlvbi5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsZi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfVxufTtcbmVsZXNmbiRnLmFsbEFyZU5laWdoYm91cnMgPSBlbGVzZm4kZy5hbGxBcmVOZWlnaGJvcnM7XG5lbGVzZm4kZy5oYXMgPSBlbGVzZm4kZy5jb250YWlucztcbmVsZXNmbiRnLmVxdWFsID0gZWxlc2ZuJGcuZXF1YWxzID0gZWxlc2ZuJGcuc2FtZTtcblxudmFyIGNhY2hlID0gZnVuY3Rpb24gY2FjaGUoZm4sIG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyYXZlcnNhbENhY2hlKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICB2YXIgc2VsZWN0b3JPckVsZXMgPSBhcmcxO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIga2V5O1xuICAgIGlmIChzZWxlY3Rvck9yRWxlcyA9PSBudWxsKSB7XG4gICAgICBrZXkgPSAnJztcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oc2VsZWN0b3JPckVsZXMpICYmIHNlbGVjdG9yT3JFbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAga2V5ID0gc2VsZWN0b3JPckVsZXMuaWQoKTtcbiAgICB9XG4gICAgaWYgKGVsZXMubGVuZ3RoID09PSAxICYmIGtleSkge1xuICAgICAgdmFyIF9wID0gZWxlc1swXS5fcHJpdmF0ZTtcbiAgICAgIHZhciB0Y2ggPSBfcC50cmF2ZXJzYWxDYWNoZSA9IF9wLnRyYXZlcnNhbENhY2hlIHx8IHt9O1xuICAgICAgdmFyIGNoID0gdGNoW25hbWVdID0gdGNoW25hbWVdIHx8IFtdO1xuICAgICAgdmFyIGhhc2ggPSBoYXNoU3RyaW5nKGtleSk7XG4gICAgICB2YXIgY2FjaGVIaXQgPSBjaFtoYXNoXTtcbiAgICAgIGlmIChjYWNoZUhpdCkge1xuICAgICAgICByZXR1cm4gY2FjaGVIaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hbaGFzaF0gPSBmbi5jYWxsKGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm4uY2FsbChlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgZWxlc2ZuJGYgPSB7XG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHNlbGVjdG9yKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgIC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIGVsZSBjYWxsXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpc1swXS5fcHJpdmF0ZS5wYXJlbnQ7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3BhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG4gICAgICBpZiAoX3BhcmVudCkge1xuICAgICAgICBwYXJlbnRzLnB1c2goX3BhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHBhcmVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIHBhcmVudHM6IGZ1bmN0aW9uIHBhcmVudHMoc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcbiAgICB3aGlsZSAoZWxlcy5ub25lbXB0eSgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHBhcmVudHMucHVzaChlbGUpO1xuICAgICAgfVxuICAgICAgZWxlcyA9IGVsZXMucGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHBhcmVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24gY29tbW9uQW5jZXN0b3JzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGFuY2VzdG9ycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHBhcmVudHMgPSBlbGUucGFyZW50cygpO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzIHx8IHBhcmVudHM7XG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KHBhcmVudHMpOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3JzLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG9ycGhhbnM6IGZ1bmN0aW9uIG9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uIG5vbm9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgY2hpbGRyZW46IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgZWxlQ2hpbGRyZW4gPSBlbGUuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZUNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goZWxlQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihjaGlsZHJlbiwgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2NoaWxkcmVuJyksXG4gIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGlzUGFyZW50OiBmdW5jdGlvbiBpc1BhcmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgfVxuICB9LFxuICBpc0NoaWxkbGVzczogZnVuY3Rpb24gaXNDaGlsZGxlc3MoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgfSxcbiAgaXNDaGlsZDogZnVuY3Rpb24gaXNDaGlsZCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGlzT3JwaGFuOiBmdW5jdGlvbiBpc09ycGhhbigpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgPT0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGRlc2NlbmRhbnRzOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhzZWxlY3Rvcikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZChlbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgaWYgKGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkpIHtcbiAgICAgICAgICBhZGQoZWxlLmNoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFkZCh0aGlzLmNoaWxkcmVuKCkpO1xuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9XG59O1xuZnVuY3Rpb24gZm9yRWFjaENvbXBvdW5kKGVsZXMsIGZuLCBpbmNsdWRlU2VsZiwgcmVjdXJzaXZlU3RlcCkge1xuICB2YXIgcSA9IFtdO1xuICB2YXIgZGlkID0gbmV3IFNldCQxKCk7XG4gIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgaWYgKGluY2x1ZGVTZWxmKSB7XG4gICAgICBxLnB1c2goZWxlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgcmVjdXJzaXZlU3RlcChxLCBkaWQsIGVsZSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgX2VsZSA9IHEuc2hpZnQoKTtcbiAgICBmbihfZWxlKTtcbiAgICBkaWQuYWRkKF9lbGUuaWQoKSk7XG4gICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgcmVjdXJzaXZlU3RlcChxLCBkaWQsIF9lbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlcztcbn1cbmZ1bmN0aW9uIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICghZGlkLmhhcyhjaGlsZC5pZCgpKSkge1xuICAgICAgICBxLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyB2ZXJ5IGVmZmljaWVudCB2ZXJzaW9uIG9mIGVsZXMuYWRkKCBlbGVzLmRlc2NlbmRhbnRzKCkgKS5mb3JFYWNoKClcbi8vIGZvciBpbnRlcm5hbCB1c2VcbmVsZXNmbiRmLmZvckVhY2hEb3duID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZENoaWxkcmVuKTtcbn07XG5mdW5jdGlvbiBhZGRQYXJlbnQocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc0NoaWxkKCkpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcbiAgICBpZiAoIWRpZC5oYXMocGFyZW50LmlkKCkpKSB7XG4gICAgICBxLnB1c2gocGFyZW50KTtcbiAgICB9XG4gIH1cbn1cbmVsZXNmbiRmLmZvckVhY2hVcCA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnQpO1xufTtcbmZ1bmN0aW9uIGFkZFBhcmVudEFuZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGFkZFBhcmVudChxLCBkaWQsIGVsZSk7XG4gIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKTtcbn1cbmVsZXNmbiRmLmZvckVhY2hVcEFuZERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50QW5kQ2hpbGRyZW4pO1xufTtcblxuLy8gYWxpYXNlc1xuZWxlc2ZuJGYuYW5jZXN0b3JzID0gZWxlc2ZuJGYucGFyZW50cztcblxudmFyIGZuJDUsIGVsZXNmbiRlO1xuZm4kNSA9IGVsZXNmbiRlID0ge1xuICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZURhdGE6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gIH0pLFxuICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIH1cbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuZm4kNS5hdHRyID0gZm4kNS5kYXRhO1xuZm4kNS5yZW1vdmVBdHRyID0gZm4kNS5yZW1vdmVEYXRhO1xudmFyIGRhdGEgPSBlbGVzZm4kZTtcblxudmFyIGVsZXNmbiRkID0ge307XG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkpIHtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tpXTtcbiAgICAgICAgaWYgKCFpbmNsdWRlTG9vcHMgJiYgZWRnZS5pc0xvb3AoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayhub2RlLCBlZGdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG59XG5leHRlbmQoZWxlc2ZuJGQsIHtcbiAgZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUoZWRnZS50YXJnZXQoKSkpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pLFxuICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS50YXJnZXQoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KSxcbiAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUobm9kZSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pXG59KTtcbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBkZWdyZWUgPSBlbGVbZGVncmVlRm5dKGluY2x1ZGVMb29wcyk7XG4gICAgICBpZiAoZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkpIHtcbiAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuZXh0ZW5kKGVsZXNmbiRkLCB7XG4gIG1pbkRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0pLFxuICBtYXhEZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcbiAgbWluSW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0pLFxuICBtYXhJbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSksXG4gIG1pbk91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gIH0pLFxuICBtYXhPdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KVxufSk7XG5leHRlbmQoZWxlc2ZuJGQsIHtcbiAgdG90YWxEZWdyZWU6IGZ1bmN0aW9uIHRvdGFsRGVncmVlKGluY2x1ZGVMb29wcykge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsICs9IG5vZGVzW2ldLmRlZ3JlZShpbmNsdWRlTG9vcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbn0pO1xuXG52YXIgZm4kNCwgZWxlc2ZuJGM7XG52YXIgYmVmb3JlUG9zaXRpb25TZXQgPSBmdW5jdGlvbiBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIHNpbGVudCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICBpZiAoIWVsZS5sb2NrZWQoKSkge1xuICAgICAgdmFyIG9sZFBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgeDogbmV3UG9zLnggIT0gbnVsbCA/IG5ld1Bvcy54IC0gb2xkUG9zLnggOiAwLFxuICAgICAgICB5OiBuZXdQb3MueSAhPSBudWxsID8gbmV3UG9zLnkgLSBvbGRQb3MueSA6IDBcbiAgICAgIH07XG4gICAgICBpZiAoZWxlLmlzUGFyZW50KCkgJiYgIShkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApKSB7XG4gICAgICAgIGVsZS5jaGlsZHJlbigpLnNoaWZ0KGRlbHRhLCBzaWxlbnQpO1xuICAgICAgfVxuICAgICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBwb3NpdGlvbkRlZiA9IHtcbiAgZmllbGQ6ICdwb3NpdGlvbicsXG4gIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICBhbGxvd1NldHRpbmc6IHRydWUsXG4gIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gIHRyaWdnZXJGbk5hbWU6ICdlbWl0QW5kTm90aWZ5JyxcbiAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gIGJlZm9yZUdldDogZnVuY3Rpb24gYmVmb3JlR2V0KGVsZSkge1xuICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICB9LFxuICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIGZhbHNlKTtcbiAgfSxcbiAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KGVsZXMpIHtcbiAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICB9LFxuICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgfVxufTtcbmZuJDQgPSBlbGVzZm4kYyA9IHtcbiAgcG9zaXRpb246IGRlZmluZS5kYXRhKHBvc2l0aW9uRGVmKSxcbiAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICBzaWxlbnRQb3NpdGlvbjogZGVmaW5lLmRhdGEoZXh0ZW5kKHt9LCBwb3NpdGlvbkRlZiwge1xuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KGVsZXMsIG5ld1Bvcykge1xuICAgICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIH1cbiAgfSkpLFxuICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyhwb3MsIHNpbGVudCkge1xuICAgIGlmIChwbGFpbk9iamVjdChwb3MpKSB7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHRoaXMuc2lsZW50UG9zaXRpb24ocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ocG9zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZuJDYocG9zKSkge1xuICAgICAgdmFyIF9mbiA9IHBvcztcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIF9wb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChfcG9zID0gX2ZuKGVsZSwgaSkpIHtcbiAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5wb3NpdGlvbihfcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBzaWxlbnRQb3NpdGlvbnM6IGZ1bmN0aW9uIHNpbGVudFBvc2l0aW9ucyhwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMocG9zLCB0cnVlKTtcbiAgfSxcbiAgc2hpZnQ6IGZ1bmN0aW9uIHNoaWZ0KGRpbSwgdmFsLCBzaWxlbnQpIHtcbiAgICB2YXIgZGVsdGE7XG4gICAgaWYgKHBsYWluT2JqZWN0KGRpbSkpIHtcbiAgICAgIGRlbHRhID0ge1xuICAgICAgICB4OiBudW1iZXIkMShkaW0ueCkgPyBkaW0ueCA6IDAsXG4gICAgICAgIHk6IG51bWJlciQxKGRpbS55KSA/IGRpbS55IDogMFxuICAgICAgfTtcbiAgICAgIHNpbGVudCA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhkaW0pICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgIGRlbHRhID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgZGVsdGFbZGltXSA9IHZhbDtcbiAgICB9XG4gICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAvLyBleGNsdWRlIGFueSBub2RlIHRoYXQgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICAgICAgaWYgKGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSAmJiBlbGUuaXNDaGlsZCgpICYmIGVsZS5hbmNlc3RvcnMoKS5hbnlTYW1lKHRoaXMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgbmV3UG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54ICsgZGVsdGEueCxcbiAgICAgICAgICB5OiBwb3MueSArIGRlbHRhLnlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgIGVsZS5zaWxlbnRQb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2lsZW50U2hpZnQ6IGZ1bmN0aW9uIHNpbGVudFNoaWZ0KGRpbSwgdmFsKSB7XG4gICAgaWYgKHBsYWluT2JqZWN0KGRpbSkpIHtcbiAgICAgIHRoaXMuc2hpZnQoZGltLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhkaW0pICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgIHRoaXMuc2hpZnQoZGltLCB2YWwsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gZ2V0L3NldCB0aGUgcmVuZGVyZWQgKGkuZS4gb24gc2NyZWVuKSBwb3NpdG9uIG9mIHRoZSBlbGVtZW50XG4gIHJlbmRlcmVkUG9zaXRpb246IGZ1bmN0aW9uIHJlbmRlcmVkUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBycG9zID0gcGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmcoZGltKTtcbiAgICBpZiAoZWxlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbGUgPSB0aGlzW2ldO1xuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUucG9zaXRpb24oZGltLCAodmFsIC0gcGFuW2RpbV0pIC8gem9vbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChycG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihyZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICBycG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24kMShwb3MsIHpvb20sIHBhbik7XG4gICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3NbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgcmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gcmVsYXRpdmVQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcHBvcyA9IHBsYWluT2JqZWN0KGRpbSkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNldHRpbmcgPSBwcG9zICE9PSB1bmRlZmluZWQgfHwgdmFsICE9PSB1bmRlZmluZWQgJiYgc3RyaW5nKGRpbSk7XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgaWYgKGVsZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfZWxlMiA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBfZWxlMi5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcbiAgICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50LnBvc2l0aW9uKCkgOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgX2VsZTIucG9zaXRpb24oZGltLCB2YWwgKyBvcmlnaW5bZGltXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgX2VsZTIucG9zaXRpb24oe1xuICAgICAgICAgICAgICB4OiBwcG9zLnggKyBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgeTogcHBvcy55ICsgb3JpZ2luLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBfcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgIHZhciBfaGFzUGFyZW50ID0gX3BhcmVudCAmJiBfcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgIHZhciBfcmVsYXRpdmVUb1BhcmVudCA9IF9oYXNQYXJlbnQ7XG4gICAgICAgIGlmIChfaGFzUGFyZW50KSB7XG4gICAgICAgICAgX3BhcmVudCA9IF9wYXJlbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9vcmlnaW4gPSBfcmVsYXRpdmVUb1BhcmVudCA/IF9wYXJlbnQucG9zaXRpb24oKSA6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgcHBvcyA9IHtcbiAgICAgICAgICB4OiBwb3MueCAtIF9vcmlnaW4ueCxcbiAgICAgICAgICB5OiBwb3MueSAtIF9vcmlnaW4ueVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBwcG9zW2RpbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5nKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9XG59O1xuXG4vLyBhbGlhc2VzXG5mbiQ0Lm1vZGVsUG9zaXRpb24gPSBmbiQ0LnBvaW50ID0gZm4kNC5wb3NpdGlvbjtcbmZuJDQubW9kZWxQb3NpdGlvbnMgPSBmbiQ0LnBvaW50cyA9IGZuJDQucG9zaXRpb25zO1xuZm4kNC5yZW5kZXJlZFBvaW50ID0gZm4kNC5yZW5kZXJlZFBvc2l0aW9uO1xuZm4kNC5yZWxhdGl2ZVBvaW50ID0gZm4kNC5yZWxhdGl2ZVBvc2l0aW9uO1xudmFyIHBvc2l0aW9uID0gZWxlc2ZuJGM7XG5cbnZhciBmbiQzLCBlbGVzZm4kYjtcbmZuJDMgPSBlbGVzZm4kYiA9IHt9O1xuZWxlc2ZuJGIucmVuZGVyZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3gob3B0aW9ucyk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHgxID0gYmIueDEgKiB6b29tICsgcGFuLng7XG4gIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICB2YXIgeTEgPSBiYi55MSAqIHpvb20gKyBwYW4ueTtcbiAgdmFyIHkyID0gYmIueTIgKiB6b29tICsgcGFuLnk7XG4gIHJldHVybiB7XG4gICAgeDE6IHgxLFxuICAgIHgyOiB4MixcbiAgICB5MTogeTEsXG4gICAgeTI6IHkyLFxuICAgIHc6IHgyIC0geDEsXG4gICAgaDogeTIgLSB5MVxuICB9O1xufTtcbmVsZXNmbiRiLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNpbGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5mb3JFYWNoVXAoZnVuY3Rpb24gKGVsZSkge1xuICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IGZhbHNlO1xuICAgICAgX3AuYmJDYWNoZSA9IG51bGw7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZWxlc2ZuJGIudXBkYXRlQ29tcG91bmRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAvLyBub3QgcG9zc2libGUgdG8gZG8gb24gbm9uLWNvbXBvdW5kIGdyYXBocyBvciB3aXRoIHRoZSBzdHlsZSBkaXNhYmxlZFxuICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNhdmUgY3ljbGVzIHdoZW4gYmF0Y2hpbmcgLS0gYnV0IGJvdW5kcyB3aWxsIGJlIHN0YWxlIChvciBub3QgZXhpc3QgeWV0KVxuICBpZiAoIWZvcmNlICYmIGN5LmJhdGNoaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQuaXNQYXJlbnQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX3AgPSBwYXJlbnQuX3ByaXZhdGU7XG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBwYXJlbnQucHN0eWxlKCdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycpLnZhbHVlID09PSAnaW5jbHVkZSc7XG4gICAgdmFyIG1pbiA9IHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgbGVmdDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtbGVmdCcpLFxuICAgICAgICByaWdodDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtcmlnaHQnKVxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQnKS5wZlZhbHVlLFxuICAgICAgICB0b3A6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy10b3AnKSxcbiAgICAgICAgYm90dG9tOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJylcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBiYiA9IGNoaWxkcmVuLmJvdW5kaW5nQm94KHtcbiAgICAgIGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHMsXG4gICAgICBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlLFxuICAgICAgLy8gdXBkYXRpbmcgdGhlIGNvbXBvdW5kIGJvdW5kcyBoYXBwZW5zIG91dHNpZGUgb2YgdGhlIHJlZ3VsYXJcbiAgICAgIC8vIGNhY2hlIGN5Y2xlIChpLmUuIGJlZm9yZSBmaXJlZCBldmVudHMpXG4gICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICB9KTtcbiAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgICAvLyBpZiBjaGlsZHJlbiB0YWtlIHVwIHplcm8gYXJlYSB0aGVuIGtlZXAgcG9zaXRpb24gYW5kIGZhbGwgYmFjayBvbiBzdHlsZXNoZWV0IHcvaFxuICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgIGJiID0ge1xuICAgICAgICB3OiBwYXJlbnQucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgIGg6IHBhcmVudC5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWVcbiAgICAgIH07XG4gICAgICBiYi54MSA9IHBvcy54IC0gYmIudyAvIDI7XG4gICAgICBiYi54MiA9IHBvcy54ICsgYmIudyAvIDI7XG4gICAgICBiYi55MSA9IHBvcy55IC0gYmIuaCAvIDI7XG4gICAgICBiYi55MiA9IHBvcy55ICsgYmIuaCAvIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVCaWFzVmFsdWVzKHByb3BEaWZmLCBwcm9wQmlhcywgcHJvcEJpYXNDb21wbGVtZW50KSB7XG4gICAgICB2YXIgYmlhc0RpZmYgPSAwO1xuICAgICAgdmFyIGJpYXNDb21wbGVtZW50RGlmZiA9IDA7XG4gICAgICB2YXIgYmlhc1RvdGFsID0gcHJvcEJpYXMgKyBwcm9wQmlhc0NvbXBsZW1lbnQ7XG4gICAgICBpZiAocHJvcERpZmYgPiAwICYmIGJpYXNUb3RhbCA+IDApIHtcbiAgICAgICAgYmlhc0RpZmYgPSBwcm9wQmlhcyAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSBwcm9wQmlhc0NvbXBsZW1lbnQgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJpYXNEaWZmOiBiaWFzRGlmZixcbiAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmOiBiaWFzQ29tcGxlbWVudERpZmZcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVQYWRkaW5nVmFsdWVzKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdPYmplY3QsIHJlbGF0aXZlVG8pIHtcbiAgICAgIC8vIEFzc3VtaW5nIHBlcmNlbnRhZ2UgaXMgbnVtYmVyIGZyb20gMCB0byAxXG4gICAgICBpZiAocGFkZGluZ09iamVjdC51bml0cyA9PT0gJyUnKSB7XG4gICAgICAgIHN3aXRjaCAocmVsYXRpdmVUbykge1xuICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG4gICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcbiAgICAgICAgICBjYXNlICdhdmVyYWdlJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqICh3aWR0aCArIGhlaWdodCkgLyAyIDogMDtcbiAgICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG4gICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAncHgnKSB7XG4gICAgICAgIHJldHVybiBwYWRkaW5nT2JqZWN0LnBmVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxlZnRWYWwgPSBtaW4ud2lkdGgubGVmdC52YWx1ZTtcbiAgICBpZiAobWluLndpZHRoLmxlZnQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgIGxlZnRWYWwgPSBsZWZ0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG4gICAgdmFyIHJpZ2h0VmFsID0gbWluLndpZHRoLnJpZ2h0LnZhbHVlO1xuICAgIGlmIChtaW4ud2lkdGgucmlnaHQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgIHJpZ2h0VmFsID0gcmlnaHRWYWwgKiAxMDAgLyBtaW4ud2lkdGgudmFsO1xuICAgIH1cbiAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG4gICAgaWYgKG1pbi5oZWlnaHQudG9wLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgdG9wVmFsID0gdG9wVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgfVxuICAgIHZhciBib3R0b21WYWwgPSBtaW4uaGVpZ2h0LmJvdHRvbS52YWx1ZTtcbiAgICBpZiAobWluLmhlaWdodC5ib3R0b20udW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICBib3R0b21WYWwgPSBib3R0b21WYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICB9XG4gICAgdmFyIHdpZHRoQmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMobWluLndpZHRoLnZhbCAtIGJiLncsIGxlZnRWYWwsIHJpZ2h0VmFsKTtcbiAgICB2YXIgZGlmZkxlZnQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICB2YXIgZGlmZlJpZ2h0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuICAgIHZhciBoZWlnaHRCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4uaGVpZ2h0LnZhbCAtIGJiLmgsIHRvcFZhbCwgYm90dG9tVmFsKTtcbiAgICB2YXIgZGlmZlRvcCA9IGhlaWdodEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICB2YXIgZGlmZkJvdHRvbSA9IGhlaWdodEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgX3AuYXV0b1BhZGRpbmcgPSBjb21wdXRlUGFkZGluZ1ZhbHVlcyhiYi53LCBiYi5oLCBwYXJlbnQucHN0eWxlKCdwYWRkaW5nJyksIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmctcmVsYXRpdmUtdG8nKS52YWx1ZSk7XG4gICAgX3AuYXV0b1dpZHRoID0gTWF0aC5tYXgoYmIudywgbWluLndpZHRoLnZhbCk7XG4gICAgcG9zLnggPSAoLWRpZmZMZWZ0ICsgYmIueDEgKyBiYi54MiArIGRpZmZSaWdodCkgLyAyO1xuICAgIF9wLmF1dG9IZWlnaHQgPSBNYXRoLm1heChiYi5oLCBtaW4uaGVpZ2h0LnZhbCk7XG4gICAgcG9zLnkgPSAoLWRpZmZUb3AgKyBiYi55MSArIGJiLnkyICsgZGlmZkJvdHRvbSkgLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICBpZiAoIV9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gfHwgZm9yY2UpIHtcbiAgICAgIHVwZGF0ZShlbGUpO1xuICAgICAgaWYgKCFjeS5iYXRjaGluZygpKSB7XG4gICAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG52YXIgbm9uaW5mID0gZnVuY3Rpb24gbm9uaW5mKHgpIHtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB4O1xufTtcbnZhciB1cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHMoYiwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggemVybyBhcmVhIGJveGVzXG4gIGlmICh4MiAtIHgxID09PSAwIHx8IHkyIC0geTEgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkb24ndCB1cGRhdGUgd2l0aCBudWxsIGRpbVxuICBpZiAoeDEgPT0gbnVsbCB8fCB5MSA9PSBudWxsIHx8IHgyID09IG51bGwgfHwgeTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBiLngxID0geDEgPCBiLngxID8geDEgOiBiLngxO1xuICBiLngyID0geDIgPiBiLngyID8geDIgOiBiLngyO1xuICBiLnkxID0geTEgPCBiLnkxID8geTEgOiBiLnkxO1xuICBiLnkyID0geTIgPiBiLnkyID8geTIgOiBiLnkyO1xuICBiLncgPSBiLngyIC0gYi54MTtcbiAgYi5oID0gYi55MiAtIGIueTE7XG59O1xudmFyIHVwZGF0ZUJvdW5kc0Zyb21Cb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQm94KGIsIGIyKSB7XG4gIGlmIChiMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZUJvdW5kcyhiLCBiMi54MSwgYjIueTEsIGIyLngyLCBiMi55Mik7XG59O1xudmFyIHByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBwcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCkge1xuICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIGZpZWxkLCBwcmVmaXgpO1xufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tQXJyb3cgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBoYWxmQXJXID0gcnN0eWxlLmFycm93V2lkdGggLyAyO1xuICB2YXIgYXJyb3dUeXBlID0gZWxlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciB4O1xuICB2YXIgeTtcbiAgaWYgKGFycm93VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgaWYgKHByZWZpeCA9PT0gJ3NvdXJjZScpIHtcbiAgICAgIHggPSByc3R5bGUuc3JjWDtcbiAgICAgIHkgPSByc3R5bGUuc3JjWTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ3RhcmdldCcpIHtcbiAgICAgIHggPSByc3R5bGUudGd0WDtcbiAgICAgIHkgPSByc3R5bGUudGd0WTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHJzdHlsZS5taWRYO1xuICAgICAgeSA9IHJzdHlsZS5taWRZO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyBzdG9yZSB0aGUgaW5kaXZpZHVhbCBhcnJvdyBib3VuZHNcbiAgICB2YXIgYmJzID0gX3AuYXJyb3dCb3VuZHMgPSBfcC5hcnJvd0JvdW5kcyB8fCB7fTtcbiAgICB2YXIgYmIgPSBiYnNbcHJlZml4XSA9IGJic1twcmVmaXhdIHx8IHt9O1xuICAgIGJiLngxID0geCAtIGhhbGZBclc7XG4gICAgYmIueTEgPSB5IC0gaGFsZkFyVztcbiAgICBiYi54MiA9IHggKyBoYWxmQXJXO1xuICAgIGJiLnkyID0geSArIGhhbGZBclc7XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmIsIDEpO1xuICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJiLngxLCBiYi55MSwgYmIueDIsIGJiLnkyKTtcbiAgfVxufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tTGFiZWwgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJlZml4RGFzaDtcbiAgaWYgKHByZWZpeCkge1xuICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4RGFzaCA9ICcnO1xuICB9XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykuc3RyVmFsdWU7XG4gIGlmIChsYWJlbCkge1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpO1xuICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxIZWlnaHQgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxYID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgIHZhciBvdXRsaW5lV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5PZkVycm9yID0gMjsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuXG4gICAgdmFyIGxoID0gbGFiZWxIZWlnaHQ7XG4gICAgdmFyIGx3ID0gbGFiZWxXaWR0aDtcbiAgICB2YXIgbHdfMiA9IGx3IC8gMjtcbiAgICB2YXIgbGhfMiA9IGxoIC8gMjtcbiAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBseDEgPSBsYWJlbFggLSBsd18yO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNoaWZ0IGJ5IG1hcmdpbiBhbmQgZXhwYW5kIGJ5IG91dGxpbmUgYW5kIGJvcmRlclxuICAgIHZhciBsZWZ0UGFkID0gbWFyZ2luWCAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmcgLSBtYXJnaW5PZkVycm9yO1xuICAgIHZhciByaWdodFBhZCA9IG1hcmdpblggKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgKyBwYWRkaW5nICsgbWFyZ2luT2ZFcnJvcjtcbiAgICB2YXIgdG9wUGFkID0gbWFyZ2luWSAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmcgLSBtYXJnaW5PZkVycm9yO1xuICAgIHZhciBib3RQYWQgPSBtYXJnaW5ZICsgTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpICsgcGFkZGluZyArIG1hcmdpbk9mRXJyb3I7XG4gICAgbHgxICs9IGxlZnRQYWQ7XG4gICAgbHgyICs9IHJpZ2h0UGFkO1xuICAgIGx5MSArPSB0b3BQYWQ7XG4gICAgbHkyICs9IGJvdFBhZDtcblxuICAgIC8vIGFsd2F5cyBzdG9yZSB0aGUgdW5yb3RhdGVkIGxhYmVsIGJvdW5kcyBzZXBhcmF0ZWx5XG4gICAgdmFyIGJiUHJlZml4ID0gcHJlZml4IHx8ICdtYWluJztcbiAgICB2YXIgYmJzID0gX3AubGFiZWxCb3VuZHM7XG4gICAgdmFyIGJiID0gYmJzW2JiUHJlZml4XSA9IGJic1tiYlByZWZpeF0gfHwge307XG4gICAgYmIueDEgPSBseDE7XG4gICAgYmIueTEgPSBseTE7XG4gICAgYmIueDIgPSBseDI7XG4gICAgYmIueTIgPSBseTI7XG4gICAgYmIudyA9IGx4MiAtIGx4MTtcbiAgICBiYi5oID0gbHkyIC0gbHkxO1xuICAgIGJiLmxlZnRQYWQgPSBsZWZ0UGFkO1xuICAgIGJiLnJpZ2h0UGFkID0gcmlnaHRQYWQ7XG4gICAgYmIudG9wUGFkID0gdG9wUGFkO1xuICAgIGJiLmJvdFBhZCA9IGJvdFBhZDtcbiAgICB2YXIgaXNBdXRvcm90YXRlID0gaXNFZGdlICYmIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gICAgdmFyIGlzUGZWYWx1ZSA9IHJvdGF0aW9uLnBmVmFsdWUgIT0gbnVsbCAmJiByb3RhdGlvbi5wZlZhbHVlICE9PSAwO1xuICAgIGlmIChpc0F1dG9yb3RhdGUgfHwgaXNQZlZhbHVlKSB7XG4gICAgICB2YXIgdGhldGEgPSBpc0F1dG9yb3RhdGUgPyBwcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpIDogcm90YXRpb24ucGZWYWx1ZTtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAvLyByb3RhdGlvbiBwb2ludCAoZGVmYXVsdCB2YWx1ZSBmb3IgY2VudGVyLWNlbnRlcilcbiAgICAgIHZhciB4byA9IChseDEgKyBseDIpIC8gMjtcbiAgICAgIHZhciB5byA9IChseTEgKyBseTIpIC8gMjtcbiAgICAgIGlmICghaXNFZGdlKSB7XG4gICAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB4byA9IGx4MjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHhvID0gbHgxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeW8gPSBseTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgeW8gPSBseTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgIHggPSB4IC0geG87XG4gICAgICAgIHkgPSB5IC0geW87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyB4byxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIHlvXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgIGx4MSA9IE1hdGgubWluKHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgbHgyID0gTWF0aC5tYXgocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICBseTEgPSBNYXRoLm1pbihweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICAgIGx5MiA9IE1hdGgubWF4KHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgIH1cbiAgICB2YXIgYmJQcmVmaXhSb3QgPSBiYlByZWZpeCArICdSb3QnO1xuICAgIHZhciBiYlJvdCA9IGJic1tiYlByZWZpeFJvdF0gPSBiYnNbYmJQcmVmaXhSb3RdIHx8IHt9O1xuICAgIGJiUm90LngxID0gbHgxO1xuICAgIGJiUm90LnkxID0gbHkxO1xuICAgIGJiUm90LngyID0gbHgyO1xuICAgIGJiUm90LnkyID0gbHkyO1xuICAgIGJiUm90LncgPSBseDIgLSBseDE7XG4gICAgYmJSb3QuaCA9IGx5MiAtIGx5MTtcbiAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICAgIHVwZGF0ZUJvdW5kcyhfcC5sYWJlbEJvdW5kcy5hbGwsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn07XG52YXIgdXBkYXRlQm91bmRzRnJvbU91dGxpbmUgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tT3V0bGluZShib3VuZHMsIGVsZSkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3V0bGluZU9wYWNpdHkgPSBlbGUucHN0eWxlKCdvdXRsaW5lLW9wYWNpdHknKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVXaWR0aCA9IGVsZS5wc3R5bGUoJ291dGxpbmUtd2lkdGgnKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVPZmZzZXQgPSBlbGUucHN0eWxlKCdvdXRsaW5lLW9mZnNldCcpLnZhbHVlO1xuICB2YXIgZXhwYW5zaW9uID0gb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldDtcbiAgdXBkYXRlQm91bmRzRnJvbU1pdGVyKGJvdW5kcywgZWxlLCBvdXRsaW5lT3BhY2l0eSwgZXhwYW5zaW9uLCAnb3V0c2lkZScsIGV4cGFuc2lvbiAvIDIpO1xufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tTWl0ZXIgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tTWl0ZXIoYm91bmRzLCBlbGUsIG9wYWNpdHksIGV4cGFuc2lvblNpemUsIGV4cGFuc2lvblBvc2l0aW9uLCB1c2VGYWxsYmFja1ZhbHVlKSB7XG4gIGlmIChvcGFjaXR5ID09PSAwIHx8IGV4cGFuc2lvblNpemUgPD0gMCB8fCBleHBhbnNpb25Qb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGN5ID0gZWxlLmN5KCk7XG4gIHZhciBzaGFwZSA9IGVsZS5wc3R5bGUoJ3NoYXBlJykudmFsdWU7XG4gIHZhciByc2hhcGUgPSBjeS5yZW5kZXJlcigpLm5vZGVTaGFwZXNbc2hhcGVdO1xuICB2YXIgX2VsZSRwb3NpdGlvbiA9IGVsZS5wb3NpdGlvbigpLFxuICAgIHggPSBfZWxlJHBvc2l0aW9uLngsXG4gICAgeSA9IF9lbGUkcG9zaXRpb24ueTtcbiAgdmFyIHcgPSBlbGUud2lkdGgoKTtcbiAgdmFyIGggPSBlbGUuaGVpZ2h0KCk7XG4gIGlmIChyc2hhcGUuaGFzTWl0ZXJCb3VuZHMpIHtcbiAgICBpZiAoZXhwYW5zaW9uUG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICBleHBhbnNpb25TaXplIC89IDI7XG4gICAgfVxuICAgIHZhciBtYmIgPSByc2hhcGUubWl0ZXJCb3VuZHMoeCwgeSwgdywgaCwgZXhwYW5zaW9uU2l6ZSk7XG4gICAgdXBkYXRlQm91bmRzRnJvbUJveChib3VuZHMsIG1iYik7XG4gIH0gZWxzZSBpZiAodXNlRmFsbGJhY2tWYWx1ZSAhPSBudWxsICYmIHVzZUZhbGxiYWNrVmFsdWUgPiAwKSB7XG4gICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhib3VuZHMsIFt1c2VGYWxsYmFja1ZhbHVlLCB1c2VGYWxsYmFja1ZhbHVlLCB1c2VGYWxsYmFja1ZhbHVlLCB1c2VGYWxsYmFja1ZhbHVlXSk7XG4gIH1cbn07XG52YXIgdXBkYXRlQm91bmRzRnJvbU1pdGVyQm9yZGVyID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbU1pdGVyQm9yZGVyKGJvdW5kcywgZWxlKSB7XG4gIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBib3JkZXJPcGFjaXR5ID0gZWxlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZTtcbiAgdmFyIGJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgdmFyIGJvcmRlclBvc2l0aW9uID0gZWxlLnBzdHlsZSgnYm9yZGVyLXBvc2l0aW9uJykudmFsdWU7XG4gIHVwZGF0ZUJvdW5kc0Zyb21NaXRlcihib3VuZHMsIGVsZSwgYm9yZGVyT3BhY2l0eSwgYm9yZGVyV2lkdGgsIGJvcmRlclBvc2l0aW9uKTtcbn07XG5cbi8vIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50cyAoaW4gcmF3IG1vZGVsIHBvc2l0aW9uKVxudmFyIGJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW1wbChlbGUsIG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG4gIHZhciBoZWFkbGVzcyA9IGN5LmhlYWRsZXNzKCk7XG4gIHZhciBib3VuZHMgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgZXgxLCBleDIsIGV5MSwgZXkyOyAvLyBleHRyZW1hIG9mIGJvZHkgLyBsaW5lc1xuICB2YXIgeCwgeTsgLy8gbm9kZSBwb3NcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIG1hbnVhbEV4cGFuc2lvbiA9IGlzTm9kZSAmJiBzdHlsZUVuYWJsZWQgPyBlbGUucHN0eWxlKCdib3VuZHMtZXhwYW5zaW9uJykucGZWYWx1ZSA6IFswXTtcblxuICAvLyBtdXN0IHVzZSBgZGlzcGxheWAgcHJvcCBvbmx5LCBhcyByZWFkaW5nIGBjb21wb3VuZC53aWR0aCgpYCBjYXVzZXMgcmVjdXJzaW9uXG4gIC8vIChvdGhlciBmYWN0b3JzIGxpa2Ugd2lkdGggdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uIGFueXdheSlcbiAgdmFyIGlzRGlzcGxheWVkID0gZnVuY3Rpb24gaXNEaXNwbGF5ZWQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSAhPT0gJ25vbmUnO1xuICB9O1xuICB2YXIgZGlzcGxheWVkID0gIXN0eWxlRW5hYmxlZCB8fCBpc0Rpc3BsYXllZChlbGUpXG5cbiAgLy8gbXVzdCB0YWtlIGludG8gYWNjb3VudCBjb25uZWN0ZWQgbm9kZXMgYi9jIG9mIGltcGxpY2l0IGVkZ2UgaGlkaW5nIG9uIGRpc3BsYXk6bm9uZSBub2RlXG4gICYmICghaXNFZGdlIHx8IGlzRGlzcGxheWVkKGVsZS5zb3VyY2UoKSkgJiYgaXNEaXNwbGF5ZWQoZWxlLnRhcmdldCgpKSk7XG4gIGlmIChkaXNwbGF5ZWQpIHtcbiAgICAvLyBkaXNwbGF5ZWQgc3VmZmljZXMsIHNpbmNlIHdlIHdpbGwgZmluZCB6ZXJvIGFyZWEgZWxlcyBhbnl3YXlcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSAwO1xuICAgIHZhciBvdmVybGF5UGFkZGluZyA9IDA7XG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVPdmVybGF5cykge1xuICAgICAgb3ZlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCdvdmVybGF5LW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIGlmIChvdmVybGF5T3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBvdmVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoJ292ZXJsYXktcGFkZGluZycpLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW5kZXJsYXlPcGFjaXR5ID0gMDtcbiAgICB2YXIgdW5kZXJsYXlQYWRkaW5nID0gMDtcbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZVVuZGVybGF5cykge1xuICAgICAgdW5kZXJsYXlPcGFjaXR5ID0gZWxlLnBzdHlsZSgndW5kZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuICAgICAgaWYgKHVuZGVybGF5T3BhY2l0eSAhPT0gMCkge1xuICAgICAgICB1bmRlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCd1bmRlcmxheS1wYWRkaW5nJykudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwYWRkaW5nID0gTWF0aC5tYXgob3ZlcmxheVBhZGRpbmcsIHVuZGVybGF5UGFkZGluZyk7XG4gICAgdmFyIHcgPSAwO1xuICAgIHZhciB3SGFsZiA9IDA7XG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgdyA9IGVsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIHdIYWxmID0gdyAvIDI7XG4gICAgfVxuICAgIGlmIChpc05vZGUgJiYgb3B0aW9ucy5pbmNsdWRlTm9kZXMpIHtcbiAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgIHggPSBwb3MueDtcbiAgICAgIHkgPSBwb3MueTtcbiAgICAgIHZhciBfdyA9IGVsZS5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgaGFsZlcgPSBfdyAvIDI7XG4gICAgICB2YXIgaCA9IGVsZS5vdXRlckhlaWdodCgpO1xuICAgICAgdmFyIGhhbGZIID0gaCAvIDI7XG5cbiAgICAgIC8vIGhhbmRsZSBub2RlIGRpbWVuc2lvbnNcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgZXgxID0geCAtIGhhbGZXO1xuICAgICAgZXgyID0geCArIGhhbGZXO1xuICAgICAgZXkxID0geSAtIGhhbGZIO1xuICAgICAgZXkyID0geSArIGhhbGZIO1xuICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbU91dGxpbmUoYm91bmRzLCBlbGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVPdXRsaW5lcyAmJiAhaGVhZGxlc3MpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbU91dGxpbmUoYm91bmRzLCBlbGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTWl0ZXJCb3JkZXIoYm91bmRzLCBlbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNFZGdlICYmIG9wdGlvbnMuaW5jbHVkZUVkZ2VzKSB7XG4gICAgICBpZiAoc3R5bGVFbmFibGVkICYmICFoZWFkbGVzcykge1xuICAgICAgICB2YXIgY3VydmVTdHlsZSA9IGVsZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykuc3RyVmFsdWU7XG5cbiAgICAgICAgLy8gaGFuZGxlIGVkZ2UgZGltZW5zaW9ucyAocm91Z2ggYm94IGVzdGltYXRlKVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgZXgxID0gTWF0aC5taW4ocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV4MiA9IE1hdGgubWF4KHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFgpO1xuICAgICAgICBleTEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcbiAgICAgICAgZXkyID0gTWF0aC5tYXgocnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSk7XG5cbiAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG5cbiAgICAgICAgLy8gcHJlY2lzZSBlZGdlc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgICB2YXIgaHB0cyA9IHJzdHlsZS5oYXlzdGFja1B0cztcbiAgICAgICAgICBpZiAoaHB0cyAmJiBocHRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICAgICAgZXkxID0gaHB0c1swXS55O1xuICAgICAgICAgICAgZXgyID0gaHB0c1sxXS54O1xuICAgICAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuICAgICAgICAgICAgaWYgKGV4MSA+IGV4Mikge1xuICAgICAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgICAgICB2YXIgX3RlbXAgPSBleTE7XG4gICAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgICAgZXkyID0gX3RlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEgLSB3SGFsZiwgZXkxIC0gd0hhbGYsIGV4MiArIHdIYWxmLCBleTIgKyB3SGFsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnZlU3R5bGUgPT09ICdiZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBlbmRzV2l0aChjdXJ2ZVN0eWxlLCAnc2VnbWVudHMnKSB8fCBlbmRzV2l0aChjdXJ2ZVN0eWxlLCAndGF4aScpKSB7XG4gICAgICAgICAgdmFyIHB0cztcbiAgICAgICAgICBzd2l0Y2ggKGN1cnZlU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgICAgICBjYXNlICd1bmJ1bmRsZWQtYmV6aWVyJzpcbiAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmJlemllclB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICAgICAgICBjYXNlICd0YXhpJzpcbiAgICAgICAgICAgIGNhc2UgJ3JvdW5kLXNlZ21lbnRzJzpcbiAgICAgICAgICAgIGNhc2UgJ3JvdW5kLXRheGknOlxuICAgICAgICAgICAgICBwdHMgPSByc3R5bGUubGluZVB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIHB0ID0gcHRzW2pdO1xuICAgICAgICAgICAgICBleDEgPSBwdC54IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV4MiA9IHB0LnggKyB3SGFsZjtcbiAgICAgICAgICAgICAgZXkxID0gcHQueSAtIHdIYWxmO1xuICAgICAgICAgICAgICBleTIgPSBwdC55ICsgd0hhbGY7XG4gICAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGJlemllci1saWtlIG9yIHNlZ21lbnQtbGlrZSBlZGdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoZWFkbGVzcyBvciBzdHlsZSBkaXNhYmxlZFxuXG4gICAgICAgIC8vIGZhbGxiYWNrIG9uIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICB2YXIgbjEgPSBlbGUuc291cmNlKCk7XG4gICAgICAgIHZhciBuMXBvcyA9IG4xLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuMiA9IGVsZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG4ycG9zID0gbjIucG9zaXRpb24oKTtcbiAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgZXkyID0gbjJwb3MueTtcbiAgICAgICAgaWYgKGV4MSA+IGV4Mikge1xuICAgICAgICAgIHZhciBfdGVtcDIgPSBleDE7XG4gICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgIGV4MiA9IF90ZW1wMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXkxID4gZXkyKSB7XG4gICAgICAgICAgdmFyIF90ZW1wMyA9IGV5MTtcbiAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgZXkyID0gX3RlbXAzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICB9IC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG4gICAgfSAvLyBlZGdlc1xuXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgJiYgaXNFZGdlKSB7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtc291cmNlJyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtdGFyZ2V0Jyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdzb3VyY2UnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3RhcmdldCcpO1xuICAgIH1cblxuICAgIC8vIGdob3N0XG4gICAgLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHZhciBnaG9zdCA9IGVsZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuICAgICAgaWYgKGdob3N0KSB7XG4gICAgICAgIHZhciBneCA9IGVsZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICAgICAgdmFyIGd5ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBib3VuZHMueDEgKyBneCwgYm91bmRzLnkxICsgZ3ksIGJvdW5kcy54MiArIGd4LCBib3VuZHMueTIgKyBneSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuICAgIHZhciBiYkJvZHkgPSBfcC5ib2R5Qm91bmRzID0gX3AuYm9keUJvdW5kcyB8fCB7fTtcbiAgICBhc3NpZ25Cb3VuZGluZ0JveChiYkJvZHksIGJvdW5kcyk7XG4gICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYkJvZHksIG1hbnVhbEV4cGFuc2lvbik7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmJCb2R5LCAxKTsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuXG4gICAgLy8gb3ZlcmxheVxuICAgIC8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHBhZGRpbmcsIGV5MSAtIHBhZGRpbmcsIGV4MiArIHBhZGRpbmcsIGV5MiArIHBhZGRpbmcpO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcbiAgICB2YXIgYmJPdmVybGF5ID0gX3Aub3ZlcmxheUJvdW5kcyA9IF9wLm92ZXJsYXlCb3VuZHMgfHwge307XG4gICAgYXNzaWduQm91bmRpbmdCb3goYmJPdmVybGF5LCBib3VuZHMpO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJPdmVybGF5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiT3ZlcmxheSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcblxuICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBiYkxhYmVscyA9IF9wLmxhYmVsQm91bmRzID0gX3AubGFiZWxCb3VuZHMgfHwge307XG4gICAgaWYgKGJiTGFiZWxzLmFsbCAhPSBudWxsKSB7XG4gICAgICBjbGVhckJvdW5kaW5nQm94KGJiTGFiZWxzLmFsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJiTGFiZWxzLmFsbCA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIH1cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZVNvdXJjZUxhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG4gIH0gLy8gaWYgZGlzcGxheWVkXG5cbiAgYm91bmRzLngxID0gbm9uaW5mKGJvdW5kcy54MSk7XG4gIGJvdW5kcy55MSA9IG5vbmluZihib3VuZHMueTEpO1xuICBib3VuZHMueDIgPSBub25pbmYoYm91bmRzLngyKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKGJvdW5kcy55Mik7XG4gIGJvdW5kcy53ID0gbm9uaW5mKGJvdW5kcy54MiAtIGJvdW5kcy54MSk7XG4gIGJvdW5kcy5oID0gbm9uaW5mKGJvdW5kcy55MiAtIGJvdW5kcy55MSk7XG4gIGlmIChib3VuZHMudyA+IDAgJiYgYm91bmRzLmggPiAwICYmIGRpc3BsYXllZCkge1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYm91bmRzLCBtYW51YWxFeHBhbnNpb24pO1xuXG4gICAgLy8gZXhwYW5kIGJvdW5kcyBieSAxIGJlY2F1c2UgYW50aWFsaWFzaW5nIGNhbiBpbmNyZWFzZSB0aGUgdmlzdWFsL2VmZmVjdGl2ZSBzaXplIGJ5IDEgb24gYWxsIHNpZGVzXG4gICAgZXhwYW5kQm91bmRpbmdCb3goYm91bmRzLCAxKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufTtcbnZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkob3B0cykge1xuICB2YXIgaSA9IDA7XG4gIHZhciB0ZiA9IGZ1bmN0aW9uIHRmKHZhbCkge1xuICAgIHJldHVybiAodmFsID8gMSA6IDApIDw8IGkrKztcbiAgfTtcbiAgdmFyIGtleSA9IDA7XG4gIGtleSArPSB0ZihvcHRzLmluY3VkZU5vZGVzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUVkZ2VzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVNYWluTGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlT3ZlcmxheXMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlT3V0bGluZXMpO1xuICByZXR1cm4ga2V5O1xufTtcbnZhciBnZXRCb3VuZGluZ0JveFBvc0tleSA9IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSkge1xuICB2YXIgciA9IGZ1bmN0aW9uIHIoeCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHgpO1xuICB9O1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgdmFyIHAxID0gZWxlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gICAgdmFyIHAyID0gZWxlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG4gICAgcmV0dXJuIGhhc2hJbnRzQXJyYXkoW3IocDEueCksIHIocDEueSksIHIocDIueCksIHIocDIueSldKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcCA9IGVsZS5wb3NpdGlvbigpO1xuICAgIHJldHVybiBoYXNoSW50c0FycmF5KFtyKHAueCksIHIocC55KV0pO1xuICB9XG59O1xudmFyIGNhY2hlZEJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGNhY2hlZEJvdW5kaW5nQm94SW1wbChlbGUsIG9wdHMpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgYmI7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBrZXkgPSBvcHRzID09IG51bGwgPyBkZWZCYk9wdHNLZXkgOiBnZXRLZXkob3B0cyk7XG4gIHZhciB1c2luZ0RlZk9wdHMgPSBrZXkgPT09IGRlZkJiT3B0c0tleTtcbiAgaWYgKF9wLmJiQ2FjaGUgPT0gbnVsbCkge1xuICAgIGJiID0gYm91bmRpbmdCb3hJbXBsKGVsZSwgZGVmQmJPcHRzKTtcbiAgICBfcC5iYkNhY2hlID0gYmI7XG4gICAgX3AuYmJDYWNoZVBvc0tleSA9IGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSk7XG4gIH0gZWxzZSB7XG4gICAgYmIgPSBfcC5iYkNhY2hlO1xuICB9XG5cbiAgLy8gbm90IHVzaW5nIGRlZiBvcHRzID0+IG5lZWQgdG8gYnVpbGQgdXAgYmIgZnJvbSBjb21iaW5hdGlvbiBvZiBzdWIgYmJzXG4gIGlmICghdXNpbmdEZWZPcHRzKSB7XG4gICAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgICBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIGlmIChvcHRzLmluY2x1ZGVOb2RlcyAmJiBpc05vZGUgfHwgb3B0cy5pbmNsdWRlRWRnZXMgJiYgIWlzTm9kZSkge1xuICAgICAgaWYgKG9wdHMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLm92ZXJsYXlCb3VuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AuYm9keUJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRzLmluY2x1ZGVMYWJlbHMpIHtcbiAgICAgIGlmIChvcHRzLmluY2x1ZGVNYWluTGFiZWxzICYmICghaXNFZGdlIHx8IG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscyAmJiBvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLmFsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0cy5pbmNsdWRlTWFpbkxhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLm1haW5Sb3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICB9XG4gIHJldHVybiBiYjtcbn07XG52YXIgZGVmQmJPcHRzID0ge1xuICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gIGluY2x1ZGVFZGdlczogdHJ1ZSxcbiAgaW5jbHVkZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU1haW5MYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVTb3VyY2VMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVUYXJnZXRMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVPdmVybGF5czogdHJ1ZSxcbiAgaW5jbHVkZVVuZGVybGF5czogdHJ1ZSxcbiAgaW5jbHVkZU91dGxpbmVzOiB0cnVlLFxuICB1c2VDYWNoZTogdHJ1ZVxufTtcbnZhciBkZWZCYk9wdHNLZXkgPSBnZXRLZXkoZGVmQmJPcHRzKTtcbnZhciBmaWxsZWRCYk9wdHMgPSBkZWZhdWx0cyRnKGRlZkJiT3B0cyk7XG5lbGVzZm4kYi5ib3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBib3VuZHM7XG4gIHZhciB1c2VDYWNoZSA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdHJ1ZTtcbiAgdmFyIGlzRGlydHkgPSBtZW1vaXplKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgcmV0dXJuIF9wLmJiQ2FjaGUgPT0gbnVsbCB8fCBfcC5zdHlsZURpcnR5IHx8IF9wLmJiQ2FjaGVQb3NLZXkgIT09IGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSk7XG4gIH0sIGZ1bmN0aW9uIChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlkKCk7XG4gIH0pO1xuXG4gIC8vIHRoZSBtYWluIHVzZWNhc2UgaXMgZWxlLmJvdW5kaW5nQm94KCkgZm9yIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCBuby9kZWYgb3B0aW9uc1xuICAvLyBzcGVjaWZpZWQgcy50LiB0aGUgY2FjaGUgaXMgdXNlZCwgc28gY2hlY2sgZm9yIHRoaXMgY2FzZSB0byBtYWtlIGl0IGZhc3RlciBieVxuICAvLyBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIHJlc3Qgb2YgdGhlIGZ1bmN0aW9uXG4gIGlmICh1c2VDYWNoZSAmJiB0aGlzLmxlbmd0aCA9PT0gMSAmJiAhaXNEaXJ0eSh0aGlzWzBdKSkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZCYk9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgfVxuICAgIGJvdW5kcyA9IGNhY2hlZEJvdW5kaW5nQm94SW1wbCh0aGlzWzBdLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBib3VuZHMgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZCYk9wdHM7XG4gICAgdmFyIG9wdHMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG5cbiAgICAvLyBjYWNoZSB0aGUgaXNEaXJ0eSBzdGF0ZSBmb3IgYWxsIGVsZXMsIGVkZ2VzIGZpcnN0IHNpbmNlIHRoZXkgZGVwZW5kIG9uIG5vZGUgc3RhdGVcbiAgICB0aGlzLmVkZ2VzKCkuZm9yRWFjaChpc0RpcnR5KTtcbiAgICB0aGlzLm5vZGVzKCkuZm9yRWFjaChpc0RpcnR5KTtcbiAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoIXVzZUNhY2hlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgaWYgKGlzRGlydHkoZWxlKSkge1xuICAgICAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICB9XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJvdW5kcywgY2FjaGVkQm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0cykpO1xuICAgIH1cbiAgfVxuICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcbiAgcmV0dXJuIGJvdW5kcztcbn07XG5lbGVzZm4kYi5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfcCA9IHRoaXNbaV0uX3ByaXZhdGU7XG4gICAgX3AuYmJDYWNoZSA9IG51bGw7XG4gICAgX3AuYmJDYWNoZVBvc0tleSA9IG51bGw7XG4gICAgX3AuYm9keUJvdW5kcyA9IG51bGw7XG4gICAgX3Aub3ZlcmxheUJvdW5kcyA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMuYWxsID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2UgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMubWFpbiA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMuc291cmNlUm90ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLm1haW5Sb3QgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXNvdXJjZSddID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXRhcmdldCddID0gbnVsbDtcbiAgfVxuICB0aGlzLmVtaXRBbmROb3RpZnkoJ2JvdW5kcycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHByaXZhdGUgaGVscGVyIHRvIGdldCBib3VuZGluZyBib3ggZm9yIGN1c3RvbSBub2RlIHBvc2l0aW9uc1xuLy8gLSBnb29kIGZvciBwZXJmIGluIGNlcnRhaW4gY2FzZXMgYnV0IGN1cnJlbnRseSByZXF1aXJlcyBkaXJ0eWluZyB0aGUgcmVuZGVyZWQgc3R5bGVcbi8vIC0gd291bGQgYmUgYmV0dGVyIHRvIG5vdCBtb2RpZnkgdGhlIG5vZGVzIGJ1dCB0aGUgbm9kZXMgYXJlIHJlYWQgZGlyZWN0bHkgZXZlcnl3aGVyZSBpbiB0aGUgcmVuZGVyZXIuLi5cbi8vIC0gdHJ5IHRvIHVzZSBmb3Igb25seSB0aGluZ3MgbGlrZSBkaXNjcmV0ZSBsYXlvdXRzIHdoZXJlIHRoZSBub2RlIHBvc2l0aW9uIHdvdWxkIGNoYW5nZSBhbnl3YXlcbmVsZXNmbiRiLmJvdW5kaW5nQm94QXQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgcGFyZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICBwYXJlbnRzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pc1BhcmVudCgpO1xuICAgIH0pO1xuICAgIG5vZGVzID0gbm9kZXMubm90KHBhcmVudHMpO1xuICB9XG4gIGlmIChwbGFpbk9iamVjdChmbikpIHtcbiAgICB2YXIgb2JqID0gZm47XG4gICAgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfVxuICB2YXIgc3RvcmVPbGRQb3MgPSBmdW5jdGlvbiBzdG9yZU9sZFBvcyhub2RlLCBpKSB7XG4gICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuYmJBdE9sZFBvcyA9IGZuKG5vZGUsIGkpO1xuICB9O1xuICB2YXIgZ2V0T2xkUG9zID0gZnVuY3Rpb24gZ2V0T2xkUG9zKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zO1xuICB9O1xuICBjeS5zdGFydEJhdGNoKCk7XG4gIG5vZGVzLmZvckVhY2goc3RvcmVPbGRQb3MpLnNpbGVudFBvc2l0aW9ucyhmbik7XG4gIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgcGFyZW50cy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBwYXJlbnRzLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgIHBhcmVudHMudXBkYXRlQ29tcG91bmRCb3VuZHModHJ1ZSk7IC8vIGZvcmNlIHVwZGF0ZSBiL2Mgd2UncmUgaW5zaWRlIGEgYmF0Y2ggY3ljbGVcbiAgfVxuICB2YXIgYmIgPSBjb3B5Qm91bmRpbmdCb3godGhpcy5ib3VuZGluZ0JveCh7XG4gICAgdXNlQ2FjaGU6IGZhbHNlXG4gIH0pKTtcbiAgbm9kZXMuc2lsZW50UG9zaXRpb25zKGdldE9sZFBvcyk7XG4gIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgcGFyZW50cy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBwYXJlbnRzLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgIHBhcmVudHMudXBkYXRlQ29tcG91bmRCb3VuZHModHJ1ZSk7IC8vIGZvcmNlIHVwZGF0ZSBiL2Mgd2UncmUgaW5zaWRlIGEgYmF0Y2ggY3ljbGVcbiAgfVxuICBjeS5lbmRCYXRjaCgpO1xuICByZXR1cm4gYmI7XG59O1xuZm4kMy5ib3VuZGluZ2JveCA9IGZuJDMuYmIgPSBmbiQzLmJvdW5kaW5nQm94O1xuZm4kMy5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4kMy5yZW5kZXJlZEJvdW5kaW5nQm94O1xudmFyIGJvdW5kcyA9IGVsZXNmbiRiO1xuXG52YXIgZm4kMiwgZWxlc2ZuJGE7XG5mbiQyID0gZWxlc2ZuJGEgPSB7fTtcbnZhciBkZWZpbmVEaW1GbnMgPSBmdW5jdGlvbiBkZWZpbmVEaW1GbnMob3B0cykge1xuICBvcHRzLnVwcGVyY2FzZU5hbWUgPSBjYXBpdGFsaXplKG9wdHMubmFtZSk7XG4gIG9wdHMuYXV0b05hbWUgPSAnYXV0bycgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMubGFiZWxOYW1lID0gJ2xhYmVsJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5vdXRlck5hbWUgPSAnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSA9IGNhcGl0YWxpemUob3B0cy5vdXRlck5hbWUpO1xuICBmbiQyW29wdHMubmFtZV0gPSBmdW5jdGlvbiBkaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgcmV0dXJuIF9wW29wdHMuYXV0b05hbWVdIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSBlbGUucHN0eWxlKG9wdHMubmFtZSk7XG4gICAgICAgIHN3aXRjaCAoZC5zdHJWYWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgICAgIGVsZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoKTtcbiAgICAgICAgICAgIHJldHVybiBfcC5yc3R5bGVbb3B0cy5sYWJlbE5hbWVdIHx8IDA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZm4kMlsnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIG91dGVyRGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHZhciBkaW0gPSBlbGVbb3B0cy5uYW1lXSgpO1xuICAgICAgICB2YXIgYm9yZGVyUG9zID0gZWxlLnBzdHlsZSgnYm9yZGVyLXBvc2l0aW9uJykudmFsdWU7XG4gICAgICAgIHZhciBib3JkZXI7XG4gICAgICAgIGlmIChib3JkZXJQb3MgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgYm9yZGVyID0gZWxlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTsgLy8gbi5iLiAxLzIgZWFjaCBzaWRlXG4gICAgICAgIH0gZWxzZSBpZiAoYm9yZGVyUG9zID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICBib3JkZXIgPSAyICogZWxlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAnaW5zaWRlJ1xuICAgICAgICAgIGJvcmRlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZGRpbmcgPSAyICogZWxlLnBhZGRpbmcoKTtcbiAgICAgICAgcmV0dXJuIGRpbSArIGJvcmRlciArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZuJDJbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiByZW5kZXJlZERpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIGQgPSBlbGVbb3B0cy5uYW1lXSgpO1xuICAgICAgcmV0dXJuIGQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgIH1cbiAgfTtcbiAgZm4kMlsncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VPdXRlck5hbWVdID0gZnVuY3Rpb24gcmVuZGVyZWRPdXRlckRpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIG9kID0gZWxlW29wdHMub3V0ZXJOYW1lXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuZGVmaW5lRGltRm5zKHtcbiAgbmFtZTogJ3dpZHRoJ1xufSk7XG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnaGVpZ2h0J1xufSk7XG5lbGVzZm4kYS5wYWRkaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICBpZiAoX3AuYXV0b1BhZGRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9wLmF1dG9QYWRkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgfVxufTtcbmVsZXNmbiRhLnBhZGRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUuaGVpZ2h0KCkgKyAyICogZWxlLnBhZGRpbmcoKTtcbn07XG5lbGVzZm4kYS5wYWRkZWRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUud2lkdGgoKSArIDIgKiBlbGUucGFkZGluZygpO1xufTtcbnZhciB3aWR0aEhlaWdodCA9IGVsZXNmbiRhO1xuXG52YXIgaWZFZGdlID0gZnVuY3Rpb24gaWZFZGdlKGVsZSwgZ2V0VmFsdWUpIHtcbiAgaWYgKGVsZS5pc0VkZ2UoKSAmJiBlbGUudGFrZXNVcFNwYWNlKCkpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUoZWxlKTtcbiAgfVxufTtcbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbihlbGUsIGdldFBvaW50KSB7XG4gIGlmIChlbGUuaXNFZGdlKCkgJiYgZWxlLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgdmFyIGN5ID0gZWxlLmN5KCk7XG4gICAgcmV0dXJuIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uJDEoZ2V0UG9pbnQoZWxlKSwgY3kuem9vbSgpLCBjeS5wYW4oKSk7XG4gIH1cbn07XG52YXIgaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnMgPSBmdW5jdGlvbiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyhlbGUsIGdldFBvaW50cykge1xuICBpZiAoZWxlLmlzRWRnZSgpICYmIGVsZS50YWtlc1VwU3BhY2UoKSkge1xuICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICByZXR1cm4gZ2V0UG9pbnRzKGVsZSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24kMShwLCB6b29tLCBwYW4pO1xuICAgIH0pO1xuICB9XG59O1xudmFyIGNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiBjb250cm9sUG9pbnRzKGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0Q29udHJvbFBvaW50cyhlbGUpO1xufTtcbnZhciBzZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gc2VnbWVudFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNlZ21lbnRQb2ludHMoZWxlKTtcbn07XG52YXIgc291cmNlRW5kcG9pbnQgPSBmdW5jdGlvbiBzb3VyY2VFbmRwb2ludChlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNvdXJjZUVuZHBvaW50KGVsZSk7XG59O1xudmFyIHRhcmdldEVuZHBvaW50ID0gZnVuY3Rpb24gdGFyZ2V0RW5kcG9pbnQoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRUYXJnZXRFbmRwb2ludChlbGUpO1xufTtcbnZhciBtaWRwb2ludCA9IGZ1bmN0aW9uIG1pZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0RWRnZU1pZHBvaW50KGVsZSk7XG59O1xudmFyIHB0cyA9IHtcbiAgY29udHJvbFBvaW50czoge1xuICAgIGdldDogY29udHJvbFBvaW50cyxcbiAgICBtdWx0OiB0cnVlXG4gIH0sXG4gIHNlZ21lbnRQb2ludHM6IHtcbiAgICBnZXQ6IHNlZ21lbnRQb2ludHMsXG4gICAgbXVsdDogdHJ1ZVxuICB9LFxuICBzb3VyY2VFbmRwb2ludDoge1xuICAgIGdldDogc291cmNlRW5kcG9pbnRcbiAgfSxcbiAgdGFyZ2V0RW5kcG9pbnQ6IHtcbiAgICBnZXQ6IHRhcmdldEVuZHBvaW50XG4gIH0sXG4gIG1pZHBvaW50OiB7XG4gICAgZ2V0OiBtaWRwb2ludFxuICB9XG59O1xudmFyIHJlbmRlcmVkTmFtZSA9IGZ1bmN0aW9uIHJlbmRlcmVkTmFtZShuYW1lKSB7XG4gIHJldHVybiAncmVuZGVyZWQnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG59O1xudmFyIGVkZ2VQb2ludHMgPSBPYmplY3Qua2V5cyhwdHMpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gIHZhciBzcGVjID0gcHRzW25hbWVdO1xuICB2YXIgck5hbWUgPSByZW5kZXJlZE5hbWUobmFtZSk7XG4gIG9ialtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaWZFZGdlKHRoaXMsIHNwZWMuZ2V0KTtcbiAgfTtcbiAgaWYgKHNwZWMubXVsdCkge1xuICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnModGhpcywgc3BlYy5nZXQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb2JqW3JOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbnZhciBkaW1lbnNpb25zID0gZXh0ZW5kKHt9LCBwb3NpdGlvbiwgYm91bmRzLCB3aWR0aEhlaWdodCwgZWRnZVBvaW50cyk7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24gRXZlbnQoc3JjLCBwcm9wcykge1xuICB0aGlzLnJlY3ljbGUoc3JjLCBwcm9wcyk7XG59O1xuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnZXZlbnQnO1xuICB9LFxuICByZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHNyYywgcHJvcHMpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuRmFsc2U7XG4gICAgaWYgKHNyYyAhPSBudWxsICYmIHNyYy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgLy8gQnJvd3NlciBFdmVudCBvYmplY3RcbiAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnR5cGUpIHtcbiAgICAgIC8vIFBsYWluIG9iamVjdCBjb250YWluaW5nIGFsbCBldmVudCBkZXRhaWxzXG4gICAgICBwcm9wcyA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZlbnQgc3RyaW5nXG4gICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgfVxuXG4gICAgLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcbiAgICBpZiAocHJvcHMgIT0gbnVsbCkge1xuICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBwcm9wcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPSBudWxsID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICAgIHRoaXMuY3kgPSBwcm9wcy5jeTtcbiAgICAgIHRoaXMudGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICAgICAgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID0gcHJvcHMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmN5ICE9IG51bGwgJiYgdGhpcy5wb3NpdGlvbiAhPSBudWxsICYmIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gdGhpcy5jeS5wYW4oKTtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgIGlmICghZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgIGlmICghZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH0sXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG59O1xuXG52YXIgZXZlbnRSZWdleCA9IC9eKFteLl0rKShcXC4oPzpbXi5dKykpPyQvOyAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxudmFyIHVuaXZlcnNhbE5hbWVzcGFjZSA9ICcuKic7IC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG5cbnZhciBkZWZhdWx0cyQ4ID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHExLCBxMikge1xuICAgIHJldHVybiBxMSA9PT0gcTI7XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKC8qY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKi9cbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcygvKmNvbnRleHQsIGV2dCovXG4gICkge30sXG4gIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGNvbnRleHQgLyosIGxpc3RlbmVyLCBldmVudE9iaiovKSB7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0sXG4gIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uIGJlZm9yZUVtaXQoLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gICkge30sXG4gIGFmdGVyRW1pdDogZnVuY3Rpb24gYWZ0ZXJFbWl0KC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL1xuICApIHt9LFxuICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgvKmNvbnRleHQqL1xuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KC8qY29udGV4dCovXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBjb250ZXh0OiBudWxsXG59O1xudmFyIGRlZmF1bHRzS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzJDgpO1xudmFyIGVtcHR5T3B0cyA9IHt9O1xuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVtcHR5T3B0cztcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgLy8gbWljcm8tb3B0aW1pc2F0aW9uIHZzIE9iamVjdC5hc3NpZ24oKSAtLSByZWR1Y2VzIEVsZW1lbnQgaW5zdGFudGlhdGlvbiB0aW1lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmYXVsdHNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGRlZmF1bHRzS2V5c1tpXTtcbiAgICB0aGlzW2tleV0gPSBvcHRzW2tleV0gfHwgZGVmYXVsdHMkOFtrZXldO1xuICB9XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5jb250ZXh0O1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICB0aGlzLmVtaXR0aW5nID0gMDtcbn1cbnZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG52YXIgZm9yRWFjaEV2ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEV2ZW50KHNlbGYsIGhhbmRsZXIsIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICBpZiAoZm4kNihxdWFsaWZpZXIpKSB7XG4gICAgY2FsbGJhY2sgPSBxdWFsaWZpZXI7XG4gICAgcXVhbGlmaWVyID0gbnVsbDtcbiAgfVxuICBpZiAoY29uZk92ZXJyaWRlcykge1xuICAgIGlmIChjb25mID09IG51bGwpIHtcbiAgICAgIGNvbmYgPSBjb25mT3ZlcnJpZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25mID0gZXh0ZW5kKHt9LCBjb25mLCBjb25mT3ZlcnJpZGVzKTtcbiAgICB9XG4gIH1cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgcmV0ID0gaGFuZGxlcihzZWxmLCBldnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gYWxsb3cgZXhpdGluZyBlYXJseVxuICAgIH1cbiAgfVxufTtcbnZhciBtYWtlRXZlbnRPYmogPSBmdW5jdGlvbiBtYWtlRXZlbnRPYmooc2VsZiwgb2JqKSB7XG4gIHNlbGYuYWRkRXZlbnRGaWVsZHMoc2VsZi5jb250ZXh0LCBvYmopO1xuICByZXR1cm4gbmV3IEV2ZW50KG9iai50eXBlLCBvYmopO1xufTtcbnZhciBmb3JFYWNoRXZlbnRPYmogPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnRPYmooc2VsZiwgaGFuZGxlciwgZXZlbnRzKSB7XG4gIGlmIChldmVudChldmVudHMpKSB7XG4gICAgaGFuZGxlcihzZWxmLCBldmVudHMpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChldmVudHMpKSB7XG4gICAgaGFuZGxlcihzZWxmLCBtYWtlRXZlbnRPYmooc2VsZiwgZXZlbnRzKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBldmVudExpc3QgPSBhcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KC9cXHMrLyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV2dCA9IGV2ZW50TGlzdFtpXTtcbiAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaChldmVudFJlZ2V4KTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgdmFyIGV2ZW50T2JqID0gbWFrZUV2ZW50T2JqKHNlbGYsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgIHRhcmdldDogc2VsZi5jb250ZXh0XG4gICAgICB9KTtcbiAgICAgIGhhbmRsZXIoc2VsZiwgZXZlbnRPYmopO1xuICAgIH1cbiAgfVxufTtcbnAub24gPSBwLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICBmb3JFYWNoRXZlbnQodGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgICBpZiAoZm4kNihjYWxsYmFjaykpIHtcbiAgICAgIHNlbGYubGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIC8vIGZ1bGwgZXZlbnQgc3RyaW5nXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgLy8gY2FsbGJhY2sgdG8gcnVuXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICBxdWFsaWZpZXI6IHF1YWxpZmllcixcbiAgICAgICAgLy8gYSByZXN0cmljdGlvbiBvbiB3aGV0aGVyIHRvIG1hdGNoIHRoaXMgZW1pdHRlclxuICAgICAgICBjb25mOiBjb25mIC8vIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5wLm9uZSA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgcmV0dXJuIHRoaXMub24oZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCB7XG4gICAgb25lOiB0cnVlXG4gIH0pO1xufTtcbnAucmVtb3ZlTGlzdGVuZXIgPSBwLm9mZiA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgaWYgKHRoaXMuZW1pdHRpbmcgIT09IDApIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IGNvcHlBcnJheSh0aGlzLmxpc3RlbmVycyk7XG4gIH1cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgIGZvckVhY2hFdmVudChfdGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2sgLyosIGNvbmYqLykge1xuICAgICAgaWYgKChsaXN0ZW5lci50eXBlID09PSB0eXBlIHx8IGV2ZW50cyA9PT0gJyonKSAmJiAoIW5hbWVzcGFjZSAmJiBsaXN0ZW5lci5uYW1lc3BhY2UgIT09ICcuKicgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBuYW1lc3BhY2UpICYmICghcXVhbGlmaWVyIHx8IHNlbGYucXVhbGlmaWVyQ29tcGFyZShsaXN0ZW5lci5xdWFsaWZpZXIsIHF1YWxpZmllcikpICYmICghY2FsbGJhY2sgfHwgbGlzdGVuZXIuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIF9sb29wKGkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbnAucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcignKicpO1xufTtcbnAuZW1pdCA9IHAudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudHMsIGV4dHJhUGFyYW1zLCBtYW51YWxDYWxsYmFjaykge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG4gIHZhciBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgdGhpcy5lbWl0dGluZysrO1xuICBpZiAoIWFycmF5KGV4dHJhUGFyYW1zKSkge1xuICAgIGV4dHJhUGFyYW1zID0gW2V4dHJhUGFyYW1zXTtcbiAgfVxuICBmb3JFYWNoRXZlbnRPYmoodGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50T2JqKSB7XG4gICAgaWYgKG1hbnVhbENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgIGxpc3RlbmVycyA9IFt7XG4gICAgICAgIGV2ZW50OiBldmVudE9iai5ldmVudCxcbiAgICAgICAgdHlwZTogZXZlbnRPYmoudHlwZSxcbiAgICAgICAgbmFtZXNwYWNlOiBldmVudE9iai5uYW1lc3BhY2UsXG4gICAgICAgIGNhbGxiYWNrOiBtYW51YWxDYWxsYmFja1xuICAgICAgfV07XG4gICAgICBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGlmIChsaXN0ZW5lci50eXBlID09PSBldmVudE9iai50eXBlICYmICghbGlzdGVuZXIubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gZXZlbnRPYmoubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gdW5pdmVyc2FsTmFtZXNwYWNlKSAmJiBzZWxmLmV2ZW50TWF0Y2hlcyhzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaikpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbZXZlbnRPYmpdO1xuICAgICAgICBpZiAoZXh0cmFQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICAgIHB1c2goYXJncywgZXh0cmFQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYmVmb3JlRW1pdChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG4gICAgICAgIGlmIChsaXN0ZW5lci5jb25mICYmIGxpc3RlbmVyLmNvbmYub25lKSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcnMgPSBzZWxmLmxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IHNlbGYuY2FsbGJhY2tDb250ZXh0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgdmFyIHJldCA9IGxpc3RlbmVyLmNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBzZWxmLmFmdGVyRW1pdChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXZlbnRPYmouc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZXZlbnRPYmoucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiBsaXN0ZW5lciBtYXRjaGVzXG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUxpc3RlbmVyc0JlZm9yZUVtaXQ7IGkrKykge1xuICAgICAgX2xvb3AyKCk7XG4gICAgfSAvLyBmb3IgbGlzdGVuZXJcblxuICAgIGlmIChzZWxmLmJ1YmJsZShzZWxmLmNvbnRleHQpICYmICFldmVudE9iai5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICBzZWxmLnBhcmVudChzZWxmLmNvbnRleHQpLmVtaXQoZXZlbnRPYmosIGV4dHJhUGFyYW1zKTtcbiAgICB9XG4gIH0sIGV2ZW50cyk7XG4gIHRoaXMuZW1pdHRpbmctLTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgZW1pdHRlck9wdGlvbnMkMSA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcbiAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZSAhPT0gZXZlbnRPYmoudGFyZ2V0ICYmIGVsZW1lbnQoZXZlbnRPYmoudGFyZ2V0KSAmJiBzZWxlY3Rvci5tYXRjaGVzKGV2ZW50T2JqLnRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoZWxlLCBldnQpIHtcbiAgICBldnQuY3kgPSBlbGUuY3koKTtcbiAgICBldnQudGFyZ2V0ID0gZWxlO1xuICB9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGVsZTtcbiAgfSxcbiAgYmVmb3JlRW1pdDogZnVuY3Rpb24gYmVmb3JlRW1pdChjb250ZXh0LCBsaXN0ZW5lciAvKiwgZXZlbnRPYmoqLykge1xuICAgIGlmIChsaXN0ZW5lci5jb25mICYmIGxpc3RlbmVyLmNvbmYub25jZSkge1xuICAgICAgbGlzdGVuZXIuY29uZi5vbmNlQ29sbGVjdGlvbi5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lci5ldmVudCwgbGlzdGVuZXIucXVhbGlmaWVyLCBsaXN0ZW5lci5jYWxsYmFjayk7XG4gICAgfVxuICB9LFxuICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkKCkgPyBlbGUucGFyZW50KCkgOiBlbGUuY3koKTtcbiAgfVxufTtcbnZhciBhcmdTZWxlY3RvciQxID0gZnVuY3Rpb24gYXJnU2VsZWN0b3IoYXJnKSB7XG4gIGlmIChzdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0b3IoYXJnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG59O1xudmFyIGVsZXNmbiQ5ID0ge1xuICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zJDEsIGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gIH0sXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgb25jZUNvbGxlY3Rpb246IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGV4dHJhUGFyYW1zKSB7XG4gICAgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuXG4gICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgdGhpcy5jeSgpLm5vdGlmeShldmVudCwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuJDkpO1xuXG52YXIgZWxlc2ZuJDggPSB7XG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIC8vIGludGVybmFsIGhlbHBlciB0byBnZXQgbm9kZXMgYW5kIGVkZ2VzIGFzIHNlcGFyYXRlIGNvbGxlY3Rpb25zIHdpdGggc2luZ2xlIGl0ZXJhdGlvbiBvdmVyIGVsZW1lbnRzXG4gIGJ5R3JvdXA6IGZ1bmN0aW9uIGJ5R3JvdXAoKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub2Rlczogbm9kZXMsXG4gICAgICBlZGdlczogZWRnZXNcbiAgICB9O1xuICB9LFxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihfZmlsdGVyLCB0aGlzQXJnKSB7XG4gICAgaWYgKF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdGhpcyBmaXJzdCBiL2MgaXQncyB0aGUgbW9zdCBjb21tb24vcGVyZm9ybWFudCBjYXNlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhfZmlsdGVyKSB8fCBlbGVtZW50T3JDb2xsZWN0aW9uKF9maWx0ZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKF9maWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGZuJDYoX2ZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXJFbGVzID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBfZmlsdGVyLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IF9maWx0ZXIoZWxlLCBpLCBlbGVzKTtcbiAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICBmaWx0ZXJFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlckVsZXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKCk7IC8vIGlmIG5vdCBoYW5kbGVkIGJ5IGFib3ZlLCBnaXZlICdlbSBhbiBlbXB0eSBjb2xsZWN0aW9uXG4gIH0sXG4gIG5vdDogZnVuY3Rpb24gbm90KHRvUmVtb3ZlKSB7XG4gICAgaWYgKCF0b1JlbW92ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICAgIHRvUmVtb3ZlID0gdGhpcy5maWx0ZXIodG9SZW1vdmUpO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IHRvUmVtb3ZlLmhhcyhlbGVtZW50KTtcbiAgICAgICAgaWYgKCFyZW1vdmUpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICB9LFxuICBhYnNvbHV0ZUNvbXBsZW1lbnQ6IGZ1bmN0aW9uIGFic29sdXRlQ29tcGxlbWVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgcmV0dXJuIGN5Lm11dGFibGVFbGVtZW50cygpLm5vdCh0aGlzKTtcbiAgfSxcbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICB2YXIgY29sMVNtYWxsZXIgPSB0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aDtcbiAgICB2YXIgY29sUyA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG4gICAgdmFyIGNvbEwgPSBjb2wxU21hbGxlciA/IGNvbDIgOiBjb2wxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGNvbFNbaV07XG4gICAgICBpZiAoY29sTC5oYXMoZWxlKSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgeG9yOiBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcbiAgICAgICAgaWYgKCFpbk90aGVyKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhZGQoY29sMSwgY29sMik7XG4gICAgYWRkKGNvbDIsIGNvbDEpO1xuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgZGlmZjogZnVuY3Rpb24gZGlmZihvdGhlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgfVxuICAgIHZhciBsZWZ0ID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciByaWdodCA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgYm90aCA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGNvbCwgb3RoZXIsIHJldEVsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICAgICAgICBpZiAoaW5PdGhlcikge1xuICAgICAgICAgIGJvdGgubWVyZ2UoZWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgYWRkKGNvbDEsIGNvbDIsIGxlZnQpO1xuICAgIGFkZChjb2wyLCBjb2wxLCByaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICByaWdodDogcmlnaHQsXG4gICAgICBib3RoOiBib3RoXG4gICAgfTtcbiAgfSxcbiAgYWRkOiBmdW5jdGlvbiBhZGQodG9BZGQpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIGlmICghdG9BZGQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nKHRvQWRkKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd25TZWxmKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRvQWRkW2ldO1xuICAgICAgdmFyIGFkZCA9ICF0aGlzLmhhcyhlbGUpO1xuICAgICAgaWYgKGFkZCkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgLy8gaW4gcGxhY2UgbWVyZ2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIG1lcmdlOiBmdW5jdGlvbiBtZXJnZSh0b0FkZCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgaWYgKCF0b0FkZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0b0FkZCAmJiBzdHJpbmcodG9BZGQpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFtpXTtcbiAgICAgIHZhciBpZCA9IHRvQWRkRWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgYWRkID0gIW1hcC5oYXMoaWQpO1xuICAgICAgaWYgKGFkZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB0aGlzW2luZGV4XSA9IHRvQWRkRWxlO1xuICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgZWxlOiB0b0FkZEVsZSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1bm1lcmdlQXQ6IGZ1bmN0aW9uIHVubWVyZ2VBdChpKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgbWFwID0gX3AubWFwO1xuXG4gICAgLy8gcmVtb3ZlIGVsZVxuICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgbWFwW1wiZGVsZXRlXCJdKGlkKTtcbiAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgLy8gcmVwbGFjZSBlbXB0eSBzcG90IHdpdGggbGFzdCBlbGUgaW4gY29sbGVjdGlvblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEgJiYgIXVubWVyZ2VkTGFzdEVsZSkge1xuICAgICAgdmFyIGxhc3RFbGVJID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3RFbGUgPSB0aGlzW2xhc3RFbGVJXTtcbiAgICAgIHZhciBsYXN0RWxlSWQgPSBsYXN0RWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB0aGlzW2xhc3RFbGVJXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXNbaV0gPSBsYXN0RWxlO1xuICAgICAgbWFwLnNldChsYXN0RWxlSWQsIHtcbiAgICAgICAgZWxlOiBsYXN0RWxlLFxuICAgICAgICBpbmRleDogaVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcbiAgICB0aGlzLmxlbmd0aC0tO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyByZW1vdmUgc2luZ2xlIGVsZSBpbiBwbGFjZSBpbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZU9uZTogZnVuY3Rpb24gdW5tZXJnZU9uZShlbGUpIHtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICB2YXIgbWFwID0gX3AubWFwO1xuICAgIHZhciBlbnRyeSA9IG1hcC5nZXQoaWQpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgIH1cbiAgICB2YXIgaSA9IGVudHJ5LmluZGV4O1xuICAgIHRoaXMudW5tZXJnZUF0KGkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyByZW1vdmUgZWxlcyBpbiBwbGFjZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZTogZnVuY3Rpb24gdW5tZXJnZSh0b1JlbW92ZSkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKCF0b1JlbW92ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0b1JlbW92ZSAmJiBzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgIHRvUmVtb3ZlID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy51bm1lcmdlT25lKHRvUmVtb3ZlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVubWVyZ2VCeTogZnVuY3Rpb24gdW5tZXJnZUJ5KHRvUm1Gbikge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGlmICh0b1JtRm4oZWxlKSkge1xuICAgICAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1hcDogZnVuY3Rpb24gbWFwKG1hcEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBtYXBGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBtYXBGbihlbGUsIGksIGVsZXMpO1xuICAgICAgYXJyLnB1c2gocmV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciB2YWwgPSBpbml0aWFsVmFsdWU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsID0gZm4odmFsLCBlbGVzW2ldLCBpLCBlbGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiBtYXgodmFsRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhFbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG4gICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgbWF4RWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1heCxcbiAgICAgIGVsZTogbWF4RWxlXG4gICAgfTtcbiAgfSxcbiAgbWluOiBmdW5jdGlvbiBtaW4odmFsRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkVsZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgIGlmICh2YWwgPCBtaW4pIHtcbiAgICAgICAgbWluID0gdmFsO1xuICAgICAgICBtaW5FbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWluLFxuICAgICAgZWxlOiBtaW5FbGVcbiAgICB9O1xuICB9XG59O1xuXG4vLyBhbGlhc2VzXG52YXIgZm4kMSA9IGVsZXNmbiQ4O1xuZm4kMVsndSddID0gZm4kMVsnfCddID0gZm4kMVsnKyddID0gZm4kMS51bmlvbiA9IGZuJDEub3IgPSBmbiQxLmFkZDtcbmZuJDFbJ1xcXFwnXSA9IGZuJDFbJyEnXSA9IGZuJDFbJy0nXSA9IGZuJDEuZGlmZmVyZW5jZSA9IGZuJDEucmVsYXRpdmVDb21wbGVtZW50ID0gZm4kMS5zdWJ0cmFjdCA9IGZuJDEubm90O1xuZm4kMVsnbiddID0gZm4kMVsnJiddID0gZm4kMVsnLiddID0gZm4kMS5hbmQgPSBmbiQxLmludGVyc2VjdGlvbiA9IGZuJDEuaW50ZXJzZWN0O1xuZm4kMVsnXiddID0gZm4kMVsnKCspJ10gPSBmbiQxWycoLSknXSA9IGZuJDEuc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuJDEuc3ltZGlmZiA9IGZuJDEueG9yO1xuZm4kMS5mbkZpbHRlciA9IGZuJDEuZmlsdGVyRm4gPSBmbiQxLnN0ZEZpbHRlciA9IGZuJDEuZmlsdGVyO1xuZm4kMS5jb21wbGVtZW50ID0gZm4kMS5hYnNjb21wID0gZm4kMS5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbnZhciBlbGVzZm4kNyA9IHtcbiAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgfSxcbiAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgfSxcbiAgaXNMb29wOiBmdW5jdGlvbiBpc0xvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSA9PT0gdGhpcy50YXJnZXQoKVswXTtcbiAgfSxcbiAgaXNTaW1wbGU6IGZ1bmN0aW9uIGlzU2ltcGxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKClbMF0gIT09IHRoaXMudGFyZ2V0KClbMF07XG4gIH0sXG4gIGdyb3VwOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyb3VwO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiAgRWxlbWVudHMgYXJlIGRyYXduIGluIGEgc3BlY2lmaWMgb3JkZXIgYmFzZWQgb24gY29tcG91bmQgZGVwdGggKGxvdyB0byBoaWdoKSwgdGhlIGVsZW1lbnQgdHlwZSAobm9kZXMgYWJvdmUgZWRnZXMpLFxuICogIGFuZCB6LWluZGV4IChsb3cgdG8gaGlnaCkuICBUaGVzZSBzdHlsZXMgYWZmZWN0IGhvdyB0aGlzIGFwcGxpZXM6XG4gKlxuICogIHotY29tcG91bmQtZGVwdGg6IE1heSBiZSBgYm90dG9tIHwgb3JwaGFuIHwgYXV0byB8IHRvcGAuICBUaGUgZmlyc3QgZHJhd24gaXMgYGJvdHRvbWAsIHRoZW4gYG9ycGhhbmAgd2hpY2ggaXMgdGhlXG4gKiAgICAgIHNhbWUgZGVwdGggYXMgdGhlIHJvb3Qgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLCBmb2xsb3dlZCBieSB0aGUgZGVmYXVsdCB2YWx1ZSBgYXV0b2Agd2hpY2ggZHJhd3MgaW4gb3JkZXIgZnJvbVxuICogICAgICByb290IHRvIGxlYXZlcyBvZiB0aGUgY29tcG91bmQgZ3JhcGguICBUaGUgbGFzdCBkcmF3biBpcyBgdG9wYC5cbiAqICB6LWluZGV4LWNvbXBhcmU6IE1heSBiZSBgYXV0byB8IG1hbnVhbGAuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgYXV0b2Agd2hpY2ggYWx3YXlzIGRyYXdzIGVkZ2VzIHVuZGVyIG5vZGVzLlxuICogICAgICBgbWFudWFsYCBpZ25vcmVzIHRoaXMgY29udmVudGlvbiBhbmQgZHJhd3MgYmFzZWQgb24gdGhlIGB6LWluZGV4YCB2YWx1ZSBzZXR0aW5nLlxuICogIHotaW5kZXg6IEFuIGludGVnZXIgdmFsdWUgdGhhdCBhZmZlY3RzIHRoZSByZWxhdGl2ZSBkcmF3IG9yZGVyIG9mIGVsZW1lbnRzLiAgSW4gZ2VuZXJhbCwgYW4gZWxlbWVudCB3aXRoIGEgaGlnaGVyXG4gKiAgICAgIGB6LWluZGV4YCB3aWxsIGJlIGRyYXduIG9uIHRvcCBvZiBhbiBlbGVtZW50IHdpdGggYSBsb3dlciBgei1pbmRleGAuXG4gKi9cbnZhciB6SW5kZXhTb3J0ID0gZnVuY3Rpb24gekluZGV4U29ydChhLCBiKSB7XG4gIHZhciBjeSA9IGEuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIGZ1bmN0aW9uIGdldERlcHRoKGVsZSkge1xuICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKTtcbiAgICBpZiAoc3R5bGUudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuIGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUuekRlcHRoKCkgOiAwO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUudmFsdWUgPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiBNQVhfSU5UJDE7XG4gICAgfVxuICAgIC8vICdvcnBoYW4nXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIGRlcHRoRGlmZiA9IGdldERlcHRoKGEpIC0gZ2V0RGVwdGgoYik7XG4gIGlmIChkZXB0aERpZmYgIT09IDApIHtcbiAgICByZXR1cm4gZGVwdGhEaWZmO1xuICB9XG4gIGZ1bmN0aW9uIGdldEVsZURlcHRoKGVsZSkge1xuICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoJ3otaW5kZXgtY29tcGFyZScpO1xuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpID8gMSA6IDA7XG4gICAgfVxuICAgIC8vICdtYW51YWwnXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIGVsZURpZmYgPSBnZXRFbGVEZXB0aChhKSAtIGdldEVsZURlcHRoKGIpO1xuICBpZiAoZWxlRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBlbGVEaWZmO1xuICB9XG4gIHZhciB6RGlmZiA9IGEucHN0eWxlKCd6LWluZGV4JykudmFsdWUgLSBiLnBzdHlsZSgnei1pbmRleCcpLnZhbHVlO1xuICBpZiAoekRpZmYgIT09IDApIHtcbiAgICByZXR1cm4gekRpZmY7XG4gIH1cbiAgLy8gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcbiAgcmV0dXJuIGEucG9vbEluZGV4KCkgLSBiLnBvb2xJbmRleCgpO1xufTtcblxudmFyIGVsZXNmbiQ2ID0ge1xuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgaWYgKGZuJDYoZm4pKSB7XG4gICAgICB2YXIgTiA9IHRoaXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gZm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgdGhpc10pIDogZm4oZWxlLCBpLCB0aGlzKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciB0aGlzU2l6ZSA9IHRoaXMubGVuZ3RoO1xuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gdGhpc1NpemU7XG4gICAgfVxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICB9XG4gICAgaWYgKGVuZCA8IDApIHtcbiAgICAgIGVuZCA9IHRoaXNTaXplICsgZW5kO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihhcnJheSk7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9LFxuICBlcTogZnVuY3Rpb24gZXEoaSkge1xuICAgIHJldHVybiB0aGlzW2ldIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzWzBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgfSxcbiAgbm9uZW1wdHk6IGZ1bmN0aW9uIG5vbmVtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lbXB0eSgpO1xuICB9LFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KHNvcnRGbikge1xuICAgIGlmICghZm4kNihzb3J0Rm4pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHNvcnRlZCA9IHRoaXMudG9BcnJheSgpLnNvcnQoc29ydEZuKTtcbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3J0ZWQpO1xuICB9LFxuICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uIHNvcnRCeVpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0KHpJbmRleFNvcnQpO1xuICB9LFxuICB6RGVwdGg6IGZ1bmN0aW9uIHpEZXB0aCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoIWVsZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBsZXQgY3kgPSBlbGUuY3koKTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGdyb3VwID0gX3AuZ3JvdXA7XG4gICAgaWYgKGdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICB2YXIgZGVwdGggPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcbiAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9JTlQkMSAtIDE7IC8vIGNoaWxkbGVzcyBub2RlcyBhbHdheXMgb24gdG9wXG4gICAgICB9XG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHNyY0RlcHRoLCB0Z3REZXB0aCwgMCk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgfVxuICB9XG59O1xuZWxlc2ZuJDYuZWFjaCA9IGVsZXNmbiQ2LmZvckVhY2g7XG52YXIgZGVmaW5lU3ltYm9sSXRlcmF0b3IgPSBmdW5jdGlvbiBkZWZpbmVTeW1ib2xJdGVyYXRvcigpIHtcbiAgdmFyIHR5cGVvZlVuZGVmID0gXCJ1bmRlZmluZWRcIiA7XG4gIHZhciBpc0l0ZXJhdG9yU3VwcG9ydGVkID0gKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihTeW1ib2wpKSAhPSB0eXBlb2ZVbmRlZiAmJiBfdHlwZW9mKFN5bWJvbC5pdGVyYXRvcikgIT0gdHlwZW9mVW5kZWY7XG4gIGlmIChpc0l0ZXJhdG9yU3VwcG9ydGVkKSB7XG4gICAgZWxlc2ZuJDZbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSQxKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgZW50cnkudmFsdWUgPSBfdGhpc1tpKytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH1cbiAgICAgIH0sIFN5bWJvbC5pdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn07XG5kZWZpbmVTeW1ib2xJdGVyYXRvcigpO1xuXG52YXIgZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyA9IGRlZmF1bHRzJGcoe1xuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kNSA9IHtcbiAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBub2RlIGRpbWVuc2lvbnMgeyB4LCB5IH0gYmFzZWQgb24gb3B0aW9ucyBnaXZlblxuICBsYXlvdXREaW1lbnNpb25zOiBmdW5jdGlvbiBsYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgZGltcztcbiAgICBpZiAoIXRoaXMudGFrZXNVcFNwYWNlKCkpIHtcbiAgICAgIGRpbXMgPSB7XG4gICAgICAgIHc6IDAsXG4gICAgICAgIGg6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscykge1xuICAgICAgdmFyIGJiRGltID0gdGhpcy5ib3VuZGluZ0JveCgpO1xuICAgICAgZGltcyA9IHtcbiAgICAgICAgdzogYmJEaW0udyxcbiAgICAgICAgaDogYmJEaW0uaFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGltcyA9IHtcbiAgICAgICAgdzogdGhpcy5vdXRlcldpZHRoKCksXG4gICAgICAgIGg6IHRoaXMub3V0ZXJIZWlnaHQoKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBzYW5pdGlzZSB0aGUgZGltZW5zaW9ucyBmb3IgZXh0ZXJuYWwgbGF5b3V0cyAoYXZvaWQgZGl2aXNpb24gYnkgemVybylcbiAgICBpZiAoZGltcy53ID09PSAwIHx8IGRpbXMuaCA9PT0gMCkge1xuICAgICAgZGltcy53ID0gZGltcy5oID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbXM7XG4gIH0sXG4gIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgbGF5b3V0UG9zaXRpb25zOiBmdW5jdGlvbiBsYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBmbikge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiAhbi5pc1BhcmVudCgpO1xuICAgIH0pO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbGF5b3V0RWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gbm9kZXMgJiBlZGdlc1xuICAgIHZhciBnZXRNZW1vaXplS2V5ID0gZnVuY3Rpb24gZ2V0TWVtb2l6ZUtleShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pZCgpO1xuICAgIH07XG4gICAgdmFyIGZuTWVtID0gbWVtb2l6ZShmbiwgZ2V0TWVtb2l6ZUtleSk7IC8vIG1lbW9pemVkIHZlcnNpb24gb2YgcG9zaXRpb24gZnVuY3Rpb25cblxuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICBsYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICAgIGxheW91dC5hbmltYXRpb25zID0gW107XG4gICAgdmFyIGNhbGN1bGF0ZVNwYWNpbmcgPSBmdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIG5vZGVzQmIsIHBvcykge1xuICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgeDogbm9kZXNCYi54MSArIG5vZGVzQmIudyAvIDIsXG4gICAgICAgIHk6IG5vZGVzQmIueTEgKyBub2Rlc0JiLmggLyAyXG4gICAgICB9O1xuICAgICAgdmFyIHNwYWNpbmdWZWN0b3IgPSB7XG4gICAgICAgIC8vIHNjYWxlIGZyb20gY2VudGVyIG9mIGJvdW5kaW5nIGJveCAobm90IG5lY2Vzc2FyaWx5IDAsMClcbiAgICAgICAgeDogKHBvcy54IC0gY2VudGVyLngpICogc3BhY2luZyxcbiAgICAgICAgeTogKHBvcy55IC0gY2VudGVyLnkpICogc3BhY2luZ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgc3BhY2luZ1ZlY3Rvci54LFxuICAgICAgICB5OiBjZW50ZXIueSArIHNwYWNpbmdWZWN0b3IueVxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciB1c2VTcGFjaW5nRmFjdG9yID0gb3B0aW9ucy5zcGFjaW5nRmFjdG9yICYmIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAhPT0gMTtcbiAgICB2YXIgc3BhY2luZ0JiID0gZnVuY3Rpb24gc3BhY2luZ0JiKCkge1xuICAgICAgaWYgKCF1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBmbk1lbShub2RlLCBpKTtcbiAgICAgICAgZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCBwb3MueCwgcG9zLnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG4gICAgdmFyIGJiID0gc3BhY2luZ0JiKCk7XG4gICAgdmFyIGdldEZpbmFsUG9zID0gbWVtb2l6ZShmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgdmFyIG5ld1BvcyA9IGZuTWVtKG5vZGUsIGkpO1xuICAgICAgaWYgKHVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyhvcHRpb25zLnNwYWNpbmdGYWN0b3IpO1xuICAgICAgICBuZXdQb3MgPSBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIGJiLCBuZXdQb3MpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICAgICAgbmV3UG9zID0gb3B0aW9ucy50cmFuc2Zvcm0obm9kZSwgbmV3UG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgfSwgZ2V0TWVtb2l6ZUtleSk7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgbmV3UG9zID0gZ2V0RmluYWxQb3Mobm9kZSwgaSk7XG4gICAgICAgIHZhciBhbmltYXRlTm9kZSA9IG9wdGlvbnMuYW5pbWF0ZUZpbHRlciA9PSBudWxsIHx8IG9wdGlvbnMuYW5pbWF0ZUZpbHRlcihub2RlLCBpKTtcbiAgICAgICAgaWYgKGFuaW1hdGVOb2RlKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGFuaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgdmFyIGZpdEFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgZml0OiB7XG4gICAgICAgICAgICBib3VuZGluZ0JveDogbGF5b3V0RWxlcy5ib3VuZGluZ0JveEF0KGdldEZpbmFsUG9zKSxcbiAgICAgICAgICAgIHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9KTtcbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaChmaXRBbmkpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnBhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB6b29tUGFuQW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICB6b29tOiBvcHRpb25zLnpvb20sXG4gICAgICAgICAgcGFuOiBvcHRpb25zLnBhbixcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKHpvb21QYW5BbmkpO1xuICAgICAgfVxuICAgICAgbGF5b3V0LmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucGxheSgpO1xuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBQcm9taXNlJDEuYWxsKGxheW91dC5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucHJvbWlzZSgpO1xuICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5wb3NpdGlvbnMoZ2V0RmluYWxQb3MpO1xuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy56b29tICE9IG51bGwpIHtcbiAgICAgICAgY3kuem9vbShvcHRpb25zLnpvb20pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucGFuKSB7XG4gICAgICAgIGN5LnBhbihvcHRpb25zLnBhbik7XG4gICAgICB9XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHJldHVybiBjeS5tYWtlTGF5b3V0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgZWxlczogdGhpc1xuICAgIH0pKTtcbiAgfVxufTtcblxuLy8gYWxpYXNlczpcbmVsZXNmbiQ1LmNyZWF0ZUxheW91dCA9IGVsZXNmbiQ1Lm1ha2VMYXlvdXQgPSBlbGVzZm4kNS5sYXlvdXQ7XG5cbmZ1bmN0aW9uIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGNhY2hlID0gX3Auc3R5bGVDYWNoZSA9IF9wLnN0eWxlQ2FjaGUgfHwgW107XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gY2FjaGVba2V5XSkgIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gY2FjaGVba2V5XSA9IGZuKGVsZSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuZnVuY3Rpb24gY2FjaGVTdHlsZUZ1bmN0aW9uKGtleSwgZm4pIHtcbiAga2V5ID0gaGFzaFN0cmluZyhrZXkpO1xuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkU3R5bGVGdW5jdGlvbihlbGUpIHtcbiAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIGZuLCBlbGUpO1xuICB9O1xufVxuZnVuY3Rpb24gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKGtleSwgZm4pIHtcbiAga2V5ID0gaGFzaFN0cmluZyhrZXkpO1xuICB2YXIgc2VsZkZuID0gZnVuY3Rpb24gc2VsZkZuKGVsZSkge1xuICAgIHJldHVybiBmbi5jYWxsKGVsZSk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiBjYWNoZWRQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgc2VsZkZuLCBlbGUpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBlbGVzZm4kNCA9IHtcbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG4gICAgaWYgKHJlbmRlcmVyICYmIHN0eWxlRW5hYmxlZCkge1xuICAgICAgcmVuZGVyZXIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHRoaXMsIHVzZUNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRpcnR5U3R5bGVDYWNoZTogZnVuY3Rpb24gZGlydHlTdHlsZUNhY2hlKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgZGlydHkgPSBmdW5jdGlvbiBkaXJ0eShlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgfTtcbiAgICBpZiAoY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICB2YXIgZWxlcztcbiAgICAgIGVsZXMgPSB0aGlzLnNwYXduU2VsZigpLm1lcmdlKHRoaXMuZGVzY2VuZGFudHMoKSkubWVyZ2UodGhpcy5wYXJlbnRzKCkpO1xuICAgICAgZWxlcy5tZXJnZShlbGVzLmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgZWxlcy5mb3JFYWNoKGRpcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgZGlydHkoZWxlKTtcbiAgICAgICAgZWxlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChkaXJ0eSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGZ1bGx5IHVwZGF0ZXMgKHJlY2FsY3VsYXRlcykgdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudHNcbiAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGN5LmJhdGNoaW5nKCkpIHtcbiAgICAgIHZhciBiRWxlcyA9IGN5Ll9wcml2YXRlLmJhdGNoU3R5bGVFbGVzO1xuICAgICAgYkVsZXMubWVyZ2UodGhpcyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmcgYW5kIGV4aXQgZWFybHkgd2hlbiBiYXRjaGluZ1xuICAgIH1cbiAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXM7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIC8vIHRoZW4gYWRkIGV2ZXJ5dGhpbmcgdXAgYW5kIGRvd24gZm9yIGNvbXBvdW5kIHNlbGVjdG9yIGNoZWNrc1xuICAgICAgdXBkYXRlZEVsZXMgPSB0aGlzLnNwYXduU2VsZigpLm1lcmdlKHRoaXMuZGVzY2VuZGFudHMoKSkubWVyZ2UodGhpcy5wYXJlbnRzKCkpO1xuICAgIH1cblxuICAgIC8vIGxldCBjaGFuZ2VkRWxlcyA9IHN0eWxlLmFwcGx5KCB1cGRhdGVkRWxlcyApO1xuICAgIHZhciBjaGFuZ2VkRWxlcyA9IHVwZGF0ZWRFbGVzO1xuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgY2hhbmdlZEVsZXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2VkRWxlcy5lbWl0KCdzdHlsZScpOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgfVxuICAgIHVwZGF0ZWRFbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgLy8gcHJpdmF0ZTogY2xlYXJzIGRpcnR5IGZsYWcgYW5kIHJlY2FsY3VsYXRlcyBzdHlsZVxuICBjbGVhblN0eWxlOiBmdW5jdGlvbiBjbGVhblN0eWxlKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBpZiAoZWxlLl9wcml2YXRlLnN0eWxlRGlydHkpIHtcbiAgICAgICAgLy8gbi5iLiB0aGlzIGZsYWcgc2hvdWxkIGJlIHNldCBiZWZvcmUgYXBwbHkoKSB0byBhdm9pZCBwb3RlbnRpYWwgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gZmFsc2U7XG4gICAgICAgIGN5LnN0eWxlKCkuYXBwbHkoZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIGdldCB0aGUgaW50ZXJuYWwgcGFyc2VkIHN0eWxlIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICBwYXJzZWRTdHlsZTogZnVuY3Rpb24gcGFyc2VkU3R5bGUocHJvcGVydHkpIHtcbiAgICB2YXIgaW5jbHVkZU5vbkRlZmF1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gZWxlLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlKSB7XG4gICAgICAvLyB0aGlzLmNsZWFuU3R5bGUoKTtcblxuICAgICAgLy8gSW5saW5lIHRoZSBpbXBvcnRhbnQgcGFydCBvZiBjbGVhblN0eWxlKCksIGZvciByYXcgcGVyZm9ybWFuY2VcbiAgICAgIGlmIChlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSkge1xuICAgICAgICAvLyBuLmIuIHRoaXMgZmxhZyBzaG91bGQgYmUgc2V0IGJlZm9yZSBhcHBseSgpIHRvIGF2b2lkIHBvdGVudGlhbCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgZWxlLl9wcml2YXRlLnN0eWxlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY3kuc3R5bGUoKS5hcHBseShlbGUpO1xuICAgICAgfVxuICAgICAgdmFyIG92ZXJyaWRkZW5TdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtwcm9wZXJ0eV07XG4gICAgICBpZiAob3ZlcnJpZGRlblN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRkZW5TdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU5vbkRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbnVtZXJpY1N0eWxlOiBmdW5jdGlvbiBudW1lcmljU3R5bGUocHJvcGVydHkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KTtcbiAgICAgIHJldHVybiBwc3R5bGUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkID8gcHN0eWxlLnBmVmFsdWUgOiBwc3R5bGUudmFsdWU7XG4gICAgfVxuICB9LFxuICBudW1lcmljU3R5bGVVbml0czogZnVuY3Rpb24gbnVtZXJpY1N0eWxlVW5pdHMocHJvcGVydHkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKHByb3BlcnR5KS51bml0cztcbiAgICB9XG4gIH0sXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgcmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVuZGVyZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZShlbGUsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0sXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBzZXQgdGhlIGJ5cGFzcyB3aXRoIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyh0aGlzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfZWxlID0gdGhpc1swXTtcbiAgICAgIGlmIChfZWxlKSB7XG4gICAgICAgIHJldHVybiBzdHlsZS5nZXRSYXdTdHlsZShfZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICByZW1vdmVTdHlsZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGUobmFtZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHN0eWxlLnJlbW92ZUFsbEJ5cGFzc2VzKGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9lbGUyID0gZWxlc1tfaV07XG4gICAgICAgIHN0eWxlLnJlbW92ZUJ5cGFzc2VzKF9lbGUyLCBuYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmNzcygnZGlzcGxheScsICdlbGVtZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbiBlZmZlY3RpdmVPcGFjaXR5KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50cyA9ICFfcC5kYXRhLnBhcmVudCA/IG51bGwgOiBlbGUucGFyZW50cygpO1xuICAgICAgaWYgKHBhcmVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgdmFyIG9wYWNpdHkgPSBwYXJlbnQucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG4gICAgICAgICAgcGFyZW50T3BhY2l0eSA9IG9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICB9XG4gIH0sXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbiB0cmFuc3BhcmVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGVsZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA9PT0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24gYmFja2dyb3VuZGluZygpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJhY2tncm91bmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gIH1cbn07XG5mdW5jdGlvbiBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGFyZW50cyA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG4gIGlmIChwYXJlbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgIGlmICghcGFyZW50T2socGFyZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oc3BlY3MpIHtcbiAgdmFyIG9rID0gc3BlY3Mub2s7XG4gIHZhciBlZGdlT2tWaWFOb2RlID0gc3BlY3MuZWRnZU9rVmlhTm9kZSB8fCBzcGVjcy5vaztcbiAgdmFyIHBhcmVudE9rID0gc3BlY3MucGFyZW50T2sgfHwgc3BlY3Mub2s7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBpZiAoIW9rKGVsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChlbGUsIHBhcmVudE9rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgIHJldHVybiBlZGdlT2tWaWFOb2RlKHNyYykgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQoc3JjLCBlZGdlT2tWaWFOb2RlKSkgJiYgKHNyYyA9PT0gdGd0IHx8IGVkZ2VPa1ZpYU5vZGUodGd0KSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZCh0Z3QsIGVkZ2VPa1ZpYU5vZGUpKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIGVsZVRha2VzVXBTcGFjZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlVGFrZXNVcFNwYWNlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnZWxlbWVudCcgJiYgZWxlLndpZHRoKCkgIT09IDAgJiYgKGVsZS5pc05vZGUoKSA/IGVsZS5oZWlnaHQoKSAhPT0gMCA6IHRydWUpO1xufSk7XG5lbGVzZm4kNC50YWtlc1VwU3BhY2UgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ3Rha2VzVXBTcGFjZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZVRha2VzVXBTcGFjZVxufSkpO1xudmFyIGVsZUludGVyYWN0aXZlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVJbnRlcmFjdGl2ZScsIGZ1bmN0aW9uIChlbGUpIHtcbiAgcmV0dXJuIGVsZS5wc3R5bGUoJ2V2ZW50cycpLnZhbHVlID09PSAneWVzJyAmJiBlbGUucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGVUYWtlc1VwU3BhY2UoZWxlKTtcbn0pO1xudmFyIHBhcmVudEludGVyYWN0aXZlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdwYXJlbnRJbnRlcmFjdGl2ZScsIGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgcmV0dXJuIHBhcmVudC5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShwYXJlbnQpO1xufSk7XG5lbGVzZm4kNC5pbnRlcmFjdGl2ZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbignaW50ZXJhY3RpdmUnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVJbnRlcmFjdGl2ZSxcbiAgcGFyZW50T2s6IHBhcmVudEludGVyYWN0aXZlLFxuICBlZGdlT2tWaWFOb2RlOiBlbGVUYWtlc1VwU3BhY2Vcbn0pKTtcbmVsZXNmbiQ0Lm5vbmludGVyYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmludGVyYWN0aXZlKCk7XG4gIH1cbn07XG52YXIgZWxlVmlzaWJsZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlVmlzaWJsZScsIGZ1bmN0aW9uIChlbGUpIHtcbiAgcmV0dXJuIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZS5wc3R5bGUoJ29wYWNpdHknKS5wZlZhbHVlICE9PSAwICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xufSk7XG52YXIgZWRnZVZpc2libGVWaWFOb2RlID0gZWxlVGFrZXNVcFNwYWNlO1xuZWxlc2ZuJDQudmlzaWJsZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndmlzaWJsZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZVZpc2libGUsXG4gIGVkZ2VPa1ZpYU5vZGU6IGVkZ2VWaXNpYmxlVmlhTm9kZVxufSkpO1xuZWxlc2ZuJDQuaGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgfVxufTtcbmVsZXNmbiQ0LmlzQnVuZGxlZEJlemllciA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbignaXNCdW5kbGVkQmV6aWVyJywgZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gIXRoaXMucmVtb3ZlZCgpICYmIHRoaXMucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlID09PSAnYmV6aWVyJyAmJiB0aGlzLnRha2VzVXBTcGFjZSgpO1xufSk7XG5lbGVzZm4kNC5ieXBhc3MgPSBlbGVzZm4kNC5jc3MgPSBlbGVzZm4kNC5zdHlsZTtcbmVsZXNmbiQ0LnJlbmRlcmVkQ3NzID0gZWxlc2ZuJDQucmVuZGVyZWRTdHlsZTtcbmVsZXNmbiQ0LnJlbW92ZUJ5cGFzcyA9IGVsZXNmbiQ0LnJlbW92ZUNzcyA9IGVsZXNmbiQ0LnJlbW92ZVN0eWxlO1xuZWxlc2ZuJDQucHN0eWxlID0gZWxlc2ZuJDQucGFyc2VkU3R5bGU7XG5cbnZhciBlbGVzZm4kMyA9IHt9O1xuZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNoYW5nZWRFbGVzID0gW107XG5cbiAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBkYXRhLCBoYW5kbGVyIClcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICAgIHRoaXMub24ocGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBmbiQ2KGFyZ3NbMF0pKSB7XG4gICAgICB2YXIgX2hhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgdGhpcy5vbihwYXJhbXMuZXZlbnQsIF9oYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KClcbiAgICAvLyBlLmcuIChwcml2YXRlKSBjeS5ub2RlcygpLnNlbGVjdChbJ3RhcHNlbGVjdCddKVxuICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAwIHx8IGFyZ3MubGVuZ3RoID09PSAxICYmIGFycmF5KGFyZ3NbMF0pKSB7XG4gICAgICB2YXIgYWRkbEV2ZW50cyA9IGFyZ3MubGVuZ3RoID09PSAxID8gYXJnc1swXSA6IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBhYmxlID0gIXBhcmFtcy5hYmxlRmllbGQgfHwgZWxlLl9wcml2YXRlW3BhcmFtcy5hYmxlRmllbGRdO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdICE9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgaWYgKHBhcmFtcy5vdmVycmlkZUFibGUpIHtcbiAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuICAgICAgICAgIGlmIChvdmVycmlkZUFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcbiAgICAgICAgICAgIGlmICghb3ZlcnJpZGVBYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJsZSkge1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdID0gcGFyYW1zLnZhbHVlO1xuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlcy5wdXNoKGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlZENvbGwgPSB0aGlzLnNwYXduKGNoYW5nZWRFbGVzKTtcbiAgICAgIGNoYW5nZWRDb2xsLnVwZGF0ZVN0eWxlKCk7IC8vIGNoYW5nZSBvZiBzdGF0ZSA9PiBwb3NzaWJsZSBjaGFuZ2Ugb2Ygc3R5bGVcbiAgICAgIGNoYW5nZWRDb2xsLmVtaXQocGFyYW1zLmV2ZW50KTtcbiAgICAgIGlmIChhZGRsRXZlbnRzKSB7XG4gICAgICAgIGNoYW5nZWRDb2xsLmVtaXQoYWRkbEV2ZW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lU3dpdGNoU2V0KHBhcmFtcykge1xuICBlbGVzZm4kM1twYXJhbXMuZmllbGRdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChwYXJhbXMub3ZlcnJpZGVGaWVsZCkge1xuICAgICAgICB2YXIgdmFsID0gcGFyYW1zLm92ZXJyaWRlRmllbGQoZWxlKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdO1xuICAgIH1cbiAgfTtcbiAgZWxlc2ZuJDNbcGFyYW1zLm9uXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICBldmVudDogcGFyYW1zLm9uLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZWxlc2ZuJDNbcGFyYW1zLm9mZl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vZmYsXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiBmYWxzZVxuICB9KTtcbn1cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnbG9ja2VkJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnbG9jaycsXG4gIG9mZjogJ3VubG9jaydcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdncmFiYmFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5ncmFiaWZ5KCkgfHwgZWxlLnBhbm5hYmxlKCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdncmFiaWZ5JyxcbiAgb2ZmOiAndW5ncmFiaWZ5J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24gb3ZlcnJpZGVBYmxlKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdCcsXG4gIG9mZjogJ3Vuc2VsZWN0J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdGlmeScsXG4gIG9mZjogJ3Vuc2VsZWN0aWZ5J1xufSk7XG5lbGVzZm4kMy5kZXNlbGVjdCA9IGVsZXNmbiQzLnVuc2VsZWN0O1xuZWxlc2ZuJDMuZ3JhYmJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmIChlbGUpIHtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gIH1cbn07XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2FjdGl2ZScsXG4gIG9uOiAnYWN0aXZhdGUnLFxuICBvZmY6ICd1bmFjdGl2YXRlJ1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3Bhbm5hYmxlJyxcbiAgb246ICdwYW5pZnknLFxuICBvZmY6ICd1bnBhbmlmeSdcbn0pO1xuZWxlc2ZuJDMuaW5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuX3ByaXZhdGUuYWN0aXZlO1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJDIgPSB7fTtcblxuLy8gREFHIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmaW5lRGFnRXh0cmVtaXR5ID0gZnVuY3Rpb24gZGVmaW5lRGFnRXh0cmVtaXR5KHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gZGFnRXh0cmVtaXR5SW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRpc3F1YWxpZmllZCA9IGZhbHNlO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5ub0luY29taW5nRWRnZXMgJiYgdGd0ID09PSBlbGUgJiYgc3JjICE9PSBlbGUgfHwgcGFyYW1zLm5vT3V0Z29pbmdFZGdlcyAmJiBzcmMgPT09IGVsZSAmJiB0Z3QgIT09IGVsZSkge1xuICAgICAgICAgIGRpc3F1YWxpZmllZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZGlzcXVhbGlmaWVkKSB7XG4gICAgICAgIHJldC5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldCwgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG52YXIgZGVmaW5lRGFnT25lSG9wID0gZnVuY3Rpb24gZGVmaW5lRGFnT25lSG9wKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBvRWxlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG4gICAgICAgIGlmIChwYXJhbXMub3V0Z29pbmcgJiYgc3JjID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2godGd0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaW5jb21pbmcgJiYgdGd0ID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2goc3JjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihvRWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG52YXIgZGVmaW5lRGFnQWxsSG9wcyA9IGZ1bmN0aW9uIGRlZmluZURhZ0FsbEhvcHMocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHNFbGVzID0gW107XG4gICAgdmFyIHNFbGVzSWRzID0ge307XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG5leHQgPSBwYXJhbXMub3V0Z29pbmcgPyBlbGVzLm91dGdvZXJzKCkgOiBlbGVzLmluY29tZXJzKCk7XG4gICAgICBpZiAobmV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGRvbmUgaWYgbm9uZSBsZWZ0XG5cbiAgICAgIHZhciBuZXdOZXh0ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBuZXh0W2ldO1xuICAgICAgICB2YXIgbmlkID0gbi5pZCgpO1xuICAgICAgICBpZiAoIXNFbGVzSWRzW25pZF0pIHtcbiAgICAgICAgICBzRWxlc0lkc1tuaWRdID0gdHJ1ZTtcbiAgICAgICAgICBzRWxlcy5wdXNoKG4pO1xuICAgICAgICAgIG5ld05leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW5ld05leHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgb3V0Z29lcnMgYWxyZWFkeVxuXG4gICAgICBlbGVzID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc0VsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xuZWxlc2ZuJDIuY2xlYXJUcmF2ZXJzYWxDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tpXS5fcHJpdmF0ZS50cmF2ZXJzYWxDYWNoZSA9IG51bGw7XG4gIH1cbn07XG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9JbmNvbWluZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9PdXRnb2luZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIG91dGdvaW5nOiB0cnVlXG4gIH0pLCAnb3V0Z29lcnMnKSxcbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICBvdXRnb2luZzogdHJ1ZVxuICB9KSxcbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIGluY29taW5nOiB0cnVlXG4gIH0pLCAnaW5jb21lcnMnKSxcbiAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgcHJlZGVjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICB9KVxufSk7XG5cbi8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgbmVpZ2hib3Job29kOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gZm9yIGFsbCBub2Rlc1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgLy8gZm9yIGVhY2ggY29ubmVjdGVkIGVkZ2UsIGFkZCB0aGUgZWRnZSBhbmQgdGhlIG90aGVyIG5vZGVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gbm9kZSA9PT0gc3JjID8gdGd0IDogc3JjO1xuXG4gICAgICAgIC8vIG5lZWQgY2hlY2sgaW4gY2FzZSBvZiBsb29wXG4gICAgICAgIGlmIChvdGhlck5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2gob3RoZXJOb2RlWzBdKTsgLy8gYWRkIG5vZGUgMSBob3AgYXdheVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZVswXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnbmVpZ2hib3Job29kJyksXG4gIGNsb3NlZE5laWdoYm9yaG9vZDogZnVuY3Rpb24gY2xvc2VkTmVpZ2hib3Job29kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuYWRkKHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG9wZW5OZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIG9wZW5OZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2Qoc2VsZWN0b3IpO1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xuZWxlc2ZuJDIubmVpZ2hib3VyaG9vZCA9IGVsZXNmbiQyLm5laWdoYm9yaG9vZDtcbmVsZXNmbiQyLmNsb3NlZE5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5jbG9zZWROZWlnaGJvcmhvb2Q7XG5lbGVzZm4kMi5vcGVuTmVpZ2hib3VyaG9vZCA9IGVsZXNmbiQyLm9wZW5OZWlnaGJvcmhvb2Q7XG5cbi8vIEVkZ2UgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgc291cmNlOiBjYWNoZShmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHNyYztcbiAgICBpZiAoZWxlKSB7XG4gICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlIHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHNyYyAmJiBzZWxlY3RvciA/IHNyYy5maWx0ZXIoc2VsZWN0b3IpIDogc3JjO1xuICB9LCAnc291cmNlJyksXG4gIHRhcmdldDogY2FjaGUoZnVuY3Rpb24gdGFyZ2V0SW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciB0Z3Q7XG4gICAgaWYgKGVsZSkge1xuICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldCB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKHNlbGVjdG9yKSA6IHRndDtcbiAgfSwgJ3RhcmdldCcpLFxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3NvdXJjZSdcbiAgfSksXG4gIHRhcmdldHM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICBhdHRyOiAndGFyZ2V0J1xuICB9KVxufSk7XG5mdW5jdGlvbiBkZWZpbmVTb3VyY2VGdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNvdXJjZUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlW3BhcmFtcy5hdHRyXTtcbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHNyYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHNvdXJjZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59XG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgZWRnZXNXaXRoOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbigpLCAnZWRnZXNXaXRoJyksXG4gIGVkZ2VzVG86IGNhY2hlKGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHtcbiAgICB0aGlzSXNTcmM6IHRydWVcbiAgfSksICdlZGdlc1RvJylcbn0pO1xuZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBlZGdlc1dpdGhJbXBsKG90aGVyTm9kZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gZ2V0IGVsZW1lbnRzIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkXG4gICAgaWYgKHN0cmluZyhvdGhlck5vZGVzKSkge1xuICAgICAgb3RoZXJOb2RlcyA9IGN5LiQob3RoZXJOb2Rlcyk7XG4gICAgfVxuICAgIGZvciAodmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKykge1xuICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlc1toXS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2VEYXRhID0gZWRnZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGhpc1RvT3RoZXIgPSB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEuc291cmNlKSAmJiBvdGhlck5vZGVzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEudGFyZ2V0KTtcbiAgICAgICAgdmFyIG90aGVyVG9UaGlzID0gb3RoZXJOb2Rlcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnNvdXJjZSkgJiYgdGhpcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnRhcmdldCk7XG4gICAgICAgIHZhciBlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgPSB0aGlzVG9PdGhlciB8fCBvdGhlclRvVGhpcztcbiAgICAgICAgaWYgKCFlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC50aGlzSXNTcmMgfHwgcC50aGlzSXNUZ3QpIHtcbiAgICAgICAgICBpZiAocC50aGlzSXNTcmMgJiYgIXRoaXNUb090aGVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHAudGhpc0lzVGd0ICYmICFvdGhlclRvVGhpcykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKTtcbiAgfTtcbn1cbmV4dGVuZChlbGVzZm4kMiwge1xuICBjb25uZWN0ZWRFZGdlczogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG4gICAgICBpZiAoIW5vZGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICByZXRFbGVzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICdjb25uZWN0ZWRFZGdlcycpLFxuICBjb25uZWN0ZWROb2RlczogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVsZXNbaV07XG4gICAgICBpZiAoIWVkZ2UuaXNFZGdlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXRFbGVzLnB1c2goZWRnZS5zb3VyY2UoKVswXSk7XG4gICAgICByZXRFbGVzLnB1c2goZWRnZS50YXJnZXQoKVswXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICdjb25uZWN0ZWROb2RlcycpLFxuICBwYXJhbGxlbEVkZ2VzOiBjYWNoZShkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oKSwgJ3BhcmFsbGVsRWRnZXMnKSxcbiAgY29kaXJlY3RlZEVkZ2VzOiBjYWNoZShkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oe1xuICAgIGNvZGlyZWN0ZWQ6IHRydWVcbiAgfSksICdjb2RpcmVjdGVkRWRnZXMnKVxufSk7XG5mdW5jdGlvbiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBjb2RpcmVjdGVkOiBmYWxzZVxuICB9O1xuICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICByZXR1cm4gZnVuY3Rpb24gcGFyYWxsZWxFZGdlc0ltcGwoc2VsZWN0b3IpIHtcbiAgICAvLyBtaWNyby1vcHRpbWlzZWQgZm9yIHJlbmRlcmVyXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UxID0gZWRnZXNbaV07XG4gICAgICB2YXIgZWRnZTFfcCA9IGVkZ2UxLl9wcml2YXRlO1xuICAgICAgdmFyIHNyYzEgPSBlZGdlMV9wLnNvdXJjZTtcbiAgICAgIHZhciBzcmNpZDEgPSBzcmMxLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgdGd0aWQxID0gZWRnZTFfcC5kYXRhLnRhcmdldDtcbiAgICAgIHZhciBzcmNFZGdlczEgPSBzcmMxLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNyY0VkZ2VzMS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZTIgPSBzcmNFZGdlczFbal07XG4gICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGd0aWQyID0gZWRnZTJkYXRhLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY2lkMiA9IGVkZ2UyZGF0YS5zb3VyY2U7XG4gICAgICAgIHZhciBjb2RpcmVjdGVkID0gdGd0aWQyID09PSB0Z3RpZDEgJiYgc3JjaWQyID09PSBzcmNpZDE7XG4gICAgICAgIHZhciBvcHBkaXJlY3RlZCA9IHNyY2lkMSA9PT0gdGd0aWQyICYmIHRndGlkMSA9PT0gc3JjaWQyO1xuICAgICAgICBpZiAocC5jb2RpcmVjdGVkICYmIGNvZGlyZWN0ZWQgfHwgIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuLy8gTWlzYyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4dGVuZChlbGVzZm4kMiwge1xuICBjb21wb25lbnRzOiBmdW5jdGlvbiBjb21wb25lbnRzKHJvb3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICAgIHZhciB2aXNpdGVkID0gY3kuY29sbGVjdGlvbigpO1xuICAgIHZhciB1bnZpc2l0ZWQgPSByb290ID09IG51bGwgPyBzZWxmLm5vZGVzKCkgOiByb290Lm5vZGVzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBpZiAocm9vdCAhPSBudWxsICYmIHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICAvLyByb290IG1heSBjb250YWluIG9ubHkgZWRnZXNcbiAgICAgIHVudmlzaXRlZCA9IHJvb3Quc291cmNlcygpOyAvLyBkb2Vzbid0IG1hdHRlciB3aGljaCBub2RlIHRvIHVzZSAodW5kaXJlY3RlZCksIHNvIGp1c3QgdXNlIHRoZSBzb3VyY2Ugc2lkZXNcbiAgICB9XG4gICAgdmFyIHZpc2l0SW5Db21wb25lbnQgPSBmdW5jdGlvbiB2aXNpdEluQ29tcG9uZW50KG5vZGUsIGNvbXBvbmVudCkge1xuICAgICAgdmlzaXRlZC5tZXJnZShub2RlKTtcbiAgICAgIHVudmlzaXRlZC51bm1lcmdlKG5vZGUpO1xuICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgIH07XG4gICAgaWYgKHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICByZXR1cm4gc2VsZi5zcGF3bigpO1xuICAgIH1cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIC8vIGVhY2ggaXRlcmF0aW9uIHlpZWxkcyBhIGNvbXBvbmVudFxuICAgICAgdmFyIGNtcHQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG4gICAgICB2YXIgcm9vdCA9IHVudmlzaXRlZFswXTtcbiAgICAgIHZpc2l0SW5Db21wb25lbnQocm9vdCwgY21wdCk7XG4gICAgICBzZWxmLmJmcyh7XG4gICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdCh2KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0SW5Db21wb25lbnQodiwgY21wdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICAgIGlmIChzZWxmLmhhcyhlKSAmJiBjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgICAgLy8gaGFzKCkgaXMgY2hlYXBcbiAgICAgICAgICAgIGNtcHQubWVyZ2UoZSk7IC8vIGZvckVhY2goKSBvbmx5IGNvbnNpZGVycyBub2RlcyAtLSBzZXRzIE4gYXQgY2FsbCB0aW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZG8ge1xuICAgICAgX2xvb3AoKTtcbiAgICB9IHdoaWxlICh1bnZpc2l0ZWQubGVuZ3RoID4gMCk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH0sXG4gIGNvbXBvbmVudDogZnVuY3Rpb24gY29tcG9uZW50KCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUuY3koKS5tdXRhYmxlRWxlbWVudHMoKS5jb21wb25lbnRzKGVsZSlbMF07XG4gIH1cbn0pO1xuZWxlc2ZuJDIuY29tcG9uZW50c09mID0gZWxlc2ZuJDIuY29tcG9uZW50cztcblxuLy8gcmVwcmVzZW50cyBhIHNldCBvZiBub2RlcywgZWRnZXMsIG9yIGJvdGggdG9nZXRoZXJcbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpIHtcbiAgdmFyIHVuaXF1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciByZW1vdmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgaWYgKGN5ID09PSB1bmRlZmluZWQpIHtcbiAgICBlcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWFwID0gbmV3IE1hcCQxKCk7XG4gIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIGVsZW1lbnRzID0gW107XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiBwbGFpbk9iamVjdChlbGVtZW50c1swXSkgJiYgIWVsZW1lbnQoZWxlbWVudHNbMF0pKSB7XG4gICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTtcblxuICAgIC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG4gICAgdmFyIGVsZXMgPSBbXTtcbiAgICB2YXIgZWxlc0lkcyA9IG5ldyBTZXQkMSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIganNvbiA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGpzb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIF9kYXRhID0ganNvbi5kYXRhO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbmV3bHkgY3JlYXRlZCBlbGVtZW50cyBoYXZlIHZhbGlkIGlkc1xuICAgICAgaWYgKF9kYXRhLmlkID09IG51bGwpIHtcbiAgICAgICAgX2RhdGEuaWQgPSB1dWlkKCk7XG4gICAgICB9IGVsc2UgaWYgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoX2RhdGEuaWQpIHx8IGVsZXNJZHMuaGFzKF9kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgcHJpb3IgaWQgYWxyZWFkeSBleGlzdHNcbiAgICAgIH1cbiAgICAgIHZhciBlbGUgPSBuZXcgRWxlbWVudChjeSwganNvbiwgZmFsc2UpO1xuICAgICAgZWxlcy5wdXNoKGVsZSk7XG4gICAgICBlbGVzSWRzLmFkZChfZGF0YS5pZCk7XG4gICAgfVxuICAgIGVsZW1lbnRzID0gZWxlcztcbiAgfVxuICB0aGlzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIF9pID0gMCwgX2wgPSBlbGVtZW50cy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICB2YXIgZWxlbWVudCQxID0gZWxlbWVudHNbX2ldWzBdOyAvLyBbMF0gaW4gY2FzZSBlbGVtZW50cyBpcyBhbiBhcnJheSBvZiBjb2xsZWN0aW9ucywgcmF0aGVyIHRoYW4gYXJyYXkgb2YgZWxlbWVudHNcbiAgICBpZiAoZWxlbWVudCQxID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaWQgPSBlbGVtZW50JDEuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICBpZiAoIXVuaXF1ZSB8fCAhbWFwLmhhcyhpZCkpIHtcbiAgICAgIGlmICh1bmlxdWUpIHtcbiAgICAgICAgbWFwLnNldChpZCwge1xuICAgICAgICAgIGluZGV4OiB0aGlzLmxlbmd0aCxcbiAgICAgICAgICBlbGU6IGVsZW1lbnQkMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXNbdGhpcy5sZW5ndGhdID0gZWxlbWVudCQxO1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH1cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBlbGVzOiB0aGlzLFxuICAgIGN5OiBjeSxcbiAgICBnZXQgbWFwKCkge1xuICAgICAgaWYgKHRoaXMubGF6eU1hcCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVidWlsZE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubGF6eU1hcDtcbiAgICB9LFxuICAgIHNldCBtYXAobSkge1xuICAgICAgdGhpcy5sYXp5TWFwID0gbTtcbiAgICB9LFxuICAgIHJlYnVpbGRNYXA6IGZ1bmN0aW9uIHJlYnVpbGRNYXAoKSB7XG4gICAgICB2YXIgbSA9IHRoaXMubGF6eU1hcCA9IG5ldyBNYXAkMSgpO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzLmVsZXM7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9lbGUgPSBlbGVzW19pMl07XG4gICAgICAgIG0uc2V0KF9lbGUuaWQoKSwge1xuICAgICAgICAgIGluZGV4OiBfaTIsXG4gICAgICAgICAgZWxlOiBfZWxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKHVuaXF1ZSkge1xuICAgIHRoaXMuX3ByaXZhdGUubWFwID0gbWFwO1xuICB9XG5cbiAgLy8gcmVzdG9yZSB0aGUgZWxlbWVudHMgaWYgd2UgY3JlYXRlZCB0aGVtIGZyb20ganNvblxuICBpZiAoY3JlYXRlZEVsZW1lbnRzICYmICFyZW1vdmVkKSB7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4vLyBhbmQgdXNlIGVsZWZuIGFuZCBlbGVzZm4gYXMgc2hvcnRoYW5kcyB0byB0aGUgcHJvdG90eXBlc1xudmFyIGVsZXNmbiQxID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcbmVsZXNmbiQxLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ2NvbGxlY3Rpb24nO1xufTtcbmVsZXNmbiQxLnNwYXduID0gZnVuY3Rpb24gKGVsZXMsIHVuaXF1ZSkge1xuICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5jeSgpLCBlbGVzLCB1bmlxdWUpO1xufTtcbmVsZXNmbiQxLnNwYXduU2VsZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3Bhd24odGhpcyk7XG59O1xuZWxlc2ZuJDEuY3kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xufTtcbmVsZXNmbiQxLnJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeS5yZW5kZXJlcigpO1xufTtcbmVsZXNmbiQxLmVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzWzBdO1xufTtcbmVsZXNmbiQxLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjb2xsZWN0aW9uKHRoaXMpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gYW4gZWxlbWVudFxuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBbdGhpc10pO1xuICB9XG59O1xuZWxlc2ZuJDEudW5pcXVlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgdGhpcywgdHJ1ZSk7XG59O1xuZWxlc2ZuJDEuaGFzRWxlbWVudFdpdGhJZCA9IGZ1bmN0aW9uIChpZCkge1xuICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmhhcyhpZCk7XG59O1xuZWxlc2ZuJDEuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbnRyeSA9IHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCk7XG4gIHJldHVybiBlbnRyeSA/IGVudHJ5LmVsZSA6IG5ldyBDb2xsZWN0aW9uKGN5KTsgLy8gZ2V0IGVsZSBvciBlbXB0eSBjb2xsZWN0aW9uXG59O1xuZWxlc2ZuJDEuJGlkID0gZWxlc2ZuJDEuZ2V0RWxlbWVudEJ5SWQ7XG5lbGVzZm4kMS5wb29sSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIHZhciBpZCA9IHRoaXNbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgcmV0dXJuIGVsZXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuZWxlc2ZuJDEuaW5kZXhPZiA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIGlkID0gZWxlWzBdLl9wcml2YXRlLmRhdGEuaWQ7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xufTtcbmVsZXNmbiQxLmluZGV4T2ZJZCA9IGZ1bmN0aW9uIChpZCkge1xuICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuZWxlc2ZuJDEuanNvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGVsZSA9IHRoaXMuZWxlbWVudCgpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIGlmIChlbGUgPT0gbnVsbCAmJiBvYmopIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBjYW4ndCBzZXQgdG8gbm8gZWxlc1xuXG4gIGlmIChlbGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gLy8gY2FuJ3QgZ2V0IGZyb20gbm8gZWxlc1xuXG4gIHZhciBwID0gZWxlLl9wcml2YXRlO1xuICBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgIC8vIHNldFxuXG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgIGlmIChvYmouZGF0YSkge1xuICAgICAgZWxlLmRhdGEob2JqLmRhdGEpO1xuICAgICAgdmFyIF9kYXRhMiA9IHAuZGF0YTtcbiAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgLy8gc291cmNlIGFuZCB0YXJnZXQgYXJlIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBtb3ZlID0gZmFsc2U7XG4gICAgICAgIHZhciBzcGVjID0ge307XG4gICAgICAgIHZhciBzcmMgPSBvYmouZGF0YS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBvYmouZGF0YS50YXJnZXQ7XG4gICAgICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMgIT0gX2RhdGEyLnNvdXJjZSkge1xuICAgICAgICAgIHNwZWMuc291cmNlID0gJycgKyBzcmM7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRndCAhPSBudWxsICYmIHRndCAhPSBfZGF0YTIudGFyZ2V0KSB7XG4gICAgICAgICAgc3BlYy50YXJnZXQgPSAnJyArIHRndDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgIGVsZSA9IGVsZS5tb3ZlKHNwZWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXJlbnQgaXMgaW1tdXRhYmxlIHZpYSBkYXRhKClcbiAgICAgICAgdmFyIG5ld1BhcmVudFZhbFNwZWNkID0gJ3BhcmVudCcgaW4gb2JqLmRhdGE7XG4gICAgICAgIHZhciBwYXJlbnQgPSBvYmouZGF0YS5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXdQYXJlbnRWYWxTcGVjZCAmJiAocGFyZW50ICE9IG51bGwgfHwgX2RhdGEyLnBhcmVudCAhPSBudWxsKSAmJiBwYXJlbnQgIT0gX2RhdGEyLnBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FuJ3Qgc2V0IHVuZGVmaW5lZCBpbXBlcmF0aXZlbHksIHNvIHVzZSBudWxsXG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudCA9ICcnICsgcGFyZW50OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGUgPSBlbGUubW92ZSh7XG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvYmoucG9zaXRpb24pIHtcbiAgICAgIGVsZS5wb3NpdGlvbihvYmoucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBncm91cCAtLSBpbW11dGFibGVcblxuICAgIHZhciBjaGVja1N3aXRjaCA9IGZ1bmN0aW9uIGNoZWNrU3dpdGNoKGssIHRydWVGbk5hbWUsIGZhbHNlRm5OYW1lKSB7XG4gICAgICB2YXIgb2JqX2sgPSBvYmpba107XG4gICAgICBpZiAob2JqX2sgIT0gbnVsbCAmJiBvYmpfayAhPT0gcFtrXSkge1xuICAgICAgICBpZiAob2JqX2spIHtcbiAgICAgICAgICBlbGVbdHJ1ZUZuTmFtZV0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVbZmFsc2VGbk5hbWVdKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrU3dpdGNoKCdyZW1vdmVkJywgJ3JlbW92ZScsICdyZXN0b3JlJyk7XG4gICAgY2hlY2tTd2l0Y2goJ3NlbGVjdGVkJywgJ3NlbGVjdCcsICd1bnNlbGVjdCcpO1xuICAgIGNoZWNrU3dpdGNoKCdzZWxlY3RhYmxlJywgJ3NlbGVjdGlmeScsICd1bnNlbGVjdGlmeScpO1xuICAgIGNoZWNrU3dpdGNoKCdsb2NrZWQnLCAnbG9jaycsICd1bmxvY2snKTtcbiAgICBjaGVja1N3aXRjaCgnZ3JhYmJhYmxlJywgJ2dyYWJpZnknLCAndW5ncmFiaWZ5Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ3Bhbm5hYmxlJywgJ3BhbmlmeScsICd1bnBhbmlmeScpO1xuICAgIGlmIChvYmouY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICBlbGUuY2xhc3NlcyhvYmouY2xhc3Nlcyk7XG4gICAgfVxuICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBnZXRcblxuICAgIHZhciBqc29uID0ge1xuICAgICAgZGF0YTogY29weShwLmRhdGEpLFxuICAgICAgcG9zaXRpb246IGNvcHkocC5wb3NpdGlvbiksXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBwYW5uYWJsZTogcC5wYW5uYWJsZSxcbiAgICAgIGNsYXNzZXM6IG51bGxcbiAgICB9O1xuICAgIGpzb24uY2xhc3NlcyA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICBwLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICByZXR1cm4ganNvbi5jbGFzc2VzICs9IGkrKyA9PT0gMCA/IGNscyA6ICcgJyArIGNscztcbiAgICB9KTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufTtcbmVsZXNmbiQxLmpzb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIGpzb25zLnB1c2goanNvbik7XG4gIH1cbiAgcmV0dXJuIGpzb25zO1xufTtcbmVsZXNmbiQxLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBlbGVzQXJyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICB2YXIgY2xvbmUgPSBuZXcgRWxlbWVudChjeSwganNvbiwgZmFsc2UpOyAvLyBOQiBubyByZXN0b3JlXG5cbiAgICBlbGVzQXJyLnB1c2goY2xvbmUpO1xuICB9XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlc0Fycik7XG59O1xuZWxlc2ZuJDEuY29weSA9IGVsZXNmbiQxLmNsb25lO1xuZWxlc2ZuJDEucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICB2YXIgYWRkVG9Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgdmFyIGN5X3AgPSBjeS5fcHJpdmF0ZTtcblxuICAvLyBjcmVhdGUgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcywgc2luY2Ugd2UgbmVlZCB0b1xuICAvLyByZXN0b3JlIHRoZSBub2RlcyBmaXJzdFxuICB2YXIgbm9kZXMgPSBbXTtcbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBlbGVtZW50cztcbiAgZm9yICh2YXIgX2kzID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBfaTMgPCBsOyBfaTMrKykge1xuICAgIHZhciBlbGUgPSBzZWxmW19pM107XG4gICAgaWYgKGFkZFRvUG9vbCAmJiAhZWxlLnJlbW92ZWQoKSkge1xuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBoYW5kbGUgdGhpcyBlbGVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGtlZXAgbm9kZXMgZmlyc3QgaW4gdGhlIGFycmF5IGFuZCBlZGdlcyBhZnRlclxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHB1dCB0byBlbmQgb2YgYXJyYXkgaWYgZWRnZVxuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuICBlbGVtZW50cyA9IG5vZGVzLmNvbmNhdChlZGdlcyk7XG4gIHZhciBpO1xuICB2YXIgcmVtb3ZlRnJvbUVsZW1lbnRzID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUVsZW1lbnRzKCkge1xuICAgIGVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICBpLS07XG4gIH07XG5cbiAgLy8gbm93LCByZXN0b3JlIGVhY2ggZWxlbWVudFxuICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2VsZTIgPSBlbGVtZW50c1tpXTtcbiAgICB2YXIgX3ByaXZhdGUgPSBfZWxlMi5fcHJpdmF0ZTtcbiAgICB2YXIgX2RhdGEzID0gX3ByaXZhdGUuZGF0YTtcblxuICAgIC8vIHRoZSB0cmF2ZXJzYWwgY2FjaGUgc2hvdWxkIHN0YXJ0IGZyZXNoIHdoZW4gZWxlIGlzIGFkZGVkXG4gICAgX2VsZTIuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuICAgIGlmICghYWRkVG9Qb29sICYmICFfcHJpdmF0ZS5yZW1vdmVkKSA7IGVsc2UgaWYgKF9kYXRhMy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfZGF0YTMuaWQgPSB1dWlkKCk7XG4gICAgfSBlbHNlIGlmIChudW1iZXIkMShfZGF0YTMuaWQpKSB7XG4gICAgICBfZGF0YTMuaWQgPSAnJyArIF9kYXRhMy5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcbiAgICB9IGVsc2UgaWYgKGVtcHR5U3RyaW5nKF9kYXRhMy5pZCkgfHwgIXN0cmluZyhfZGF0YTMuaWQpKSB7XG4gICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTtcblxuICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG4gICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY3kuaGFzRWxlbWVudFdpdGhJZChfZGF0YTMuaWQpKSB7XG4gICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgc2Vjb25kIGVsZW1lbnQgd2l0aCBJRCBgJyArIF9kYXRhMy5pZCArICdgJyk7XG5cbiAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIG9uZSBhbHJlYWR5IGhhcyB0aGF0IGlkXG4gICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaWQgPSBfZGF0YTMuaWQ7IC8vIGlkIGlzIGZpbmFsaXNlZCwgbm93IGxldCdzIGtlZXAgYSByZWZcblxuICAgIGlmIChfZWxlMi5pc05vZGUoKSkge1xuICAgICAgLy8gZXh0cmEgY2hlY2tzIGZvciBub2Rlc1xuICAgICAgdmFyIHBvcyA9IF9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIG5vZGVzIGhhdmUgYSBkZWZpbmVkIHBvc2l0aW9uXG5cbiAgICAgIGlmIChwb3MueCA9PSBudWxsKSB7XG4gICAgICAgIHBvcy54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MueSA9PSBudWxsKSB7XG4gICAgICAgIHBvcy55ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9lbGUyLmlzRWRnZSgpKSB7XG4gICAgICAvLyBleHRyYSBjaGVja3MgZm9yIGVkZ2VzXG5cbiAgICAgIHZhciBlZGdlID0gX2VsZTI7XG4gICAgICB2YXIgZmllbGRzID0gWydzb3VyY2UnLCAndGFyZ2V0J107XG4gICAgICB2YXIgZmllbGRzTGVuZ3RoID0gZmllbGRzLmxlbmd0aDtcbiAgICAgIHZhciBiYWRTb3VyY2VPclRhcmdldCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHNMZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgIHZhciB2YWwgPSBfZGF0YTNbZmllbGRdO1xuICAgICAgICBpZiAobnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgIHZhbCA9IF9kYXRhM1tmaWVsZF0gPSAnJyArIF9kYXRhM1tmaWVsZF07IC8vIG5vdyBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSAnJykge1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggdW5zcGVjaWZpZWQgJyArIGZpZWxkKTtcbiAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWN5Lmhhc0VsZW1lbnRXaXRoSWQodmFsKSkge1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcpO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJhZFNvdXJjZU9yVGFyZ2V0KSB7XG4gICAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gY2FuJ3QgY3JlYXRlIHRoaXNcblxuICAgICAgdmFyIHNyYyA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy5zb3VyY2UpO1xuICAgICAgdmFyIHRndCA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy50YXJnZXQpO1xuXG4gICAgICAvLyBvbmx5IG9uZSBlZGdlIGluIG5vZGUgaWYgbG9vcFxuICAgICAgaWYgKHNyYy5zYW1lKHRndCkpIHtcbiAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgdGd0Ll9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuICAgIH0gLy8gaWYgaXMgZWRnZVxuXG4gICAgLy8gY3JlYXRlIG1vY2sgaWRzIC8gaW5kZXhlcyBtYXBzIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICBfcHJpdmF0ZS5tYXAgPSBuZXcgTWFwJDEoKTtcbiAgICBfcHJpdmF0ZS5tYXAuc2V0KGlkLCB7XG4gICAgICBlbGU6IF9lbGUyLFxuICAgICAgaW5kZXg6IDBcbiAgICB9KTtcbiAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG4gICAgaWYgKGFkZFRvUG9vbCkge1xuICAgICAgY3kuYWRkVG9Qb29sKF9lbGUyKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVhY2ggZWxlbWVudFxuXG4gIC8vIGRvIGNvbXBvdW5kIG5vZGUgc2FuaXR5IGNoZWNrc1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgLy8gZWFjaCBub2RlXG4gICAgdmFyIG5vZGUgPSBub2Rlc1tfaTRdO1xuICAgIHZhciBfZGF0YTQgPSBub2RlLl9wcml2YXRlLmRhdGE7XG4gICAgaWYgKG51bWJlciQxKF9kYXRhNC5wYXJlbnQpKSB7XG4gICAgICAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgX2RhdGE0LnBhcmVudCA9ICcnICsgX2RhdGE0LnBhcmVudDtcbiAgICB9XG4gICAgdmFyIHBhcmVudElkID0gX2RhdGE0LnBhcmVudDtcbiAgICB2YXIgc3BlY2lmaWVkUGFyZW50ID0gcGFyZW50SWQgIT0gbnVsbDtcbiAgICBpZiAoc3BlY2lmaWVkUGFyZW50IHx8IG5vZGUuX3ByaXZhdGUucGFyZW50KSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPyBjeS5jb2xsZWN0aW9uKCkubWVyZ2Uobm9kZS5fcHJpdmF0ZS5wYXJlbnQpIDogY3kuZ2V0RWxlbWVudEJ5SWQocGFyZW50SWQpO1xuICAgICAgaWYgKHBhcmVudC5lbXB0eSgpKSB7XG4gICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudFswXS5yZW1vdmVkKCkpIHtcbiAgICAgICAgd2FybignTm9kZSBhZGRlZCB3aXRoIG1pc3NpbmcgcGFyZW50LCByZWZlcmVuY2UgdG8gcGFyZW50IHJlbW92ZWQnKTtcbiAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGZBc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlICghYW5jZXN0b3IuZW1wdHkoKSkge1xuICAgICAgICAgIGlmIChub2RlLnNhbWUoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAvLyBtYXJrIHNlbGYgYXMgcGFyZW50IGFuZCByZW1vdmUgZnJvbSBkYXRhXG4gICAgICAgICAgICBzZWxmQXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDsgLy8gcmVtb3ZlIHBhcmVudCByZWZlcmVuY2VcblxuICAgICAgICAgICAgLy8gZXhpdCBvciB3ZSBsb29wIGZvcmV2ZXJcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZkFzUGFyZW50KSB7XG4gICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICAgICAgICAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcbiAgICAgICAgICBjeV9wLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVsc2VcbiAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcbiAgfSAvLyBmb3IgZWFjaCBub2RlXG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcmVzdG9yZWQgPSBlbGVtZW50cy5sZW5ndGggPT09IHNlbGYubGVuZ3RoID8gc2VsZiA6IG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgcmVzdG9yZWQubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIF9lbGUzID0gcmVzdG9yZWRbX2k1XTtcbiAgICAgIGlmIChfZWxlMy5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkaW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuICAgICAgX2VsZTMucGFyYWxsZWxFZGdlcygpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcblxuICAgICAgLy8gYWRkaW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZSBmb3IgdGhlIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgX2VsZTMuc291cmNlKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICAgICAgX2VsZTMudGFyZ2V0KCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICAgIH1cbiAgICB2YXIgdG9VcGRhdGVTdHlsZTtcbiAgICBpZiAoY3lfcC5oYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gY3kuY29sbGVjdGlvbigpLm1lcmdlKHJlc3RvcmVkKS5tZXJnZShyZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpKS5tZXJnZShyZXN0b3JlZC5wYXJlbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSByZXN0b3JlZDtcbiAgICB9XG4gICAgdG9VcGRhdGVTdHlsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKS51cGRhdGVTdHlsZShub3RpZnlSZW5kZXJlcik7XG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICByZXN0b3JlZC5lbWl0QW5kTm90aWZ5KCdhZGQnKTtcbiAgICB9IGVsc2UgaWYgKGFkZFRvUG9vbCkge1xuICAgICAgcmVzdG9yZWQuZW1pdCgnYWRkJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5lbGVzZm4kMS5yZW1vdmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiBlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5lbGVzZm4kMS5pbnNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmICFlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5lbGVzZm4kMS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIHJlbW92ZUZyb21Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuXG4gIC8vIGFkZCBjb25uZWN0ZWQgZWRnZXNcbiAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYWRkKGVkZ2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuICBmdW5jdGlvbiBhZGRDaGlsZHJlbihub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZGQoZWxlKSB7XG4gICAgdmFyIGFscmVhZHlBZGRlZCA9IGVsZXNUb1JlbW92ZUlkc1tlbGUuaWQoKV07XG4gICAgaWYgKHJlbW92ZUZyb21Qb29sICYmIGVsZS5yZW1vdmVkKCkgfHwgYWxyZWFkeUFkZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZUlkc1tlbGUuaWQoKV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaChlbGUpOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKGVsZSk7XG4gICAgICBhZGRDaGlsZHJlbihlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdChlbGUpOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgYWRkKGVsZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZihub2RlLCBlZGdlKSB7XG4gICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICByZW1vdmVGcm9tQXJyYXkoY29ubmVjdGVkRWRnZXMsIGVkZ2UpO1xuXG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZXMgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZSBmb3IgaXRzIG5vZGVzXG4gICAgbm9kZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUGFyYWxsZWxSZWYocGxsRWRnZSkge1xuICAgIC8vIHJlbW92aW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuICAgIHBsbEVkZ2UuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICB9XG4gIHZhciBhbHRlcmVkUGFyZW50cyA9IFtdO1xuICBhbHRlcmVkUGFyZW50cy5pZHMgPSB7fTtcbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpIHtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG4gICAgcmVtb3ZlRnJvbUFycmF5KGNoaWxkcmVuLCBlbGUpOyAvLyByZW1vdmUgcGFyZW50ID0+IGNoaWxkIHJlZlxuXG4gICAgZWxlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7IC8vIHJlbW92ZSBjaGlsZCA9PiBwYXJlbnQgcmVmXG5cbiAgICBpZiAoIWFsdGVyZWRQYXJlbnRzLmlkc1twaWRdKSB7XG4gICAgICBhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSA9IHRydWU7XG4gICAgICBhbHRlcmVkUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuICB9XG4gIHNlbGYuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgIGN5LnJlbW92ZUZyb21Qb29sKGVsZXNUb1JlbW92ZSk7IC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICB9XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIF9lbGU0ID0gZWxlc1RvUmVtb3ZlW19pNl07XG4gICAgaWYgKF9lbGU0LmlzRWRnZSgpKSB7XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgdmFyIHNyYyA9IF9lbGU0LnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHRndCA9IF9lbGU0LnRhcmdldCgpWzBdO1xuICAgICAgcmVtb3ZlRWRnZVJlZihzcmMsIF9lbGU0KTtcbiAgICAgIHJlbW92ZUVkZ2VSZWYodGd0LCBfZWxlNCk7XG4gICAgICB2YXIgcGxsRWRnZXMgPSBfZWxlNC5wYXJhbGxlbEVkZ2VzKCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBsbEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwbGxFZGdlID0gcGxsRWRnZXNbal07XG4gICAgICAgIHJlbW92ZVBhcmFsbGVsUmVmKHBsbEVkZ2UpO1xuICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSBfZWxlNC5wYXJlbnQoKTtcbiAgICAgIGlmIChwYXJlbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgX2VsZTQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgICAgX2VsZTQuX3ByaXZhdGUucmVtb3ZlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaCBvciBub3RcbiAgdmFyIGVsZXNTdGlsbEluc2lkZSA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGVsZXNTdGlsbEluc2lkZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgdmFyIF9lbGU1ID0gZWxlc1N0aWxsSW5zaWRlW19pN107XG4gICAgaWYgKF9lbGU1LmlzUGFyZW50KCkpIHtcbiAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXNUb1JlbW92ZSk7XG4gIGlmIChyZW1vdmVkRWxlbWVudHMuc2l6ZSgpID4gMCkge1xuICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICByZW1vdmVkRWxlbWVudHMuZW1pdEFuZE5vdGlmeSgncmVtb3ZlJyk7XG4gICAgfSBlbHNlIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXQoJ3JlbW92ZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBwYXJlbnRzIHdobyB3ZXJlIG1vZGlmaWVkIGJ5IHRoZSByZW1vdmFsIG5lZWQgdGhlaXIgc3R5bGUgdXBkYXRlZFxuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBhbHRlcmVkUGFyZW50cy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIF9lbGU2ID0gYWx0ZXJlZFBhcmVudHNbX2k4XTtcbiAgICBpZiAoIXJlbW92ZUZyb21Qb29sIHx8ICFfZWxlNi5yZW1vdmVkKCkpIHtcbiAgICAgIF9lbGU2LnVwZGF0ZVN0eWxlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW1vdmVkRWxlbWVudHM7XG59O1xuZWxlc2ZuJDEubW92ZSA9IGZ1bmN0aW9uIChzdHJ1Y3QpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gIC8vIGp1c3QgY2xlYW4gdXAgcmVmcywgY2FjaGVzLCBldGMuIGluIHRoZSBzYW1lIHdheSBhcyB3aGVuIHJlbW92aW5nIGFuZCB0aGVuIHJlc3RvcmluZ1xuICAvLyAob3VyIGNhbGxzIHRvIHJlbW92ZS9yZXN0b3JlIGRvIG5vdCByZW1vdmUgZnJvbSB0aGUgZ3JhcGggb3IgbWFrZSBldmVudHMpXG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGZhbHNlO1xuICB2YXIgbW9kaWZ5UG9vbCA9IGZhbHNlO1xuICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhpZCkge1xuICAgIHJldHVybiBpZCA9PSBudWxsID8gaWQgOiAnJyArIGlkO1xuICB9OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIGlmIChzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNyY0lkID0gdG9TdHJpbmcoc3RydWN0LnNvdXJjZSk7XG4gICAgdmFyIHRndElkID0gdG9TdHJpbmcoc3RydWN0LnRhcmdldCk7XG4gICAgdmFyIHNyY0V4aXN0cyA9IHNyY0lkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZChzcmNJZCk7XG4gICAgdmFyIHRndEV4aXN0cyA9IHRndElkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZCh0Z3RJZCk7XG4gICAgaWYgKHNyY0V4aXN0cyB8fCB0Z3RFeGlzdHMpIHtcbiAgICAgIGN5LmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYXZvaWQgZHVwbGljYXRlIHN0eWxlIHVwZGF0ZXNcbiAgICAgICAgZWxlcy5yZW1vdmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBjbGVhbiB1cCByZWZzIGV0Yy5cbiAgICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfZGF0YTUgPSBlbGUuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICBpZiAoc3JjRXhpc3RzKSB7XG4gICAgICAgICAgICAgIF9kYXRhNS5zb3VyY2UgPSBzcmNJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0Z3RFeGlzdHMpIHtcbiAgICAgICAgICAgICAgX2RhdGE1LnRhcmdldCA9IHRndElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVzLnJlc3RvcmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBtYWtlIG5ldyByZWZzLCBzdHlsZSwgZXRjLlxuICAgICAgfSk7XG4gICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmUnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSB0b1N0cmluZyhzdHJ1Y3QucGFyZW50KTtcbiAgICB2YXIgcGFyZW50RXhpc3RzID0gcGFyZW50SWQgPT09IG51bGwgfHwgY3kuaGFzRWxlbWVudFdpdGhJZChwYXJlbnRJZCk7XG4gICAgaWYgKHBhcmVudEV4aXN0cykge1xuICAgICAgdmFyIHBpZFRvQXNzaWduID0gcGFyZW50SWQgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJlbnRJZDtcbiAgICAgIGN5LmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYXZvaWQgZHVwbGljYXRlIHN0eWxlIHVwZGF0ZXNcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuICAgICAgICB1cGRhdGVkLmVtaXRBbmROb3RpZnkoJ21vdmVvdXQnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9kYXRhNiA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICAgIF9kYXRhNi5wYXJlbnQgPSBwaWRUb0Fzc2lnbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZC5yZXN0b3JlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gbWFrZSBuZXcgcmVmcywgc3R5bGUsIGV0Yy5cbiAgICAgIH0pO1xuICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3ZlJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbltlbGVzZm4kaiwgZWxlc2ZuJGksIGVsZXNmbiRoLCBlbGVzZm4kZywgZWxlc2ZuJGYsIGRhdGEsIGVsZXNmbiRkLCBkaW1lbnNpb25zLCBlbGVzZm4kOSwgZWxlc2ZuJDgsIGVsZXNmbiQ3LCBlbGVzZm4kNiwgZWxlc2ZuJDUsIGVsZXNmbiQ0LCBlbGVzZm4kMywgZWxlc2ZuJDJdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChlbGVzZm4kMSwgcHJvcHMpO1xufSk7XG5cbnZhciBjb3JlZm4kOSA9IHtcbiAgYWRkOiBmdW5jdGlvbiBhZGQob3B0cykge1xuICAgIHZhciBlbGVtZW50cztcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgLy8gYWRkIHRoZSBlbGVtZW50c1xuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdHMpKSB7XG4gICAgICB2YXIgZWxlcyA9IG9wdHM7XG4gICAgICBpZiAoZWxlcy5fcHJpdmF0ZS5jeSA9PT0gY3kpIHtcbiAgICAgICAgLy8gc2FtZSBpbnN0YW5jZSA9PiBqdXN0IHJlc3RvcmVcbiAgICAgICAgZWxlbWVudHMgPSBlbGVzLnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgY29weSBmcm9tIGpzb25cbiAgICAgICAgdmFyIGpzb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIGpzb25zLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgIGVsc2UgaWYgKGFycmF5KG9wdHMpKSB7XG4gICAgICB2YXIgX2pzb25zID0gb3B0cztcbiAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIF9qc29ucyk7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSB2aWEgb3B0cy5ub2RlcyBhbmQgb3B0cy5lZGdlc1xuICAgIGVsc2UgaWYgKHBsYWluT2JqZWN0KG9wdHMpICYmIChhcnJheShvcHRzLm5vZGVzKSB8fCBhcnJheShvcHRzLmVkZ2VzKSkpIHtcbiAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICB2YXIgX2pzb25zMiA9IFtdO1xuICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgaWwgPSBncnMubGVuZ3RoOyBfaSA8IGlsOyBfaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyc1tfaV07XG4gICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG4gICAgICAgIGlmIChhcnJheShlbGVzQXJyYXkpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gZWxlc0FycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBqc29uID0gZXh0ZW5kKHtcbiAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICB9LCBlbGVzQXJyYXlbal0pO1xuICAgICAgICAgICAgX2pzb25zMi5wdXNoKGpzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zMik7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBvcHRpb25zIGZvciBvbmUgZWxlbWVudFxuICAgIGVsc2Uge1xuICAgICAgdmFyIF9qc29uID0gb3B0cztcbiAgICAgIGVsZW1lbnRzID0gbmV3IEVsZW1lbnQoY3ksIF9qc29uKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbikge1xuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24pKSA7IGVsc2UgaWYgKHN0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29sbGVjdGlvbjtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xuXG4vKiEgQmV6aWVyIGN1cnZlIGZ1bmN0aW9uIGdlbmVyYXRvci4gQ29weXJpZ2h0IEdhZXRhbiBSZW5hdWRlYXUuIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5mdW5jdGlvbiBnZW5lcmF0ZUN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICB2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0LFxuICAgIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMSxcbiAgICBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG4gICAgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMCxcbiAgICBrU3BsaW5lVGFibGVTaXplID0gMTEsXG4gICAga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuICAgIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuXG4gIC8qIE11c3QgY29udGFpbiBmb3VyIGFyZ3VtZW50cy4gKi9cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiBBcmd1bWVudHMgbXVzdCBiZSBudW1iZXJzLiAqL1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKGFyZ3VtZW50c1tpXSkgfHwgIWlzRmluaXRlKGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKiBYIHZhbHVlcyBtdXN0IGJlIGluIHRoZSBbMCwgMV0gcmFuZ2UuICovXG4gIG1YMSA9IE1hdGgubWluKG1YMSwgMSk7XG4gIG1YMiA9IE1hdGgubWluKG1YMiwgMSk7XG4gIG1YMSA9IE1hdGgubWF4KG1YMSwgMCk7XG4gIG1YMiA9IE1hdGgubWF4KG1YMiwgMCk7XG4gIHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gIH1cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7XG4gIH1cbiAgZnVuY3Rpb24gQyhhQTEpIHtcbiAgICByZXR1cm4gMy4wICogYUExO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK19pKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwga1NwbGluZVRhYmxlU2l6ZTsgKytfaTIpIHtcbiAgICAgIG1TYW1wbGVWYWx1ZXNbX2kyXSA9IGNhbGNCZXppZXIoX2kyICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCKSB7XG4gICAgdmFyIGN1cnJlbnRYLFxuICAgICAgY3VycmVudFQsXG4gICAgICBpID0gMDtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wLFxuICAgICAgY3VycmVudFNhbXBsZSA9IDEsXG4gICAgICBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSxcbiAgICAgIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCk7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG4gICAgfVxuICB9XG4gIHZhciBfcHJlY29tcHV0ZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgICBfcHJlY29tcHV0ZWQgPSB0cnVlO1xuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgY2FsY1NhbXBsZVZhbHVlcygpO1xuICAgIH1cbiAgfVxuICB2YXIgZiA9IGZ1bmN0aW9uIGYoYVgpIHtcbiAgICBpZiAoIV9wcmVjb21wdXRlZCkge1xuICAgICAgcHJlY29tcHV0ZSgpO1xuICAgIH1cbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiBhWDtcbiAgICB9XG4gICAgaWYgKGFYID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGFYID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoYVgpLCBtWTEsIG1ZMik7XG4gIH07XG4gIGYuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHg6IG1YMSxcbiAgICAgIHk6IG1ZMVxuICAgIH0sIHtcbiAgICAgIHg6IG1YMixcbiAgICAgIHk6IG1ZMlxuICAgIH1dO1xuICB9O1xuICB2YXIgc3RyID0gXCJnZW5lcmF0ZUJlemllcihcIiArIFttWDEsIG1ZMSwgbVgyLCBtWTJdICsgXCIpXCI7XG4gIGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgcmV0dXJuIGY7XG59XG5cbi8qISBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbi8qIEdpdmVuIGEgdGVuc2lvbiwgZnJpY3Rpb24sIGFuZCBkdXJhdGlvbiwgYSBzaW11bGF0aW9uIGF0IDYwRlBTIHdpbGwgZmlyc3QgcnVuIHdpdGhvdXQgYSBkZWZpbmVkIGR1cmF0aW9uIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgZnVsbCBwYXRoLiBBIHNlY29uZCBwYXNzXG4gICB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cbnZhciBnZW5lcmF0ZVNwcmluZ1JLNCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gLXN0YXRlLnRlbnNpb24gKiBzdGF0ZS54IC0gc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52O1xuICB9XG4gIGZ1bmN0aW9uIHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgeDogaW5pdGlhbFN0YXRlLnggKyBkZXJpdmF0aXZlLmR4ICogZHQsXG4gICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgIHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuICAgICAgZnJpY3Rpb246IGluaXRpYWxTdGF0ZS5mcmljdGlvblxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG4gICAgdmFyIGEgPSB7XG4gICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgICB9LFxuICAgICAgYiA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGEpLFxuICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGIpLFxuICAgICAgZCA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQsIGMpLFxuICAgICAgZHhkdCA9IDEuMCAvIDYuMCAqIChhLmR4ICsgMi4wICogKGIuZHggKyBjLmR4KSArIGQuZHgpLFxuICAgICAgZHZkdCA9IDEuMCAvIDYuMCAqIChhLmR2ICsgMi4wICogKGIuZHYgKyBjLmR2KSArIGQuZHYpO1xuICAgIHN0YXRlLnggPSBzdGF0ZS54ICsgZHhkdCAqIGR0O1xuICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgaW5pdFN0YXRlID0ge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgdjogMCxcbiAgICAgICAgdGVuc2lvbjogbnVsbCxcbiAgICAgICAgZnJpY3Rpb246IG51bGxcbiAgICAgIH0sXG4gICAgICBwYXRoID0gWzBdLFxuICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgdG9sZXJhbmNlID0gMSAvIDEwMDAwLFxuICAgICAgRFQgPSAxNiAvIDEwMDAsXG4gICAgICBoYXZlX2R1cmF0aW9uLFxuICAgICAgZHQsXG4gICAgICBsYXN0X3N0YXRlO1xuICAgIHRlbnNpb24gPSBwYXJzZUZsb2F0KHRlbnNpb24pIHx8IDUwMDtcbiAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgbnVsbDtcbiAgICBpbml0U3RhdGUudGVuc2lvbiA9IHRlbnNpb247XG4gICAgaW5pdFN0YXRlLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgaGF2ZV9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSBudWxsO1xuXG4gICAgLyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cbiAgICBpZiAoaGF2ZV9kdXJhdGlvbikge1xuICAgICAgLyogUnVuIHRoZSBzaW11bGF0aW9uIHdpdGhvdXQgYSBkdXJhdGlvbi4gKi9cbiAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG4gICAgICAvKiBDb21wdXRlIHRoZSBhZGp1c3RlZCB0aW1lIGRlbHRhLiAqL1xuICAgICAgZHQgPSB0aW1lX2xhcHNlZCAvIGR1cmF0aW9uICogRFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR0ID0gRFQ7XG4gICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIC8qIE5leHQvc3RlcCBmdW5jdGlvbiAuKi9cbiAgICAgIGxhc3Rfc3RhdGUgPSBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShsYXN0X3N0YXRlIHx8IGluaXRTdGF0ZSwgZHQpO1xuICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuICAgICAgcGF0aC5wdXNoKDEgKyBsYXN0X3N0YXRlLngpO1xuICAgICAgdGltZV9sYXBzZWQgKz0gMTY7XG4gICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cbiAgICAgIGlmICghKE1hdGguYWJzKGxhc3Rfc3RhdGUueCkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMobGFzdF9zdGF0ZS52KSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgIGNvbXB1dGVkIHBhdGggYW5kIHJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gcGVyY2VudENvbXBsZXRlLiAqL1xuICAgIHJldHVybiAhaGF2ZV9kdXJhdGlvbiA/IHRpbWVfbGFwc2VkIDogZnVuY3Rpb24gKHBlcmNlbnRDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHBhdGhbcGVyY2VudENvbXBsZXRlICogKHBhdGgubGVuZ3RoIC0gMSkgfCAwXTtcbiAgICB9O1xuICB9O1xufSgpO1xuXG52YXIgY3ViaWNCZXppZXIgPSBmdW5jdGlvbiBjdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMikge1xuICB2YXIgYmV6aWVyID0gZ2VuZXJhdGVDdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMik7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBiZXppZXIocGVyY2VudCk7XG4gIH07XG59O1xudmFyIGVhc2luZ3MgPSB7XG4gICdsaW5lYXInOiBmdW5jdGlvbiBsaW5lYXIoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBwZXJjZW50O1xuICB9LFxuICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgJ2Vhc2UnOiBjdWJpY0JlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpLFxuICAnZWFzZS1pbic6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDEsIDEpLFxuICAnZWFzZS1vdXQnOiBjdWJpY0JlemllcigwLCAwLCAwLjU4LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0JzogY3ViaWNCZXppZXIoMC40MiwgMCwgMC41OCwgMSksXG4gIC8vIHNpbmVcbiAgJ2Vhc2UtaW4tc2luZSc6IGN1YmljQmV6aWVyKDAuNDcsIDAsIDAuNzQ1LCAwLjcxNSksXG4gICdlYXNlLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC4zOSwgMC41NzUsIDAuNTY1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjQ0NSwgMC4wNSwgMC41NSwgMC45NSksXG4gIC8vIHF1YWRcbiAgJ2Vhc2UtaW4tcXVhZCc6IGN1YmljQmV6aWVyKDAuNTUsIDAuMDg1LCAwLjY4LCAwLjUzKSxcbiAgJ2Vhc2Utb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KSxcbiAgJ2Vhc2UtaW4tb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjQ1NSwgMC4wMywgMC41MTUsIDAuOTU1KSxcbiAgLy8gY3ViaWNcbiAgJ2Vhc2UtaW4tY3ViaWMnOiBjdWJpY0JlemllcigwLjU1LCAwLjA1NSwgMC42NzUsIDAuMTkpLFxuICAnZWFzZS1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpLFxuICAnZWFzZS1pbi1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjY0NSwgMC4wNDUsIDAuMzU1LCAxKSxcbiAgLy8gcXVhcnRcbiAgJ2Vhc2UtaW4tcXVhcnQnOiBjdWJpY0JlemllcigwLjg5NSwgMC4wMywgMC42ODUsIDAuMjIpLFxuICAnZWFzZS1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSksXG4gICdlYXNlLWluLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKSxcbiAgLy8gcXVpbnRcbiAgJ2Vhc2UtaW4tcXVpbnQnOiBjdWJpY0JlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpLFxuICAnZWFzZS1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjIzLCAxLCAwLjMyLCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC44NiwgMCwgMC4wNywgMSksXG4gIC8vIGV4cG9cbiAgJ2Vhc2UtaW4tZXhwbyc6IGN1YmljQmV6aWVyKDAuOTUsIDAuMDUsIDAuNzk1LCAwLjAzNSksXG4gICdlYXNlLW91dC1leHBvJzogY3ViaWNCZXppZXIoMC4xOSwgMSwgMC4yMiwgMSksXG4gICdlYXNlLWluLW91dC1leHBvJzogY3ViaWNCZXppZXIoMSwgMCwgMCwgMSksXG4gIC8vIGNpcmNcbiAgJ2Vhc2UtaW4tY2lyYyc6IGN1YmljQmV6aWVyKDAuNiwgMC4wNCwgMC45OCwgMC4zMzUpLFxuICAnZWFzZS1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSksXG4gICdlYXNlLWluLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC43ODUsIDAuMTM1LCAwLjE1LCAwLjg2KSxcbiAgLy8gdXNlciBwYXJhbSBlYXNpbmdzLi4uXG5cbiAgJ3NwcmluZyc6IGZ1bmN0aW9uIHNwcmluZyh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIC8vIGNhbid0IGdldCBhIHNwcmluZyB3LyBkdXJhdGlvbiAwXG4gICAgICByZXR1cm4gZWFzaW5ncy5saW5lYXI7IC8vIGR1cmF0aW9uIDAgPT4ganVtcCB0byBlbmQgc28gaW1wbCBkb2Vzbid0IG1hdHRlclxuICAgIH1cbiAgICB2YXIgc3ByaW5nID0gZ2VuZXJhdGVTcHJpbmdSSzQodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBzcHJpbmcocGVyY2VudCk7XG4gICAgfTtcbiAgfSxcbiAgJ2N1YmljLWJlemllcic6IGN1YmljQmV6aWVyXG59O1xuXG5mdW5jdGlvbiBnZXRFYXNlZFZhbHVlKHR5cGUsIHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZ0ZuKSB7XG4gIGlmIChwZXJjZW50ID09PSAxKSB7XG4gICAgcmV0dXJuIGVuZDtcbiAgfVxuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiBlbmQ7XG4gIH1cbiAgdmFyIHZhbCA9IGVhc2luZ0ZuKHN0YXJ0LCBlbmQsIHBlcmNlbnQpO1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZS5yb3VuZFZhbHVlIHx8IHR5cGUuY29sb3IpIHtcbiAgICB2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG4gIH1cbiAgaWYgKHR5cGUubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBNYXRoLm1heCh2YWwsIHR5cGUubWluKTtcbiAgfVxuICBpZiAodHlwZS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IE1hdGgubWluKHZhbCwgdHlwZS5tYXgpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShwcm9wLCBzcGVjKSB7XG4gIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBwcm9wLnZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwgJiYgKHNwZWMgPT0gbnVsbCB8fCBzcGVjLnR5cGUudW5pdHMgIT09ICclJykpIHtcbiAgICAgIHJldHVybiBwcm9wLnBmVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcm9wLnZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufVxuZnVuY3Rpb24gZWFzZShzdGFydFByb3AsIGVuZFByb3AsIHBlcmNlbnQsIGVhc2luZ0ZuLCBwcm9wU3BlYykge1xuICB2YXIgdHlwZSA9IHByb3BTcGVjICE9IG51bGwgPyBwcm9wU3BlYy50eXBlIDogbnVsbDtcbiAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgcGVyY2VudCA9IDA7XG4gIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfVxuICB2YXIgc3RhcnQgPSBnZXRWYWx1ZShzdGFydFByb3AsIHByb3BTcGVjKTtcbiAgdmFyIGVuZCA9IGdldFZhbHVlKGVuZFByb3AsIHByb3BTcGVjKTtcbiAgaWYgKG51bWJlciQxKHN0YXJ0KSAmJiBudW1iZXIkMShlbmQpKSB7XG4gICAgcmV0dXJuIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pO1xuICB9IGVsc2UgaWYgKGFycmF5KHN0YXJ0KSAmJiBhcnJheShlbmQpKSB7XG4gICAgdmFyIGVhc2VkQXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzaSA9IHN0YXJ0W2ldO1xuICAgICAgdmFyIGVpID0gZW5kW2ldO1xuICAgICAgaWYgKHNpICE9IG51bGwgJiYgZWkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgdmFsID0gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzaSwgZWksIHBlcmNlbnQsIGVhc2luZ0ZuKTtcbiAgICAgICAgZWFzZWRBcnIucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZWRBcnIucHVzaChlaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlYXNlZEFycjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzdGVwJDEoc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICB2YXIgcEVhc2luZyA9IGFuaV9wLmVhc2luZztcbiAgdmFyIHN0YXJ0VGltZSA9IGFuaV9wLnN0YXJ0VGltZTtcbiAgdmFyIGN5ID0gaXNDb3JlID8gc2VsZiA6IHNlbGYuY3koKTtcbiAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgaWYgKCFhbmlfcC5lYXNpbmdJbXBsKSB7XG4gICAgaWYgKHBFYXNpbmcgPT0gbnVsbCkge1xuICAgICAgLy8gdXNlIGRlZmF1bHRcbiAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWydsaW5lYXInXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBkZWZpbmUgdy8gbmFtZVxuICAgICAgdmFyIGVhc2luZ1ZhbHM7XG4gICAgICBpZiAoc3RyaW5nKHBFYXNpbmcpKSB7XG4gICAgICAgIHZhciBlYXNpbmdQcm9wID0gc3R5bGUucGFyc2UoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgcEVhc2luZyk7XG4gICAgICAgIGVhc2luZ1ZhbHMgPSBlYXNpbmdQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBhc3N1bWUgcHJlcGFyc2VkIGFycmF5XG4gICAgICAgIGVhc2luZ1ZhbHMgPSBwRWFzaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5hbWUsIGFyZ3M7XG4gICAgICBpZiAoc3RyaW5nKGVhc2luZ1ZhbHMpKSB7XG4gICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzO1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZWFzaW5nVmFsc1sxXTtcbiAgICAgICAgYXJncyA9IGVhc2luZ1ZhbHMuc2xpY2UoMikubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuICtuO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gY3JlYXRlIHdpdGggYXJnc1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3NwcmluZycpIHtcbiAgICAgICAgICBhcmdzLnB1c2goYW5pX3AuZHVyYXRpb24pOyAvLyBuZWVkIGR1cmF0aW9uIHRvIGdlbmVyYXRlIHNwcmluZ1xuICAgICAgICB9XG4gICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzW25hbWVdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RhdGljIGltcGwgYnkgbmFtZVxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGVhc2luZyA9IGFuaV9wLmVhc2luZ0ltcGw7XG4gIHZhciBwZXJjZW50O1xuICBpZiAoYW5pX3AuZHVyYXRpb24gPT09IDApIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwZXJjZW50ID0gKG5vdyAtIHN0YXJ0VGltZSkgLyBhbmlfcC5kdXJhdGlvbjtcbiAgfVxuICBpZiAoYW5pX3AuYXBwbHlpbmcpIHtcbiAgICBwZXJjZW50ID0gYW5pX3AucHJvZ3Jlc3M7XG4gIH1cbiAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgcGVyY2VudCA9IDA7XG4gIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfVxuICBpZiAoYW5pX3AuZGVsYXkgPT0gbnVsbCkge1xuICAgIC8vIHRoZW4gdXBkYXRlXG5cbiAgICB2YXIgc3RhcnRQb3MgPSBhbmlfcC5zdGFydFBvc2l0aW9uO1xuICAgIHZhciBlbmRQb3MgPSBhbmlfcC5wb3NpdGlvbjtcbiAgICBpZiAoZW5kUG9zICYmIGlzRWxlcyAmJiAhc2VsZi5sb2NrZWQoKSkge1xuICAgICAgdmFyIG5ld1BvcyA9IHt9O1xuICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLngsIGVuZFBvcy54KSkge1xuICAgICAgICBuZXdQb3MueCA9IGVhc2Uoc3RhcnRQb3MueCwgZW5kUG9zLngsIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWQoc3RhcnRQb3MueSwgZW5kUG9zLnkpKSB7XG4gICAgICAgIG5ld1Bvcy55ID0gZWFzZShzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cbiAgICAgIHNlbGYucG9zaXRpb24obmV3UG9zKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0UGFuID0gYW5pX3Auc3RhcnRQYW47XG4gICAgdmFyIGVuZFBhbiA9IGFuaV9wLnBhbjtcbiAgICB2YXIgcGFuID0gX3AucGFuO1xuICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgaWYgKGFuaW1hdGluZ1Bhbikge1xuICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLngsIGVuZFBhbi54KSkge1xuICAgICAgICBwYW4ueCA9IGVhc2Uoc3RhcnRQYW4ueCwgZW5kUGFuLngsIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueSwgZW5kUGFuLnkpKSB7XG4gICAgICAgIHBhbi55ID0gZWFzZShzdGFydFBhbi55LCBlbmRQYW4ueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdCgncGFuJyk7XG4gICAgfVxuICAgIHZhciBzdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb207XG4gICAgdmFyIGVuZFpvb20gPSBhbmlfcC56b29tO1xuICAgIHZhciBhbmltYXRpbmdab29tID0gZW5kWm9vbSAhPSBudWxsICYmIGlzQ29yZTtcbiAgICBpZiAoYW5pbWF0aW5nWm9vbSkge1xuICAgICAgaWYgKHZhbGlkKHN0YXJ0Wm9vbSwgZW5kWm9vbSkpIHtcbiAgICAgICAgX3Auem9vbSA9IGJvdW5kKF9wLm1pblpvb20sIGVhc2Uoc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50LCBlYXNpbmcpLCBfcC5tYXhab29tKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdCgnem9vbScpO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW5nUGFuIHx8IGFuaW1hdGluZ1pvb20pIHtcbiAgICAgIHNlbGYuZW1pdCgndmlld3BvcnQnKTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gYW5pX3Auc3R5bGU7XG4gICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDAgJiYgaXNFbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIGVuZCA9IHByb3A7XG4gICAgICAgIHZhciBzdGFydCA9IGFuaV9wLnN0YXJ0U3R5bGVbX25hbWVdO1xuICAgICAgICB2YXIgcHJvcFNwZWMgPSBzdHlsZS5wcm9wZXJ0aWVzW3N0YXJ0Lm5hbWVdO1xuICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZywgcHJvcFNwZWMpO1xuICAgICAgICBzdHlsZS5vdmVycmlkZUJ5cGFzcyhzZWxmLCBfbmFtZSwgZWFzZWRWYWwpO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgc2VsZi5lbWl0KCdzdHlsZScpO1xuICAgIH0gLy8gaWZcbiAgfVxuICBhbmlfcC5wcm9ncmVzcyA9IHBlcmNlbnQ7XG4gIHJldHVybiBwZXJjZW50O1xufVxuZnVuY3Rpb24gdmFsaWQoc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobnVtYmVyJDEoc3RhcnQpICYmIG51bWJlciQxKGVuZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKHNlbGYsIGFuaSwgbm93LCBpc0NvcmUpIHtcbiAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICBhbmlfcC5zdGFydGVkID0gdHJ1ZTtcbiAgYW5pX3Auc3RhcnRUaW1lID0gbm93IC0gYW5pX3AucHJvZ3Jlc3MgKiBhbmlfcC5kdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gc3RlcEFsbChub3csIGN5KSB7XG4gIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuYW5pRWxlcztcbiAgdmFyIGRvbmVFbGVzID0gW107XG4gIGZ1bmN0aW9uIHN0ZXBPbmUoZWxlLCBpc0NvcmUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICB2YXIgcXVldWUgPSBfcC5hbmltYXRpb24ucXVldWU7XG4gICAgdmFyIHJhbkFuaXMgPSBmYWxzZTtcblxuICAgIC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIG5leHQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24gY2FsbGJhY2tzKF9jYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSBfY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBjYiA9IF9jYWxsYmFja3Nbal07XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tzLnNwbGljZSgwLCBfY2FsbGJhY2tzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhbmkgPSBjdXJyZW50W2ldO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgICAgaWYgKGFuaV9wLnN0b3BwZWQpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhbmlfcC5wbGF5aW5nICYmICFhbmlfcC5hcHBseWluZykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYW4gYXBwbHkoKSB3aGlsZSBwbGF5aW5nIHNob3VsZG4ndCBkbyBhbnl0aGluZ1xuICAgICAgaWYgKGFuaV9wLnBsYXlpbmcgJiYgYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghYW5pX3Auc3RhcnRlZCkge1xuICAgICAgICBzdGFydEFuaW1hdGlvbihlbGUsIGFuaSwgbm93KTtcbiAgICAgIH1cbiAgICAgIHN0ZXAkMShlbGUsIGFuaSwgbm93LCBpc0NvcmUpO1xuICAgICAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcbiAgICAgIGlmIChhbmlfcC5zdGVwICE9IG51bGwpIHtcbiAgICAgICAgYW5pX3Auc3RlcChub3cpO1xuICAgICAgfVxuICAgICAgaWYgKGFuaS5jb21wbGV0ZWQoKSkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFja3MoYW5pX3AuY29tcGxldGVzKTtcbiAgICAgIH1cbiAgICAgIHJhbkFuaXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvbmVFbGVzLnB1c2goZWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbkFuaXM7XG4gIH0gLy8gc3RlcEVsZW1lbnRcblxuICAvLyBoYW5kbGUgYWxsIGVsZXNcbiAgdmFyIHJhbkVsZUFuaSA9IGZhbHNlO1xuICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcbiAgICB2YXIgaGFuZGxlZFRoaXNFbGUgPSBzdGVwT25lKGVsZSk7XG4gICAgcmFuRWxlQW5pID0gcmFuRWxlQW5pIHx8IGhhbmRsZWRUaGlzRWxlO1xuICB9IC8vIGVhY2ggZWxlbWVudFxuXG4gIHZhciByYW5Db3JlQW5pID0gc3RlcE9uZShjeSwgdHJ1ZSk7XG5cbiAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gIGlmIChyYW5FbGVBbmkgfHwgcmFuQ29yZUFuaSkge1xuICAgIGlmIChlbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycsIGVsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeS5ub3RpZnkoJ2RyYXcnKTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcbiAgZWxlcy51bm1lcmdlKGRvbmVFbGVzKTtcbiAgY3kuZW1pdCgnc3RlcCcpO1xufSAvLyBzdGVwQWxsXG5cbnZhciBjb3JlZm4kOCA9IHtcbiAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpLFxuICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uIGFkZFRvQW5pbWF0aW9uUG9vbChlbGVzKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoZWxlcyk7XG4gIH0sXG4gIHN0b3BBbmltYXRpb25Mb29wOiBmdW5jdGlvbiBzdG9wQW5pbWF0aW9uTG9vcCgpIHtcbiAgICB0aGlzLl9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gZmFsc2U7XG4gIH0sXG4gIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RhcnRBbmltYXRpb25Mb29wKCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG4gICAgLy8gTkIgdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgZXhlYyBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMgaWYgc3R5bGUgZW5hYmxlZFxuICAgIC8vIGFuZCBleHBsaWNpdCBjeS5kZXN0cm95KCkgaXMgbmVjZXNzYXJ5IHRvIHN0b3AgdGhlIGxvb3BcblxuICAgIGZ1bmN0aW9uIGhlYWRsZXNzU3RlcCgpIHtcbiAgICAgIGlmICghY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGlvblN0ZXAobm93KSB7XG4gICAgICAgIHN0ZXBBbGwobm93LCBjeSk7XG4gICAgICAgIGhlYWRsZXNzU3RlcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG4gICAgaWYgKHJlbmRlcmVyICYmIHJlbmRlcmVyLmJlZm9yZVJlbmRlcikge1xuICAgICAgLy8gbGV0IHRoZSByZW5kZXJlciBzY2hlZHVsZSBhbmltYXRpb25zXG4gICAgICByZW5kZXJlci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gcmVuZGVyZXJBbmltYXRpb25TdGVwKHdpbGxEcmF3LCBub3cpIHtcbiAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgIH0sIHJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuYW5pbWF0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1hbmFnZSB0aGUgYW5pbWF0aW9uIGxvb3Agb3Vyc2VsdmVzXG4gICAgICBoZWFkbGVzc1N0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgIH1cbiAgfVxufTtcblxudmFyIGVtaXR0ZXJPcHRpb25zID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHNlbGVjdG9yMSwgc2VsZWN0b3IyKSB7XG4gICAgaWYgKHNlbGVjdG9yMSA9PSBudWxsIHx8IHNlbGVjdG9yMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxID09IG51bGwgJiYgc2VsZWN0b3IyID09IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEuc2FtZVRleHQoc2VsZWN0b3IyKTtcbiAgICB9XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGN5LCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBsaXN0ZW5lci5xdWFsaWZpZXI7XG4gICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjeSAhPT0gZXZlbnRPYmoudGFyZ2V0ICYmIGVsZW1lbnQoZXZlbnRPYmoudGFyZ2V0KSAmJiBzZWxlY3Rvci5tYXRjaGVzKGV2ZW50T2JqLnRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoY3ksIGV2dCkge1xuICAgIGV2dC5jeSA9IGN5O1xuICAgIGV2dC50YXJnZXQgPSBjeTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGN5O1xuICB9XG59O1xudmFyIGFyZ1NlbGVjdG9yID0gZnVuY3Rpb24gYXJnU2VsZWN0b3IoYXJnKSB7XG4gIGlmIChzdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0b3IoYXJnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG59O1xudmFyIGVsZXNmbiA9IHtcbiAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgfSxcbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdEFuZE5vdGlmeTogZnVuY3Rpb24gZW1pdEFuZE5vdGlmeShldmVudCwgZWxlcykge1xuICAgIHRoaXMuZW1pdChldmVudCk7XG4gICAgdGhpcy5ub3RpZnkoZXZlbnQsIGVsZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuZGVmaW5lLmV2ZW50QWxpYXNlc09uKGVsZXNmbik7XG5cbnZhciBjb3JlZm4kNyA9IHtcbiAgcG5nOiBmdW5jdGlvbiBwbmcob3B0aW9ucykge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHJlbmRlcmVyLnBuZyhvcHRpb25zKTtcbiAgfSxcbiAganBnOiBmdW5jdGlvbiBqcGcob3B0aW9ucykge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuICAgIHJldHVybiByZW5kZXJlci5qcGcob3B0aW9ucyk7XG4gIH1cbn07XG5jb3JlZm4kNy5qcGVnID0gY29yZWZuJDcuanBnO1xuXG52YXIgY29yZWZuJDYgPSB7XG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGVycm9yKCdMYXlvdXQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdmFyIExheW91dCA9IGN5LmV4dGVuc2lvbignbGF5b3V0JywgbmFtZSk7XG4gICAgaWYgKExheW91dCA9PSBudWxsKSB7XG4gICAgICBlcnJvcignTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQuICBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0PycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZWxlcztcbiAgICBpZiAoc3RyaW5nKG9wdGlvbnMuZWxlcykpIHtcbiAgICAgIGVsZXMgPSBjeS4kKG9wdGlvbnMuZWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IGN5LiQoKTtcbiAgICB9XG4gICAgdmFyIGxheW91dCA9IG5ldyBMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBjeTogY3ksXG4gICAgICBlbGVzOiBlbGVzXG4gICAgfSkpO1xuICAgIHJldHVybiBsYXlvdXQ7XG4gIH1cbn07XG5jb3JlZm4kNi5jcmVhdGVMYXlvdXQgPSBjb3JlZm4kNi5tYWtlTGF5b3V0ID0gY29yZWZuJDYubGF5b3V0O1xuXG52YXIgY29yZWZuJDUgPSB7XG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KGV2ZW50TmFtZSwgZXZlbnRFbGVzKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAodGhpcy5iYXRjaGluZygpKSB7XG4gICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgfHwge307XG4gICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gfHwgdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBpZiAoZXZlbnRFbGVzICE9IG51bGwpIHtcbiAgICAgICAgZWxlcy5tZXJnZShldmVudEVsZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICB9XG4gICAgaWYgKCFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuXG4gICAgLy8gZXhpdCBpZiBkZXN0cm95KCkgY2FsbGVkIG9uIGNvcmUgb3IgcmVuZGVyZXIgaW4gYmV0d2VlbiBmcmFtZXMgIzE0OTkgIzE1MjhcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQoKSB8fCAhcmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVuZGVyZXIubm90aWZ5KGV2ZW50TmFtZSwgZXZlbnRFbGVzKTtcbiAgfSxcbiAgbm90aWZpY2F0aW9uczogZnVuY3Rpb24gbm90aWZpY2F0aW9ucyhib29sKSB7XG4gICAgdmFyIHAgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24gbm9Ob3RpZmljYXRpb25zKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgfSxcbiAgYmF0Y2hpbmc6IGZ1bmN0aW9uIGJhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJhdGNoQ291bnQgPiAwO1xuICB9LFxuICBzdGFydEJhdGNoOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT0gbnVsbCkge1xuICAgICAgX3AuYmF0Y2hDb3VudCA9IDA7XG4gICAgfVxuICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcyA9IHRoaXMuY29sbGVjdGlvbigpO1xuICAgICAgX3AuYmF0Y2hOb3RpZmljYXRpb25zID0ge307XG4gICAgfVxuICAgIF9wLmJhdGNoQ291bnQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfcC5iYXRjaENvdW50LS07XG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMudXBkYXRlU3R5bGUoKTtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTtcblxuICAgICAgLy8gbm90aWZ5IHRoZSByZW5kZXJlciBvZiBxdWV1ZWQgZWxlcyBhbmQgZXZlbnQgdHlwZXNcbiAgICAgIE9iamVjdC5rZXlzKF9wLmJhdGNoTm90aWZpY2F0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBlbGVzID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV07XG4gICAgICAgIGlmIChlbGVzLmVtcHR5KCkpIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBlbGVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBiYXRjaDogZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGJhdGNoRGF0YTogZnVuY3Rpb24gYmF0Y2hEYXRhKG1hcCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gbWFwW2lkXTtcbiAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgZWxlLmRhdGEoZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciByZW5kZXJlckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIGhpZGVFZGdlc09uVmlld3BvcnQ6IGZhbHNlLFxuICB0ZXh0dXJlT25WaWV3cG9ydDogZmFsc2UsXG4gIG1vdGlvbkJsdXI6IGZhbHNlLFxuICBtb3Rpb25CbHVyT3BhY2l0eTogMC4wNSxcbiAgcGl4ZWxSYXRpbzogdW5kZWZpbmVkLFxuICBkZXNrdG9wVGFwVGhyZXNob2xkOiA0LFxuICB0b3VjaFRhcFRocmVzaG9sZDogOCxcbiAgd2hlZWxTZW5zaXRpdml0eTogMSxcbiAgZGVidWc6IGZhbHNlLFxuICBzaG93RnBzOiBmYWxzZSxcbiAgLy8gd2ViZ2wgb3B0aW9uc1xuICB3ZWJnbDogZmFsc2UsXG4gIHdlYmdsRGVidWc6IGZhbHNlLFxuICB3ZWJnbERlYnVnU2hvd0F0bGFzZXM6IGZhbHNlLFxuICAvLyBkZWZhdWx0cyBnb29kIGZvciBtb2JpbGVcbiAgd2ViZ2xUZXhTaXplOiAyMDQ4LFxuICB3ZWJnbFRleFJvd3M6IDM2LFxuICB3ZWJnbFRleFJvd3NOb2RlczogMTgsXG4gIHdlYmdsQmF0Y2hTaXplOiAyMDQ4LFxuICB3ZWJnbFRleFBlckJhdGNoOiAxNCxcbiAgd2ViZ2xCZ0NvbG9yOiBbMjU1LCAyNTUsIDI1NV1cbn0pO1xudmFyIGNvcmVmbiQ0ID0ge1xuICByZW5kZXJUbzogZnVuY3Rpb24gcmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gICAgdmFyIHIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIHIucmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVuZGVyZXI6IGZ1bmN0aW9uIHJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICB9LFxuICBmb3JjZVJlbmRlcjogZnVuY3Rpb24gZm9yY2VSZW5kZXIoKSB7XG4gICAgdGhpcy5ub3RpZnkoJ2RyYXcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgncmVzaXplJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGluaXRSZW5kZXJlcjogZnVuY3Rpb24gaW5pdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBSZW5kZXJlclByb3RvID0gY3kuZXh0ZW5zaW9uKCdyZW5kZXJlcicsIG9wdGlvbnMubmFtZSk7XG4gICAgaWYgKFJlbmRlcmVyUHJvdG8gPT0gbnVsbCkge1xuICAgICAgZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYFwiLmNvbmNhdChvcHRpb25zLm5hbWUsIFwiYCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD9cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdhcm4oXCJZb3UgaGF2ZSBzZXQgYSBjdXN0b20gd2hlZWwgc2Vuc2l0aXZpdHkuICBUaGlzIHdpbGwgbWFrZSB5b3VyIGFwcCB6b29tIHVubmF0dXJhbGx5IHdoZW4gdXNpbmcgbWFpbnN0cmVhbSBtaWNlLiAgWW91IHNob3VsZCBjaGFuZ2UgdGhpcyB2YWx1ZSBmcm9tIHRoZSBkZWZhdWx0IG9ubHkgaWYgeW91IGNhbiBndWFyYW50ZWUgdGhhdCBhbGwgeW91ciB1c2VycyB3aWxsIHVzZSB0aGUgc2FtZSBoYXJkd2FyZSBhbmQgT1MgY29uZmlndXJhdGlvbiBhcyB5b3VyIGN1cnJlbnQgbWFjaGluZS5cIik7XG4gICAgfVxuICAgIHZhciByT3B0cyA9IHJlbmRlcmVyRGVmYXVsdHMob3B0aW9ucyk7XG4gICAgck9wdHMuY3kgPSBjeTtcbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKHJPcHRzKTtcbiAgICB0aGlzLm5vdGlmeSgnaW5pdCcpO1xuICB9LFxuICBkZXN0cm95UmVuZGVyZXI6IGZ1bmN0aW9uIGRlc3Ryb3lSZW5kZXJlcigpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGN5Lm5vdGlmeSgnZGVzdHJveScpOyAvLyBkZXN0cm95IHRoZSByZW5kZXJlclxuXG4gICAgdmFyIGRvbUVsZSA9IGN5LmNvbnRhaW5lcigpO1xuICAgIGlmIChkb21FbGUpIHtcbiAgICAgIGRvbUVsZS5fY3lyZWcgPSBudWxsO1xuICAgICAgd2hpbGUgKGRvbUVsZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZG9tRWxlLnJlbW92ZUNoaWxkKGRvbUVsZS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBudWxsOyAvLyB0byBiZSBleHRyYSBzYWZlLCByZW1vdmUgdGhlIHJlZlxuICAgIGN5Lm11dGFibGVFbGVtZW50cygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgX3AucnNjcmF0Y2ggPSB7fTtcbiAgICAgIF9wLnJzdHlsZSA9IHt9O1xuICAgICAgX3AuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgIH0pO1xuICB9LFxuICBvblJlbmRlcjogZnVuY3Rpb24gb25SZW5kZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbigncmVuZGVyJywgZm4pO1xuICB9LFxuICBvZmZSZW5kZXI6IGZ1bmN0aW9uIG9mZlJlbmRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9mZigncmVuZGVyJywgZm4pO1xuICB9XG59O1xuY29yZWZuJDQuaW52YWxpZGF0ZURpbWVuc2lvbnMgPSBjb3JlZm4kNC5yZXNpemU7XG5cbnZhciBjb3JlZm4kMyA9IHtcbiAgLy8gZ2V0IGEgY29sbGVjdGlvblxuICAvLyAtIGVtcHR5IGNvbGxlY3Rpb24gb24gbm8gYXJnc1xuICAvLyAtIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgaW4gdGhlIGdyYXBoIG9uIHNlbGVjdG9yIGFyZ1xuICAvLyAtIGd1YXJhbnRlZSBhIHJldHVybmVkIGNvbGxlY3Rpb24gd2hlbiBlbGVtZW50cyBvciBjb2xsZWN0aW9uIHNwZWNpZmllZFxuICBjb2xsZWN0aW9uOiBmdW5jdGlvbiBjb2xsZWN0aW9uKGVsZXMsIG9wdHMpIHtcbiAgICBpZiAoc3RyaW5nKGVsZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy4kKGVsZXMpO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihlbGVzKSkge1xuICAgICAgcmV0dXJuIGVsZXMuY29sbGVjdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoZWxlcykpIHtcbiAgICAgIGlmICghb3B0cykge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcywgZWxlcywgb3B0cy51bmlxdWUsIG9wdHMucmVtb3ZlZCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzKTtcbiAgfSxcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9LFxuICBlZGdlczogZnVuY3Rpb24gZWRnZXMoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0VkZ2UoKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXM7XG4gIH0sXG4gIC8vIHNlYXJjaCB0aGUgZ3JhcGggbGlrZSBqUXVlcnlcbiAgJDogZnVuY3Rpb24gJChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBlbGVzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVzLnNwYXduU2VsZigpO1xuICAgIH1cbiAgfSxcbiAgbXV0YWJsZUVsZW1lbnRzOiBmdW5jdGlvbiBtdXRhYmxlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gIH1cbn07XG5cbi8vIGFsaWFzZXNcbmNvcmVmbiQzLmVsZW1lbnRzID0gY29yZWZuJDMuZmlsdGVyID0gY29yZWZuJDMuJDtcblxudmFyIHN0eWZuJDggPSB7fTtcblxuLy8ga2V5cyBmb3Igc3R5bGUgYmxvY2tzLCBlLmcuIHR0ZmZ0dFxudmFyIFRSVUUgPSAndCc7XG52YXIgRkFMU0UgPSAnZic7XG5cbi8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4vLyBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb25cbi8vIC0gaXRzIGJ5cGFzc1xuLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuc3R5Zm4kOC5hcHBseSA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgdmFyIGN5ID0gX3AuY3k7XG4gIHZhciB1cGRhdGVkRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgZm9yICh2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaWVdO1xuICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YShlbGUpO1xuICAgIGlmIChjeHRNZXRhLmVtcHR5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGN4dFN0eWxlID0gc2VsZi5nZXRDb250ZXh0U3R5bGUoY3h0TWV0YSk7XG4gICAgdmFyIGFwcCA9IHNlbGYuYXBwbHlDb250ZXh0U3R5bGUoY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSk7XG4gICAgaWYgKGVsZS5fcHJpdmF0ZS5hcHBsaWVkSW5pdFN0eWxlKSB7XG4gICAgICBzZWxmLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgYXBwLmRpZmZQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZS5fcHJpdmF0ZS5hcHBsaWVkSW5pdFN0eWxlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGhpbnRzRGlmZiA9IHNlbGYudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIGlmIChoaW50c0RpZmYpIHtcbiAgICAgIHVwZGF0ZWRFbGVzLnB1c2goZWxlKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZW1lbnRzXG5cbiAgcmV0dXJuIHVwZGF0ZWRFbGVzO1xufTtcbnN0eWZuJDguZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiAob2xkQ3h0S2V5LCBuZXdDeHRLZXkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2R1YWxDeHRLZXldO1xuICBpZiAoY2FjaGVkVmFsKSB7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuICB2YXIgZGlmZlByb3BzID0gW107XG4gIHZhciBhZGRlZFByb3AgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIG9sZEhhc0N4dCA9IG9sZEN4dEtleVtpXSA9PT0gVFJVRTtcbiAgICB2YXIgbmV3SGFzQ3h0ID0gbmV3Q3h0S2V5W2ldID09PSBUUlVFO1xuICAgIHZhciBjeHRIYXNEaWZmZWQgPSBvbGRIYXNDeHQgIT09IG5ld0hhc0N4dDtcbiAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuICAgIGlmIChjeHRIYXNEaWZmZWQgfHwgbmV3SGFzQ3h0ICYmIGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICB2YXIgcHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgIH0gZWxzZSBpZiAoY3h0SGFzRGlmZmVkKSB7XG4gICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgIH0gZWxzZSBpZiAoY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllczsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG1hcHBlZFxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcblxuICAgICAgICAvLyBpZiBhIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzIHRoaXMgcHJvcGVydHksIHRoZW4gdGhlIGZhY3QgdGhhdCB0aGlzIGNvbnRleHQgaGFzIHN3aXRjaGVkL2RpZmZlZCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAvLyAoc2VtaSBleHBlbnNpdmUgY2hlY2sgc2luY2UgaXQgbWFrZXMgdGhpcyBmdW5jdGlvbiBPKG5eMikgb24gY29udGV4dCBsZW5ndGgsIGJ1dCB3b3J0aCBpdCBzaW5jZSBvdmVyYWxsIHJlc3VsdFxuICAgICAgICAvLyBpcyBjYWNoZWQpXG4gICAgICAgIHZhciBsYXRlckN4dE92ZXJyaWRlcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGxhdGVyQ3h0ID0gc2VsZltrXTtcbiAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlba10gPT09IFRSVUU7XG4gICAgICAgICAgaWYgKCFoYXNMYXRlckN4dCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cbiAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbcHJvcC5uYW1lXSAhPSBudWxsO1xuICAgICAgICAgIGlmIChsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhZGRlZFByb3BbbmFtZV0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzKSB7XG4gICAgICAgICAgYWRkZWRQcm9wW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBkaWZmUHJvcHMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgcHJvcHNcbiAgICB9IC8vIGlmXG4gIH0gLy8gZm9yIGNvbnRleHRzXG5cbiAgY2FjaGVbZHVhbEN4dEtleV0gPSBkaWZmUHJvcHM7XG4gIHJldHVybiBkaWZmUHJvcHM7XG59O1xuc3R5Zm4kOC5nZXRDb250ZXh0TWV0YSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0S2V5ID0gJyc7XG4gIHZhciBkaWZmUHJvcHM7XG4gIHZhciBwcmV2S2V5ID0gZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5IHx8ICcnO1xuXG4gIC8vIGdldCB0aGUgY3h0IGtleVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHNlbGZbaV07XG4gICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyhlbGUpOyAvLyBOQjogY29udGV4dC5zZWxlY3RvciBtYXkgYmUgbnVsbCBmb3IgJ2NvcmUnXG5cbiAgICBpZiAoY29udGV4dFNlbGVjdG9yTWF0Y2hlcykge1xuICAgICAgY3h0S2V5ICs9IFRSVUU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN4dEtleSArPSBGQUxTRTtcbiAgICB9XG4gIH0gLy8gZm9yIGNvbnRleHRcblxuICBkaWZmUHJvcHMgPSBzZWxmLmdldFByb3BlcnRpZXNEaWZmKHByZXZLZXksIGN4dEtleSk7XG4gIGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSA9IGN4dEtleTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGN4dEtleSxcbiAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHMsXG4gICAgZW1wdHk6IGRpZmZQcm9wcy5sZW5ndGggPT09IDBcbiAgfTtcbn07XG5cbi8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcbnN0eWZuJDguZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24gKGN4dE1ldGEpIHtcbiAgdmFyIGN4dEtleSA9IGN4dE1ldGEua2V5O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307XG5cbiAgLy8gaWYgYWxyZWFkeSBjb21wdXRlZCBzdHlsZSwgcmV0dXJuZWQgY2FjaGVkIGNvcHlcbiAgaWYgKGN4dFN0eWxlc1tjeHRLZXldKSB7XG4gICAgcmV0dXJuIGN4dFN0eWxlc1tjeHRLZXldO1xuICB9XG4gIHZhciBzdHlsZSA9IHtcbiAgICBfcHJpdmF0ZToge1xuICAgICAga2V5OiBjeHRLZXlcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgIHZhciBoYXNDeHQgPSBjeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgaWYgKCFoYXNDeHQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN4dC5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IGN4dC5wcm9wZXJ0aWVzW2pdO1xuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgfVxuICB9XG4gIGN4dFN0eWxlc1tjeHRLZXldID0gc3R5bGU7XG4gIHJldHVybiBzdHlsZTtcbn07XG5zdHlmbiQ4LmFwcGx5Q29udGV4dFN0eWxlID0gZnVuY3Rpb24gKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGlmZlByb3BzID0gY3h0TWV0YS5kaWZmUHJvcE5hbWVzO1xuICB2YXIgcmV0RGlmZlByb3BzID0ge307XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpZmZQcm9wTmFtZSA9IGRpZmZQcm9wc1tpXTtcbiAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlW2RpZmZQcm9wTmFtZV07XG4gICAgdmFyIGVsZVByb3AgPSBlbGUucHN0eWxlKGRpZmZQcm9wTmFtZSk7XG4gICAgaWYgKCFjeHRQcm9wKSB7XG4gICAgICAvLyBubyBjb250ZXh0IHByb3AgbWVhbnMgZGVsZXRlXG4gICAgICBpZiAoIWVsZVByb3ApIHtcbiAgICAgICAgY29udGludWU7IC8vIG5vIGV4aXN0aW5nIHByb3AgbWVhbnMgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIC8vIG5iIGFmZmVjdHMgaW5pdGlhbCBhcHBsaWNhdGlvbiBvbiBtYXBwZWQgdmFsdWVzIGxpa2UgY29udHJvbC1wb2ludC1kaXN0YW5jZXNcbiAgICAgIH0gZWxzZSBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgZGVsZXRlQnlwYXNzZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dFByb3AgPSB7XG4gICAgICAgICAgbmFtZTogZGlmZlByb3BOYW1lLFxuICAgICAgICAgIFwiZGVsZXRlXCI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyB3aGVuIHRoZSBjb250ZXh0IHByb3AgZG9lc24ndCBuZWVkIHRvIGJlIGFwcGxpZWRcbiAgICBpZiAoZWxlUHJvcCA9PT0gY3h0UHJvcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gc2F2ZSBjeWNsZXMgd2hlbiBhIG1hcHBlZCBjb250ZXh0IHByb3AgZG9lc24ndCBuZWVkIHRvIGJlIGFwcGxpZWRcbiAgICBpZiAoY3h0UHJvcC5tYXBwZWQgPT09IHR5cGVzLmZuIC8vIGNvbnRleHQgcHJvcCBpcyBmdW5jdGlvbiBtYXBwZXJcbiAgICAmJiBlbGVQcm9wICE9IG51bGwgLy8gc29tZSBwcm9wcyBjYW4gYmUgbnVsbCBldmVuIGJ5IGRlZmF1bHQgKGUuZy4gYSBwcm9wIHRoYXQgb3ZlcnJpZGVzIGFub3RoZXIgb25lKVxuICAgICYmIGVsZVByb3AubWFwcGluZyAhPSBudWxsIC8vIGVsZSBwcm9wIGlzIGEgY29uY3JldGUgdmFsdWUgZnJvbSBmcm9tIGEgbWFwcGVyXG4gICAgJiYgZWxlUHJvcC5tYXBwaW5nLnZhbHVlID09PSBjeHRQcm9wLnZhbHVlIC8vIHRoZSBjdXJyZW50IHByb3Agb24gdGhlIGVsZSBpcyBhIGZsYXQgcHJvcCB2YWx1ZSBmb3IgdGhlIGZ1bmN0aW9uIG1hcHBlclxuICAgICkge1xuICAgICAgLy8gTkIgZG9uJ3Qgd3JpdGUgdG8gY3h0UHJvcCwgYXMgaXQncyBzaGFyZWQgYW1vbmcgZWxlcyAoc3RvcmVkIGluIHN0eWxlc2hlZXQpXG4gICAgICB2YXIgbWFwcGluZyA9IGVsZVByb3AubWFwcGluZzsgLy8gY2FuIHdyaXRlIHRvIG1hcHBpbmcsIGFzIGl0J3MgYSBwZXItZWxlIGNvcHlcbiAgICAgIHZhciBmblZhbHVlID0gbWFwcGluZy5mblZhbHVlID0gY3h0UHJvcC52YWx1ZShlbGUpOyAvLyB0ZW1wb3JhcmlseSBjYWNoZSB0aGUgdmFsdWUgaW4gY2FzZSBvZiBhIG1pc3NcblxuICAgICAgaWYgKGZuVmFsdWUgPT09IG1hcHBpbmcucHJldkZuVmFsdWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXREaWZmUHJvcCA9IHJldERpZmZQcm9wc1tkaWZmUHJvcE5hbWVdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG4gICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgY3h0UHJvcCk7XG4gICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcbiAgICBpZiAocmV0RGlmZlByb3AubmV4dCAmJiByZXREaWZmUHJvcC5uZXh0LmJ5cGFzcykge1xuICAgICAgcmV0RGlmZlByb3AubmV4dCA9IHJldERpZmZQcm9wLm5leHQuYnlwYXNzZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZGlmZlByb3BzOiByZXREaWZmUHJvcHNcbiAgfTtcbn07XG5zdHlmbiQ4LnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcE5hbWVzID0gc2VsZi5wcm9wZXJ0eUdyb3VwTmFtZXM7XG4gIHZhciBwcm9wR3JLZXlzID0gc2VsZi5wcm9wZXJ0eUdyb3VwS2V5cztcbiAgdmFyIHByb3BIYXNoID0gZnVuY3Rpb24gcHJvcEhhc2goZWxlLCBwcm9wTmFtZXMsIHNlZWRLZXkpIHtcbiAgICByZXR1cm4gc2VsZi5nZXRQcm9wZXJ0aWVzSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSk7XG4gIH07XG4gIHZhciBvbGRTdHlsZUtleSA9IF9wLnN0eWxlS2V5O1xuICBpZiAoZWxlLnJlbW92ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXNOb2RlID0gX3AuZ3JvdXAgPT09ICdub2Rlcyc7XG5cbiAgLy8gZ2V0IHRoZSBzdHlsZSBrZXkgaGFzaGVzIHBlciBwcm9wIGdyb3VwXG4gIC8vIGJ1dCBsYXppbHkgLS0gb25seSB1c2Ugbm9uLWRlZmF1bHQgcHJvcCB2YWx1ZXMgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgaGFzaGVzXG4gIC8vXG5cbiAgdmFyIG92ZXJyaWRkZW5TdHlsZXMgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG92ZXJyaWRkZW5TdHlsZXMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BHcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JLZXkgPSBwcm9wR3JLZXlzW2ldO1xuICAgIF9wLnN0eWxlS2V5c1tncktleV0gPSBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF07XG4gIH1cbiAgdmFyIHVwZGF0ZUdyS2V5MSA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5MSh2YWwsIGdyS2V5KSB7XG4gICAgcmV0dXJuIF9wLnN0eWxlS2V5c1tncktleV1bMF0gPSBoYXNoSW50KHZhbCwgX3Auc3R5bGVLZXlzW2dyS2V5XVswXSk7XG4gIH07XG4gIHZhciB1cGRhdGVHcktleTIgPSBmdW5jdGlvbiB1cGRhdGVHcktleTIodmFsLCBncktleSkge1xuICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldWzFdID0gaGFzaEludEFsdCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV1bMV0pO1xuICB9O1xuICB2YXIgdXBkYXRlR3JLZXkgPSBmdW5jdGlvbiB1cGRhdGVHcktleSh2YWwsIGdyS2V5KSB7XG4gICAgdXBkYXRlR3JLZXkxKHZhbCwgZ3JLZXkpO1xuICAgIHVwZGF0ZUdyS2V5Mih2YWwsIGdyS2V5KTtcbiAgfTtcbiAgdmFyIHVwZGF0ZUdyS2V5V1N0ciA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5V1N0cihzdHJWYWwsIGdyS2V5KSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJWYWwubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBjaCA9IHN0clZhbC5jaGFyQ29kZUF0KGopO1xuICAgICAgdXBkYXRlR3JLZXkxKGNoLCBncktleSk7XG4gICAgICB1cGRhdGVHcktleTIoY2gsIGdyS2V5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gLSBoYXNoaW5nIHdvcmtzIG9uIDMyIGJpdCBpbnRzIGIvYyB3ZSB1c2UgYml0d2lzZSBvcHNcbiAgLy8gLSBzbWFsbCBudW1iZXJzIGdldCBjdXQgb2ZmIChlLmcuIDAuMTIzIGlzIHNlZW4gYXMgMCBieSB0aGUgaGFzaGluZyBmdW5jdGlvbilcbiAgLy8gLSByYWlzZSB1cCBzbWFsbCBudW1iZXJzIHNvIG1vcmUgc2lnbmlmaWNhbnQgZGlnaXRzIGFyZSBzZWVuIGJ5IGhhc2hpbmdcbiAgLy8gLSBtYWtlIHNtYWxsIG51bWJlcnMgbGFyZ2VyIHRoYW4gYSBub3JtYWwgdmFsdWUgdG8gYXZvaWQgY29sbGlzaW9uc1xuICAvLyAtIHdvcmtzIGluIHByYWN0aWNlIGFuZCBpdCdzIHJlbGF0aXZlbHkgY2hlYXBcbiAgdmFyIE4gPSAyMDAwMDAwMDAwO1xuICB2YXIgY2xlYW5OdW0gPSBmdW5jdGlvbiBjbGVhbk51bSh2YWwpIHtcbiAgICByZXR1cm4gLTEyOCA8IHZhbCAmJiB2YWwgPCAxMjggJiYgTWF0aC5mbG9vcih2YWwpICE9PSB2YWwgPyBOIC0gKHZhbCAqIDEwMjQgfCAwKSA6IHZhbDtcbiAgfTtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByb3BOYW1lcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgbmFtZSA9IHByb3BOYW1lc1tfaV07XG4gICAgdmFyIHBhcnNlZFByb3AgPSBvdmVycmlkZGVuU3R5bGVzW25hbWVdO1xuICAgIGlmIChwYXJzZWRQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcEluZm8gPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgdmFyIHR5cGUgPSBwcm9wSW5mby50eXBlO1xuICAgIHZhciBfZ3JLZXkgPSBwcm9wSW5mby5ncm91cEtleTtcbiAgICB2YXIgbm9ybWFsaXplZE51bWJlclZhbCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcEluZm8uaGFzaE92ZXJyaWRlICE9IG51bGwpIHtcbiAgICAgIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSBwcm9wSW5mby5oYXNoT3ZlcnJpZGUoZWxlLCBwYXJzZWRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZFByb3AucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBub3JtYWxpemVkTnVtYmVyVmFsID0gcGFyc2VkUHJvcC5wZlZhbHVlO1xuICAgIH1cblxuICAgIC8vIG1pZ2h0IG5vdCBiZSBhIG51bWJlciBpZiBpdCBhbGxvd3MgZW51bXNcbiAgICB2YXIgbnVtYmVyVmFsID0gcHJvcEluZm8uZW51bXMgPT0gbnVsbCA/IHBhcnNlZFByb3AudmFsdWUgOiBudWxsO1xuICAgIHZhciBoYXZlTm9ybU51bSA9IG5vcm1hbGl6ZWROdW1iZXJWYWwgIT0gbnVsbDtcbiAgICB2YXIgaGF2ZVVuaXRlZE51bSA9IG51bWJlclZhbCAhPSBudWxsO1xuICAgIHZhciBoYXZlTnVtID0gaGF2ZU5vcm1OdW0gfHwgaGF2ZVVuaXRlZE51bTtcbiAgICB2YXIgdW5pdHMgPSBwYXJzZWRQcm9wLnVuaXRzO1xuXG4gICAgLy8gbnVtYmVycyBhcmUgY2hlYXBlciB0byBoYXNoIHRoYW4gc3RyaW5nc1xuICAgIC8vIDEgaGFzaCBvcCB2cyBuIGhhc2ggb3BzIChmb3IgbGVuZ3RoIG4gc3RyaW5nKVxuICAgIGlmICh0eXBlLm51bWJlciAmJiBoYXZlTnVtICYmICF0eXBlLm11bHRpcGxlKSB7XG4gICAgICB2YXIgdiA9IGhhdmVOb3JtTnVtID8gbm9ybWFsaXplZE51bWJlclZhbCA6IG51bWJlclZhbDtcbiAgICAgIHVwZGF0ZUdyS2V5KGNsZWFuTnVtKHYpLCBfZ3JLZXkpO1xuICAgICAgaWYgKCFoYXZlTm9ybU51bSAmJiB1bml0cyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUdyS2V5V1N0cih1bml0cywgX2dyS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlR3JLZXlXU3RyKHBhcnNlZFByb3Auc3RyVmFsdWUsIF9ncktleSk7XG4gICAgfVxuICB9XG5cbiAgLy8gb3ZlcmFsbCBzdHlsZSBrZXlcbiAgLy9cblxuICB2YXIgaGFzaCA9IFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcEdyS2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9ncktleTIgPSBwcm9wR3JLZXlzW19pMl07XG4gICAgdmFyIGdySGFzaCA9IF9wLnN0eWxlS2V5c1tfZ3JLZXkyXTtcbiAgICBoYXNoWzBdID0gaGFzaEludChnckhhc2hbMF0sIGhhc2hbMF0pO1xuICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGdySGFzaFsxXSwgaGFzaFsxXSk7XG4gIH1cbiAgX3Auc3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzKGhhc2hbMF0sIGhhc2hbMV0pO1xuXG4gIC8vIGxhYmVsIGRpbXNcbiAgLy9cblxuICB2YXIgc2sgPSBfcC5zdHlsZUtleXM7XG4gIF9wLmxhYmVsRGltc0tleSA9IGNvbWJpbmVIYXNoZXNBcnJheShzay5sYWJlbERpbWVuc2lvbnMpO1xuICB2YXIgbGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ2xhYmVsJ10sIHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gIF9wLmxhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGxhYmVsS2V5cyk7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaEFycmF5cyhzay5jb21tb25MYWJlbCwgbGFiZWxLZXlzKSk7XG4gIGlmICghaXNOb2RlKSB7XG4gICAgdmFyIHNvdXJjZUxhYmVsS2V5cyA9IHByb3BIYXNoKGVsZSwgWydzb3VyY2UtbGFiZWwnXSwgc2subGFiZWxEaW1lbnNpb25zKTtcbiAgICBfcC5zb3VyY2VMYWJlbEtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShzb3VyY2VMYWJlbEtleXMpO1xuICAgIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaEFycmF5cyhzay5jb21tb25MYWJlbCwgc291cmNlTGFiZWxLZXlzKSk7XG4gICAgdmFyIHRhcmdldExhYmVsS2V5cyA9IHByb3BIYXNoKGVsZSwgWyd0YXJnZXQtbGFiZWwnXSwgc2subGFiZWxEaW1lbnNpb25zKTtcbiAgICBfcC50YXJnZXRMYWJlbEtleSA9IGNvbWJpbmVIYXNoZXNBcnJheSh0YXJnZXRMYWJlbEtleXMpO1xuICAgIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaEFycmF5cyhzay5jb21tb25MYWJlbCwgdGFyZ2V0TGFiZWxLZXlzKSk7XG4gIH1cblxuICAvLyBub2RlXG4gIC8vXG5cbiAgaWYgKGlzTm9kZSkge1xuICAgIHZhciBfcCRzdHlsZUtleXMgPSBfcC5zdHlsZUtleXMsXG4gICAgICBub2RlQm9keSA9IF9wJHN0eWxlS2V5cy5ub2RlQm9keSxcbiAgICAgIG5vZGVCb3JkZXIgPSBfcCRzdHlsZUtleXMubm9kZUJvcmRlcixcbiAgICAgIG5vZGVPdXRsaW5lID0gX3Akc3R5bGVLZXlzLm5vZGVPdXRsaW5lLFxuICAgICAgYmFja2dyb3VuZEltYWdlID0gX3Akc3R5bGVLZXlzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgIGNvbXBvdW5kID0gX3Akc3R5bGVLZXlzLmNvbXBvdW5kLFxuICAgICAgcGllID0gX3Akc3R5bGVLZXlzLnBpZSxcbiAgICAgIHN0cmlwZSA9IF9wJHN0eWxlS2V5cy5zdHJpcGU7XG4gICAgdmFyIG5vZGVLZXlzID0gW25vZGVCb2R5LCBub2RlQm9yZGVyLCBub2RlT3V0bGluZSwgYmFja2dyb3VuZEltYWdlLCBjb21wb3VuZCwgcGllLCBzdHJpcGVdLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIGsgIT0gbnVsbDtcbiAgICB9KS5yZWR1Y2UoaGFzaEFycmF5cywgW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdKTtcbiAgICBfcC5ub2RlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KG5vZGVLZXlzKTtcbiAgICBfcC5oYXNQaWUgPSBwaWUgIT0gbnVsbCAmJiBwaWVbMF0gIT09IERFRkFVTFRfSEFTSF9TRUVEICYmIHBpZVsxXSAhPT0gREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICAgIF9wLmhhc1N0cmlwZSA9IHN0cmlwZSAhPSBudWxsICYmIHN0cmlwZVswXSAhPT0gREVGQVVMVF9IQVNIX1NFRUQgJiYgc3RyaXBlWzFdICE9PSBERUZBVUxUX0hBU0hfU0VFRF9BTFQ7XG4gIH1cbiAgcmV0dXJuIG9sZFN0eWxlS2V5ICE9PSBfcC5zdHlsZUtleTtcbn07XG5zdHlmbiQ4LmNsZWFyU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICBfcC5zdHlsZUN4dEtleSA9ICcnO1xuICBfcC5zdHlsZUtleXMgPSB7fTtcbiAgX3Auc3R5bGVLZXkgPSBudWxsO1xuICBfcC5sYWJlbEtleSA9IG51bGw7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5zb3VyY2VMYWJlbEtleSA9IG51bGw7XG4gIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC50YXJnZXRMYWJlbEtleSA9IG51bGw7XG4gIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5ub2RlS2V5ID0gbnVsbDtcbiAgX3AuaGFzUGllID0gbnVsbDtcbiAgX3AuaGFzU3RyaXBlID0gbnVsbDtcbn07XG5cbi8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuLy8gcmV0dXJucyB3aGV0aGVyIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsXG4vL1xuLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4vLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbi8vIGVsZW1lbnQncyBzdHlsZSBpcyByZXBsYWNlZCBieSB3aGF0J3MgcG9pbnRlZCB0byBieSB0aGUgYGJ5cGFzc2VkYFxuLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuc3R5Zm4kOC5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsZSwgcGFyc2VkUHJvcCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZmxhdFByb3A7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG4gIHZhciB0eXBlID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3AubmFtZV0udHlwZTtcbiAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVtwcm9wLm5hbWVdO1xuICB2YXIgb3JpZ1Byb3BJc0J5cGFzcyA9IG9yaWdQcm9wICYmIG9yaWdQcm9wLmJ5cGFzcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgZmxhdFByb3BNYXBwaW5nID0gJ21hcHBpbmcnO1xuICB2YXIgZ2V0VmFsID0gZnVuY3Rpb24gZ2V0VmFsKHApIHtcbiAgICBpZiAocCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHAucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcC5wZlZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcC52YWx1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBjaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gY2hlY2tUcmlnZ2VycygpIHtcbiAgICB2YXIgZnJvbVZhbCA9IGdldFZhbChvcmlnUHJvcCk7XG4gICAgdmFyIHRvVmFsID0gZ2V0VmFsKHByb3ApO1xuICAgIHNlbGYuY2hlY2tUcmlnZ2VycyhlbGUsIHByb3AubmFtZSwgZnJvbVZhbCwgdG9WYWwpO1xuICB9O1xuXG4gIC8vIGVkZ2Ugc2FuaXR5IGNoZWNrcyB0byBwcmV2ZW50IHRoZSBjbGllbnQgZnJvbSBtYWtpbmcgc2VyaW91cyBtaXN0YWtlc1xuICBpZiAocGFyc2VkUHJvcC5uYW1lID09PSAnY3VydmUtc3R5bGUnICYmIGVsZS5pc0VkZ2UoKSAmJiAoXG4gIC8vIGxvb3BzIG11c3QgYmUgYnVuZGxlZCBiZXppZXJzXG4gIHBhcnNlZFByb3AudmFsdWUgIT09ICdiZXppZXInICYmIGVsZS5pc0xvb3AoKSB8fFxuICAvLyBlZGdlcyBjb25uZWN0ZWQgdG8gY29tcG91bmQgbm9kZXMgY2FuIG5vdCBiZSBoYXlzdGFja3NcbiAgcGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2hheXN0YWNrJyAmJiAoZWxlLnNvdXJjZSgpLmlzUGFyZW50KCkgfHwgZWxlLnRhcmdldCgpLmlzUGFyZW50KCkpKSkge1xuICAgIHByb3AgPSBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShwYXJzZWRQcm9wLm5hbWUsICdiZXppZXInLCBwcm9wSXNCeXBhc3MpO1xuICB9XG4gIGlmIChwcm9wW1wiZGVsZXRlXCJdKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSBhbmQgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGZhbHNleSB2YWx1ZVxuICAgIHN0eWxlW3Byb3AubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgY2hlY2tUcmlnZ2VycygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzc2VkKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NlZFxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGJ5cGFzc1xuICBpZiAocHJvcC5kZWxldGVCeXBhc3MpIHtcbiAgICAvLyB0aGVuIHRoaXMgcHJvcGVydHkgaXMganVzdCBoZXJlIHRvIGluZGljYXRlIHdlIG5lZWQgdG8gZGVsZXRlXG4gICAgaWYgKCFvcmlnUHJvcCkge1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcbiAgICB9IGVsc2UgaWYgKG9yaWdQcm9wLmJ5cGFzcykge1xuICAgICAgLy8gdGhlbiByZXBsYWNlIHRoZSBieXBhc3MgcHJvcGVydHkgd2l0aCB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGJ5cGFzc2VkIHByb3BlcnR5IHdhcyBhbHJlYWR5IGFwcGxpZWQgKGFuZCB0aGVyZWZvcmUgcGFyc2VkKSwgd2UgY2FuIGp1c3QgcmVwbGFjZSBpdCAobm8gcmVhcHBseWluZyBuZWNlc3NhcnkpXG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gb3JpZ1Byb3AuYnlwYXNzZWQ7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc1xuICAgIH1cbiAgfVxuICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24gcHJpbnRNYXBwaW5nRXJyKCkge1xuICAgIHdhcm4oJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGkuZS4gZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBoYXMgbm8gbWFwcGluZyBmb3IgcHJvcGVydHkgYCcgKyBwcm9wLm5hbWUgKyAnYCB3aXRoIGRhdGEgZmllbGQgYCcgKyBwcm9wLmZpZWxkICsgJ2ApOyB0cnkgYSBgWycgKyBwcm9wLmZpZWxkICsgJ11gIHNlbGVjdG9yIHRvIGxpbWl0IHNjb3BlIHRvIGVsZW1lbnRzIHdpdGggYCcgKyBwcm9wLmZpZWxkICsgJ2AgZGVmaW5lZCcpO1xuICB9O1xuXG4gIC8vIHB1dCB0aGUgcHJvcGVydHkgaW4gdGhlIHN0eWxlIG9iamVjdHNcbiAgc3dpdGNoIChwcm9wLm1hcHBlZCkge1xuICAgIC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgZmllbGRWYWwgPSBfcC5kYXRhO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGggJiYgZmllbGRWYWw7IGkrKykge1xuICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRWYWwgPT0gbnVsbCkge1xuICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGVyY2VudDtcbiAgICAgICAgaWYgKCFudW1iZXIkMShmaWVsZFZhbCkpIHtcbiAgICAgICAgICAvLyB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgd2FybignRG8gbm90IHVzZSBjb250aW51b3VzIG1hcHBlcnMgd2l0aG91dCBzcGVjaWZ5aW5nIG51bWVyaWMgZGF0YSAoaS5lLiBgJyArIHByb3AuZmllbGQgKyAnOiAnICsgZmllbGRWYWwgKyAnYCBmb3IgYCcgKyBlbGUuaWQoKSArICdgIGlzIG5vbi1udW1lcmljKScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmllbGRXaWR0aCA9IHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluO1xuICAgICAgICAgIGlmIChmaWVsZFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzYWZldHkgY2hlY2sgLS0gbm90IHN0cmljdGx5IG5lY2Vzc2FyeSBhcyBubyBwcm9wcyBvZiB6ZXJvIHJhbmdlIHNob3VsZCBiZSBwYXNzZWQgaGVyZVxuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAoZmllbGRWYWwgLSBwcm9wLmZpZWxkTWluKSAvIGZpZWxkV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcbiAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZS5jb2xvcikge1xuICAgICAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICAgICAgdmFyIHIyID0gcHJvcC52YWx1ZU1heFswXTtcbiAgICAgICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICAgICAgdmFyIGIxID0gcHJvcC52YWx1ZU1pblsyXTtcbiAgICAgICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgICAgIHZhciBhMiA9IHByb3AudmFsdWVNYXhbM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWF4WzNdO1xuICAgICAgICAgIHZhciBjbHIgPSBbTWF0aC5yb3VuZChyMSArIChyMiAtIHIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGcxICsgKGcyIC0gZzEpICogcGVyY2VudCksIE1hdGgucm91bmQoYjEgKyAoYjIgLSBiMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChhMSArIChhMiAtIGExKSAqIHBlcmNlbnQpXTtcbiAgICAgICAgICBmbGF0UHJvcCA9IHtcbiAgICAgICAgICAgIC8vIGNvbG91cnMgYXJlIHNpbXBsZSwgc28ganVzdCBjcmVhdGUgdGhlIGZsYXQgcHJvcGVydHkgaW5zdGVhZCBvZiBleHBlbnNpdmUgc3RyaW5nIHBhcnNpbmdcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcC5ieXBhc3MsXG4gICAgICAgICAgICAvLyB3ZSdyZSBhIGJ5cGFzcyBpZiB0aGUgbWFwcGluZyBwcm9wZXJ0eSBpcyBhIGJ5cGFzc1xuICAgICAgICAgICAgbmFtZTogcHJvcC5uYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgICAgIHN0clZhbHVlOiAncmdiKCcgKyBjbHJbMF0gKyAnLCAnICsgY2xyWzFdICsgJywgJyArIGNsclsyXSArICcpJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5udW1iZXIpIHtcbiAgICAgICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGNhbGNWYWx1ZSwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4gb25seSBtYXAgdG8gY29sb3VycyBhbmQgbnVtYmVyc1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmxhdFByb3ApIHtcbiAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiBkb24ndCBhcHBseSB0aGUgcHJvcGVydHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gZGlyZWN0IG1hcHBpbmdcbiAgICBjYXNlIHR5cGVzLmRhdGE6XG4gICAgICB7XG4gICAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgICAgdmFyIF9maWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBfZmllbGRWYWwgPSBfcC5kYXRhO1xuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBfZmllbGRzLmxlbmd0aCAmJiBfZmllbGRWYWw7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9maWVsZCA9IF9maWVsZHNbX2kzXTtcbiAgICAgICAgICBfZmllbGRWYWwgPSBfZmllbGRWYWxbX2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZpZWxkVmFsICE9IG51bGwpIHtcbiAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBfZmllbGRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmxhdFByb3ApIHtcbiAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiBkb24ndCBhcHBseSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSB0eXBlcy5mbjpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZuID0gcHJvcC52YWx1ZTtcbiAgICAgICAgdmFyIGZuUmV0VmFsID0gcHJvcC5mblZhbHVlICE9IG51bGwgPyBwcm9wLmZuVmFsdWUgOiBmbihlbGUpOyAvLyBjaGVjayBmb3IgY2FjaGVkIHZhbHVlIGJlZm9yZSBjYWxsaW5nIGZ1bmN0aW9uXG5cbiAgICAgICAgcHJvcC5wcmV2Rm5WYWx1ZSA9IGZuUmV0VmFsO1xuICAgICAgICBpZiAoZm5SZXRWYWwgPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIG51bGwgKGkuZS4gYCcgKyBwcm9wLm5hbWUgKyAnYCBmb3IgZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBudWxsKScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIGlmICghZmxhdFByb3ApIHtcbiAgICAgICAgICB3YXJuKCdDdXN0b20gZnVuY3Rpb24gbWFwcGVycyBtYXkgbm90IHJldHVybiBpbnZhbGlkIHZhbHVlcyBmb3IgdGhlIHByb3BlcnR5IHR5cGUgKGkuZS4gYCcgKyBwcm9wLm5hbWUgKyAnYCBmb3IgZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBpbnZhbGlkKScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gY29weShwcm9wKTsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBicmVhaztcbiAgICAvLyBqdXN0IHNldCB0aGUgcHJvcGVydHlcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gbm90IGEgdmFsaWQgbWFwcGluZ1xuICB9XG5cbiAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG4gIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgIH1cbiAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDsgLy8gYW5kIHNldFxuICB9IGVsc2Uge1xuICAgIC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgIGlmIChvcmlnUHJvcElzQnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIGtlZXAgdGhlIG9yaWcgcHJvcCAoc2luY2UgaXQncyBhIGJ5cGFzcykgYW5kIGxpbmsgdG8gdGhlIG5ldyBwcm9wXG4gICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4ganVzdCByZXBsYWNlIHRoZSBvbGQgcHJvcCB3aXRoIHRoZSBuZXcgb25lXG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICB9XG4gIH1cbiAgY2hlY2tUcmlnZ2VycygpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5zdHlmbiQ4LmNsZWFuRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcywga2VlcEJ5cGFzc2VzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHRoaXMuY2xlYXJTdHlsZUhpbnRzKGVsZSk7XG4gICAgZWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICBpZiAoIWtlZXBCeXBhc3Nlcykge1xuICAgICAgZWxlLl9wcml2YXRlLnN0eWxlID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wTmFtZXNbal07XG4gICAgICAgIHZhciBlbGVQcm9wID0gc3R5bGVbcHJvcE5hbWVdO1xuICAgICAgICBpZiAoZWxlUHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGVsZVByb3AuYnlwYXNzKSB7XG4gICAgICAgICAgICBlbGVQcm9wLmJ5cGFzc2VkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcbnN0eWZuJDgudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICBlbGVzLnVwZGF0ZVN0eWxlKCk7XG59O1xuXG4vLyBkaWZmUHJvcHMgOiB7IG5hbWUgPT4geyBwcmV2LCBuZXh0IH0gfVxuc3R5Zm4kOC51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChlbGUsIGRpZmZQcm9wcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHByb3BzID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1wcm9wZXJ0eScpLnZhbHVlO1xuICB2YXIgZHVyYXRpb24gPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykucGZWYWx1ZTtcbiAgdmFyIGRlbGF5ID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kZWxheScpLnBmVmFsdWU7XG4gIGlmIChwcm9wcy5sZW5ndGggPiAwICYmIGR1cmF0aW9uID4gMCkge1xuICAgIHZhciBzdHlsZSA9IHt9O1xuXG4gICAgLy8gYnVpbGQgdXAgdGhlIHN0eWxlIHRvIGFuaW1hdGUgdG93YXJkc1xuICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHZhciBzdHlQcm9wID0gZWxlLnBzdHlsZShwcm9wKTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1twcm9wXTtcbiAgICAgIGlmICghZGlmZlByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgdmFyIGZyb21Qcm9wID0gcHJldlByb3A7XG4gICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuICAgICAgdmFyIGluaXRWYWwgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgaW5pdER0ID0gMC4wMDAwMDE7IC8vIGRlbHRhIHRpbWUgJSB2YWx1ZSBmb3IgaW5pdFZhbCAoYWxsb3dzIGFuaW1hdGluZyBvdXQgb2YgaW5pdCB6ZXJvIG9wYWNpdHkpXG5cbiAgICAgIGlmICghZnJvbVByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuICAgICAgaWYgKG51bWJlciQxKGZyb21Qcm9wLnBmVmFsdWUpICYmIG51bWJlciQxKHRvUHJvcC5wZlZhbHVlKSkge1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnBmVmFsdWUgLSBmcm9tUHJvcC5wZlZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AucGZWYWx1ZSArIGluaXREdCAqIGRpZmY7XG5cbiAgICAgICAgLy8gY29uc2lkZXIgbnVtZXJpY2FsIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmIChudW1iZXIkMShmcm9tUHJvcC52YWx1ZSkgJiYgbnVtYmVyJDEodG9Qcm9wLnZhbHVlKSkge1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnZhbHVlIC0gZnJvbVByb3AudmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC52YWx1ZSArIGluaXREdCAqIGRpZmY7XG5cbiAgICAgICAgLy8gY29uc2lkZXIgY29sb3VyIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmIChhcnJheShmcm9tUHJvcC52YWx1ZSkgJiYgYXJyYXkodG9Qcm9wLnZhbHVlKSkge1xuICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWVbMF0gIT09IHRvUHJvcC52YWx1ZVswXSB8fCBmcm9tUHJvcC52YWx1ZVsxXSAhPT0gdG9Qcm9wLnZhbHVlWzFdIHx8IGZyb21Qcm9wLnZhbHVlWzJdICE9PSB0b1Byb3AudmFsdWVbMl07XG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5zdHJWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIHByZXZpb3VzIHZhbHVlIGlzIGdvb2QgZm9yIGFuIGFuaW1hdGlvbiBvbmx5IGlmIGl0J3MgZGlmZmVyZW50XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG4gICAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBwcm9wLCBpbml0VmFsKTsgLy8gZnJvbSB2YWxcbiAgICAgICAgYW55UHJldiA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBlbmQgaWYgcHJvcHMgYWxsb3cgYW5pXG5cbiAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICBpZiAoIWFueVByZXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3AudHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICBlbGUuZGVsYXlBbmltYXRpb24oZGVsYXkpLnBsYXkoKS5wcm9taXNlKCkudGhlbihyZXNvbHZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlbGUuYW5pbWF0aW9uKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogZWxlLnBzdHlsZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nKS52YWx1ZSxcbiAgICAgICAgcXVldWU6IGZhbHNlXG4gICAgICB9KS5wbGF5KCkucHJvbWlzZSgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaWYoICFpc0J5cGFzcyApe1xuICAgICAgc2VsZi5yZW1vdmVCeXBhc3NlcyhlbGUsIHByb3BzKTtcbiAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpO1xuICAgICAgLy8gfVxuXG4gICAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoX3AudHJhbnNpdGlvbmluZykge1xuICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoZWxlLCBwcm9wcyk7XG4gICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7XG4gICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICB9XG59O1xuc3R5Zm4kOC5jaGVja1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGdldFRyaWdnZXIsIG9uVHJpZ2dlcikge1xuICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgdmFyIHRyaWdnZXJDaGVjayA9IGdldFRyaWdnZXIocHJvcCk7XG4gIGlmIChlbGUucmVtb3ZlZCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0cmlnZ2VyQ2hlY2sgIT0gbnVsbCAmJiB0cmlnZ2VyQ2hlY2soZnJvbVZhbHVlLCB0b1ZhbHVlLCBlbGUpKSB7XG4gICAgb25UcmlnZ2VyKHByb3ApO1xuICB9XG59O1xuc3R5Zm4kOC5jaGVja1pPcmRlclRyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNaT3JkZXI7XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5fcHJpdmF0ZS5jeS5ub3RpZnkoJ3pvcmRlcicsIGVsZSk7XG4gIH0pO1xufTtcbnN0eWZuJDguY2hlY2tCb3VuZHNUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICB9LCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gIH0pO1xufTtcbnN0eWZuJDguY2hlY2tDb25uZWN0ZWRFZGdlc0JvdW5kc1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNCb3VuZHNPZkNvbm5lY3RlZEVkZ2VzO1xuICB9LCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIGVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgfSk7XG4gIH0pO1xufTtcbnN0eWZuJDguY2hlY2tQYXJhbGxlbEVkZ2VzQm91bmRzVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxFZGdlcztcbiAgfSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBlbGUucGFyYWxsZWxFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKHBsbEVkZ2UpIHtcbiAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgfSk7XG4gIH0pO1xufTtcbnN0eWZuJDguY2hlY2tUcmlnZ2VycyA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICBlbGUuZGlydHlTdHlsZUNhY2hlKCk7XG4gIHRoaXMuY2hlY2taT3JkZXJUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbiAgdGhpcy5jaGVja0JvdW5kc1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICB0aGlzLmNoZWNrQ29ubmVjdGVkRWRnZXNCb3VuZHNUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbiAgdGhpcy5jaGVja1BhcmFsbGVsRWRnZXNCb3VuZHNUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbn07XG5cbnZhciBzdHlmbiQ3ID0ge307XG5cbi8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcbnN0eWZuJDcuYXBwbHlCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3BzID0gW107XG4gIHZhciBpc0J5cGFzcyA9IHRydWU7XG5cbiAgLy8gcHV0IGFsbCB0aGUgcHJvcGVydGllcyAoY2FuIHNwZWNpZnkgb25lIG9yIG1hbnkpIGluIGFuIGFycmF5IGFmdGVyIHBhcnNpbmcgdGhlbVxuICBpZiAobmFtZSA9PT0gJyonIHx8IG5hbWUgPT09ICcqKicpIHtcbiAgICAvLyBhcHBseSB0byBhbGwgcHJvcGVydHkgbmFtZXNcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoX25hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgaWYgKHBhcnNlZFByb3ApIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHBhcnNlZFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgIC8vIHRoZW4gcGFyc2UgdGhlIHNpbmdsZSBwcm9wZXJ0eVxuICAgIHZhciBfcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgIGlmIChfcGFyc2VkUHJvcCkge1xuICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgLy8gdGhlbiBwYXJzZSBlYWNoIHByb3BlcnR5XG4gICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHNwZWNpZmllZFByb3BzKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25hbWUyID0gbmFtZXNbX2ldO1xuICAgICAgdmFyIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW19uYW1lMl07XG4gICAgICBpZiAoX3ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdHJ5IGNhbWVsIGNhc2UgbmFtZSB0b29cbiAgICAgICAgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbZGFzaDJjYW1lbChfbmFtZTIpXTtcbiAgICAgIH1cbiAgICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3BhcnNlZFByb3AyID0gdGhpcy5wYXJzZShfbmFtZTIsIF92YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChfcGFyc2VkUHJvcDIpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbm93LCBhcHBseSB0aGUgYnlwYXNzIHByb3BlcnRpZXMgb24gdGhlIGVsZW1lbnRzXG4gIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1tfaTJdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICB2YXIgZGlmZlByb3AgPSB1bmRlZmluZWQ7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIF9wcm9wID0gcHJvcHNbal07XG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbX3Byb3AubmFtZV0gPSB7XG4gICAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldCA9IHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIGNvcHkoX3Byb3ApKSB8fCByZXQ7XG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoX3Byb3AubmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgcHJvcHNcblxuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcblxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gb25seSB1c2VmdWwgaW4gc3BlY2lmaWMgY2FzZXMgbGlrZSBhbmltYXRpb25cbnN0eWZuJDcub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IGNhbWVsMmRhc2gobmFtZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBwcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlW25hbWVdO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdLnR5cGU7XG4gICAgdmFyIGlzQ29sb3IgPSB0eXBlLmNvbG9yO1xuICAgIHZhciBpc011bHRpID0gdHlwZS5tdXRpcGxlO1xuICAgIHZhciBvbGRWYWx1ZSA9ICFwcm9wID8gbnVsbCA6IHByb3AucGZWYWx1ZSAhPSBudWxsID8gcHJvcC5wZlZhbHVlIDogcHJvcC52YWx1ZTtcbiAgICBpZiAoIXByb3AgfHwgIXByb3AuYnlwYXNzKSB7XG4gICAgICAvLyBuZWVkIGEgYnlwYXNzIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC5wZlZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gJ3JnYignICsgdmFsdWUuam9pbignLCcpICsgJyknO1xuICAgICAgfSBlbHNlIGlmIChpc011bHRpKSB7XG4gICAgICAgIHByb3Auc3RyVmFsdWUgPSB2YWx1ZS5qb2luKCcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrVHJpZ2dlcnMoZWxlLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICB9XG59O1xuc3R5Zm4kNy5yZW1vdmVBbGxCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICByZXR1cm4gdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGVzLCB0aGlzLnByb3BlcnR5TmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbn07XG5zdHlmbiQ3LnJlbW92ZUJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuICAgICAgaWYgKCFwcmV2UHJvcCB8fCAhcHJldlByb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIGlmIGEgYnlwYXNzIGRvZXNuJ3QgZXhpc3QgZm9yIHRoZSBwcm9wLCBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1twcm9wLm5hbWVdID0ge1xuICAgICAgICBwcmV2OiBwcmV2UHJvcFxuICAgICAgfTtcbiAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVzXG59O1xuXG52YXIgc3R5Zm4kNiA9IHt9O1xuXG4vLyBnZXRzIHdoYXQgYW4gZW0gc2l6ZSBjb3JyZXNwb25kcyB0byBpbiBwaXhlbHMgcmVsYXRpdmUgdG8gYSBkb20gZWxlbWVudFxuc3R5Zm4kNi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoJ2ZvbnQtc2l6ZScpO1xuICBpZiAocHggIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHB4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTsgLy8gZm9yIGhlYWRsZXNzXG4gIH1cbn07XG5cbi8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG5zdHlmbiQ2LmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZG9tRWxlbWVudCA9IGN5LmNvbnRhaW5lcigpO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gY3kud2luZG93KCk7XG4gIGlmIChjb250YWluZXJXaW5kb3cgJiYgZG9tRWxlbWVudCAmJiBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIHJldHVybiBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgfVxufTtcblxudmFyIHN0eWZuJDUgPSB7fTtcblxuLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuJDUuZ2V0UmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIHByb3ApIHtcbiAgaWYgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBwcm9wLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSYXdTdHlsZShlbGUsIHRydWUpO1xuICB9XG59O1xuXG4vLyBnZXRzIHRoZSByYXcgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbnN0eWZuJDUuZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciByc3R5bGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICB2YXIgdmFsID0gc2VsZi5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwpO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHJzdHlsZVtwcm9wLm5hbWVdID0gdmFsO1xuICAgICAgICByc3R5bGVbZGFzaDJjYW1lbChwcm9wLm5hbWUpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcbnN0eWZuJDUuZ2V0SW5kZXhlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcGVydHksIHN1YnByb3BlcnR5LCBpbmRleCkge1xuICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZShwcm9wZXJ0eSlbc3VicHJvcGVydHldW2luZGV4XTtcbiAgcmV0dXJuIHBzdHlsZSAhPSBudWxsID8gcHN0eWxlIDogZWxlLmN5KCkuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkocHJvcGVydHkpW3N1YnByb3BlcnR5XVswXTtcbn07XG5zdHlmbiQ1LmdldFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BOYW1lLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICBpZiAocHJvcC5hbGlhcykge1xuICAgICAgcHJvcCA9IHByb3AucG9pbnRzVG87XG4gICAgfVxuICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgIHZhciBzdHlsZVByb3AgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wLnZhbHVlLFxuICAgICAgICB1bml0cyA9IHN0eWxlUHJvcC51bml0cyxcbiAgICAgICAgc3RyVmFsdWUgPSBzdHlsZVByb3Auc3RyVmFsdWU7XG4gICAgICBpZiAoaXNSZW5kZXJlZFZhbCAmJiB0eXBlLm51bWJlciAmJiB2YWx1ZSAhPSBudWxsICYmIG51bWJlciQxKHZhbHVlKSkge1xuICAgICAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICAgICAgdmFyIGdldFJlbmRlcmVkVmFsdWUgPSBmdW5jdGlvbiBnZXRSZW5kZXJlZFZhbHVlKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWwgKiB6b29tO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHMgPSBmdW5jdGlvbiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWwsIHVuaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFJlbmRlcmVkVmFsdWUodmFsKSArIHVuaXRzO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaXNBcnJheVZhbHVlID0gYXJyYXkodmFsdWUpO1xuICAgICAgICB2YXIgaGF2ZVVuaXRzID0gaXNBcnJheVZhbHVlID8gdW5pdHMuZXZlcnkoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICByZXR1cm4gdSAhPSBudWxsO1xuICAgICAgICB9KSA6IHVuaXRzICE9IG51bGw7XG4gICAgICAgIGlmIChoYXZlVW5pdHMpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2LCB1bml0c1tpXSk7XG4gICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWx1ZSwgdW5pdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJpbmcodikgPyB2IDogJycgKyBnZXRSZW5kZXJlZFZhbHVlKHYpO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBnZXRSZW5kZXJlZFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuc3R5Zm4kNS5nZXRBbmltYXRpb25TdGFydFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgYW5pUHJvcHMpIHtcbiAgdmFyIHJzdHlsZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaVByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFuaVByb3AgPSBhbmlQcm9wc1tpXTtcbiAgICB2YXIgbmFtZSA9IGFuaVByb3AubmFtZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShuYW1lKTtcbiAgICBpZiAoc3R5bGVQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgIGlmIChwbGFpbk9iamVjdChzdHlsZVByb3ApKSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgcnN0eWxlW25hbWVdID0gc3R5bGVQcm9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnN0eWxlO1xufTtcbnN0eWZuJDUuZ2V0UHJvcHNMaXN0ID0gZnVuY3Rpb24gKHByb3BzT2JqKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IFtdO1xuICB2YXIgc3R5bGUgPSBwcm9wc09iajtcbiAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuICBpZiAoc3R5bGUpIHtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzdHlsZVtuYW1lXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV0gfHwgcHJvcHNbY2FtZWwyZGFzaChuYW1lKV07XG4gICAgICB2YXIgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIHZhbCk7XG4gICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHJzdHlsZS5wdXNoKHN0eWxlUHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByc3R5bGU7XG59O1xuc3R5Zm4kNS5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2ggPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZXMsIHNlZWQpIHtcbiAgdmFyIGhhc2ggPSBzZWVkLnNsaWNlKCk7XG4gIHZhciBuYW1lLCB2YWwsIHN0clZhbCwgY2hWYWw7XG4gIHZhciBpLCBqO1xuICBmb3IgKGkgPSAwOyBpIDwgcHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmFtZSA9IHByb3BOYW1lc1tpXTtcbiAgICB2YWwgPSBlbGUucHN0eWxlKG5hbWUsIGZhbHNlKTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAodmFsLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgaGFzaFswXSA9IGhhc2hJbnQoY2hWYWwsIGhhc2hbMF0pO1xuICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoY2hWYWwsIGhhc2hbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJWYWwgPSB2YWwuc3RyVmFsdWU7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoVmFsID0gc3RyVmFsLmNoYXJDb2RlQXQoaik7XG4gICAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGNoVmFsLCBoYXNoWzBdKTtcbiAgICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoY2hWYWwsIGhhc2hbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzaDtcbn07XG5zdHlmbiQ1LmdldFByb3BlcnRpZXNIYXNoID0gc3R5Zm4kNS5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2g7XG5cbnZhciBzdHlmbiQ0ID0ge307XG5zdHlmbiQ0LmFwcGVuZEZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5zdHlsZSB8fCBjb250ZXh0LmNzcztcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tqXTtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzW25hbWVdO1xuICAgICAgc3R5bGUuY3NzKG5hbWUsIHZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gYWNjZXNzaWJsZSBjeS5zdHlsZSgpIGZ1bmN0aW9uXG5zdHlmbiQ0LmZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcbiAgc3R5bGUuYXBwZW5kRnJvbUpzb24oanNvbik7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIGdldCBqc29uIGZyb20gY3kuc3R5bGUoKSBhcGlcbnN0eWZuJDQuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGpzb24gPSBbXTtcbiAgZm9yICh2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3h0ID0gdGhpc1tpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjeHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY3h0LnByb3BlcnRpZXM7XG4gICAgdmFyIGNzcyA9IHt9O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICBjc3NbcHJvcC5uYW1lXSA9IHByb3Auc3RyVmFsdWU7XG4gICAgfVxuICAgIGpzb24ucHVzaCh7XG4gICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgIHN0eWxlOiBjc3NcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ganNvbjtcbn07XG5cbnZhciBzdHlmbiQzID0ge307XG5zdHlmbiQzLmFwcGVuZEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgdmFyIHJlbWFpbmluZyA9ICcnICsgc3RyaW5nO1xuICB2YXIgc2VsQW5kQmxvY2tTdHI7XG4gIHZhciBibG9ja1JlbTtcbiAgdmFyIHByb3BBbmRWYWxTdHI7XG5cbiAgLy8gcmVtb3ZlIGNvbW1lbnRzIGZyb20gdGhlIHN0eWxlIHN0cmluZ1xuICByZW1haW5pbmcgPSByZW1haW5pbmcucmVwbGFjZSgvWy9dWypdKFxcc3wuKSs/WypdWy9dL2csICcnKTtcbiAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgIGlmIChyZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoKSB7XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKHNlbEFuZEJsb2NrU3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpIHtcbiAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBwcm9wZXJ0eSBhbmQgdmFsdWUgZnJvbSB0aGUgcmVtYWluaW5nIGJsb2NrIHRleHQgdG8gcGFyc2VcbiAgICBpZiAoYmxvY2tSZW0ubGVuZ3RoID4gcHJvcEFuZFZhbFN0ci5sZW5ndGgpIHtcbiAgICAgIGJsb2NrUmVtID0gYmxvY2tSZW0uc3Vic3RyKHByb3BBbmRWYWxTdHIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmxvY2tSZW0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yICg7Oykge1xuICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pO1xuICAgIGlmIChub3RoaW5nTGVmdFRvUGFyc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2VsQW5kQmxvY2sgPSByZW1haW5pbmcubWF0Y2goL15cXHMqKCg/Oi58XFxzKSs/KVxccypcXHsoKD86LnxcXHMpKz8pXFx9Lyk7XG4gICAgaWYgKCFzZWxBbmRCbG9jaykge1xuICAgICAgd2FybignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTtcblxuICAgIC8vIHBhcnNlIHRoZSBzZWxlY3RvclxuICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuICAgIGlmIChzZWxlY3RvclN0ciAhPT0gJ2NvcmUnKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuICAgICAgaWYgKHNlbGVjdG9yLmludmFsaWQpIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBzZWxlY3RvciBmb3VuZCBpbiBzdHJpbmcgc3R5bGVzaGVldDogJyArIHNlbGVjdG9yU3RyKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG4gICAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZSB0aGUgYmxvY2sgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgdmFyIGJsb2NrU3RyID0gc2VsQW5kQmxvY2tbMl07XG4gICAgdmFyIGludmFsaWRCbG9jayA9IGZhbHNlO1xuICAgIGJsb2NrUmVtID0gYmxvY2tTdHI7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIF9ub3RoaW5nTGVmdFRvUGFyc2UgPSBibG9ja1JlbS5tYXRjaCgvXlxccyokLyk7XG4gICAgICBpZiAoX25vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wQW5kVmFsID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqKC4rPylcXHMqOlxccyooLis/KSg/Olxccyo7fFxccyokKS8pO1xuICAgICAgaWYgKCFwcm9wQW5kVmFsKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgZm9ybWF0dGluZyBvZiBzdHlsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVmaW5pdGlvbnMgZm91bmQgaW46JyArIGJsb2NrU3RyKTtcbiAgICAgICAgaW52YWxpZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcm9wQW5kVmFsU3RyID0gcHJvcEFuZFZhbFswXTtcbiAgICAgIHZhciBwcm9wU3RyID0gcHJvcEFuZFZhbFsxXTtcbiAgICAgIHZhciB2YWxTdHIgPSBwcm9wQW5kVmFsWzJdO1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbcHJvcFN0cl07XG4gICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKHByb3BTdHIsIHZhbFN0cik7XG4gICAgICBpZiAoIXBhcnNlZFByb3ApIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgZGVmaW5pdGlvbiBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcm9wcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcHJvcFN0cixcbiAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICB9XG4gICAgaWYgKGludmFsaWRCbG9jaykge1xuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3RvclN0cik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9wcm9wID0gcHJvcHNbaV07XG4gICAgICBzdHlsZS5jc3MoX3Byb3AubmFtZSwgX3Byb3AudmFsKTtcbiAgICB9XG4gICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufTtcbnN0eWZuJDMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcbiAgc3R5bGUuYXBwZW5kRnJvbVN0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG52YXIgc3R5Zm4kMiA9IHt9O1xuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG51bWJlciQxID0gbnVtYmVyO1xuICB2YXIgcmdiYSA9IHJnYmFOb0JhY2tSZWZzO1xuICB2YXIgaHNsYSA9IGhzbGFOb0JhY2tSZWZzO1xuICB2YXIgaGV4MyQxID0gaGV4MztcbiAgdmFyIGhleDYkMSA9IGhleDY7XG4gIHZhciBkYXRhID0gZnVuY3Rpb24gZGF0YShwcmVmaXgpIHtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJztcbiAgfTtcbiAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiBtYXBEYXRhKHByZWZpeCkge1xuICAgIHZhciBtYXBBcmcgPSBudW1iZXIkMSArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMkMSArICd8JyArIGhleDYkMTtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG1hcEFyZyArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG1hcEFyZyArICcpXFxcXCkkJztcbiAgfTtcbiAgdmFyIHVybFJlZ2V4ZXMgPSBbJ151cmxcXFxccypcXFxcKFxcXFxzKltcXCdcIl0/KC4rPylbXFwnXCJdP1xcXFxzKlxcXFwpJCcsICdeKG5vbmUpJCcsICdeKC4rKSQnXTtcblxuICAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG4gIHN0eWZuJDIudHlwZXMgPSB7XG4gICAgdGltZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgdW5pdHM6ICdzfG1zJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdtcydcbiAgICB9LFxuICAgIHBlcmNlbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgdW5pdHM6ICclJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICclJ1xuICAgIH0sXG4gICAgcGVyY2VudGFnZXM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgdW5pdHM6ICclJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICclJyxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICB6ZXJvT25lTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgemVyb09uZU51bWJlcnM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIG5PbmVPbmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogLTEsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgbm9uTmVnYXRpdmVJbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGludGVnZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgbm9uTmVnYXRpdmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddXG4gICAgfSxcbiAgICBub2RlU2l6ZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgZW51bXM6IFsnbGFiZWwnXVxuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgbnVtYmVyczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgcG9zaXRpdmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgc3RyaWN0TWluOiB0cnVlXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDBcbiAgICB9LFxuICAgIGJpZGlyZWN0aW9uYWxTaXplOiB7XG4gICAgICBudW1iZXI6IHRydWVcbiAgICB9LFxuICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIGJpZGlyZWN0aW9uYWxTaXplTWF5YmVQZXJjZW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWVcbiAgICB9LFxuICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIGJpZGlyZWN0aW9uYWxTaXplczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgIHNpemVNYXliZVBlcmNlbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZVxuICAgIH0sXG4gICAgYXhpc0RpcmVjdGlvbjoge1xuICAgICAgZW51bXM6IFsnaG9yaXpvbnRhbCcsICdsZWZ0d2FyZCcsICdyaWdodHdhcmQnLCAndmVydGljYWwnLCAndXB3YXJkJywgJ2Rvd253YXJkJywgJ2F1dG8nXVxuICAgIH0sXG4gICAgYXhpc0RpcmVjdGlvbkV4cGxpY2l0OiB7XG4gICAgICBlbnVtczogWydsZWZ0d2FyZCcsICdyaWdodHdhcmQnLCAndXB3YXJkJywgJ2Rvd253YXJkJ11cbiAgICB9LFxuICAgIGF4aXNEaXJlY3Rpb25QcmltYXJ5OiB7XG4gICAgICBlbnVtczogWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ11cbiAgICB9LFxuICAgIHBhZGRpbmdSZWxhdGl2ZVRvOiB7XG4gICAgICBlbnVtczogWyd3aWR0aCcsICdoZWlnaHQnLCAnYXZlcmFnZScsICdtaW4nLCAnbWF4J11cbiAgICB9LFxuICAgIGJnV0g6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgIGVudW1zOiBbJ2F1dG8nXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1Bvczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUmVsYXRpdmVUbzoge1xuICAgICAgZW51bXM6IFsnaW5uZXInLCAnaW5jbHVkZS1wYWRkaW5nJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdSZXBlYXQ6IHtcbiAgICAgIGVudW1zOiBbJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsICduby1yZXBlYXQnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0ZpdDoge1xuICAgICAgZW51bXM6IFsnbm9uZScsICdjb250YWluJywgJ2NvdmVyJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdDcm9zc09yaWdpbjoge1xuICAgICAgZW51bXM6IFsnYW5vbnltb3VzJywgJ3VzZS1jcmVkZW50aWFscycsICdudWxsJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdDbGlwOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ25vZGUnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0NvbnRhaW5tZW50OiB7XG4gICAgICBlbnVtczogWydpbnNpZGUnLCAnb3ZlciddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJveFNlbGVjdGlvbjoge1xuICAgICAgZW51bXM6IFsnY29udGFpbicsICdvdmVybGFwJywgJ25vbmUnXVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiB0cnVlXG4gICAgfSxcbiAgICBjb2xvcnM6IHtcbiAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGZpbGw6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2xpbmVhci1ncmFkaWVudCcsICdyYWRpYWwtZ3JhZGllbnQnXVxuICAgIH0sXG4gICAgYm9vbDoge1xuICAgICAgZW51bXM6IFsneWVzJywgJ25vJ11cbiAgICB9LFxuICAgIGJvb2xzOiB7XG4gICAgICBlbnVtczogWyd5ZXMnLCAnbm8nXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnXVxuICAgIH0sXG4gICAgbGluZUNhcDoge1xuICAgICAgZW51bXM6IFsnYnV0dCcsICdyb3VuZCcsICdzcXVhcmUnXVxuICAgIH0sXG4gICAgbGluZVBvc2l0aW9uOiB7XG4gICAgICBlbnVtczogWydjZW50ZXInLCAnaW5zaWRlJywgJ291dHNpZGUnXVxuICAgIH0sXG4gICAgbGluZUpvaW46IHtcbiAgICAgIGVudW1zOiBbJ3JvdW5kJywgJ2JldmVsJywgJ21pdGVyJ11cbiAgICB9LFxuICAgIGJvcmRlclN0eWxlOiB7XG4gICAgICBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ2RvdWJsZSddXG4gICAgfSxcbiAgICBjdXJ2ZVN0eWxlOiB7XG4gICAgICBlbnVtczogWydiZXppZXInLCAndW5idW5kbGVkLWJlemllcicsICdoYXlzdGFjaycsICdzZWdtZW50cycsICdzdHJhaWdodCcsICdzdHJhaWdodC10cmlhbmdsZScsICd0YXhpJywgJ3JvdW5kLXNlZ21lbnRzJywgJ3JvdW5kLXRheGknXVxuICAgIH0sXG4gICAgcmFkaXVzVHlwZToge1xuICAgICAgZW51bXM6IFsnYXJjLXJhZGl1cycsICdpbmZsdWVuY2UtcmFkaXVzJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgZm9udEZhbWlseToge1xuICAgICAgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnXG4gICAgfSxcbiAgICBmb250U3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZSddXG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiB7XG4gICAgICBlbnVtczogWydub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc4MDAnLCAnOTAwJywgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMF1cbiAgICB9LFxuICAgIHRleHREZWNvcmF0aW9uOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXVxuICAgIH0sXG4gICAgdGV4dFRyYW5zZm9ybToge1xuICAgICAgZW51bXM6IFsnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJ11cbiAgICB9LFxuICAgIHRleHRXcmFwOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3dyYXAnLCAnZWxsaXBzaXMnXVxuICAgIH0sXG4gICAgdGV4dE92ZXJmbG93V3JhcDoge1xuICAgICAgZW51bXM6IFsnd2hpdGVzcGFjZScsICdhbnl3aGVyZSddXG4gICAgfSxcbiAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7XG4gICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2NpcmNsZSddXG4gICAgfSxcbiAgICBub2RlU2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnLCAnY3V0cmVjdGFuZ2xlJywgJ2N1dC1yZWN0YW5nbGUnLCAnYm90dG9tcm91bmRyZWN0YW5nbGUnLCAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZScsICdiYXJyZWwnLCAnZWxsaXBzZScsICd0cmlhbmdsZScsICdyb3VuZC10cmlhbmdsZScsICdzcXVhcmUnLCAncGVudGFnb24nLCAncm91bmQtcGVudGFnb24nLCAnaGV4YWdvbicsICdyb3VuZC1oZXhhZ29uJywgJ2NvbmNhdmVoZXhhZ29uJywgJ2NvbmNhdmUtaGV4YWdvbicsICdoZXB0YWdvbicsICdyb3VuZC1oZXB0YWdvbicsICdvY3RhZ29uJywgJ3JvdW5kLW9jdGFnb24nLCAndGFnJywgJ3JvdW5kLXRhZycsICdzdGFyJywgJ2RpYW1vbmQnLCAncm91bmQtZGlhbW9uZCcsICd2ZWUnLCAncmhvbWJvaWQnLCAncmlnaHQtcmhvbWJvaWQnLCAncG9seWdvbiddXG4gICAgfSxcbiAgICBvdmVybGF5U2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdlbGxpcHNlJ11cbiAgICB9LFxuICAgIGNvcm5lclJhZGl1czoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgdW5pdHM6ICdweHxlbScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncHgnLFxuICAgICAgZW51bXM6IFsnYXV0byddXG4gICAgfSxcbiAgICBjb21wb3VuZEluY2x1ZGVMYWJlbHM6IHtcbiAgICAgIGVudW1zOiBbJ2luY2x1ZGUnLCAnZXhjbHVkZSddXG4gICAgfSxcbiAgICBhcnJvd1NoYXBlOiB7XG4gICAgICBlbnVtczogWyd0ZWUnLCAndHJpYW5nbGUnLCAndHJpYW5nbGUtdGVlJywgJ2NpcmNsZS10cmlhbmdsZScsICd0cmlhbmdsZS1jcm9zcycsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAndmVlJywgJ3NxdWFyZScsICdjaXJjbGUnLCAnZGlhbW9uZCcsICdjaGV2cm9uJywgJ25vbmUnXVxuICAgIH0sXG4gICAgYXJyb3dGaWxsOiB7XG4gICAgICBlbnVtczogWydmaWxsZWQnLCAnaG9sbG93J11cbiAgICB9LFxuICAgIGFycm93V2lkdGg6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnJXxweHxlbScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncHgnLFxuICAgICAgZW51bXM6IFsnbWF0Y2gtbGluZSddXG4gICAgfSxcbiAgICBkaXNwbGF5OiB7XG4gICAgICBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXVxuICAgIH0sXG4gICAgdmlzaWJpbGl0eToge1xuICAgICAgZW51bXM6IFsnaGlkZGVuJywgJ3Zpc2libGUnXVxuICAgIH0sXG4gICAgekNvbXBvdW5kRGVwdGg6IHtcbiAgICAgIGVudW1zOiBbJ2JvdHRvbScsICdvcnBoYW4nLCAnYXV0bycsICd0b3AnXVxuICAgIH0sXG4gICAgekluZGV4Q29tcGFyZToge1xuICAgICAgZW51bXM6IFsnYXV0bycsICdtYW51YWwnXVxuICAgIH0sXG4gICAgdmFsaWduOiB7XG4gICAgICBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddXG4gICAgfSxcbiAgICBoYWxpZ246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cbiAgICB9LFxuICAgIGp1c3RpZmljYXRpb246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JywgJ2F1dG8nXVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgc3RyaW5nOiB0cnVlXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ2RhdGEnKVxuICAgIH0sXG4gICAgbGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdsYXlvdXREYXRhJylcbiAgICB9LFxuICAgIHNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnc2NyYXRjaCcpXG4gICAgfSxcbiAgICBtYXBEYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKVxuICAgIH0sXG4gICAgbWFwTGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBMYXlvdXREYXRhJylcbiAgICB9LFxuICAgIG1hcFNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwU2NyYXRjaCcpXG4gICAgfSxcbiAgICBmbjoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIGZuOiB0cnVlXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHVybHM6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgcHJvcExpc3Q6IHtcbiAgICAgIHByb3BMaXN0OiB0cnVlXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnXG4gICAgfSxcbiAgICB0ZXh0Um90YXRpb246IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJyxcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnYXV0b3JvdGF0ZSddXG4gICAgfSxcbiAgICBwb2x5Z29uUG9pbnRMaXN0OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIGV2ZW5NdWx0aXBsZTogdHJ1ZSxcbiAgICAgIG1pbjogLTEsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgZWRnZURpc3RhbmNlczoge1xuICAgICAgZW51bXM6IFsnaW50ZXJzZWN0aW9uJywgJ25vZGUtcG9zaXRpb24nLCAnZW5kcG9pbnRzJ11cbiAgICB9LFxuICAgIGVkZ2VFbmRwb2ludDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICB1bml0czogJyV8cHh8ZW18ZGVnfHJhZCcsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncHgnLFxuICAgICAgZW51bXM6IFsnaW5zaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcsICdvdXRzaWRlLXRvLWxpbmUnLCAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJ10sXG4gICAgICBzaW5nbGVFbnVtOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpIHtcbiAgICAgICAgc3dpdGNoICh2YWxBcnIubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgLy8gY2FuIGJlICUgb3IgcHggb25seVxuICAgICAgICAgICAgcmV0dXJuIHVuaXRzQXJyWzBdICE9PSAnZGVnJyAmJiB1bml0c0FyclswXSAhPT0gJ3JhZCcgJiYgdW5pdHNBcnJbMV0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzFdICE9PSAncmFkJztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAvLyBjYW4gYmUgZW51bSwgZGVnLCBvciByYWQgb25seVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyh2YWxBcnJbMF0pIHx8IHVuaXRzQXJyWzBdID09PSAnZGVnJyB8fCB1bml0c0FyclswXSA9PT0gJ3JhZCc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZWFzaW5nOiB7XG4gICAgICByZWdleGVzOiBbJ14oc3ByaW5nKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwpJCcsICdeKGN1YmljLWJlemllcilcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwpJCddLFxuICAgICAgZW51bXM6IFsnbGluZWFyJywgJ2Vhc2UnLCAnZWFzZS1pbicsICdlYXNlLW91dCcsICdlYXNlLWluLW91dCcsICdlYXNlLWluLXNpbmUnLCAnZWFzZS1vdXQtc2luZScsICdlYXNlLWluLW91dC1zaW5lJywgJ2Vhc2UtaW4tcXVhZCcsICdlYXNlLW91dC1xdWFkJywgJ2Vhc2UtaW4tb3V0LXF1YWQnLCAnZWFzZS1pbi1jdWJpYycsICdlYXNlLW91dC1jdWJpYycsICdlYXNlLWluLW91dC1jdWJpYycsICdlYXNlLWluLXF1YXJ0JywgJ2Vhc2Utb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tcXVpbnQnLCAnZWFzZS1vdXQtcXVpbnQnLCAnZWFzZS1pbi1vdXQtcXVpbnQnLCAnZWFzZS1pbi1leHBvJywgJ2Vhc2Utb3V0LWV4cG8nLCAnZWFzZS1pbi1vdXQtZXhwbycsICdlYXNlLWluLWNpcmMnLCAnZWFzZS1vdXQtY2lyYycsICdlYXNlLWluLW91dC1jaXJjJ11cbiAgICB9LFxuICAgIGdyYWRpZW50RGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWyd0by1ib3R0b20nLCAndG8tdG9wJywgJ3RvLWxlZnQnLCAndG8tcmlnaHQnLCAndG8tYm90dG9tLXJpZ2h0JywgJ3RvLWJvdHRvbS1sZWZ0JywgJ3RvLXRvcC1yaWdodCcsICd0by10b3AtbGVmdCcsICd0by1yaWdodC1ib3R0b20nLCAndG8tbGVmdC1ib3R0b20nLCAndG8tcmlnaHQtdG9wJywgJ3RvLWxlZnQtdG9wJyAvLyBkaWZmZXJlbnQgb3JkZXJcbiAgICAgIF1cbiAgICB9LFxuICAgIGJvdW5kc0V4cGFuc2lvbjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2YWxBcnIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID09PSAxIHx8IGxlbmd0aCA9PT0gMiB8fCBsZW5ndGggPT09IDQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZGlmZiA9IHtcbiAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24gemVyb05vblplcm8odmFsMSwgdmFsMikge1xuICAgICAgaWYgKCh2YWwxID09IG51bGwgfHwgdmFsMiA9PSBudWxsKSAmJiB2YWwxICE9PSB2YWwyKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBudWxsIGNhc2VzIGNvdWxkIHJlcHJlc2VudCBhbnkgdmFsdWVcbiAgICAgIH1cbiAgICAgIGlmICh2YWwxID09IDAgJiYgdmFsMiAhPSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh2YWwxICE9IDAgJiYgdmFsMiA9PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYW55OiBmdW5jdGlvbiBhbnkodmFsMSwgdmFsMikge1xuICAgICAgcmV0dXJuIHZhbDEgIT0gdmFsMjtcbiAgICB9LFxuICAgIGVtcHR5Tm9uRW1wdHk6IGZ1bmN0aW9uIGVtcHR5Tm9uRW1wdHkoc3RyMSwgc3RyMikge1xuICAgICAgdmFyIGVtcHR5MSA9IGVtcHR5U3RyaW5nKHN0cjEpO1xuICAgICAgdmFyIGVtcHR5MiA9IGVtcHR5U3RyaW5nKHN0cjIpO1xuICAgICAgcmV0dXJuIGVtcHR5MSAmJiAhZW1wdHkyIHx8ICFlbXB0eTEgJiYgZW1wdHkyO1xuICAgIH1cbiAgfTtcblxuICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgLy9cbiAgLy8gLSBuLmIuIGFkZGluZyBhIG5ldyBncm91cCBvZiBwcm9wcyBtYXkgcmVxdWlyZSB1cGRhdGVzIHRvIHVwZGF0ZVN0eWxlSGludHMoKVxuICAvLyAtIGFkZGluZyBuZXcgcHJvcHMgdG8gYW4gZXhpc3RpbmcgZ3JvdXAgZ2V0cyBoYW5kbGVkIGF1dG9tYXRpY2FsbHlcblxuICB2YXIgdCA9IHN0eWZuJDIudHlwZXM7XG4gIHZhciBtYWluTGFiZWwgPSBbe1xuICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5lbXB0eU5vbkVtcHR5XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1tYXJnaW4teCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIHNvdXJjZUxhYmVsID0gW3tcbiAgICBuYW1lOiAnc291cmNlLWxhYmVsJyxcbiAgICB0eXBlOiB0LnRleHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LW9mZnNldCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIHRhcmdldExhYmVsID0gW3tcbiAgICBuYW1lOiAndGFyZ2V0LWxhYmVsJyxcbiAgICB0eXBlOiB0LnRleHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LW9mZnNldCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IFt7XG4gICAgbmFtZTogJ2ZvbnQtZmFtaWx5JyxcbiAgICB0eXBlOiB0LmZvbnRGYW1pbHksXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC1zdHlsZScsXG4gICAgdHlwZTogdC5mb250U3R5bGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC13ZWlnaHQnLFxuICAgIHR5cGU6IHQuZm9udFdlaWdodCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXRyYW5zZm9ybScsXG4gICAgdHlwZTogdC50ZXh0VHJhbnNmb3JtLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtd3JhcCcsXG4gICAgdHlwZTogdC50ZXh0V3JhcCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW92ZXJmbG93LXdyYXAnLFxuICAgIHR5cGU6IHQudGV4dE92ZXJmbG93V3JhcCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1heC13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtaGVpZ2h0JyxcbiAgICB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGNvbW1vbkxhYmVsID0gW3tcbiAgICBuYW1lOiAndGV4dC12YWxpZ24nLFxuICAgIHR5cGU6IHQudmFsaWduLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtaGFsaWduJyxcbiAgICB0eXBlOiB0LmhhbGlnbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3V0bGluZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLFxuICAgIHR5cGU6IHQuYm9yZGVyU3R5bGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJyxcbiAgICB0eXBlOiB0LnRleHRCYWNrZ3JvdW5kU2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1qdXN0aWZpY2F0aW9uJyxcbiAgICB0eXBlOiB0Lmp1c3RpZmljYXRpb25cbiAgfSwge1xuICAgIG5hbWU6ICdib3gtc2VsZWN0LWxhYmVscycsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGJlaGF2aW9yID0gW3tcbiAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICB0eXBlOiB0LmJvb2wsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ldmVudHMnLFxuICAgIHR5cGU6IHQuYm9vbCxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdib3gtc2VsZWN0aW9uJyxcbiAgICB0eXBlOiB0LmJveFNlbGVjdGlvbixcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfV07XG4gIHZhciB2aXNpYmlsaXR5ID0gW3tcbiAgICBuYW1lOiAnZGlzcGxheScsXG4gICAgdHlwZTogdC5kaXNwbGF5LFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHNPZkNvbm5lY3RlZEVkZ2VzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxFZGdlczogZnVuY3Rpb24gdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsRWRnZXMoZnJvbVZhbHVlLCB0b1ZhbHVlLCBlbGUpIHtcbiAgICAgIGlmIChmcm9tVmFsdWUgPT09IHRvVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGlmIGVkZ2UgaXMgYnVuZGxlZCBiZXppZXIgKHNvIGFzIG5vdCB0byBhZmZlY3QgcGVyZm9ybWFuY2Ugb2Ygb3RoZXIgZWRnZXMpXG4gICAgICByZXR1cm4gZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZSA9PT0gJ2Jlemllcic7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ3Zpc2liaWxpdHknLFxuICAgIHR5cGU6IHQudmlzaWJpbGl0eSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ21pbi16b29tZWQtZm9udC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICd6LWNvbXBvdW5kLWRlcHRoJyxcbiAgICB0eXBlOiB0LnpDb21wb3VuZERlcHRoLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3otaW5kZXgtY29tcGFyZScsXG4gICAgdHlwZTogdC56SW5kZXhDb21wYXJlLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3otaW5kZXgnLFxuICAgIHR5cGU6IHQubnVtYmVyLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIG92ZXJsYXkgPSBbe1xuICAgIG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LXNoYXBlJyxcbiAgICB0eXBlOiB0Lm92ZXJsYXlTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LWNvcm5lci1yYWRpdXMnLFxuICAgIHR5cGU6IHQuY29ybmVyUmFkaXVzXG4gIH1dO1xuICB2YXIgdW5kZXJsYXkgPSBbe1xuICAgIG5hbWU6ICd1bmRlcmxheS1wYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndW5kZXJsYXktY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1zaGFwZScsXG4gICAgdHlwZTogdC5vdmVybGF5U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndW5kZXJsYXktY29ybmVyLXJhZGl1cycsXG4gICAgdHlwZTogdC5jb3JuZXJSYWRpdXNcbiAgfV07XG4gIHZhciB0cmFuc2l0aW9uID0gW3tcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsXG4gICAgdHlwZTogdC5wcm9wTGlzdFxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZGVsYXknLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJyxcbiAgICB0eXBlOiB0LmVhc2luZ1xuICB9XTtcbiAgdmFyIG5vZGVTaXplSGFzaE92ZXJyaWRlID0gZnVuY3Rpb24gbm9kZVNpemVIYXNoT3ZlcnJpZGUoZWxlLCBwYXJzZWRQcm9wKSB7XG4gICAgaWYgKHBhcnNlZFByb3AudmFsdWUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiAtZWxlLnBvb2xJbmRleCgpOyAvLyBubyBoYXNoIGtleSBoaXRzIGlzIHVzaW5nIGxhYmVsIHNpemUgKGhpdHJhdGUgZm9yIHBlcmYgcHJvYmFibHkgbG93IGFueXdheSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBub2RlQm9keSA9IFt7XG4gICAgbmFtZTogJ2hlaWdodCcsXG4gICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICB9LCB7XG4gICAgbmFtZTogJ3dpZHRoJyxcbiAgICB0eXBlOiB0Lm5vZGVTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICBoYXNoT3ZlcnJpZGU6IG5vZGVTaXplSGFzaE92ZXJyaWRlXG4gIH0sIHtcbiAgICBuYW1lOiAnc2hhcGUnLFxuICAgIHR5cGU6IHQubm9kZVNoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NoYXBlLXBvbHlnb24tcG9pbnRzJyxcbiAgICB0eXBlOiB0LnBvbHlnb25Qb2ludExpc3QsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29ybmVyLXJhZGl1cycsXG4gICAgdHlwZTogdC5jb3JuZXJSYWRpdXNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1maWxsJyxcbiAgICB0eXBlOiB0LmZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsXG4gICAgdHlwZTogdC5uT25lT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgdHlwZTogdC5jb2xvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuZ3JhZGllbnREaXJlY3Rpb25cbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5wYWRkaW5nUmVsYXRpdmVUbyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdib3VuZHMtZXhwYW5zaW9uJyxcbiAgICB0eXBlOiB0LmJvdW5kc0V4cGFuc2lvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBub2RlQm9yZGVyID0gW3tcbiAgICBuYW1lOiAnYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1zdHlsZScsXG4gICAgdHlwZTogdC5ib3JkZXJTdHlsZVxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1jYXAnLFxuICAgIHR5cGU6IHQubGluZUNhcFxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1qb2luJyxcbiAgICB0eXBlOiB0LmxpbmVKb2luXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLWRhc2gtcGF0dGVybicsXG4gICAgdHlwZTogdC5udW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLWRhc2gtb2Zmc2V0JyxcbiAgICB0eXBlOiB0Lm51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1wb3NpdGlvbicsXG4gICAgdHlwZTogdC5saW5lUG9zaXRpb25cbiAgfV07XG4gIHZhciBub2RlT3V0bGluZSA9IFt7XG4gICAgbmFtZTogJ291dGxpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRsaW5lLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ291dGxpbmUtd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRsaW5lLXN0eWxlJyxcbiAgICB0eXBlOiB0LmJvcmRlclN0eWxlXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0bGluZS1vZmZzZXQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSBbe1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlJyxcbiAgICB0eXBlOiB0LnVybHNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJyxcbiAgICB0eXBlOiB0LmJnQ3Jvc3NPcmlnaW5cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcnNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNvbnRhaW5tZW50JyxcbiAgICB0eXBlOiB0LmJnQ29udGFpbm1lbnRcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZycsXG4gICAgdHlwZTogdC5ib29sc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teCcsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teScsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLFxuICAgIHR5cGU6IHQuYmdSZWxhdGl2ZVRvXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nLFxuICAgIHR5cGU6IHQuYmdSZWxhdGl2ZVRvXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1yZXBlYXQnLFxuICAgIHR5cGU6IHQuYmdSZXBlYXRcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWZpdCcsXG4gICAgdHlwZTogdC5iZ0ZpdFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtY2xpcCcsXG4gICAgdHlwZTogdC5iZ0NsaXBcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoJyxcbiAgICB0eXBlOiB0LmJnV0hcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodCcsXG4gICAgdHlwZTogdC5iZ1dIXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteCcsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtb2Zmc2V0LXknLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfV07XG4gIHZhciBjb21wb3VuZCA9IFt7XG4gICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICB0eXBlOiB0LnBvc2l0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJyxcbiAgICB0eXBlOiB0LmNvbXBvdW5kSW5jbHVkZUxhYmVscyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1sZWZ0JyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXdpZHRoLWJpYXMtcmlnaHQnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLXRvcCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBlZGdlTGluZSA9IFt7XG4gICAgbmFtZTogJ2xpbmUtc3R5bGUnLFxuICAgIHR5cGU6IHQubGluZVN0eWxlXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZmlsbCcsXG4gICAgdHlwZTogdC5maWxsXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1jYXAnLFxuICAgIHR5cGU6IHQubGluZUNhcFxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1kYXNoLXBhdHRlcm4nLFxuICAgIHR5cGU6IHQubnVtYmVyc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZGFzaC1vZmZzZXQnLFxuICAgIHR5cGU6IHQubnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1vdXRsaW5lLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLW91dGxpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICB0eXBlOiB0LmNvbG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgfSwge1xuICAgIG5hbWU6ICdjdXJ2ZS1zdHlsZScsXG4gICAgdHlwZTogdC5jdXJ2ZVN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxFZGdlczogZnVuY3Rpb24gdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsRWRnZXMoZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gICAgICBpZiAoZnJvbVZhbHVlID09PSB0b1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gbXVzdCBoYXZlIGRpZmZcblxuICAgICAgcmV0dXJuIGZyb21WYWx1ZSA9PT0gJ2JlemllcicgfHxcbiAgICAgIC8vIHJlbW92ZSBmcm9tIGJ1bmRsZVxuICAgICAgdG9WYWx1ZSA9PT0gJ2Jlemllcic7IC8vIGFkZCB0byBidW5kbGVcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnaGF5c3RhY2stcmFkaXVzJyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLWVuZHBvaW50JyxcbiAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZW5kcG9pbnQnLFxuICAgIHR5cGU6IHQuZWRnZUVuZHBvaW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycsXG4gICAgdHlwZTogdC5udW1iZXJzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXdlaWdodHMnLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXJhZGlpJyxcbiAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAncmFkaXVzLXR5cGUnLFxuICAgIHR5cGU6IHQucmFkaXVzVHlwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLXR1cm4nLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuLW1pbi1kaXN0YW5jZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmF4aXNEaXJlY3Rpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS1yYWRpdXMnLFxuICAgIHR5cGU6IHQubnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2VkZ2UtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmVkZ2VEaXN0YW5jZXMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctc2NhbGUnLFxuICAgIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbG9vcC1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuYW5nbGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbG9vcC1zd2VlcCcsXG4gICAgdHlwZTogdC5hbmdsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGdob3N0ID0gW3tcbiAgICBuYW1lOiAnZ2hvc3QnLFxuICAgIHR5cGU6IHQuYm9vbCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdnaG9zdC1vZmZzZXQteCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdnaG9zdC1vZmZzZXQteScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdnaG9zdC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfV07XG4gIHZhciBjb3JlID0gW3tcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2FjdGl2ZS1iZy1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH1dO1xuXG4gIC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcbiAgdmFyIHBpZSA9IFtdO1xuICBzdHlmbiQyLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICBwaWUucHVzaCh7XG4gICAgbmFtZTogJ3BpZS1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnRcbiAgfSk7XG4gIHBpZS5wdXNoKHtcbiAgICBuYW1lOiAncGllLWhvbGUnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudFxuICB9KTtcbiAgcGllLnB1c2goe1xuICAgIG5hbWU6ICdwaWUtc3RhcnQtYW5nbGUnLFxuICAgIHR5cGU6IHQuYW5nbGVcbiAgfSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDIucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0pO1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRcbiAgICB9KTtcbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSk7XG4gIH1cblxuICAvLyBzdHJpcGUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG4gIHZhciBzdHJpcGUgPSBbXTtcbiAgc3R5Zm4kMi5zdHJpcGVCYWNrZ3JvdW5kTiA9IDE2OyAvLyBiZWNhdXNlIHRoZSBzdHJpcGUgcHJvcGVydGllcyBhcmUgbnVtYmVyZWQsIGdpdmUgYWNjZXNzIHRvIGEgY29uc3RhbnQgTiAoZm9yIHJlbmRlcmVyIHVzZSlcbiAgc3RyaXBlLnB1c2goe1xuICAgIG5hbWU6ICdzdHJpcGUtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50XG4gIH0pO1xuICBzdHJpcGUucHVzaCh7XG4gICAgbmFtZTogJ3N0cmlwZS1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuYXhpc0RpcmVjdGlvblByaW1hcnlcbiAgfSk7XG4gIGZvciAodmFyIF9pID0gMTsgX2kgPD0gc3R5Zm4kMi5zdHJpcGVCYWNrZ3JvdW5kTjsgX2krKykge1xuICAgIHN0cmlwZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdzdHJpcGUtJyArIF9pICsgJy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9KTtcbiAgICBzdHJpcGUucHVzaCh7XG4gICAgICBuYW1lOiAnc3RyaXBlLScgKyBfaSArICctYmFja2dyb3VuZC1zaXplJyxcbiAgICAgIHR5cGU6IHQucGVyY2VudFxuICAgIH0pO1xuICAgIHN0cmlwZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdzdHJpcGUtJyArIF9pICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSk7XG4gIH1cblxuICAvLyBlZGdlIGFycm93c1xuICB2YXIgZWRnZUFycm93ID0gW107XG4gIHZhciBhcnJvd1ByZWZpeGVzID0gc3R5Zm4kMi5hcnJvd1ByZWZpeGVzID0gWydzb3VyY2UnLCAnbWlkLXNvdXJjZScsICd0YXJnZXQnLCAnbWlkLXRhcmdldCddO1xuICBbe1xuICAgIG5hbWU6ICdhcnJvdy1zaGFwZScsXG4gICAgdHlwZTogdC5hcnJvd1NoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctZmlsbCcsXG4gICAgdHlwZTogdC5hcnJvd0ZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy13aWR0aCcsXG4gICAgdHlwZTogdC5hcnJvd1dpZHRoXG4gIH1dLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBhcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdHlwZSA9IHByb3AudHlwZSxcbiAgICAgICAgdHJpZ2dlcnNCb3VuZHMgPSBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICAgICAgZWRnZUFycm93LnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0cmlnZ2Vyc0JvdW5kczogdHJpZ2dlcnNCb3VuZHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCB7fSk7XG4gIHZhciBwcm9wcyA9IHN0eWZuJDIucHJvcGVydGllcyA9IFtdLmNvbmNhdChiZWhhdmlvciwgdHJhbnNpdGlvbiwgdmlzaWJpbGl0eSwgb3ZlcmxheSwgdW5kZXJsYXksIGdob3N0LCBjb21tb25MYWJlbCwgbGFiZWxEaW1lbnNpb25zLCBtYWluTGFiZWwsIHNvdXJjZUxhYmVsLCB0YXJnZXRMYWJlbCwgbm9kZUJvZHksIG5vZGVCb3JkZXIsIG5vZGVPdXRsaW5lLCBiYWNrZ3JvdW5kSW1hZ2UsIHBpZSwgc3RyaXBlLCBjb21wb3VuZCwgZWRnZUxpbmUsIGVkZ2VBcnJvdywgY29yZSk7XG4gIHZhciBwcm9wR3JvdXBzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwcyA9IHtcbiAgICAvLyBjb21tb24gdG8gYWxsIGVsZXNcbiAgICBiZWhhdmlvcjogYmVoYXZpb3IsXG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5LFxuICAgIG92ZXJsYXk6IG92ZXJsYXksXG4gICAgdW5kZXJsYXk6IHVuZGVybGF5LFxuICAgIGdob3N0OiBnaG9zdCxcbiAgICAvLyBsYWJlbHNcbiAgICBjb21tb25MYWJlbDogY29tbW9uTGFiZWwsXG4gICAgbGFiZWxEaW1lbnNpb25zOiBsYWJlbERpbWVuc2lvbnMsXG4gICAgbWFpbkxhYmVsOiBtYWluTGFiZWwsXG4gICAgc291cmNlTGFiZWw6IHNvdXJjZUxhYmVsLFxuICAgIHRhcmdldExhYmVsOiB0YXJnZXRMYWJlbCxcbiAgICAvLyBub2RlIHByb3BzXG4gICAgbm9kZUJvZHk6IG5vZGVCb2R5LFxuICAgIG5vZGVCb3JkZXI6IG5vZGVCb3JkZXIsXG4gICAgbm9kZU91dGxpbmU6IG5vZGVPdXRsaW5lLFxuICAgIGJhY2tncm91bmRJbWFnZTogYmFja2dyb3VuZEltYWdlLFxuICAgIHBpZTogcGllLFxuICAgIHN0cmlwZTogc3RyaXBlLFxuICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAvLyBlZGdlIHByb3BzXG4gICAgZWRnZUxpbmU6IGVkZ2VMaW5lLFxuICAgIGVkZ2VBcnJvdzogZWRnZUFycm93LFxuICAgIGNvcmU6IGNvcmVcbiAgfTtcbiAgdmFyIHByb3BHcm91cE5hbWVzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwTmFtZXMgPSB7fTtcbiAgdmFyIHByb3BHcm91cEtleXMgPSBzdHlmbiQyLnByb3BlcnR5R3JvdXBLZXlzID0gT2JqZWN0LmtleXMocHJvcEdyb3Vwcyk7XG4gIHByb3BHcm91cEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcHJvcEdyb3VwTmFtZXNba2V5XSA9IHByb3BHcm91cHNba2V5XS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLm5hbWU7XG4gICAgfSk7XG4gICAgcHJvcEdyb3Vwc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLmdyb3VwS2V5ID0ga2V5O1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBkZWZpbmUgYWxpYXNlc1xuICB2YXIgYWxpYXNlcyA9IHN0eWZuJDIuYWxpYXNlcyA9IFt7XG4gICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgIHBvaW50c1RvOiAnbGFiZWwnXG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZScsXG4gICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcydcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsXG4gICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LXdlaWdodHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC1kaXN0YW5jZScsXG4gICAgcG9pbnRzVG86ICdzZWdtZW50LWRpc3RhbmNlcydcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXdlaWdodCcsXG4gICAgcG9pbnRzVG86ICdzZWdtZW50LXdlaWdodHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC1yYWRpdXMnLFxuICAgIHBvaW50c1RvOiAnc2VnbWVudC1yYWRpaSdcbiAgfSwge1xuICAgIG5hbWU6ICdlZGdlLXRleHQtcm90YXRpb24nLFxuICAgIHBvaW50c1RvOiAndGV4dC1yb3RhdGlvbidcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLWxlZnQnLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLXJpZ2h0JyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy10b3AnLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9XTtcblxuICAvLyBsaXN0IG9mIHByb3BlcnR5IG5hbWVzXG4gIHN0eWZuJDIucHJvcGVydHlOYW1lcyA9IHByb3BzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLm5hbWU7XG4gIH0pO1xuXG4gIC8vIGFsbG93IGFjY2VzcyBvZiBwcm9wZXJ0aWVzIGJ5IG5hbWUgKCBlLmcuIHN0eWxlLnByb3BlcnRpZXMuaGVpZ2h0IClcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbX2kyXTtcbiAgICBwcm9wc1twcm9wLm5hbWVdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfVxuXG4gIC8vIG1hcCBhbGlhc2VzXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGFsaWFzZXMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBhbGlhcyA9IGFsaWFzZXNbX2kzXTtcbiAgICB2YXIgcG9pbnRzVG9Qcm9wID0gcHJvcHNbYWxpYXMucG9pbnRzVG9dO1xuICAgIHZhciBhbGlhc1Byb3AgPSB7XG4gICAgICBuYW1lOiBhbGlhcy5uYW1lLFxuICAgICAgYWxpYXM6IHRydWUsXG4gICAgICBwb2ludHNUbzogcG9pbnRzVG9Qcm9wXG4gICAgfTtcblxuICAgIC8vIGFkZCBhbGlhcyBwcm9wIGZvciBwYXJzaW5nXG4gICAgcHJvcHMucHVzaChhbGlhc1Byb3ApO1xuICAgIHByb3BzW2FsaWFzLm5hbWVdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG59KSgpO1xuc3R5Zm4kMi5nZXREZWZhdWx0UHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5nZXREZWZhdWx0UHJvcGVydGllcygpW25hbWVdO1xufTtcbnN0eWZuJDIuZ2V0RGVmYXVsdFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gIGlmIChfcC5kZWZhdWx0UHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF9wLmRlZmF1bHRQcm9wZXJ0aWVzO1xuICB9XG4gIHZhciByYXdQcm9wcyA9IGV4dGVuZCh7XG4gICAgLy8gY29yZSBwcm9wc1xuICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkZGQnLFxuICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAwLjY1LFxuICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcic6ICcjYWFhJyxcbiAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnOiAxLFxuICAgICdhY3RpdmUtYmctY29sb3InOiAnYmxhY2snLFxuICAgICdhY3RpdmUtYmctb3BhY2l0eSc6IDAuMTUsXG4gICAgJ2FjdGl2ZS1iZy1zaXplJzogMzAsXG4gICAgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcic6ICcjMDAwJyxcbiAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknOiAwLjEyNSxcbiAgICAvLyBjb21tb24gbm9kZS9lZGdlIHByb3BzXG4gICAgJ2V2ZW50cyc6ICd5ZXMnLFxuICAgICd0ZXh0LWV2ZW50cyc6ICdubycsXG4gICAgJ3RleHQtdmFsaWduJzogJ3RvcCcsXG4gICAgJ3RleHQtaGFsaWduJzogJ2NlbnRlcicsXG4gICAgJ3RleHQtanVzdGlmaWNhdGlvbic6ICdhdXRvJyxcbiAgICAnbGluZS1oZWlnaHQnOiAxLFxuICAgICdjb2xvcic6ICcjMDAwJyxcbiAgICAnYm94LXNlbGVjdGlvbic6ICdjb250YWluJyxcbiAgICAndGV4dC1vdXRsaW5lLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LW91dGxpbmUtd2lkdGgnOiAwLFxuICAgICd0ZXh0LW91dGxpbmUtb3BhY2l0eSc6IDEsXG4gICAgJ3RleHQtb3BhY2l0eSc6IDEsXG4gICAgJ3RleHQtZGVjb3JhdGlvbic6ICdub25lJyxcbiAgICAndGV4dC10cmFuc2Zvcm0nOiAnbm9uZScsXG4gICAgJ3RleHQtd3JhcCc6ICdub25lJyxcbiAgICAndGV4dC1vdmVyZmxvdy13cmFwJzogJ3doaXRlc3BhY2UnLFxuICAgICd0ZXh0LW1heC13aWR0aCc6IDk5OTksXG4gICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnOiAwLFxuICAgICd0ZXh0LWJvcmRlci1vcGFjaXR5JzogMCxcbiAgICAndGV4dC1ib3JkZXItd2lkdGgnOiAwLFxuICAgICd0ZXh0LWJvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ3RleHQtYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICdmb250LWZhbWlseSc6ICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJyxcbiAgICAnZm9udC1zdHlsZSc6ICdub3JtYWwnLFxuICAgICdmb250LXdlaWdodCc6ICdub3JtYWwnLFxuICAgICdmb250LXNpemUnOiAxNixcbiAgICAnbWluLXpvb21lZC1mb250LXNpemUnOiAwLFxuICAgICd0ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICdzb3VyY2UtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndGFyZ2V0LXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgJ2Rpc3BsYXknOiAnZWxlbWVudCcsXG4gICAgJ29wYWNpdHknOiAxLFxuICAgICd6LWNvbXBvdW5kLWRlcHRoJzogJ2F1dG8nLFxuICAgICd6LWluZGV4LWNvbXBhcmUnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgnOiAwLFxuICAgICdsYWJlbCc6ICcnLFxuICAgICd0ZXh0LW1hcmdpbi14JzogMCxcbiAgICAndGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ3NvdXJjZS1sYWJlbCc6ICcnLFxuICAgICdzb3VyY2UtdGV4dC1vZmZzZXQnOiAwLFxuICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAndGFyZ2V0LWxhYmVsJzogJycsXG4gICAgJ3RhcmdldC10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3RhcmdldC10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXknOiAwLFxuICAgICdvdmVybGF5LW9wYWNpdHknOiAwLFxuICAgICdvdmVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAnb3ZlcmxheS1zaGFwZSc6ICdyb3VuZC1yZWN0YW5nbGUnLFxuICAgICdvdmVybGF5LWNvcm5lci1yYWRpdXMnOiAnYXV0bycsXG4gICAgJ3VuZGVybGF5LW9wYWNpdHknOiAwLFxuICAgICd1bmRlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAndW5kZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICd1bmRlcmxheS1zaGFwZSc6ICdyb3VuZC1yZWN0YW5nbGUnLFxuICAgICd1bmRlcmxheS1jb3JuZXItcmFkaXVzJzogJ2F1dG8nLFxuICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogMCxcbiAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG4gICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogJ2xpbmVhcicsXG4gICAgJ2JveC1zZWxlY3QtbGFiZWxzJzogJ25vJyxcbiAgICAvLyBub2RlIHByb3BzXG4gICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nOiAnYW5vbnltb3VzJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCc6ICdpbnNpZGUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZyc6ICd5ZXMnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogJzUwJScsXG4gICAgJ2JhY2tncm91bmQtb2Zmc2V0LXgnOiAwLFxuICAgICdiYWNrZ3JvdW5kLW9mZnNldC15JzogMCxcbiAgICAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJ2F1dG8nLFxuICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICdhdXRvJyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2JvcmRlci1kYXNoLXBhdHRlcm4nOiBbNCwgMl0sXG4gICAgJ2JvcmRlci1kYXNoLW9mZnNldCc6IDAsXG4gICAgJ2JvcmRlci1jYXAnOiAnYnV0dCcsXG4gICAgJ2JvcmRlci1qb2luJzogJ21pdGVyJyxcbiAgICAnYm9yZGVyLXBvc2l0aW9uJzogJ2NlbnRlcicsXG4gICAgJ291dGxpbmUtY29sb3InOiAnIzk5OScsXG4gICAgJ291dGxpbmUtb3BhY2l0eSc6IDEsXG4gICAgJ291dGxpbmUtd2lkdGgnOiAwLFxuICAgICdvdXRsaW5lLW9mZnNldCc6IDAsXG4gICAgJ291dGxpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICdoZWlnaHQnOiAzMCxcbiAgICAnd2lkdGgnOiAzMCxcbiAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAxLCAtMSwgICAxLCAxLCAgIC0xLCAxJyxcbiAgICAnY29ybmVyLXJhZGl1cyc6ICdhdXRvJyxcbiAgICAnYm91bmRzLWV4cGFuc2lvbic6IDAsXG4gICAgLy8gbm9kZSBncmFkaWVudFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbic6ICd0by1ib3R0b20nLFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAvLyBnaG9zdCBwcm9wc1xuICAgICdnaG9zdCc6ICdubycsXG4gICAgJ2dob3N0LW9mZnNldC15JzogMCxcbiAgICAnZ2hvc3Qtb2Zmc2V0LXgnOiAwLFxuICAgICdnaG9zdC1vcGFjaXR5JzogMCxcbiAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgICdwYWRkaW5nJzogMCxcbiAgICAncGFkZGluZy1yZWxhdGl2ZS10byc6ICd3aWR0aCcsXG4gICAgJ3Bvc2l0aW9uJzogJ29yaWdpbicsXG4gICAgJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJzogJ2luY2x1ZGUnLFxuICAgICdtaW4td2lkdGgnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1sZWZ0JzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtcmlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLXRvcCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nOiAwXG4gIH0sIHtcbiAgICAvLyBub2RlIHBpZSBiZ1xuICAgICdwaWUtc2l6ZSc6ICcxMDAlJyxcbiAgICAncGllLWhvbGUnOiAwLFxuICAgICdwaWUtc3RhcnQtYW5nbGUnOiAnMGRlZydcbiAgfSwgW3tcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtY29sb3InLFxuICAgIHZhbHVlOiAnYmxhY2snXG4gIH0sIHtcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtc2l6ZScsXG4gICAgdmFsdWU6ICcwJSdcbiAgfSwge1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB2YWx1ZTogMVxuICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDIucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUucmVwbGFjZSgne3tpfX0nLCBpKTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSksIHtcbiAgICAvLyBub2RlIHN0cmlwZXMgYmdcbiAgICAnc3RyaXBlLXNpemUnOiAnMTAwJScsXG4gICAgJ3N0cmlwZS1kaXJlY3Rpb24nOiAnaG9yaXpvbnRhbCdcbiAgfSwgW3tcbiAgICBuYW1lOiAnc3RyaXBlLXt7aX19LWJhY2tncm91bmQtY29sb3InLFxuICAgIHZhbHVlOiAnYmxhY2snXG4gIH0sIHtcbiAgICBuYW1lOiAnc3RyaXBlLXt7aX19LWJhY2tncm91bmQtc2l6ZScsXG4gICAgdmFsdWU6ICcwJSdcbiAgfSwge1xuICAgIG5hbWU6ICdzdHJpcGUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB2YWx1ZTogMVxuICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDIuc3RyaXBlQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUucmVwbGFjZSgne3tpfX0nLCBpKTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSksIHtcbiAgICAvLyBlZGdlIHByb3BzXG4gICAgJ2xpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICdsaW5lLWNvbG9yJzogJyM5OTknLFxuICAgICdsaW5lLWZpbGwnOiAnc29saWQnLFxuICAgICdsaW5lLWNhcCc6ICdidXR0JyxcbiAgICAnbGluZS1vcGFjaXR5JzogMSxcbiAgICAnbGluZS1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAnbGluZS1vdXRsaW5lLWNvbG9yJzogJyMwMDAnLFxuICAgICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnOiA0MCxcbiAgICAnY29udHJvbC1wb2ludC13ZWlnaHRzJzogMC41LFxuICAgICdzZWdtZW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtZGlzdGFuY2VzJzogMjAsXG4gICAgJ3NlZ21lbnQtcmFkaWknOiAxNSxcbiAgICAncmFkaXVzLXR5cGUnOiAnYXJjLXJhZGl1cycsXG4gICAgJ3RheGktdHVybic6ICc1MCUnLFxuICAgICd0YXhpLXJhZGl1cyc6IDE1LFxuICAgICd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJzogMTAsXG4gICAgJ3RheGktZGlyZWN0aW9uJzogJ2F1dG8nLFxuICAgICdlZGdlLWRpc3RhbmNlcyc6ICdpbnRlcnNlY3Rpb24nLFxuICAgICdjdXJ2ZS1zdHlsZSc6ICdoYXlzdGFjaycsXG4gICAgJ2hheXN0YWNrLXJhZGl1cyc6IDAsXG4gICAgJ2Fycm93LXNjYWxlJzogMSxcbiAgICAnbG9vcC1kaXJlY3Rpb24nOiAnLTQ1ZGVnJyxcbiAgICAnbG9vcC1zd2VlcCc6ICctOTBkZWcnLFxuICAgICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAnbGluZS1kYXNoLXBhdHRlcm4nOiBbNiwgM10sXG4gICAgJ2xpbmUtZGFzaC1vZmZzZXQnOiAwXG4gIH0sIFt7XG4gICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICB2YWx1ZTogJ25vbmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgIHZhbHVlOiAnIzk5OSdcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICB2YWx1ZTogJ2ZpbGxlZCdcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy13aWR0aCcsXG4gICAgdmFsdWU6IDFcbiAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBzdHlmbiQyLmFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH0pO1xuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSk7XG4gIHZhciBwYXJzZWRQcm9wcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW2ldO1xuICAgIGlmIChwcm9wLnBvaW50c1RvKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgdmFyIHZhbCA9IHJhd1Byb3BzW25hbWVdO1xuICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWwpO1xuICAgIHBhcnNlZFByb3BzW25hbWVdID0gcGFyc2VkUHJvcDtcbiAgfVxuICBfcC5kZWZhdWx0UHJvcGVydGllcyA9IHBhcnNlZFByb3BzO1xuICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG59O1xuc3R5Zm4kMi5hZGREZWZhdWx0U3R5bGVzaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZWxlY3RvcignOnBhcmVudCcpLmNzcyh7XG4gICAgJ3NoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgJ3BhZGRpbmcnOiAxMCxcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZWVlJyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyNjY2MnLFxuICAgICdib3JkZXItd2lkdGgnOiAxXG4gIH0pLnNlbGVjdG9yKCdlZGdlJykuY3NzKHtcbiAgICAnd2lkdGgnOiAzXG4gIH0pLnNlbGVjdG9yKCc6bG9vcCcpLmNzcyh7XG4gICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcidcbiAgfSkuc2VsZWN0b3IoJ2VkZ2U6Y29tcG91bmQnKS5jc3Moe1xuICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICdzb3VyY2UtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJyxcbiAgICAndGFyZ2V0LWVuZHBvaW50JzogJ291dHNpZGUtdG8tbGluZSdcbiAgfSkuc2VsZWN0b3IoJzpzZWxlY3RlZCcpLmNzcyh7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ2xpbmUtY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdtaWQtc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdtaWQtdGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknXG4gIH0pLnNlbGVjdG9yKCc6cGFyZW50OnNlbGVjdGVkJykuY3NzKHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjQ0NFMUY5JyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyNhZWM4ZTUnXG4gIH0pLnNlbGVjdG9yKCc6YWN0aXZlJykuY3NzKHtcbiAgICAnb3ZlcmxheS1jb2xvcic6ICdibGFjaycsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gIH0pO1xuICB0aGlzLmRlZmF1bHRMZW5ndGggPSB0aGlzLmxlbmd0aDtcbn07XG5cbnZhciBzdHlmbiQxID0ge307XG5cbi8vIGEgY2FjaGluZyBsYXllciBmb3IgcHJvcGVydHkgcGFyc2luZ1xuc3R5Zm4kMS5wYXJzZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBmdW5jdGlvbiB2YWx1ZXMgY2FuJ3QgYmUgY2FjaGVkIGluIGFsbCBjYXNlcywgYW5kIHRoZXJlIGlzbid0IG11Y2ggYmVuZWZpdCBvZiBjYWNoaW5nIHRoZW0gYW55d2F5XG4gIGlmIChmbiQ2KHZhbHVlKSkge1xuICAgIHJldHVybiBzZWxmLnBhcnNlSW1wbFdhcm4obmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG4gIH1cbiAgdmFyIGZsYXRLZXkgPSBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycgfHwgcHJvcElzRmxhdCA9PT0gdHJ1ZSB8fCBwcm9wSXNGbGF0ID09PSBmYWxzZSB8fCBwcm9wSXNGbGF0ID09IG51bGwgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgdmFyIGJ5cGFzc0tleSA9IHByb3BJc0J5cGFzcyA/ICd0JyA6ICdmJztcbiAgdmFyIHZhbHVlS2V5ID0gJycgKyB2YWx1ZTtcbiAgdmFyIGFyZ0hhc2ggPSBoYXNoU3RyaW5ncyhuYW1lLCB2YWx1ZUtleSwgYnlwYXNzS2V5LCBmbGF0S2V5KTtcbiAgdmFyIHByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgfHwgW107XG4gIHZhciByZXQ7XG4gIGlmICghKHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSkpIHtcbiAgICByZXQgPSBwcm9wQ2FjaGVbYXJnSGFzaF0gPSBzZWxmLnBhcnNlSW1wbFdhcm4obmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG4gIH1cblxuICAvLyAtIGJ5cGFzc2VzIGNhbid0IGJlIHNoYXJlZCBiL2MgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGJ5IGFuaW1hdGlvbnMgb3Igb3RoZXJ3aXNlIG92ZXJyaWRkZW5cbiAgLy8gLSBtYXBwaW5ncyBjYW4ndCBiZSBzaGFyZWQgYi9jIG1hcHBpbmdzIGFyZSBwZXItZWxlbWVudFxuICBpZiAocHJvcElzQnlwYXNzIHx8IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJykge1xuICAgIC8vIG5lZWQgYSBjb3B5IHNpbmNlIHByb3BzIGFyZSBtdXRhdGVkIGxhdGVyIGluIHRoZWlyIGxpZmVjeWNsZXNcbiAgICByZXQgPSBjb3B5KHJldCk7XG4gICAgaWYgKHJldCkge1xuICAgICAgcmV0LnZhbHVlID0gY29weShyZXQudmFsdWUpOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbnN0eWZuJDEucGFyc2VJbXBsV2FybiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBwcm9wID0gdGhpcy5wYXJzZUltcGwobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG4gIGlmICghcHJvcCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgd2FybihcIlRoZSBzdHlsZSBwcm9wZXJ0eSBgXCIuY29uY2F0KG5hbWUsIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcImAgaXMgaW52YWxpZFwiKSk7XG4gIH1cbiAgaWYgKHByb3AgJiYgKHByb3AubmFtZSA9PT0gJ3dpZHRoJyB8fCBwcm9wLm5hbWUgPT09ICdoZWlnaHQnKSAmJiB2YWx1ZSA9PT0gJ2xhYmVsJykge1xuICAgIHdhcm4oJ1RoZSBzdHlsZSB2YWx1ZSBvZiBgbGFiZWxgIGlzIGRlcHJlY2F0ZWQgZm9yIGAnICsgcHJvcC5uYW1lICsgJ2AnKTtcbiAgfVxuICByZXR1cm4gcHJvcDtcbn07XG5cbi8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4vLyBmaWVsZHMgOlxuLy8gLSBuYW1lIDogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4vLyAtIGJ5cGFzcyA6IHRydWUgaWZmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eVxuc3R5Zm4kMS5wYXJzZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIG5hbWUgPSBjYW1lbDJkYXNoKG5hbWUpOyAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnR5IG5hbWUgaXMgaW4gZGFzaCBmb3JtIChlLmcuICdwcm9wZXJ0eS1uYW1lJyBub3QgJ3Byb3BlcnR5TmFtZScpXG5cbiAgdmFyIHByb3BlcnR5ID0gc2VsZi5wcm9wZXJ0aWVzW25hbWVdO1xuICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgaWYgKCFwcm9wZXJ0eSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGNhbid0IGFzc2lnbiB1bmRlZmluZWRcblxuICAvLyB0aGUgcHJvcGVydHkgbWF5IGJlIGFuIGFsaWFzXG4gIGlmIChwcm9wZXJ0eS5hbGlhcykge1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucG9pbnRzVG87XG4gICAgbmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gIH1cbiAgdmFyIHZhbHVlSXNTdHJpbmcgPSBzdHJpbmcodmFsdWUpO1xuICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgIC8vIHRyaW0gdGhlIHZhbHVlIHRvIG1ha2UgcGFyc2luZyBlYXNpZXJcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICB2YXIgdHlwZSA9IHByb3BlcnR5LnR5cGU7XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIG5vIHR5cGUsIG5vIGx1Y2tcblxuICAvLyBjaGVjayBpZiBieXBhc3MgaXMgbnVsbCBvciBlbXB0eSBzdHJpbmcgKGkuZS4gaW5kaWNhdGlvbiB0byBkZWxldGUgYnlwYXNzIHByb3BlcnR5KVxuICBpZiAocHJvcElzQnlwYXNzICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBieXBhc3M6IHRydWUsXG4gICAgICBkZWxldGVCeXBhc3M6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiB1c2VkIGFzIGEgbWFwcGVyXG4gIGlmIChmbiQ2KHZhbHVlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICdmbicsXG4gICAgICBtYXBwZWQ6IHR5cGVzLmZuLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgbWFwcGVkXG4gIHZhciBkYXRhLCBtYXBEYXRhO1xuICBpZiAoIXZhbHVlSXNTdHJpbmcgfHwgcHJvcElzRmxhdCB8fCB2YWx1ZS5sZW5ndGggPCA3IHx8IHZhbHVlWzFdICE9PSAnYScpIDsgZWxzZSBpZiAodmFsdWUubGVuZ3RoID49IDcgJiYgdmFsdWVbMF0gPT09ICdkJyAmJiAoZGF0YSA9IG5ldyBSZWdFeHAodHlwZXMuZGF0YS5yZWdleCkuZXhlYyh2YWx1ZSkpKSB7XG4gICAgaWYgKHByb3BJc0J5cGFzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuICAgIHZhciBtYXBwZWQgPSB0eXBlcy5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgZmllbGQ6IGRhdGFbMV0sXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID49IDEwICYmIHZhbHVlWzBdID09PSAnbScgJiYgKG1hcERhdGEgPSBuZXcgUmVnRXhwKHR5cGVzLm1hcERhdGEucmVnZXgpLmV4ZWModmFsdWUpKSkge1xuICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG4gICAgaWYgKHR5cGUubXVsdGlwbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGltcG9zc2libGUgdG8gbWFwIHRvIG51bVxuXG4gICAgdmFyIF9tYXBwZWQgPSB0eXBlcy5tYXBEYXRhO1xuXG4gICAgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG4gICAgaWYgKCEodHlwZS5jb2xvciB8fCB0eXBlLm51bWJlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlTWluID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzRdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiAoIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs1XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgaWYgKCF2YWx1ZU1heCB8fCB2YWx1ZU1heC5tYXBwZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZU1pbiBhbmQgdmFsdWVNYXggYXJlIHRoZSBzYW1lXG4gICAgaWYgKHZhbHVlTWluLnBmVmFsdWUgPT09IHZhbHVlTWF4LnBmVmFsdWUgfHwgdmFsdWVNaW4uc3RyVmFsdWUgPT09IHZhbHVlTWF4LnN0clZhbHVlKSB7XG4gICAgICB3YXJuKCdgJyArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnYCBpcyBub3QgYSB2YWxpZCBtYXBwZXIgYmVjYXVzZSB0aGUgb3V0cHV0IHJhbmdlIGlzIHplcm87IGNvbnZlcnRpbmcgdG8gYCcgKyBuYW1lICsgJzogJyArIHZhbHVlTWluLnN0clZhbHVlICsgJ2AnKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlTWluLnN0clZhbHVlKTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcbiAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgJiYgYzFbMV0gPT09IGMyWzFdIC8vIGdyZWVuXG4gICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgJiYgKFxuICAgICAgLy8gb3B0aW9uYWwgYWxwaGFcbiAgICAgIGMxWzNdID09PSBjMlszXSAvLyBzYW1lIGFscGhhIG91dHJpZ2h0XG4gICAgICB8fCAoYzFbM10gPT0gbnVsbCB8fCBjMVszXSA9PT0gMSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAxP1xuICAgICAgKSAmJiAoYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICk7XG4gICAgICBpZiAoc2FtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGNhbid0IG1ha2UgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IG1hcERhdGEsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIG1hcHBlZDogX21hcHBlZCxcbiAgICAgIGZpZWxkOiBtYXBEYXRhWzFdLFxuICAgICAgZmllbGRNaW46IHBhcnNlRmxvYXQobWFwRGF0YVsyXSksXG4gICAgICAvLyBtaW4gJiBtYXggYXJlIG51bWVyaWNcbiAgICAgIGZpZWxkTWF4OiBwYXJzZUZsb2F0KG1hcERhdGFbM10pLFxuICAgICAgdmFsdWVNaW46IHZhbHVlTWluLnZhbHVlLFxuICAgICAgdmFsdWVNYXg6IHZhbHVlTWF4LnZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlLm11bHRpcGxlICYmIHByb3BJc0ZsYXQgIT09ICdtdWx0aXBsZScpIHtcbiAgICB2YXIgdmFscztcbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFscyA9IHZhbHVlLnNwbGl0KC9cXHMrLyk7XG4gICAgfSBlbHNlIGlmIChhcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHMgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFscyA9IFt2YWx1ZV07XG4gICAgfVxuICAgIGlmICh0eXBlLmV2ZW5NdWx0aXBsZSAmJiB2YWxzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsQXJyID0gW107XG4gICAgdmFyIHVuaXRzQXJyID0gW107XG4gICAgdmFyIHBmVmFsQXJyID0gW107XG4gICAgdmFyIHN0clZhbCA9ICcnO1xuICAgIHZhciBoYXNFbnVtID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHNlbGYucGFyc2UobmFtZSwgdmFsc1tpXSwgcHJvcElzQnlwYXNzLCAnbXVsdGlwbGUnKTtcbiAgICAgIGhhc0VudW0gPSBoYXNFbnVtIHx8IHN0cmluZyhwLnZhbHVlKTtcbiAgICAgIHZhbEFyci5wdXNoKHAudmFsdWUpO1xuICAgICAgcGZWYWxBcnIucHVzaChwLnBmVmFsdWUgIT0gbnVsbCA/IHAucGZWYWx1ZSA6IHAudmFsdWUpO1xuICAgICAgdW5pdHNBcnIucHVzaChwLnVuaXRzKTtcbiAgICAgIHN0clZhbCArPSAoaSA+IDAgPyAnICcgOiAnJykgKyBwLnN0clZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZS52YWxpZGF0ZSAmJiAhdHlwZS52YWxpZGF0ZSh2YWxBcnIsIHVuaXRzQXJyKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlLnNpbmdsZUVudW0gJiYgaGFzRW51bSkge1xuICAgICAgaWYgKHZhbEFyci5sZW5ndGggPT09IDEgJiYgc3RyaW5nKHZhbEFyclswXSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgc3RyVmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbEFycixcbiAgICAgIHBmVmFsdWU6IHBmVmFsQXJyLFxuICAgICAgc3RyVmFsdWU6IHN0clZhbCxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgdW5pdHM6IHVuaXRzQXJyXG4gICAgfTtcbiAgfVxuXG4gIC8vIHNldmVyYWwgdHlwZXMgYWxzbyBhbGxvdyBlbnVtc1xuICB2YXIgY2hlY2tFbnVtcyA9IGZ1bmN0aW9uIGNoZWNrRW51bXMoKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgZW4gPSB0eXBlLmVudW1zW19pXTtcbiAgICAgIGlmIChlbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvLyBjaGVjayB0aGUgdHlwZSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBvYmplY3RcbiAgaWYgKHR5cGUubnVtYmVyKSB7XG4gICAgdmFyIHVuaXRzO1xuICAgIHZhciBpbXBsaWNpdFVuaXRzID0gJ3B4JzsgLy8gbm90IHNldCA9PiBweFxuXG4gICAgaWYgKHR5cGUudW5pdHMpIHtcbiAgICAgIC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICB1bml0cyA9IHR5cGUudW5pdHM7XG4gICAgfVxuICAgIGlmICh0eXBlLmltcGxpY2l0VW5pdHMpIHtcbiAgICAgIGltcGxpY2l0VW5pdHMgPSB0eXBlLmltcGxpY2l0VW5pdHM7XG4gICAgfVxuICAgIGlmICghdHlwZS51bml0bGVzcykge1xuICAgICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHVuaXRzUmVnZXggPSAncHh8ZW0nICsgKHR5cGUuYWxsb3dQZXJjZW50ID8gJ3xcXFxcJScgOiAnJyk7XG4gICAgICAgIGlmICh1bml0cykge1xuICAgICAgICAgIHVuaXRzUmVnZXggPSB1bml0cztcbiAgICAgICAgfSAvLyBvbmx5IGFsbG93IGV4cGxpY2l0IHVuaXRzIGlmIHNvIHNldFxuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgnXignICsgbnVtYmVyICsgJykoJyArIHVuaXRzUmVnZXggKyAnKT8nICsgJyQnKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICB1bml0cyA9IG1hdGNoWzJdIHx8IGltcGxpY2l0VW5pdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXVuaXRzIHx8IHR5cGUuaW1wbGljaXRVbml0cykge1xuICAgICAgICB1bml0cyA9IGltcGxpY2l0VW5pdHM7IC8vIGltcGxpY2l0bHkgcHggaWYgdW5zcGVjaWZpZWRcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgIC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcbiAgICBpZiAoaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBudW1iZXIgdHlwZSBhbHNvIGFjY2VwdHMgc3BlY2lhbCBrZXl3b3JkcyBpbiBwbGFjZSBvZiBudW1iZXJzXG4gICAgLy8gKGkuZS4gYGxlZnRgLCBgYXV0b2AsIGV0YylcbiAgICBpZiAoaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcbiAgICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgaWYgKHR5cGUuaW50ZWdlciAmJiAhaW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHZhbHVlIGlzIHdpdGhpbiByYW5nZVxuICAgIGlmICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmICh2YWx1ZSA8IHR5cGUubWluIHx8IHR5cGUuc3RyaWN0TWluICYmIHZhbHVlID09PSB0eXBlLm1pbikgfHwgdHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPiB0eXBlLm1heCB8fCB0eXBlLnN0cmljdE1heCAmJiB2YWx1ZSA9PT0gdHlwZS5tYXgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJldCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuICAgIGlmICh0eXBlLnVuaXRsZXNzIHx8IHVuaXRzICE9PSAncHgnICYmIHVuaXRzICE9PSAnZW0nKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncHgnIHx8ICF1bml0cyA/IHZhbHVlIDogdGhpcy5nZXRFbVNpemVJblBpeGVscygpICogdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIG1zXG4gICAgaWYgKHVuaXRzID09PSAnbXMnIHx8IHVuaXRzID09PSAncycpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdtcycgPyB2YWx1ZSA6IDEwMDAgKiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcmFkXG4gICAgaWYgKHVuaXRzID09PSAnZGVnJyB8fCB1bml0cyA9PT0gJ3JhZCcpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdyYWQnID8gdmFsdWUgOiBkZWcycmFkKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgdmFsdWUgaW4gJVxuICAgIGlmICh1bml0cyA9PT0gJyUnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHZhbHVlIC8gMTAwO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9IGVsc2UgaWYgKHR5cGUucHJvcExpc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlO1xuICAgIGlmIChwcm9wc1N0ciA9PT0gJ25vbmUnKSA7IGVsc2Uge1xuICAgICAgLy8gZ28gb3ZlciBlYWNoIHByb3BcblxuICAgICAgdmFyIHByb3BzU3BsaXQgPSBwcm9wc1N0ci5zcGxpdCgvXFxzKixcXHMqfFxccysvKTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHByb3BzU3BsaXQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wc1NwbGl0W19pMl0udHJpbSgpO1xuICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXSkge1xuICAgICAgICAgIHByb3BzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ2AnICsgcHJvcE5hbWUgKyAnYCBpcyBub3QgYSB2YWxpZCBwcm9wZXJ0eSBuYW1lJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHByb3BzLFxuICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oJyAnKSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgdmFyIHR1cGxlID0gY29sb3IydHVwbGUodmFsdWUpO1xuICAgIGlmICghdHVwbGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgIHBmVmFsdWU6IHR1cGxlLFxuICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIHR1cGxlWzBdICsgJywnICsgdHVwbGVbMV0gKyAnLCcgKyB0dXBsZVsyXSArICcpJyxcbiAgICAgIC8vIG4uYi4gbm8gc3BhY2VzIGIvYyBvZiBtdWx0aXBsZSBzdXBwb3J0XG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5yZWdleCB8fCB0eXBlLnJlZ2V4ZXMpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBlbnVtc1xuICAgIGlmICh0eXBlLmVudW1zKSB7XG4gICAgICB2YXIgZW51bVByb3AgPSBjaGVja0VudW1zKCk7XG4gICAgICBpZiAoZW51bVByb3ApIHtcbiAgICAgICAgcmV0dXJuIGVudW1Qcm9wO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVnZXhlcyA9IHR5cGUucmVnZXhlcyA/IHR5cGUucmVnZXhlcyA6IFt0eXBlLnJlZ2V4XTtcbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByZWdleGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhlc1tfaTNdKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGUgc3RyaW5nXG4gICAgICB2YXIgbSA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgLy8gcmVnZXggbWF0Y2hlc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHR5cGUuc2luZ2xlUmVnZXhNYXRjaFZhbHVlID8gbVsxXSA6IG0sXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCBhbnlcbiAgfSBlbHNlIGlmICh0eXBlLnN0cmluZykge1xuICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAvLyBjaGVjayBlbnVtcyBsYXN0IGJlY2F1c2UgaXQncyBhIGNvbWJvIHR5cGUgaW4gb3RoZXJzXG4gICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gIH1cbn07XG5cbnZhciBfU3R5bGUgPSBmdW5jdGlvbiBTdHlsZShjeSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX1N0eWxlKSkge1xuICAgIHJldHVybiBuZXcgX1N0eWxlKGN5KTtcbiAgfVxuICBpZiAoIWNvcmUoY3kpKSB7XG4gICAgZXJyb3IoJ0Egc3R5bGUgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgY29yZVN0eWxlOiB7fVxuICB9O1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucmVzZXRUb0RlZmF1bHQoKTtcbn07XG52YXIgc3R5Zm4gPSBfU3R5bGUucHJvdG90eXBlO1xuc3R5Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnc3R5bGUnO1xufTtcblxuLy8gcmVtb3ZlIGFsbCBjb250ZXh0c1xuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy5sZW5ndGggPSAwO1xuICBfcC5jb250ZXh0U3R5bGVzID0ge307XG4gIF9wLnByb3BEaWZmcyA9IHt9O1xuICB0aGlzLmNsZWFuRWxlbWVudHMoZWxlcywgdHJ1ZSk7XG4gIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGVsZV9wID0gZWxlWzBdLl9wcml2YXRlO1xuICAgIGVsZV9wLnN0eWxlRGlydHkgPSB0cnVlO1xuICAgIGVsZV9wLmFwcGxpZWRJbml0U3R5bGUgPSBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbnN0eWZuLnJlc2V0VG9EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBidWlsZHMgYSBzdHlsZSBvYmplY3QgZm9yIHRoZSAnY29yZScgc2VsZWN0b3JcbnN0eWZuLmNvcmUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlW3Byb3BOYW1lXSB8fCB0aGlzLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wTmFtZSk7XG59O1xuXG4vLyBjcmVhdGUgYSBuZXcgY29udGV4dCBmcm9tIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3Igc3RyaW5nIGFuZCBzd2l0Y2ggdG8gdGhhdCBjb250ZXh0XG5zdHlmbi5zZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvclN0cikge1xuICAvLyAnY29yZScgaXMgYSBzcGVjaWFsIGNhc2UgYW5kIGRvZXMgbm90IG5lZWQgYSBzZWxlY3RvclxuICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvclN0ciA9PT0gJ2NvcmUnID8gbnVsbCA6IG5ldyBTZWxlY3RvcihzZWxlY3RvclN0cik7XG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKzsgLy8gbmV3IGNvbnRleHQgbWVhbnMgbmV3IGluZGV4XG4gIHRoaXNbaV0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdLFxuICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgIGluZGV4OiBpXG4gIH07XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG5zdHlmbi5jc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciBtYXBWYWwgPSBtYXBbcHJvcC5uYW1lXTtcbiAgICAgIGlmIChtYXBWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXBWYWwgPSBtYXBbZGFzaDJjYW1lbChwcm9wLm5hbWUpXTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXBWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNzc1J1bGUocHJvcC5uYW1lLCBtYXBWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMuY3NzUnVsZShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxuXG4gIC8vIGRvIG5vdGhpbmcgaWYgYXJncyBhcmUgaW52YWxpZFxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbnN0eWZuLnN0eWxlID0gc3R5Zm4uY3NzO1xuXG4vLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuc3R5Zm4uY3NzUnVsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAvLyBuYW1lLXZhbHVlIHBhaXJcbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSk7XG5cbiAgLy8gYWRkIHByb3BlcnR5IHRvIGN1cnJlbnQgY29udGV4dCBpZiB2YWxpZFxuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzW3Byb3BlcnR5Lm5hbWVdID0gcHJvcGVydHk7IC8vIGFsbG93IGFjY2VzcyBieSBuYW1lIGFzIHdlbGxcblxuICAgIGlmIChwcm9wZXJ0eS5uYW1lLm1hdGNoKC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pICYmIHByb3BlcnR5LnZhbHVlKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmhhc1BpZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eS5uYW1lLm1hdGNoKC9zdHJpcGUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pICYmIHByb3BlcnR5LnZhbHVlKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmhhc1N0cmlwZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eS5tYXBwZWQpIHtcbiAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcbiAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbaV0uc2VsZWN0b3I7XG4gICAgaWYgKGN1cnJlbnRTZWxlY3RvcklzQ29yZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuc3R5Zm4uYXBwZW5kID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gIGlmIChzdHlsZXNoZWV0KHN0eWxlKSkge1xuICAgIHN0eWxlLmFwcGVuZFRvU3R5bGUodGhpcyk7XG4gIH0gZWxzZSBpZiAoYXJyYXkoc3R5bGUpKSB7XG4gICAgdGhpcy5hcHBlbmRGcm9tSnNvbihzdHlsZSk7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHN0eWxlKSkge1xuICAgIHRoaXMuYXBwZW5kRnJvbVN0cmluZyhzdHlsZSk7XG4gIH0gLy8geW91IHByb2JhYmx5IHdvdWxkbid0IHdhbnQgdG8gYXBwZW5kIGEgU3R5bGUsIHNpbmNlIHlvdSdkIGR1cGxpY2F0ZSB0aGUgZGVmYXVsdCBwYXJ0c1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc3RhdGljIGZ1bmN0aW9uXG5fU3R5bGUuZnJvbUpzb24gPSBmdW5jdGlvbiAoY3ksIGpzb24pIHtcbiAgdmFyIHN0eWxlID0gbmV3IF9TdHlsZShjeSk7XG4gIHN0eWxlLmZyb21Kc29uKGpzb24pO1xuICByZXR1cm4gc3R5bGU7XG59O1xuX1N0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoY3ksIHN0cmluZykge1xuICByZXR1cm4gbmV3IF9TdHlsZShjeSkuZnJvbVN0cmluZyhzdHJpbmcpO1xufTtcbltzdHlmbiQ4LCBzdHlmbiQ3LCBzdHlmbiQ2LCBzdHlmbiQ1LCBzdHlmbiQ0LCBzdHlmbiQzLCBzdHlmbiQyLCBzdHlmbiQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoc3R5Zm4sIHByb3BzKTtcbn0pO1xuX1N0eWxlLnR5cGVzID0gc3R5Zm4udHlwZXM7XG5fU3R5bGUucHJvcGVydGllcyA9IHN0eWZuLnByb3BlcnRpZXM7XG5fU3R5bGUucHJvcGVydHlHcm91cHMgPSBzdHlmbi5wcm9wZXJ0eUdyb3Vwcztcbl9TdHlsZS5wcm9wZXJ0eUdyb3VwTmFtZXMgPSBzdHlmbi5wcm9wZXJ0eUdyb3VwTmFtZXM7XG5fU3R5bGUucHJvcGVydHlHcm91cEtleXMgPSBzdHlmbi5wcm9wZXJ0eUdyb3VwS2V5cztcblxudmFyIGNvcmVmbiQyID0ge1xuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmV3U3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zZXRTdHlsZShuZXdTdHlsZSk7XG4gICAgICBzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZTtcbiAgfSxcbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gc3R5bGUuZ2VuZXJhdGVTdHlsZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBfU3R5bGUuZnJvbUpzb24odGhpcywgc3R5bGUpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBfU3R5bGUuZnJvbVN0cmluZyh0aGlzLCBzdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wLnN0eWxlID0gX1N0eWxlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gX3Auc3R5bGU7XG4gIH0sXG4gIC8vIGUuZy4gY3kuZGF0YSgpIGNoYW5nZWQgPT4gcmVjYWxjIGVsZSBtYXBwZXJzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiB1cGRhdGVTdHlsZSgpIHtcbiAgICB0aGlzLm11dGFibGVFbGVtZW50cygpLnVwZGF0ZVN0eWxlKCk7IC8vIGp1c3Qgc2VuZCB0byBhbGwgZWxlc1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbnZhciBjb3JlZm4kMSA9IHtcbiAgYXV0b2xvY2s6IGZ1bmN0aW9uIGF1dG9sb2NrKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBhdXRvdW5ncmFiaWZ5OiBmdW5jdGlvbiBhdXRvdW5ncmFiaWZ5KGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbiBhdXRvdW5zZWxlY3RpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24gc2VsZWN0aW9uVHlwZShzZWxUeXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoX3Auc2VsZWN0aW9uVHlwZSA9PSBudWxsKSB7XG4gICAgICBfcC5zZWxlY3Rpb25UeXBlID0gZGVmYXVsdFNlbGVjdGlvblR5cGU7XG4gICAgfVxuICAgIGlmIChzZWxUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzZWxUeXBlID09PSAnYWRkaXRpdmUnIHx8IHNlbFR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3Auc2VsZWN0aW9uVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiBwYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgdXNlclBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiB1c2VyUGFubmluZ0VuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgem9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJab29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBib3hTZWxlY3Rpb25FbmFibGVkOiBmdW5jdGlvbiBib3hTZWxlY3Rpb25FbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcGFuOiBmdW5jdGlvbiBwYW4oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIC5wYW4oKVxuICAgICAgICByZXR1cm4gcGFuO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoc3RyaW5nKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgLy8gLnBhbigneCcpXG4gICAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgICByZXR1cm4gcGFuW2RpbV07XG4gICAgICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3QoYXJnc1swXSkpIHtcbiAgICAgICAgICAvLyAucGFuKHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICB5ID0gZGltcy55O1xuICAgICAgICAgIGlmIChudW1iZXIkMSh4KSkge1xuICAgICAgICAgICAgcGFuLnggPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVtYmVyJDEoeSkpIHtcbiAgICAgICAgICAgIHBhbi55ID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gLnBhbigneCcsIDEwMClcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgdmFsID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgIHBhbltkaW1dID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaW52YWxpZFxuICAgIH1cbiAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcGFuQnk6IGZ1bmN0aW9uIHBhbkJ5KGFyZzAsIGFyZzEpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKHBsYWluT2JqZWN0KGFyZzApKSB7XG4gICAgICAgICAgLy8gLnBhbkJ5KHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICB5ID0gZGltcy55O1xuICAgICAgICAgIGlmIChudW1iZXIkMSh4KSkge1xuICAgICAgICAgICAgcGFuLnggKz0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bWJlciQxKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSArPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgIGRpbSA9IGFyZzA7XG4gICAgICAgIHZhbCA9IGFyZzE7XG4gICAgICAgIGlmICgoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBpbnZhbGlkXG4gICAgfVxuICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBnYzogZnVuY3Rpb24gZ2MoKSB7XG4gICAgdGhpcy5ub3RpZnkoJ2djJyk7XG4gIH0sXG4gIGZpdDogZnVuY3Rpb24gZml0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKTtcbiAgICBpZiAodmlld3BvcnRTdGF0ZSkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIF9wLnpvb20gPSB2aWV3cG9ydFN0YXRlLnpvb207XG4gICAgICBfcC5wYW4gPSB2aWV3cG9ydFN0YXRlLnBhbjtcbiAgICAgIHRoaXMuZW1pdCgncGFuIHpvb20gdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uIGdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgaWYgKG51bWJlciQxKGVsZW1lbnRzKSAmJiBwYWRkaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGVsZW1lbnRzIGlzIG9wdGlvbmFsXG4gICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBiYjtcbiAgICBpZiAoc3RyaW5nKGVsZW1lbnRzKSkge1xuICAgICAgdmFyIHNlbCA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLiQoc2VsKTtcbiAgICB9IGVsc2UgaWYgKGJvdW5kaW5nQm94KGVsZW1lbnRzKSkge1xuICAgICAgLy8gYXNzdW1lIGJiXG4gICAgICB2YXIgYmJlID0gZWxlbWVudHM7XG4gICAgICBiYiA9IHtcbiAgICAgICAgeDE6IGJiZS54MSxcbiAgICAgICAgeTE6IGJiZS55MSxcbiAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgeTI6IGJiZS55MlxuICAgICAgfTtcbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgfSBlbHNlIGlmICghZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICYmIGVsZW1lbnRzLmVtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNhbid0IGZpdCB0byBub3RoaW5nXG5cbiAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHZhciB6b29tO1xuICAgIHBhZGRpbmcgPSBudW1iZXIkMShwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuICAgIGlmICghaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgYmIudyA+IDAgJiYgYmIuaCA+IDApIHtcbiAgICAgIHpvb20gPSBNYXRoLm1pbigodyAtIDIgKiBwYWRkaW5nKSAvIGJiLncsIChoIC0gMiAqIHBhZGRpbmcpIC8gYmIuaCk7XG5cbiAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgLy8gbm93IHBhbiB0byBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICAgIHk6IChoIC0gem9vbSAqIChiYi55MSArIGJiLnkyKSkgLyAyXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBwYW5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSxcbiAgem9vbVJhbmdlOiBmdW5jdGlvbiB6b29tUmFuZ2UobWluLCBtYXgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgdmFyIG9wdHMgPSBtaW47XG4gICAgICBtaW4gPSBvcHRzLm1pbjtcbiAgICAgIG1heCA9IG9wdHMubWF4O1xuICAgIH1cbiAgICBpZiAobnVtYmVyJDEobWluKSAmJiBudW1iZXIkMShtYXgpICYmIG1pbiA8PSBtYXgpIHtcbiAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgICBfcC5tYXhab29tID0gbWF4O1xuICAgIH0gZWxzZSBpZiAobnVtYmVyJDEobWluKSAmJiBtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPD0gX3AubWF4Wm9vbSkge1xuICAgICAgX3AubWluWm9vbSA9IG1pbjtcbiAgICB9IGVsc2UgaWYgKG51bWJlciQxKG1heCkgJiYgbWluID09PSB1bmRlZmluZWQgJiYgbWF4ID49IF9wLm1pblpvb20pIHtcbiAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtaW5ab29tOiBmdW5jdGlvbiBtaW5ab29tKHpvb20pIHtcbiAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5taW5ab29tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICBtaW46IHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgbWF4Wm9vbTogZnVuY3Rpb24gbWF4Wm9vbSh6b29tKSB7XG4gICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuem9vbVJhbmdlKHtcbiAgICAgICAgbWF4OiB6b29tXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldFpvb21lZFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRab29tZWRWaWV3cG9ydChwYXJhbXMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjdXJyZW50UGFuID0gX3AucGFuO1xuICAgIHZhciBjdXJyZW50Wm9vbSA9IF9wLnpvb207XG4gICAgdmFyIHBvczsgLy8gaW4gcmVuZGVyZWQgcHhcbiAgICB2YXIgem9vbTtcbiAgICB2YXIgYmFpbCA9IGZhbHNlO1xuICAgIGlmICghX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIHpvb21pbmcgZGlzYWJsZWRcbiAgICAgIGJhaWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobnVtYmVyJDEocGFyYW1zKSkge1xuICAgICAgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgIHpvb20gPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgem9vbSA9IHBhcmFtcy5sZXZlbDtcbiAgICAgIGlmIChwYXJhbXMucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBwb3MgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiQxKHBhcmFtcy5wb3NpdGlvbiwgY3VycmVudFpvb20sIGN1cnJlbnRQYW4pO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyAhPSBudWxsICYmICFfcC5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAvLyBwYW5uaW5nIGRpc2FibGVkXG4gICAgICAgIGJhaWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyb3Agem9vbVxuICAgIHpvb20gPSB6b29tID4gX3AubWF4Wm9vbSA/IF9wLm1heFpvb20gOiB6b29tO1xuICAgIHpvb20gPSB6b29tIDwgX3AubWluWm9vbSA/IF9wLm1pblpvb20gOiB6b29tO1xuXG4gICAgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG4gICAgaWYgKGJhaWwgfHwgIW51bWJlciQxKHpvb20pIHx8IHpvb20gPT09IGN1cnJlbnRab29tIHx8IHBvcyAhPSBudWxsICYmICghbnVtYmVyJDEocG9zLngpIHx8ICFudW1iZXIkMShwb3MueSkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAvLyBzZXQgem9vbSBhYm91dCBwb3NpdGlvblxuICAgICAgdmFyIHBhbjEgPSBjdXJyZW50UGFuO1xuICAgICAgdmFyIHpvb20xID0gY3VycmVudFpvb207XG4gICAgICB2YXIgem9vbTIgPSB6b29tO1xuICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKHBvcy54IC0gcGFuMS54KSArIHBvcy54LFxuICAgICAgICB5OiAtem9vbTIgLyB6b29tMSAqIChwb3MueSAtIHBhbjEueSkgKyBwb3MueVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgcGFubmVkOiB0cnVlLFxuICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgcGFuOiBwYW4yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbWVkOiB0cnVlLFxuICAgICAgICBwYW5uZWQ6IGZhbHNlLFxuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IGN1cnJlbnRQYW5cbiAgICAgIH07XG4gICAgfVxuICB9LFxuICB6b29tOiBmdW5jdGlvbiB6b29tKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZ2V0XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXRcbiAgICAgIHZhciB2cCA9IHRoaXMuZ2V0Wm9vbWVkVmlld3BvcnQocGFyYW1zKTtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBpZiAodnAgPT0gbnVsbCB8fCAhdnAuem9vbWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgX3Auem9vbSA9IHZwLnpvb207XG4gICAgICBpZiAodnAucGFubmVkKSB7XG4gICAgICAgIF9wLnBhbi54ID0gdnAucGFuLng7XG4gICAgICAgIF9wLnBhbi55ID0gdnAucGFuLnk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ3pvb20nICsgKHZwLnBhbm5lZCA/ICcgcGFuJyA6ICcnKSArICcgdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfVxuICB9LFxuICB2aWV3cG9ydDogZnVuY3Rpb24gdmlld3BvcnQob3B0cykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICB2YXIgcGFuRGVmZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG4gICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFudW1iZXIkMShvcHRzLnpvb20pKSB7XG4gICAgICB6b29tRGVmZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdHMucGFuKSkge1xuICAgICAgcGFuRGVmZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXpvb21EZWZkICYmICFwYW5EZWZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHpvb21EZWZkKSB7XG4gICAgICB2YXIgeiA9IG9wdHMuem9vbTtcbiAgICAgIGlmICh6IDwgX3AubWluWm9vbSB8fCB6ID4gX3AubWF4Wm9vbSB8fCAhX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgICAgem9vbUZhaWxlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC56b29tID0gejtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3pvb20nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHZhciBwID0gb3B0cy5wYW47XG4gICAgICBpZiAobnVtYmVyJDEocC54KSkge1xuICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyJDEocC55KSkge1xuICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXBhbkZhaWxlZCkge1xuICAgICAgICBldmVudHMucHVzaCgncGFuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgZXZlbnRzLnB1c2goJ3ZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLmVtaXQoZXZlbnRzLmpvaW4oJyAnKSk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKGVsZW1lbnRzKSB7XG4gICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKGVsZW1lbnRzKTtcbiAgICBpZiAocGFuKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjtcbiAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdldENlbnRlclBhbjogZnVuY3Rpb24gZ2V0Q2VudGVyUGFuKGVsZW1lbnRzLCB6b29tKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNhbid0IGNlbnRyZSBwYW4gdG8gbm90aGluZ1xuXG4gICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG4gICAgdmFyIHBhbiA9IHtcbiAgICAgIC8vIG1pZGRsZVxuICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgIH07XG4gICAgcmV0dXJuIHBhbjtcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMudmlld3BvcnQoe1xuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICB6b29tOiAxXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiBpbnZhbGlkYXRlU2l6ZSgpIHtcbiAgICB0aGlzLl9wcml2YXRlLnNpemVDYWNoZSA9IG51bGw7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY29udGFpbmVyID0gX3AuY29udGFpbmVyO1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgcmV0dXJuIF9wLnNpemVDYWNoZSA9IF9wLnNpemVDYWNoZSB8fCAoY29udGFpbmVyID8gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0eWxlID0gY3kud2luZG93KCkuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgdmFyIHZhbCA9IGZ1bmN0aW9uIHZhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGggLSB2YWwoJ3BhZGRpbmctbGVmdCcpIC0gdmFsKCdwYWRkaW5nLXJpZ2h0JyksXG4gICAgICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodCAtIHZhbCgncGFkZGluZy10b3AnKSAtIHZhbCgncGFkZGluZy1ib3R0b20nKVxuICAgICAgfTtcbiAgICB9KCkgOiB7XG4gICAgICAvLyBmYWxsYmFjayBpZiBubyBjb250YWluZXIgKG5vdCAwIGIvYyBjYW4gYmUgdXNlZCBmb3IgZGl2aWRpbmcgZXRjKVxuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDFcbiAgICB9KTtcbiAgfSxcbiAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUoKS53aWR0aDtcbiAgfSxcbiAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLmhlaWdodDtcbiAgfSxcbiAgZXh0ZW50OiBmdW5jdGlvbiBleHRlbnQoKSB7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgIHZhciByYiA9IHRoaXMucmVuZGVyZWRFeHRlbnQoKTtcbiAgICB2YXIgYiA9IHtcbiAgICAgIHgxOiAocmIueDEgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeDI6IChyYi54MiAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5MTogKHJiLnkxIC0gcGFuLnkpIC8gem9vbSxcbiAgICAgIHkyOiAocmIueTIgLSBwYW4ueSkgLyB6b29tXG4gICAgfTtcbiAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICBiLmggPSBiLnkyIC0gYi55MTtcbiAgICByZXR1cm4gYjtcbiAgfSxcbiAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uIHJlbmRlcmVkRXh0ZW50KCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHgyOiB3aWR0aCxcbiAgICAgIHkyOiBoZWlnaHQsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodFxuICAgIH07XG4gIH0sXG4gIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWU6IGZ1bmN0aW9uIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoX2ludCkge1xuICAgIGlmIChfaW50KSB0aGlzLl9wcml2YXRlLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUgPSBfaW50O2Vsc2UgcmV0dXJuIHRoaXMuX3ByaXZhdGUubXVsdGlDbGlja0RlYm91bmNlVGltZTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuY29yZWZuJDEuY2VudHJlID0gY29yZWZuJDEuY2VudGVyO1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuY29yZWZuJDEuYXV0b2xvY2tOb2RlcyA9IGNvcmVmbiQxLmF1dG9sb2NrO1xuY29yZWZuJDEuYXV0b3VuZ3JhYmlmeU5vZGVzID0gY29yZWZuJDEuYXV0b3VuZ3JhYmlmeTtcblxudmFyIGZuID0ge1xuICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZURhdGE6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSlcbn07XG5cbi8vIGFsaWFzZXNcbmZuLmF0dHIgPSBmbi5kYXRhO1xuZm4ucmVtb3ZlQXR0ciA9IGZuLnJlbW92ZURhdGE7XG5cbnZhciBDb3JlID0gZnVuY3Rpb24gQ29yZShvcHRzKSB7XG4gIHZhciBjeSA9IHRoaXM7XG4gIG9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICB2YXIgY29udGFpbmVyID0gb3B0cy5jb250YWluZXI7XG5cbiAgLy8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cmFwcGVkIGpxdWVyeSBvYmplY3RcbiAgLy8gZS5nLiBjeXRvc2NhcGUoeyBjb250YWluZXI6ICQoJyNjeScpIH0pXG4gIGlmIChjb250YWluZXIgJiYgIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgfVxuICB2YXIgcmVnID0gY29udGFpbmVyID8gY29udGFpbmVyLl9jeXJlZyA6IG51bGw7IC8vIGUuZy4gYWxyZWFkeSByZWdpc3RlcmVkIHNvbWUgaW5mbyAoZS5nLiByZWFkaWVzKSB2aWEganF1ZXJ5XG4gIHJlZyA9IHJlZyB8fCB7fTtcbiAgaWYgKHJlZyAmJiByZWcuY3kpIHtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICB9XG4gIHZhciByZWFkaWVzID0gcmVnLnJlYWRpZXMgPSByZWcucmVhZGllcyB8fCBbXTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5fY3lyZWcgPSByZWc7XG4gIH0gLy8gbWFrZSBzdXJlIGNvbnRhaW5lciBhc3NvYydkIHJlZyBwb2ludHMgdG8gdGhpcyBjeVxuICByZWcuY3kgPSBjeTtcbiAgdmFyIGhlYWQgPSBfd2luZG93ICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgIW9wdHMuaGVhZGxlc3M7XG4gIHZhciBvcHRpb25zID0gb3B0cztcbiAgb3B0aW9ucy5sYXlvdXQgPSBleHRlbmQoe1xuICAgIG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCdcbiAgfSwgb3B0aW9ucy5sYXlvdXQpO1xuICBvcHRpb25zLnJlbmRlcmVyID0gZXh0ZW5kKHtcbiAgICBuYW1lOiBoZWFkID8gJ2NhbnZhcycgOiAnbnVsbCdcbiAgfSwgb3B0aW9ucy5yZW5kZXJlcik7XG4gIHZhciBkZWZWYWwgPSBmdW5jdGlvbiBkZWZWYWwoZGVmLCB2YWwsIGFsdFZhbCkge1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2UgaWYgKGFsdFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYWx0VmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgfTtcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgcmVhZHk6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAvLyBjYWNoZWQgb3B0aW9uc1xuICAgIGVsZW1lbnRzOiBuZXcgQ29sbGVjdGlvbih0aGlzKSxcbiAgICAvLyBlbGVtZW50cyBpbiB0aGUgZ3JhcGhcbiAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgYW5pRWxlczogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICBkYXRhOiBvcHRpb25zLmRhdGEgfHwge30sXG4gICAgLy8gZGF0YSBmb3IgdGhlIGNvcmVcbiAgICBzY3JhdGNoOiB7fSxcbiAgICAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgIGxheW91dDogbnVsbCxcbiAgICByZW5kZXJlcjogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgZGVzdHJveSB3YXMgY2FsbGVkXG4gICAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IHRydWUsXG4gICAgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgIG1pblpvb206IDFlLTUwLFxuICAgIG1heFpvb206IDFlNTAsXG4gICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnpvb21pbmdFbmFibGVkKSxcbiAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJab29taW5nRW5hYmxlZCksXG4gICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJQYW5uaW5nRW5hYmxlZCksXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCksXG4gICAgYXV0b2xvY2s6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvbG9jaywgb3B0aW9ucy5hdXRvbG9ja05vZGVzKSxcbiAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSksXG4gICAgc3R5bGVFbmFibGVkOiBvcHRpb25zLnN0eWxlRW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gaGVhZCA6IG9wdGlvbnMuc3R5bGVFbmFibGVkLFxuICAgIHpvb206IG51bWJlciQxKG9wdGlvbnMuem9vbSkgPyBvcHRpb25zLnpvb20gOiAxLFxuICAgIHBhbjoge1xuICAgICAgeDogcGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIG51bWJlciQxKG9wdGlvbnMucGFuLngpID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICB5OiBwbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgbnVtYmVyJDEob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgcXVldWU6IFtdXG4gICAgfSxcbiAgICBoYXNDb21wb3VuZE5vZGVzOiBmYWxzZSxcbiAgICBtdWx0aUNsaWNrRGVib3VuY2VUaW1lOiBkZWZWYWwoMjUwLCBvcHRpb25zLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUpXG4gIH07XG4gIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuXG4gIC8vIHNldCBzZWxlY3Rpb24gdHlwZVxuICB0aGlzLnNlbGVjdGlvblR5cGUob3B0aW9ucy5zZWxlY3Rpb25UeXBlKTtcblxuICAvLyBpbml0IHpvb20gYm91bmRzXG4gIHRoaXMuem9vbVJhbmdlKHtcbiAgICBtaW46IG9wdGlvbnMubWluWm9vbSxcbiAgICBtYXg6IG9wdGlvbnMubWF4Wm9vbVxuICB9KTtcbiAgdmFyIGxvYWRFeHREYXRhID0gZnVuY3Rpb24gbG9hZEV4dERhdGEoZXh0RGF0YSwgbmV4dCkge1xuICAgIHZhciBhbnlJc1Byb21pc2UgPSBleHREYXRhLnNvbWUocHJvbWlzZSk7XG4gICAgaWYgKGFueUlzUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UkMS5hbGwoZXh0RGF0YSkudGhlbihuZXh0KTsgLy8gbG9hZCBhbGwgZGF0YSBhc3luY2hyb25vdXNseSwgdGhlbiBleGVjIHJlc3Qgb2YgaW5pdFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0KGV4dERhdGEpOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgfVxuICB9O1xuXG4gIC8vIHN0YXJ0IHdpdGggdGhlIGRlZmF1bHQgc3R5bGVzaGVldCBzbyB3ZSBoYXZlIHNvbWV0aGluZyBiZWZvcmUgbG9hZGluZyBhbiBleHRlcm5hbCBzdHlsZXNoZWV0XG4gIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICBjeS5zZXRTdHlsZShbXSk7XG4gIH1cblxuICAvLyBjcmVhdGUgdGhlIHJlbmRlcmVyXG4gIHZhciByZW5kZXJlck9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIpOyAvLyBhbGxvdyByZW5kZXJpbmcgaGludHMgaW4gdG9wIGxldmVsIG9wdGlvbnNcbiAgY3kuaW5pdFJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG4gIHZhciBzZXRFbGVzQW5kTGF5b3V0ID0gZnVuY3Rpb24gc2V0RWxlc0FuZExheW91dChlbGVtZW50cywgb25sb2FkLCBvbmRvbmUpIHtcbiAgICBjeS5ub3RpZmljYXRpb25zKGZhbHNlKTtcblxuICAgIC8vIHJlbW92ZSBvbGQgZWxlbWVudHNcbiAgICB2YXIgb2xkRWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICAgIGlmIChvbGRFbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG9sZEVsZXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50cyAhPSBudWxsKSB7XG4gICAgICBpZiAocGxhaW5PYmplY3QoZWxlbWVudHMpIHx8IGFycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICBjeS5hZGQoZWxlbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgICBjeS5lbWl0KGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgIGN5Lm9uZSgnbG9hZCcsIG9ubG9hZCk7XG4gICAgICBjeS5lbWl0QW5kTm90aWZ5KCdsb2FkJyk7XG4gICAgfSkub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24gKCkge1xuICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgIGN5LmVtaXQoJ2RvbmUnKTtcbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0T3B0cyA9IGV4dGVuZCh7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgIGxheW91dE9wdHMuZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgY3kubGF5b3V0KGxheW91dE9wdHMpLnJ1bigpO1xuICB9O1xuICBsb2FkRXh0RGF0YShbb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50c10sIGZ1bmN0aW9uICh0aGVucykge1xuICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICB2YXIgaW5pdEVsZXMgPSB0aGVuc1sxXTtcblxuICAgIC8vIGluaXQgc3R5bGVcbiAgICBpZiAoX3Auc3R5bGVFbmFibGVkKSB7XG4gICAgICBjeS5zdHlsZSgpLmFwcGVuZChpbml0U3R5bGUpO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWwgbG9hZFxuICAgIHNldEVsZXNBbmRMYXlvdXQoaW5pdEVsZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIG9ucmVhZHlcbiAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgX3AucmVhZHkgPSB0cnVlO1xuXG4gICAgICAvLyBpZiBhIHJlYWR5IGNhbGxiYWNrIGlzIHNwZWNpZmllZCBhcyBhbiBvcHRpb24sIHRoZSBiaW5kIGl0XG4gICAgICBpZiAoZm4kNihvcHRpb25zLnJlYWR5KSkge1xuICAgICAgICBjeS5vbigncmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIH1cblxuICAgICAgLy8gYmluZCBhbGwgdGhlIHJlYWR5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgYmVmb3JlIGNyZWF0aW5nIHRoaXMgaW5zdGFuY2VcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVhZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm4gPSByZWFkaWVzW2ldO1xuICAgICAgICBjeS5vbigncmVhZHknLCBmbik7XG4gICAgICB9XG4gICAgICBpZiAocmVnKSB7XG4gICAgICAgIHJlZy5yZWFkaWVzID0gW107XG4gICAgICB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG5cbiAgICAgIGN5LmVtaXQoJ3JlYWR5Jyk7XG4gICAgfSwgb3B0aW9ucy5kb25lKTtcbiAgfSk7XG59O1xudmFyIGNvcmVmbiA9IENvcmUucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG5leHRlbmQoY29yZWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2NvcmUnO1xuICB9LFxuICBpc1JlYWR5OiBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICB9LFxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIGlmICh0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdCgncmVhZHknLCBbXSwgZm4pOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGlmIChjeS5kZXN0cm95ZWQoKSkgcmV0dXJuO1xuICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgY3kuX3ByaXZhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY3k7XG4gIH0sXG4gIGhhc0VsZW1lbnRXaXRoSWQ6IGZ1bmN0aW9uIGhhc0VsZW1lbnRXaXRoSWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5oYXNFbGVtZW50V2l0aElkKGlkKTtcbiAgfSxcbiAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICB9LFxuICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbiBoYXNDb21wb3VuZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gIH0sXG4gIGhlYWRsZXNzOiBmdW5jdGlvbiBoZWFkbGVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlci5pc0hlYWRsZXNzKCk7XG4gIH0sXG4gIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24gc3R5bGVFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgfSxcbiAgYWRkVG9Qb29sOiBmdW5jdGlvbiBhZGRUb1Bvb2woZWxlcykge1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMubWVyZ2UoZWxlcyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHJlbW92ZUZyb21Qb29sOiBmdW5jdGlvbiByZW1vdmVGcm9tUG9vbChlbGVzKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy51bm1lcmdlKGVsZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb250YWluZXI6IGZ1bmN0aW9uIGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXIgfHwgbnVsbDtcbiAgfSxcbiAgd2luZG93OiBmdW5jdGlvbiB3aW5kb3coKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkgcmV0dXJuIF93aW5kb3c7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lci5vd25lckRvY3VtZW50O1xuICAgIGlmIChvd25lckRvY3VtZW50ID09PSB1bmRlZmluZWQgfHwgb3duZXJEb2N1bWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gX3dpbmRvdztcbiAgICB9XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgX3dpbmRvdztcbiAgfSxcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcbiAgICBpZiAoIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICAgIH1cbiAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgIF9wLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBfcC5zdHlsZUVuYWJsZWQgPSB0cnVlO1xuICAgIGN5LmludmFsaWRhdGVTaXplKCk7XG4gICAgY3kuaW5pdFJlbmRlcmVyKGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlciwge1xuICAgICAgLy8gYWxsb3cgY3VzdG9tIHJlbmRlcmVyIG5hbWUgdG8gYmUgcmUtdXNlZCwgb3RoZXJ3aXNlIHVzZSBjYW52YXNcbiAgICAgIG5hbWU6IG9wdGlvbnMucmVuZGVyZXIubmFtZSA9PT0gJ251bGwnID8gJ2NhbnZhcycgOiBvcHRpb25zLnJlbmRlcmVyLm5hbWVcbiAgICB9KSk7XG4gICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgY3kuc3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gICAgY3kuZW1pdCgnbW91bnQnKTtcbiAgICByZXR1cm4gY3k7XG4gIH0sXG4gIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgIGN5LmluaXRSZW5kZXJlcih7XG4gICAgICBuYW1lOiAnbnVsbCdcbiAgICB9KTtcbiAgICBjeS5lbWl0KCd1bm1vdW50Jyk7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKCkge1xuICAgIHJldHVybiBjb3B5KHRoaXMuX3ByaXZhdGUub3B0aW9ucyk7XG4gIH0sXG4gIGpzb246IGZ1bmN0aW9uIGpzb24ob2JqKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICAgIHZhciBnZXRGcmVzaFJlZiA9IGZ1bmN0aW9uIGdldEZyZXNoUmVmKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKGVsZS5pZCgpKTtcbiAgICB9O1xuICAgIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgICAvLyBzZXRcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgaWYgKG9iai5lbGVtZW50cykge1xuICAgICAgICB2YXIgaWRJbkpzb24gPSB7fTtcbiAgICAgICAgdmFyIHVwZGF0ZUVsZXMgPSBmdW5jdGlvbiB1cGRhdGVFbGVzKGpzb25zLCBncikge1xuICAgICAgICAgIHZhciB0b0FkZCA9IFtdO1xuICAgICAgICAgIHZhciB0b01vZCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgICAgICBpZiAoIWpzb24uZGF0YS5pZCkge1xuICAgICAgICAgICAgICB3YXJuKCdjeS5qc29uKCkgY2Fubm90IGhhbmRsZSBlbGVtZW50cyB3aXRob3V0IGFuIElEIGF0dHJpYnV0ZScpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZCA9ICcnICsganNvbi5kYXRhLmlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuICAgICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgIGlkSW5Kc29uW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZWxlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAvLyBleGlzdGluZyBlbGVtZW50IHNob3VsZCBiZSB1cGRhdGVkXG4gICAgICAgICAgICAgIHRvTW9kLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZTogZWxlLFxuICAgICAgICAgICAgICAgIGpzb246IGpzb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugc2hvdWxkIGJlIGFkZGVkXG4gICAgICAgICAgICAgIGlmIChncikge1xuICAgICAgICAgICAgICAgIGpzb24uZ3JvdXAgPSBncjtcbiAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goanNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3kuYWRkKHRvQWRkKTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9Nb2QubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX3RvTW9kJF9pID0gdG9Nb2RbX2ldLFxuICAgICAgICAgICAgICBfZWxlID0gX3RvTW9kJF9pLmVsZSxcbiAgICAgICAgICAgICAgX2pzb24gPSBfdG9Nb2QkX2kuanNvbjtcbiAgICAgICAgICAgIF9lbGUuanNvbihfanNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJyYXkob2JqLmVsZW1lbnRzKSkge1xuICAgICAgICAgIC8vIGVsZW1lbnRzOiBbXVxuICAgICAgICAgIHVwZGF0ZUVsZXMob2JqLmVsZW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbGVtZW50czogeyBub2RlczogW10sIGVkZ2VzOiBbXSB9XG4gICAgICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdyID0gZ3JzW2ldO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gb2JqLmVsZW1lbnRzW2dyXTtcbiAgICAgICAgICAgIGlmIChhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgdXBkYXRlRWxlcyhlbGVtZW50cywgZ3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50c1RvUmVtb3ZlID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuICFpZEluSnNvbltlbGUuaWQoKV07XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgcGFyZW50c1RvUmVtb3ZlLm1lcmdlKGVsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNvIHRoYXQgY2hpbGRyZW4gYXJlIG5vdCByZW1vdmVkIHcvcGFyZW50XG4gICAgICAgIHBhcmVudHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmNoaWxkcmVuKCkubW92ZSh7XG4gICAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW50ZXJtZWRpYXRlIHBhcmVudHMgbWF5IGJlIG1vdmVkIGJ5IHByaW9yIGxpbmUsIHNvIG1ha2Ugc3VyZSB3ZSByZW1vdmUgYnkgZnJlc2ggcmVmc1xuICAgICAgICBwYXJlbnRzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEZyZXNoUmVmKGVsZSkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5zdHlsZSkge1xuICAgICAgICBjeS5zdHlsZShvYmouc3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20pIHtcbiAgICAgICAgY3kuem9vbShvYmouem9vbSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqLnBhbikge1xuICAgICAgICBpZiAob2JqLnBhbi54ICE9PSBfcC5wYW4ueCB8fCBvYmoucGFuLnkgIT09IF9wLnBhbi55KSB7XG4gICAgICAgICAgY3kucGFuKG9iai5wYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgICAgY3kuZGF0YShvYmouZGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgZmllbGRzID0gWydtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJywgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsICdib3hTZWxlY3Rpb25FbmFibGVkJywgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5JywgJ211bHRpQ2xpY2tEZWJvdW5jZVRpbWUnXTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGZpZWxkcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBmID0gZmllbGRzW19pMl07XG4gICAgICAgIGlmIChvYmpbZl0gIT0gbnVsbCkge1xuICAgICAgICAgIGN5W2ZdKG9ialtmXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0XG4gICAgICB2YXIgZmxhdCA9ICEhb2JqO1xuICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgIGlmIChmbGF0KSB7XG4gICAgICAgIGpzb24uZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCkubWFwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmpzb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG4gICAgICAgICAgaWYgKCFqc29uLmVsZW1lbnRzW2dyb3VwXSkge1xuICAgICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0ucHVzaChlbGUuanNvbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQpIHtcbiAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgfVxuICAgICAganNvbi5kYXRhID0gY29weShjeS5kYXRhKCkpO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfcC5vcHRpb25zO1xuICAgICAganNvbi56b29taW5nRW5hYmxlZCA9IF9wLnpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyWm9vbWluZ0VuYWJsZWQgPSBfcC51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnpvb20gPSBfcC56b29tO1xuICAgICAganNvbi5taW5ab29tID0gX3AubWluWm9vbTtcbiAgICAgIGpzb24ubWF4Wm9vbSA9IF9wLm1heFpvb207XG4gICAgICBqc29uLnBhbm5pbmdFbmFibGVkID0gX3AucGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJQYW5uaW5nRW5hYmxlZCA9IF9wLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24ucGFuID0gY29weShfcC5wYW4pO1xuICAgICAganNvbi5ib3hTZWxlY3Rpb25FbmFibGVkID0gX3AuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICAgIGpzb24ucmVuZGVyZXIgPSBjb3B5KG9wdGlvbnMucmVuZGVyZXIpO1xuICAgICAganNvbi5oaWRlRWRnZXNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICAgICAganNvbi50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gICAgICBqc29uLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICBqc29uLm1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXI7XG4gICAgICBqc29uLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUgPSBvcHRpb25zLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH1cbn0pO1xuY29yZWZuLiRpZCA9IGNvcmVmbi5nZXRFbGVtZW50QnlJZDtcbltjb3JlZm4kOSwgY29yZWZuJDgsIGVsZXNmbiwgY29yZWZuJDcsIGNvcmVmbiQ2LCBjb3JlZm4kNSwgY29yZWZuJDQsIGNvcmVmbiQzLCBjb3JlZm4kMiwgY29yZWZuJDEsIGZuXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoY29yZWZuLCBwcm9wcyk7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBkZWZhdWx0cyQ3ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gIGRpcmVjdGlvbjogJ2Rvd253YXJkJyxcbiAgLy8gZGV0ZXJtaW5lcyB0aGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSB0cmVlIHN0cnVjdHVyZSBpcyBkcmF3bi4gIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlICdkb3dud2FyZCcsICd1cHdhcmQnLCAncmlnaHR3YXJkJywgb3IgJ2xlZnR3YXJkJy5cbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgb24gZml0XG4gIGNpcmNsZTogZmFsc2UsXG4gIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgZ3JpZDogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gY3JlYXRlIGFuIGV2ZW4gZ3JpZCBpbnRvIHdoaWNoIHRoZSBEQUcgaXMgcGxhY2VkIChjaXJjbGU6ZmFsc2Ugb25seSlcbiAgc3BhY2luZ0ZhY3RvcjogMS43NSxcbiAgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHJvb3RzOiB1bmRlZmluZWQsXG4gIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgZGVwdGhTb3J0OiB1bmRlZmluZWQsXG4gIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciBub2RlcyBhdCBlcXVhbCBkZXB0aC4gZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZCxcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xufTtcbnZhciBkZXByZWNhdGVkT3B0aW9uRGVmYXVsdHMgPSB7XG4gIG1heGltYWw6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHNoaWZ0IG5vZGVzIGRvd24gdGhlaXIgbmF0dXJhbCBCRlMgZGVwdGhzIGluIG9yZGVyIHRvIGF2b2lkIHVwd2FyZHMgZWRnZXMgKERBR1Mgb25seSk7IHNldHRpbmcgYWN5Y2xpYyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlIGFsc29cbiAgYWN5Y2xpYzogZmFsc2UgLy8gd2hldGhlciB0aGUgdHJlZSBpcyBhY3ljbGljIGFuZCB0aHVzIGEgbm9kZSBjb3VsZCBiZSBzaGlmdGVkIChkdWUgdG8gdGhlIG1heGltYWwgb3B0aW9uKSBtdWx0aXBsZSB0aW1lcyB3aXRob3V0IGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcDsgc2V0dGluZyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlIGFsc287IGlmIHlvdSBhcmUgdW5jZXJ0YWluIHdoZXRoZXIgYSB0cmVlIGlzIGFjeWNsaWMsIHNldCB0byBmYWxzZSB0byBhdm9pZCBwb3RlbnRpYWwgaW5maW5pdGUgbG9vcHNcbn07XG5cbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGdldEluZm8gPSBmdW5jdGlvbiBnZXRJbmZvKGVsZSkge1xuICByZXR1cm4gZWxlLnNjcmF0Y2goJ2JyZWFkdGhmaXJzdCcpO1xufTtcbnZhciBzZXRJbmZvID0gZnVuY3Rpb24gc2V0SW5mbyhlbGUsIG9iaikge1xuICByZXR1cm4gZWxlLnNjcmF0Y2goJ2JyZWFkdGhmaXJzdCcsIG9iaik7XG59O1xuZnVuY3Rpb24gQnJlYWR0aEZpcnN0TGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ3LCBkZXByZWNhdGVkT3B0aW9uRGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzQ2hpbGRsZXNzKCk7XG4gIH0pO1xuICB2YXIgZ3JhcGggPSBlbGVzO1xuICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICB2YXIgbWF4aW1hbCA9IG9wdGlvbnMuYWN5Y2xpYyB8fCBvcHRpb25zLm1heGltYWwgfHwgb3B0aW9ucy5tYXhpbWFsQWRqdXN0bWVudHMgPiAwOyAvLyBtYXhpbWFsQWRqdXN0bWVudHMgZm9yIGNvbXBhdC4gdy8gb2xkIGNvZGU7IGFsc28sIHNldHRpbmcgYWN5Y2xpYyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlXG5cbiAgdmFyIGhhc0JvdW5kaW5nQm94ID0gISFvcHRpb25zLmJvdW5kaW5nQm94O1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3goaGFzQm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDogc3RydWN0dXJlZENsb25lKGN5LmV4dGVudCgpKSk7XG4gIHZhciByb290cztcbiAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykpIHtcbiAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gIH0gZWxzZSBpZiAoYXJyYXkob3B0aW9ucy5yb290cykpIHtcbiAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gb3B0aW9ucy5yb290c1tpXTtcbiAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICByb290c0FycmF5LnB1c2goZWxlKTtcbiAgICB9XG4gICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKHJvb3RzQXJyYXkpO1xuICB9IGVsc2UgaWYgKHN0cmluZyhvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gY3kuJChvcHRpb25zLnJvb3RzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgIHJvb3RzID0gbm9kZXMucm9vdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBlbGVzLmNvbXBvbmVudHMoKTtcbiAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcG9uZW50c1tfaV07XG4gICAgICAgIHZhciBtYXhEZWdyZWUgPSBjb21wLm1heERlZ3JlZShmYWxzZSk7XG4gICAgICAgIHZhciBjb21wUm9vdHMgPSBjb21wLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5kZWdyZWUoZmFsc2UpID09PSBtYXhEZWdyZWU7XG4gICAgICAgIH0pO1xuICAgICAgICByb290cyA9IHJvb3RzLmFkZChjb21wUm9vdHMpO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb21wb25lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZGVwdGhzID0gW107XG4gIHZhciBmb3VuZEJ5QmZzID0ge307XG4gIHZhciBhZGRUb0RlcHRoID0gZnVuY3Rpb24gYWRkVG9EZXB0aChlbGUsIGQpIHtcbiAgICBpZiAoZGVwdGhzW2RdID09IG51bGwpIHtcbiAgICAgIGRlcHRoc1tkXSA9IFtdO1xuICAgIH1cbiAgICB2YXIgaSA9IGRlcHRoc1tkXS5sZW5ndGg7XG4gICAgZGVwdGhzW2RdLnB1c2goZWxlKTtcbiAgICBzZXRJbmZvKGVsZSwge1xuICAgICAgaW5kZXg6IGksXG4gICAgICBkZXB0aDogZFxuICAgIH0pO1xuICB9O1xuICB2YXIgY2hhbmdlRGVwdGggPSBmdW5jdGlvbiBjaGFuZ2VEZXB0aChlbGUsIG5ld0RlcHRoKSB7XG4gICAgdmFyIF9nZXRJbmZvID0gZ2V0SW5mbyhlbGUpLFxuICAgICAgZGVwdGggPSBfZ2V0SW5mby5kZXB0aCxcbiAgICAgIGluZGV4ID0gX2dldEluZm8uaW5kZXg7XG4gICAgZGVwdGhzW2RlcHRoXVtpbmRleF0gPSBudWxsO1xuXG4gICAgLy8gYWRkIG9ubHkgY2hpbGRsZXNzIG5vZGVzXG4gICAgaWYgKGVsZS5pc0NoaWxkbGVzcygpKSBhZGRUb0RlcHRoKGVsZSwgbmV3RGVwdGgpO1xuICB9O1xuXG4gIC8vIGZpbmQgdGhlIGRlcHRocyBvZiB0aGUgbm9kZXNcbiAgZ3JhcGguYmZzKHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGVkZ2UsIHBOb2RlLCBpLCBkZXB0aCkge1xuICAgICAgdmFyIGVsZSA9IG5vZGVbMF07XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgLy8gYWRkIG9ubHkgY2hpbGRsZXNzIG5vZGVzXG4gICAgICBpZiAoZWxlLmlzQ2hpbGRsZXNzKCkpIGFkZFRvRGVwdGgoZWxlLCBkZXB0aCk7XG4gICAgICBmb3VuZEJ5QmZzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfZWxlID0gbm9kZXNbX2kyXTtcbiAgICBpZiAoZm91bmRCeUJmc1tfZWxlLmlkKCldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JwaGFuTm9kZXMucHVzaChfZWxlKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3NpZ24gdGhlIG5vZGVzIGEgZGVwdGggYW5kIGluZGV4XG4gIHZhciBhc3NpZ25EZXB0aHNBdCA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRoc0F0KGkpIHtcbiAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfZWxlMiA9IGVsZXNbal07XG4gICAgICBpZiAoX2VsZTIgPT0gbnVsbCkge1xuICAgICAgICBlbGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNldEluZm8oX2VsZTIsIHtcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIGluZGV4OiBqXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHZhciBhZGp1c3RNYXhpbWFsbHkgPSBmdW5jdGlvbiBhZGp1c3RNYXhpbWFsbHkoZWxlLCBzaGlmdGVkKSB7XG4gICAgdmFyIGVJbmZvID0gZ2V0SW5mbyhlbGUpO1xuICAgIHZhciBpbmNvbWVycyA9IGVsZS5pbmNvbWVycygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbC5pc05vZGUoKSAmJiBlbGVzLmhhcyhlbCk7XG4gICAgfSk7XG4gICAgdmFyIG1heERlcHRoID0gLTE7XG4gICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbmNvbWVycy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGluY21yID0gaW5jb21lcnNba107XG4gICAgICB2YXIgaUluZm8gPSBnZXRJbmZvKGluY21yKTtcbiAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGlJbmZvLmRlcHRoKTtcbiAgICB9XG4gICAgaWYgKGVJbmZvLmRlcHRoIDw9IG1heERlcHRoKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuYWN5Y2xpYyAmJiBzaGlmdGVkW2lkXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEZXB0aCA9IG1heERlcHRoICsgMTtcbiAgICAgIGNoYW5nZURlcHRoKGVsZSwgbmV3RGVwdGgpO1xuICAgICAgc2hpZnRlZFtpZF0gPSBuZXdEZXB0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gZm9yIHRoZSBkaXJlY3RlZCBjYXNlLCB0cnkgdG8gbWFrZSB0aGUgZWRnZXMgYWxsIGdvIGRvd24gKGkuZS4gZGVwdGggaSA9PiBkZXB0aCBpICsgMSlcbiAgaWYgKGRpcmVjdGVkICYmIG1heGltYWwpIHtcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBzaGlmdGVkID0ge307XG4gICAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKG4pIHtcbiAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgfTtcbiAgICB2YXIgZGVxdWV1ZSA9IGZ1bmN0aW9uIGRlcXVldWUoKSB7XG4gICAgICByZXR1cm4gUS5zaGlmdCgpO1xuICAgIH07XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFEucHVzaChuKTtcbiAgICB9KTtcbiAgICB3aGlsZSAoUS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX2VsZTMgPSBkZXF1ZXVlKCk7XG4gICAgICB2YXIgZGlkU2hpZnQgPSBhZGp1c3RNYXhpbWFsbHkoX2VsZTMsIHNoaWZ0ZWQpO1xuICAgICAgaWYgKGRpZFNoaWZ0KSB7XG4gICAgICAgIF9lbGUzLm91dGdvZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5pc05vZGUoKSAmJiBlbGVzLmhhcyhlbCk7XG4gICAgICAgIH0pLmZvckVhY2goZW5xdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGRpZFNoaWZ0ID09PSBudWxsKSB7XG4gICAgICAgIHdhcm4oJ0RldGVjdGVkIGRvdWJsZSBtYXhpbWFsIHNoaWZ0IGZvciBub2RlIGAnICsgX2VsZTMuaWQoKSArICdgLiAgQmFpbGluZyBtYXhpbWFsIGFkanVzdG1lbnQgZHVlIHRvIGN5Y2xlLiAgVXNlIGBvcHRpb25zLm1heGltYWw6IHRydWVgIG9ubHkgb24gREFHcy4nKTtcbiAgICAgICAgYnJlYWs7IC8vIGV4aXQgb24gZmFpbHVyZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgbWluIGRpc3RhbmNlIHdlIG5lZWQgdG8gbGVhdmUgYmV0d2VlbiBub2Rlc1xuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW19pM107XG4gICAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIHcgPSBuYmIudztcbiAgICAgIHZhciBoID0gbmJiLmg7XG4gICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcbiAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuICB2YXIgZ2V0V2VpZ2h0ZWRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0V2VpZ2h0ZWRQZXJjZW50KGVsZSkge1xuICAgIGlmIChjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldKSB7XG4gICAgICByZXR1cm4gY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXTtcbiAgICB9XG4gICAgdmFyIGVsZURlcHRoID0gZ2V0SW5mbyhlbGUpLmRlcHRoO1xuICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCk7XG4gICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgIHZhciBzYW1wbGVzID0gMDtcbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBuZWlnaGJvcnMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW19pNF07XG4gICAgICBpZiAobmVpZ2hib3IuaXNFZGdlKCkgfHwgbmVpZ2hib3IuaXNQYXJlbnQoKSB8fCAhbm9kZXMuaGFzKG5laWdoYm9yKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBiZiA9IGdldEluZm8obmVpZ2hib3IpO1xuICAgICAgaWYgKGJmID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBiZi5pbmRleDtcbiAgICAgIHZhciBkZXB0aCA9IGJmLmRlcHRoO1xuXG4gICAgICAvLyB1bmFzc2lnbmVkIG5laWdoYm91cnMgc2hvdWxkbid0IGFmZmVjdCB0aGUgb3JkZXJpbmdcbiAgICAgIGlmIChpbmRleCA9PSBudWxsIHx8IGRlcHRoID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbkRlcHRoID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG4gICAgICBpZiAoZGVwdGggPCBlbGVEZXB0aCkge1xuICAgICAgICAvLyBvbmx5IGdldCBpbmZsdWVuY2VkIGJ5IGVsZW1lbnRzIGFib3ZlXG4gICAgICAgIHBlcmNlbnQgKz0gaW5kZXggLyBuRGVwdGg7XG4gICAgICAgIHNhbXBsZXMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcbiAgICBpZiAoc2FtcGxlcyA9PT0gMCkge1xuICAgICAgLy8gcHV0IGxvbmUgbm9kZXMgYXQgdGhlIHN0YXJ0XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9XG4gICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSA9IHBlcmNlbnQ7XG4gICAgcmV0dXJuIHBlcmNlbnQ7XG4gIH07XG5cbiAgLy8gcmVhcnJhbmdlIHRoZSBpbmRpY2VzIGluIGVhY2ggZGVwdGggbGV2ZWwgYmFzZWQgb24gY29ubmVjdGl2aXR5XG4gIHZhciBzb3J0Rm4gPSBmdW5jdGlvbiBzb3J0Rm4oYSwgYikge1xuICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGEpO1xuICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGIpO1xuICAgIHZhciBkaWZmID0gYXBjdCAtIGJwY3Q7XG4gICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgIHJldHVybiBhc2NlbmRpbmcoYS5pZCgpLCBiLmlkKCkpOyAvLyBtYWtlIHN1cmUgc29ydCBkb2Vzbid0IGhhdmUgZG9uJ3QtY2FyZSBjb21wYXJpc29uc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gIH07XG4gIGlmIChvcHRpb25zLmRlcHRoU29ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc29ydEZuID0gb3B0aW9ucy5kZXB0aFNvcnQ7XG4gIH1cbiAgdmFyIGRlcHRoc0xlbiA9IGRlcHRocy5sZW5ndGg7XG5cbiAgLy8gc29ydCBlYWNoIGxldmVsIHRvIG1ha2UgY29ubmVjdGVkIG5vZGVzIGNsb3NlclxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBkZXB0aHNMZW47IF9pNSsrKSB7XG4gICAgZGVwdGhzW19pNV0uc29ydChzb3J0Rm4pO1xuICAgIGFzc2lnbkRlcHRoc0F0KF9pNSk7XG4gIH1cblxuICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIHRvIGEgbmV3IHRvcC1sZXZlbCBkZXB0aFxuICB2YXIgb3JwaGFuRGVwdGggPSBbXTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgb3JwaGFuTm9kZXMubGVuZ3RoOyBfaTYrKykge1xuICAgIG9ycGhhbkRlcHRoLnB1c2gob3JwaGFuTm9kZXNbX2k2XSk7XG4gIH1cbiAgdmFyIGFzc2lnbkRlcHRocyA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRocygpIHtcbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBkZXB0aHNMZW47IF9pNysrKSB7XG4gICAgICBhc3NpZ25EZXB0aHNBdChfaTcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBhZGQgYSBuZXcgdG9wLWxldmVsIGRlcHRoIG9ubHkgd2hlbiB0aGVyZSBhcmUgb3JwaGFuIG5vZGVzXG4gIGlmIChvcnBoYW5EZXB0aC5sZW5ndGgpIHtcbiAgICBkZXB0aHMudW5zaGlmdChvcnBoYW5EZXB0aCk7XG4gICAgZGVwdGhzTGVuID0gZGVwdGhzLmxlbmd0aDtcbiAgICBhc3NpZ25EZXB0aHMoKTtcbiAgfVxuICB2YXIgYmlnZ2VzdERlcHRoU2l6ZSA9IDA7XG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGRlcHRoc0xlbjsgX2k4KyspIHtcbiAgICBiaWdnZXN0RGVwdGhTaXplID0gTWF0aC5tYXgoZGVwdGhzW19pOF0ubGVuZ3RoLCBiaWdnZXN0RGVwdGhTaXplKTtcbiAgfVxuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuXG4gIC8vIGF2ZXJhZ2Ugbm9kZSBzaXplXG4gIHZhciBhdmVOb2RlU2l6ZSA9IG5vZGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChib3gpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IGFjYy53ID09PSAtMSA/IGJveC53IDogKGFjYy53ICsgYm94LncpIC8gMixcbiAgICAgICAgaDogYWNjLmggPT09IC0xID8gYm94LmggOiAoYWNjLmggKyBib3guaCkgLyAyXG4gICAgICB9O1xuICAgIH0obm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICBpbmNsdWRlTGFiZWxzOiBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsc1xuICAgIH0pKTtcbiAgfSwge1xuICAgIHc6IC0xLFxuICAgIGg6IC0xXG4gIH0pO1xuICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoXG4gIC8vIG9ubHkgb25lIGRlcHRoXG4gIGRlcHRoc0xlbiA9PT0gMSA/IDAgOlxuICAvLyBpbnNpZGUgYSBib3VuZGluZyBib3gsIG5vIG5lZWQgZm9yIHRvcCAmIGJvdHRvbSBwYWRkaW5nXG4gIGhhc0JvdW5kaW5nQm94ID8gKGJiLmggLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gYXZlTm9kZVNpemUuaCkgLyAoZGVwdGhzTGVuIC0gMSkgOiAoYmIuaCAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBhdmVOb2RlU2l6ZS5oKSAvIChkZXB0aHNMZW4gKyAxKSwgbWluRGlzdGFuY2UpO1xuICB2YXIgbWF4RGVwdGhTaXplID0gZGVwdGhzLnJlZHVjZShmdW5jdGlvbiAobWF4LCBlbGVzKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgZWxlcy5sZW5ndGgpO1xuICB9LCAwKTtcbiAgdmFyIGdldFBvc2l0aW9uVG9wQm90dG9tID0gZnVuY3Rpb24gZ2V0UG9zaXRpb25Ub3BCb3R0b20oZWxlKSB7XG4gICAgdmFyIF9nZXRJbmZvMiA9IGdldEluZm8oZWxlKSxcbiAgICAgIGRlcHRoID0gX2dldEluZm8yLmRlcHRoLFxuICAgICAgaW5kZXggPSBfZ2V0SW5mbzIuaW5kZXg7XG4gICAgaWYgKG9wdGlvbnMuY2lyY2xlKSB7XG4gICAgICB2YXIgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1pbihiYi53IC8gMiAvIGRlcHRoc0xlbiwgYmIuaCAvIDIgLyBkZXB0aHNMZW4pO1xuICAgICAgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1heChyYWRpdXNTdGVwU2l6ZSwgbWluRGlzdGFuY2UpO1xuICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c1N0ZXBTaXplICogZGVwdGggKyByYWRpdXNTdGVwU2l6ZSAtIChkZXB0aHNMZW4gPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplIC8gMiA6IDApO1xuICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuICAgICAgaWYgKGRlcHRoID09PSAwICYmIGRlcHRoc1swXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlcHRoU2l6ZSA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGgubWF4KFxuICAgICAgLy8gb25seSBvbmUgZGVwdGhcbiAgICAgIGRlcHRoU2l6ZSA9PT0gMSA/IDAgOlxuICAgICAgLy8gaW5zaWRlIGEgYm91bmRpbmcgYm94LCBubyBuZWVkIGZvciBsZWZ0ICYgcmlnaHQgcGFkZGluZ1xuICAgICAgaGFzQm91bmRpbmdCb3ggPyAoYmIudyAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBhdmVOb2RlU2l6ZS53KSAvICgob3B0aW9ucy5ncmlkID8gbWF4RGVwdGhTaXplIDogZGVwdGhTaXplKSAtIDEpIDogKGJiLncgLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gYXZlTm9kZVNpemUudykgLyAoKG9wdGlvbnMuZ3JpZCA/IG1heERlcHRoU2l6ZSA6IGRlcHRoU2l6ZSkgKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICB5OiBjZW50ZXIueSArIChkZXB0aCArIDEgLSAoZGVwdGhzTGVuICsgMSkgLyAyKSAqIGRpc3RhbmNlWVxuICAgICAgfTtcbiAgICAgIHJldHVybiBlcG9zO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJvdGF0ZURlZ3JlZXMgPSB7XG4gICAgJ2Rvd253YXJkJzogMCxcbiAgICAnbGVmdHdhcmQnOiA5MCxcbiAgICAndXB3YXJkJzogMTgwLFxuICAgICdyaWdodHdhcmQnOiAtOTBcbiAgfTtcbiAgaWYgKE9iamVjdC5rZXlzKHJvdGF0ZURlZ3JlZXMpLmluZGV4T2Yob3B0aW9ucy5kaXJlY3Rpb24pID09PSAtMSkge1xuICAgIGVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb24gJ1wiLmNvbmNhdChvcHRpb25zLmRpcmVjdGlvbiwgXCInIHNwZWNpZmllZCBmb3IgYnJlYWR0aGZpcnN0IGxheW91dC4gVmFsaWQgdmFsdWVzIGFyZTogXCIpLmNvbmNhdChPYmplY3Qua2V5cyhyb3RhdGVEZWdyZWVzKS5qb2luKCcsICcpKSk7XG4gIH1cbiAgdmFyIGdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWxlKSB7XG4gICAgcmV0dXJuIHJvdGF0ZVBvc0FuZFNrZXdCeUJveChnZXRQb3NpdGlvblRvcEJvdHRvbShlbGUpLCBiYiwgcm90YXRlRGVncmVlc1tvcHRpb25zLmRpcmVjdGlvbl0pO1xuICB9O1xuICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvc2l0aW9uKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkNiA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLFxuICAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggYW5kIHJhZGl1cyBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgcmFkaXVzOiB1bmRlZmluZWQsXG4gIC8vIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIHNvcnQ6IHVuZGVmaW5lZCxcbiAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxufTtcbmZ1bmN0aW9uIENpcmNsZUxheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNiwgb3B0aW9ucyk7XG59XG5DaXJjbGVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gIH1cbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG4gIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBub2Rlcy5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICB2YXIgZFRoZXRhID0gc3dlZXAgLyBNYXRoLm1heCgxLCBub2Rlcy5sZW5ndGggLSAxKTtcbiAgdmFyIHI7XG4gIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgdmFyIHcgPSBuYmIudztcbiAgICB2YXIgaCA9IG5iYi5oO1xuICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICB9XG4gIGlmIChudW1iZXIkMShvcHRpb25zLnJhZGl1cykpIHtcbiAgICByID0gb3B0aW9ucy5yYWRpdXM7XG4gIH0gZWxzZSBpZiAobm9kZXMubGVuZ3RoIDw9IDEpIHtcbiAgICByID0gMDtcbiAgfSBlbHNlIHtcbiAgICByID0gTWF0aC5taW4oYmIuaCwgYmIudykgLyAyIC0gbWluRGlzdGFuY2U7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICBpZiAobm9kZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcblxuICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbikpOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG4gICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICB9XG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlLCBpKSB7XG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgaSAqIGRUaGV0YSAqIChjbG9ja3dpc2UgPyAxIDogLTEpO1xuICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICB2YXIgcG9zID0ge1xuICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICB9O1xuICAgIHJldHVybiBwb3M7XG4gIH07XG4gIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkNSA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLFxuICAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLFxuICAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gIHN3ZWVwOiB1bmRlZmluZWQsXG4gIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICBjbG9ja3dpc2U6IHRydWUsXG4gIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICBlcXVpZGlzdGFudDogZmFsc2UsXG4gIC8vIHdoZXRoZXIgbGV2ZWxzIGhhdmUgYW4gZXF1YWwgcmFkaWFsIGRpc3RhbmNlIGJldHdlbiB0aGVtLCBtYXkgY2F1c2UgYm91bmRpbmcgYm94IG92ZXJmbG93XG4gIG1pbk5vZGVTcGFjaW5nOiAxMCxcbiAgLy8gbWluIHNwYWNpbmcgYmV0d2VlbiBvdXRzaWRlIG9mIG5vZGVzICh1c2VkIGZvciByYWRpdXMgYWRqdXN0bWVudClcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgLy8gaGVpZ2h0IG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIGhlaWdodClcbiAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgLy8gd2lkdGggb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgd2lkdGgpXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgY29uY2VudHJpYzogZnVuY3Rpb24gY29uY2VudHJpYyhub2RlKSB7XG4gICAgLy8gcmV0dXJucyBudW1lcmljIHZhbHVlIGZvciBlYWNoIG5vZGUsIHBsYWNpbmcgaGlnaGVyIG5vZGVzIGluIGxldmVscyB0b3dhcmRzIHRoZSBjZW50cmVcbiAgICByZXR1cm4gbm9kZS5kZWdyZWUoKTtcbiAgfSxcbiAgbGV2ZWxXaWR0aDogZnVuY3Rpb24gbGV2ZWxXaWR0aChub2Rlcykge1xuICAgIC8vIHRoZSB2YXJpYXRpb24gb2YgY29uY2VudHJpYyB2YWx1ZXMgaW4gZWFjaCBsZXZlbFxuICAgIHJldHVybiBub2Rlcy5tYXhEZWdyZWUoKSAvIDQ7XG4gIH0sXG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xufTtcbmZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDUsIG9wdGlvbnMpO1xufVxuQ29uY2VudHJpY0xheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuICB2YXIgbm9kZVZhbHVlcyA9IFtdOyAvLyB7IG5vZGUsIHZhbHVlIH1cbiAgdmFyIG1heE5vZGVTaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHZhbHVlXG4gICAgdmFsdWUgPSBvcHRpb25zLmNvbmNlbnRyaWMobm9kZSk7XG4gICAgbm9kZVZhbHVlcy5wdXNoKHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG5vZGU6IG5vZGVcbiAgICB9KTtcblxuICAgIC8vIGZvciBzdHlsZSBtYXBwaW5nXG4gICAgbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbmNlbnRyaWMgPSB2YWx1ZTtcbiAgfVxuXG4gIC8vIGluIGNhc2Ugd2UgdXNlZCB0aGUgYGNvbmNlbnRyaWNgIGluIHN0eWxlXG4gIG5vZGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgLy8gY2FsY3VsYXRlIG1heCBzaXplIG5vdyBiYXNlZCBvbiBwb3RlbnRpYWxseSB1cGRhdGVkIG1hcHBlcnNcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICB2YXIgbmJiID0gX25vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KG1heE5vZGVTaXplLCBuYmIudywgbmJiLmgpO1xuICB9XG5cbiAgLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH0pO1xuICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aChub2Rlcyk7XG5cbiAgLy8gcHV0IHRoZSB2YWx1ZXMgaW50byBsZXZlbHNcbiAgdmFyIGxldmVscyA9IFtbXV07XG4gIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW19pMl07XG4gICAgaWYgKGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGN1cnJlbnRMZXZlbFswXS52YWx1ZSAtIHZhbC52YWx1ZSk7XG4gICAgICBpZiAoZGlmZiA+PSBsZXZlbFdpZHRoKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IFtdO1xuICAgICAgICBsZXZlbHMucHVzaChjdXJyZW50TGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50TGV2ZWwucHVzaCh2YWwpO1xuICB9XG5cbiAgLy8gY3JlYXRlIHBvc2l0aW9ucyBmcm9tIGxldmVsc1xuXG4gIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgaWYgKCFvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICB2YXIgbWF4UiA9IE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3Q7XG4gICAgdmFyIHJTdGVwID0gbWF4UiAvIChsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCwgclN0ZXApO1xuICB9XG5cbiAgLy8gZmluZCB0aGUgbWV0cmljcyBmb3IgZWFjaCBsZXZlbFxuICB2YXIgciA9IDA7XG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxldmVscy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW19pM107XG4gICAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIGxldmVsLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gICAgdmFyIGRUaGV0YSA9IGxldmVsLmRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbGV2ZWwubGVuZ3RoIC0gMSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICAgIGlmIChsZXZlbC5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdCAqIG1pbkRpc3QgLyAoZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbikpOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG5cbiAgICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgICB9XG4gICAgbGV2ZWwuciA9IHI7XG4gICAgciArPSBtaW5EaXN0O1xuICB9XG4gIGlmIChvcHRpb25zLmVxdWlkaXN0YW50KSB7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIF9yID0gMDtcbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBsZXZlbHMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIF9sZXZlbCA9IGxldmVsc1tfaTRdO1xuICAgICAgdmFyIHJEZWx0YSA9IF9sZXZlbC5yIC0gX3I7XG4gICAgICByRGVsdGFNYXggPSBNYXRoLm1heChyRGVsdGFNYXgsIHJEZWx0YSk7XG4gICAgfVxuICAgIF9yID0gMDtcbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsZXZlbHMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIF9sZXZlbDIgPSBsZXZlbHNbX2k1XTtcbiAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgX3IgPSBfbGV2ZWwyLnI7XG4gICAgICB9XG4gICAgICBfbGV2ZWwyLnIgPSBfcjtcbiAgICAgIF9yICs9IHJEZWx0YU1heDtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgcG9zaXRpb25zXG4gIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbGV2ZWxzLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgX2xldmVsMyA9IGxldmVsc1tfaTZdO1xuICAgIHZhciBfZFRoZXRhID0gX2xldmVsMy5kVGhldGE7XG4gICAgdmFyIF9yMiA9IF9sZXZlbDMucjtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9sZXZlbDMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfdmFsID0gX2xldmVsM1tqXTtcbiAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogX2RUaGV0YSAqIGo7XG4gICAgICB2YXIgcCA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyBfcjIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgIHk6IGNlbnRlci55ICsgX3IyICogTWF0aC5zaW4odGhldGEpXG4gICAgICB9O1xuICAgICAgcG9zW192YWwubm9kZS5pZCgpXSA9IHA7XG4gICAgfVxuICB9XG5cbiAgLy8gcG9zaXRpb24gdGhlIG5vZGVzXG4gIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIHJldHVybiBwb3NbaWRdO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vKlxuVGhlIENvU0UgbGF5b3V0IHdhcyB3cml0dGVuIGJ5IEdlcmFyZG8gSHVjay5cbmh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9nZXJhcmRvaHVjay9cblxuQmFzZWQgb24gdGhlIGZvbGxvd2luZyBhcnRpY2xlOlxuaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTE0OTgwNDdcblxuTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbnZhciBERUJVRztcblxuLyoqXG4gKiBAYnJpZWYgOiAgZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICovXG52YXIgZGVmYXVsdHMkNCA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuICAvLyBXaGV0aGVyIHRvIGFuaW1hdGUgd2hpbGUgcnVubmluZyB0aGUgbGF5b3V0XG4gIC8vIHRydWUgOiBBbmltYXRlIGNvbnRpbnVvdXNseSBhcyB0aGUgbGF5b3V0IGlzIHJ1bm5pbmdcbiAgLy8gZmFsc2UgOiBKdXN0IHNob3cgdGhlIGVuZCByZXN1bHRcbiAgLy8gJ2VuZCcgOiBBbmltYXRlIHdpdGggdGhlIGVuZCByZXN1bHQsIGZyb20gdGhlIGluaXRpYWwgcG9zaXRpb25zIHRvIHRoZSBlbmQgcG9zaXRpb25zXG4gIGFuaW1hdGU6IHRydWUsXG4gIC8vIEVhc2luZyBvZiB0aGUgYW5pbWF0aW9uIGZvciBhbmltYXRlOidlbmQnXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25EdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZFxuICAvLyBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWRcbiAgLy8gTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIFRoZSBsYXlvdXQgYW5pbWF0ZXMgb25seSBhZnRlciB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzIGZvciBhbmltYXRlOnRydWVcbiAgLy8gKHByZXZlbnRzIGZsYXNoaW5nIG9uIGZhc3QgcnVucylcbiAgYW5pbWF0aW9uVGhyZXNob2xkOiAyNTAsXG4gIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGVcbiAgcmVmcmVzaDogMjAsXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdDogdHJ1ZSxcbiAgLy8gUGFkZGluZyBvbiBmaXRcbiAgcGFkZGluZzogMzAsXG4gIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBSYW5kb21pemUgdGhlIGluaXRpYWwgcG9zaXRpb25zIG9mIHRoZSBub2RlcyAodHJ1ZSkgb3IgdXNlIGV4aXN0aW5nIHBvc2l0aW9ucyAoZmFsc2UpXG4gIHJhbmRvbWl6ZTogZmFsc2UsXG4gIC8vIEV4dHJhIHNwYWNpbmcgYmV0d2VlbiBjb21wb25lbnRzIGluIG5vbi1jb21wb3VuZCBncmFwaHNcbiAgY29tcG9uZW50U3BhY2luZzogNDAsXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDIwNDg7XG4gIH0sXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlT3ZlcmxhcDogNCxcbiAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gIGlkZWFsRWRnZUxlbmd0aDogZnVuY3Rpb24gaWRlYWxFZGdlTGVuZ3RoKGVkZ2UpIHtcbiAgICByZXR1cm4gMzI7XG4gIH0sXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eTogZnVuY3Rpb24gZWRnZUVsYXN0aWNpdHkoZWRnZSkge1xuICAgIHJldHVybiAzMjtcbiAgfSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAxLjIsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAxLFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMTAwMCxcbiAgLy8gSW5pdGlhbCB0ZW1wZXJhdHVyZSAobWF4aW11bSBub2RlIGRpc3BsYWNlbWVudClcbiAgaW5pdGlhbFRlbXA6IDEwMDAsXG4gIC8vIENvb2xpbmcgZmFjdG9yIChob3cgdGhlIHRlbXBlcmF0dXJlIGlzIHJlZHVjZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSBpdGVyYXRpb25zXG4gIGNvb2xpbmdGYWN0b3I6IDAuOTksXG4gIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICBtaW5UZW1wOiAxLjBcbn07XG5cbi8qKlxuICogQGJyaWVmICAgICAgIDogY29uc3RydWN0b3JcbiAqIEBhcmcgb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIENvc2VMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDQsIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gdGhpcztcblxuICAvLyBFeGNsdWRlIGFueSBlZGdlIHRoYXQgaGFzIGEgc291cmNlIG9yIHRhcmdldCBub2RlIHRoYXQgaXMgbm90IGluIHRoZSBzZXQgb2YgcGFzc2VkLWluIG5vZGVzXG4gIHZhciBub2RlcyA9IHRoaXMub3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMub3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gIHZhciBub3RFZGdlcyA9IGVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzb3VyY2VJZCA9IGUuc291cmNlKCkuZGF0YSgnaWQnKTtcbiAgICB2YXIgdGFyZ2V0SWQgPSBlLnRhcmdldCgpLmRhdGEoJ2lkJyk7XG4gICAgdmFyIGhhc1NvdXJjZSA9IG5vZGVzLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuLmRhdGEoJ2lkJykgPT09IHNvdXJjZUlkO1xuICAgIH0pO1xuICAgIHZhciBoYXNUYXJnZXQgPSBub2Rlcy5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5kYXRhKCdpZCcpID09PSB0YXJnZXRJZDtcbiAgICB9KTtcbiAgICByZXR1cm4gIWhhc1NvdXJjZSB8fCAhaGFzVGFyZ2V0O1xuICB9KTtcbiAgdGhpcy5vcHRpb25zLmVsZXMgPSB0aGlzLm9wdGlvbnMuZWxlcy5ub3Qobm90RWRnZXMpO1xufVxuXG4vKipcbiAqIEBicmllZiA6IHJ1bnMgdGhlIGxheW91dFxuICovXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgbGF5b3V0LmVtaXQoe1xuICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgIGxheW91dDogbGF5b3V0XG4gICAgfSk7XG4gIH1cblxuICAvLyBTZXQgREVCVUcgLSBHbG9iYWwgdmFyaWFibGVcbiAgaWYgKHRydWUgPT09IG9wdGlvbnMuZGVidWcpIHtcbiAgICBERUJVRyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgREVCVUcgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgbGF5b3V0IGluZm9cbiAgdmFyIGxheW91dEluZm8gPSBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpO1xuXG4gIC8vIFNob3cgTGF5b3V0SW5mbyBjb250ZW50cyBpZiBkZWJ1Z2dpbmdcbiAgaWYgKERFQlVHKSB7XG4gICAgcHJpbnRMYXlvdXRJbmZvKGxheW91dEluZm8pO1xuICB9XG5cbiAgLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbyk7XG4gIH1cbiAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIHZhciByZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcblxuICAgIC8vIEZpdCB0aGUgZ3JhcGggaWYgbmVjZXNzYXJ5XG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZml0KSB7XG4gICAgICBjeS5maXQob3B0aW9ucy5wYWRkaW5nKTtcbiAgICB9XG4gIH07XG4gIHZhciBtYWluTG9vcCA9IGZ1bmN0aW9uIG1haW5Mb29wKGkpIHtcbiAgICBpZiAobGF5b3V0LnN0b3BwZWQgfHwgaSA+PSBvcHRpb25zLm51bUl0ZXIpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiTGF5b3V0IG1hbnVhbGx5IHN0b3BwZWQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBEbyBvbmUgc3RlcCBpbiB0aGUgcGhpc2ljYWwgc2ltdWxhdGlvblxuICAgIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucyk7XG5cbiAgICAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcbiAgICBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlID0gbGF5b3V0SW5mby50ZW1wZXJhdHVyZSAqIG9wdGlvbnMuY29vbGluZ0ZhY3RvcjtcbiAgICAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgIGlmIChsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlRlbXBlcmF0dXJlIGRyb3AgYmVsb3cgbWluaW11bSB0aHJlc2hvbGQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJlZnJlc2goKTtcblxuICAgICAgLy8gTGF5b3V0IGhhcyBmaW5pc2hlZFxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICAgIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZ2V0U2NhbGVkUG9zKTtcbiAgICB9XG4gIH07XG4gIHZhciBpID0gMDtcbiAgdmFyIGxvb3BSZXQgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlKSB7XG4gICAgdmFyIF9mcmFtZSA9IGZ1bmN0aW9uIGZyYW1lKCkge1xuICAgICAgdmFyIGYgPSAwO1xuICAgICAgd2hpbGUgKGxvb3BSZXQgJiYgZiA8IG9wdGlvbnMucmVmcmVzaCkge1xuICAgICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgIGkrKztcbiAgICAgICAgZisrO1xuICAgICAgfVxuICAgICAgaWYgKCFsb29wUmV0KSB7XG4gICAgICAgIC8vIGl0J3MgZG9uZVxuICAgICAgICBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBpZiAobm93IC0gc3RhcnRUaW1lID49IG9wdGlvbnMuYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShfZnJhbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX2ZyYW1lKCk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGxvb3BSZXQpIHtcbiAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgIGRvbmUoKTtcbiAgfVxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8qKlxuICogQGJyaWVmIDogY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gKi9cbkNvc2VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gIGlmICh0aGlzLnRocmVhZCkge1xuICAgIHRoaXMudGhyZWFkLnN0b3AoKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuQ29zZUxheW91dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqL1xudmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbiBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgLy8gU2hvcnRjdXRcbiAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGxheW91dEluZm8gPSB7XG4gICAgaXNDb21wb3VuZDogY3kuaGFzQ29tcG91bmROb2RlcygpLFxuICAgIGxheW91dE5vZGVzOiBbXSxcbiAgICBpZFRvSW5kZXg6IHt9LFxuICAgIG5vZGVTaXplOiBub2Rlcy5zaXplKCksXG4gICAgZ3JhcGhTZXQ6IFtdLFxuICAgIGluZGV4VG9HcmFwaDogW10sXG4gICAgbGF5b3V0RWRnZXM6IFtdLFxuICAgIGVkZ2VTaXplOiBlZGdlcy5zaXplKCksXG4gICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgY2xpZW50V2lkdGg6IGJiLncsXG4gICAgY2xpZW50SGVpZ2h0OiBiYi5oLFxuICAgIGJvdW5kaW5nQm94OiBiYlxuICB9O1xuICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gIHZhciBpZDJjbXB0SWQgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBub2RlID0gY29tcG9uZW50W2pdO1xuICAgICAgaWQyY21wdElkW25vZGUuaWQoKV0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICB2YXIgdGVtcE5vZGUgPSB7fTtcbiAgICB0ZW1wTm9kZS5pc0xvY2tlZCA9IG4ubG9ja2VkKCk7XG4gICAgdGVtcE5vZGUuaWQgPSBuLmRhdGEoJ2lkJyk7XG4gICAgdGVtcE5vZGUucGFyZW50SWQgPSBuLmRhdGEoJ3BhcmVudCcpO1xuICAgIHRlbXBOb2RlLmNtcHRJZCA9IGlkMmNtcHRJZFtuLmlkKCldO1xuICAgIHRlbXBOb2RlLmNoaWxkcmVuID0gW107XG4gICAgdGVtcE5vZGUucG9zaXRpb25YID0gbi5wb3NpdGlvbigneCcpO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWSA9IG4ucG9zaXRpb24oJ3knKTtcbiAgICB0ZW1wTm9kZS5vZmZzZXRYID0gMDtcbiAgICB0ZW1wTm9kZS5vZmZzZXRZID0gMDtcbiAgICB0ZW1wTm9kZS5oZWlnaHQgPSBuYmIudztcbiAgICB0ZW1wTm9kZS53aWR0aCA9IG5iYi5oO1xuICAgIHRlbXBOb2RlLm1heFggPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgdGVtcE5vZGUubWluWCA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICB0ZW1wTm9kZS5tYXhZID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5taW5ZID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5wYWRMZWZ0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFJpZ2h0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFRvcCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRCb3R0b20gPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG5cbiAgICAvLyBmb3JjZXNcbiAgICB0ZW1wTm9kZS5ub2RlUmVwdWxzaW9uID0gZm4kNihvcHRpb25zLm5vZGVSZXB1bHNpb24pID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uKG4pIDogb3B0aW9ucy5ub2RlUmVwdWxzaW9uO1xuXG4gICAgLy8gQWRkIG5ldyBub2RlXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG4gICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUuaWRdID0gaTtcbiAgfVxuXG4gIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgdmFyIHRlbXBHcmFwaCA9IFtdO1xuXG4gIC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICB2YXIgcF9pZCA9IG4ucGFyZW50SWQ7XG4gICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICBxdWV1ZVsrK2VuZF0gPSBuLmlkO1xuICAgICAgdGVtcEdyYXBoLnB1c2gobi5pZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcbiAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZV9pZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlX2l4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZV9pZF07XG4gICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaChjaGlsZHJlbik7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVlIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyYXBoLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgaW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV07XG4gICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpbmRleF0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgdmFyIHRlbXBFZGdlID0ge307XG4gICAgdGVtcEVkZ2UuaWQgPSBlLmRhdGEoJ2lkJyk7XG4gICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoJ3NvdXJjZScpO1xuICAgIHRlbXBFZGdlLnRhcmdldElkID0gZS5kYXRhKCd0YXJnZXQnKTtcblxuICAgIC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG4gICAgdmFyIGlkZWFsTGVuZ3RoID0gZm4kNihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkgPyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aChlKSA6IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICAgIHZhciBlbGFzdGljaXR5ID0gZm4kNihvcHRpb25zLmVkZ2VFbGFzdGljaXR5KSA/IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkoZSkgOiBvcHRpb25zLmVkZ2VFbGFzdGljaXR5O1xuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG4gICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2Uuc291cmNlSWRdO1xuICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnRhcmdldElkXTtcbiAgICB2YXIgc291cmNlR3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtzb3VyY2VJeF07XG4gICAgdmFyIHRhcmdldEdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbdGFyZ2V0SXhdO1xuICAgIGlmIChzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCkge1xuICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICB2YXIgbGNhID0gZmluZExDQSh0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8pO1xuXG4gICAgICAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG4gICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2xjYV07XG4gICAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgICAvLyBTb3VyY2UgZGVwdGhcbiAgICAgIHZhciB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gVGFyZ2V0IGRlcHRoXG4gICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgK1xuICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICtcbiAgICAgIC8vICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuXG4gICAgICAvLyBVcGRhdGUgaWRlYWxMZW5ndGhcbiAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgIH1cbiAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuICAgIHRlbXBFZGdlLmVsYXN0aWNpdHkgPSBlbGFzdGljaXR5O1xuICAgIGxheW91dEluZm8ubGF5b3V0RWRnZXMucHVzaCh0ZW1wRWRnZSk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcbiAgcmV0dXJuIGxheW91dEluZm87XG59O1xuXG4vKipcbiAqIEBicmllZiA6IFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGluZGV4IG9mIHRoZSBsb3dlc3QgY29tbW9uXG4gKiAgICAgICAgICBncmFwaCBhbmNlc3RvciBiZXR3ZWVuIDIgbm9kZXMgaW4gdGhlIHN1YnRyZWVcbiAqICAgICAgICAgIChmcm9tIHRoZSBncmFwaCBoaWVyYXJjaHkgaW5kdWNlZCB0cmVlKSB3aG9zZVxuICogICAgICAgICAgcm9vdCBpcyBncmFwaEl4XG4gKlxuICogQGFyZyBub2RlMTogbm9kZTEncyBJRFxuICogQGFyZyBub2RlMjogbm9kZTIncyBJRFxuICogQGFyZyBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqL1xudmFyIGZpbmRMQ0EgPSBmdW5jdGlvbiBmaW5kTENBKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICB2YXIgcmVzID0gX2ZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgMCwgbGF5b3V0SW5mbyk7XG4gIGlmICgyID4gcmVzLmNvdW50KSB7XG4gICAgLy8gSWYgYXV4IGZ1bmN0aW9uIGNvdWxkbid0IGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RlcixcbiAgICAvLyB0aGVuIGl0IGlzIHRoZSByb290IGdyYXBoXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcy5ncmFwaDtcbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBBdXhpbGlhcnkgZnVuY3Rpb24gdXNlZCBmb3IgTENBIGNvbXB1dGF0aW9uXG4gKlxuICogQGFyZyBub2RlMSAgICAgIDogbm9kZTEncyBJRFxuICogQGFyZyBub2RlMiAgICAgIDogbm9kZTIncyBJRFxuICogQGFyZyBncmFwaEl4ICAgIDogc3ViZ3JhcGggaW5kZXhcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICogQHJldHVybiAgICAgICAgIDogb2JqZWN0IG9mIHRoZSBmb3JtIHtjb3VudDogWCwgZ3JhcGg6IFl9LCB3aGVyZTpcbiAqICAgICAgICAgICAgICAgICAgIFggaXMgdGhlIG51bWJlciBvZiBhbmNlc3RvcnMgKG1heDogMikgZm91bmQgaW5cbiAqICAgICAgICAgICAgICAgICAgIGdyYXBoSXggKGFuZCBpdCdzIHN1YmdyYXBocyksXG4gKiAgICAgICAgICAgICAgICAgICBZIGlzIHRoZSBncmFwaCBpbmRleCBvZiB0aGUgbG93ZXN0IGdyYXBoIGNvbnRhaW5pbmdcbiAqICAgICAgICAgICAgICAgICAgIGFsbCBYIG5vZGVzXG4gKi9cbnZhciBfZmluZExDQV9hdXggPSBmdW5jdGlvbiBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGdyYXBoSXgsIGxheW91dEluZm8pIHtcbiAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtncmFwaEl4XTtcbiAgLy8gSWYgYm90aCBub2RlcyBiZWxvbmdzIHRvIGdyYXBoSXhcbiAgaWYgKC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMSkgJiYgLTEgPCBncmFwaC5pbmRleE9mKG5vZGUyKSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb3VudDogMixcbiAgICAgIGdyYXBoOiBncmFwaEl4XG4gICAgfTtcbiAgfVxuXG4gIC8vIE1ha2UgcmVjdXJzaXZlIGNhbGxzIGZvciBhbGwgc3ViZ3JhcGhzXG4gIHZhciBjID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlSWQgPSBncmFwaFtpXTtcbiAgICB2YXIgbm9kZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICB2YXIgY2hpbGRyZW4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJeF0uY2hpbGRyZW47XG5cbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIHNraXAgaXRcbiAgICBpZiAoMCA9PT0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGNoaWxkR3JhcGhJeCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuWzBdXV07XG4gICAgdmFyIHJlc3VsdCA9IF9maW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG4gICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcbiAgICAgIGlmICgyID09PSBjKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvdW50OiBjLFxuICAgIGdyYXBoOiBncmFwaEl4XG4gIH07XG59O1xuXG4vKipcbiAqIEBicmllZjogcHJpbnRzTGF5b3V0SW5mbyBpbnRvIGpzIGNvbnNvbGVcbiAqICAgICAgICAgT25seSB1c2VkIGZvciBkZWJidWdpbmdcbiAqL1xudmFyIHByaW50TGF5b3V0SW5mbzsgXG5cbi8qKlxuICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gKi9cbnZhciByYW5kb21pemVQb3NpdGlvbnMgPSBmdW5jdGlvbiByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3kpIHtcbiAgdmFyIHdpZHRoID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuICAgIGlmICgwID09PSBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCkge1xuICAgICAgbi5wb3NpdGlvblggPSBNYXRoLnJhbmRvbSgpICogd2lkdGg7XG4gICAgICBuLnBvc2l0aW9uWSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7XG4gICAgfVxuICB9XG59O1xudmFyIGdldFNjYWxlSW5Cb3VuZHNGbiA9IGZ1bmN0aW9uIGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcykge1xuICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICB2YXIgY29zZUJCID0ge1xuICAgIHgxOiBJbmZpbml0eSxcbiAgICB4MjogLUluZmluaXR5LFxuICAgIHkxOiBJbmZpbml0eSxcbiAgICB5MjogLUluZmluaXR5XG4gIH07XG4gIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcbiAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICB9KTtcbiAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZWxlLmRhdGEoJ2lkJyldXTtcbiAgICBpZiAob3B0aW9ucy5ib3VuZGluZ0JveCkge1xuICAgICAgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgIC8vIEhhbmRsZSBzaW5nbGUgbm9kZSBjYXNlIHdoZXJlIGNvc2VCQi53IG9yIGNvc2VCQi5oIGlzIDBcbiAgICAgIHZhciBwY3RYID0gY29zZUJCLncgPT09IDAgPyAwLjUgOiAobG5vZGUucG9zaXRpb25YIC0gY29zZUJCLngxKSAvIGNvc2VCQi53O1xuICAgICAgdmFyIHBjdFkgPSBjb3NlQkIuaCA9PT0gMCA/IDAuNSA6IChsbm9kZS5wb3NpdGlvblkgLSBjb3NlQkIueTEpIC8gY29zZUJCLmg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIHBjdFggKiBiYi53LFxuICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgIHk6IGxub2RlLnBvc2l0aW9uWVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cbnZhciByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24gcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAvLyB2YXIgcyA9ICdSZWZyZXNoaW5nIHBvc2l0aW9ucyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIHZhciBsYXlvdXQgPSBvcHRpb25zLmxheW91dDtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICBub2Rlcy5wb3NpdGlvbnMoZ2V0U2NhbGVkUG9zKTtcblxuICAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuICBpZiAodHJ1ZSAhPT0gbGF5b3V0SW5mby5yZWFkeSkge1xuICAgIC8vIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgbGF5b3V0SW5mby5yZWFkeSA9IHRydWU7XG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgbGF5b3V0OiB0aGlzXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAqL1xuLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuLy8gICBpZiAoREVCVUcpIHtcbi8vICAgICBjb25zb2xlLmRlYnVnKHRleHQpO1xuLy8gICB9XG4vLyB9O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdGhlIHBoeXNpY2FsIHNpbXVsYXRpb25cbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cbnZhciBzdGVwID0gZnVuY3Rpb24gc3RlcChsYXlvdXRJbmZvLCBvcHRpb25zLCBfc3RlcCkge1xuICAvLyB2YXIgcyA9IFwiXFxuXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1wiO1xuICAvLyBzICs9IFwiXFxuU1RFUDogXCIgKyBzdGVwO1xuICAvLyBzICs9IFwiXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xcblwiO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAvLyBDYWxjdWxhdGUgbm9kZSByZXB1bHNpb25zXG4gIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gIC8vIENhbGN1bGF0ZSBlZGdlIGZvcmNlc1xuICBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8pO1xuICAvLyBDYWxjdWxhdGUgZ3Jhdml0eSBmb3JjZXNcbiAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuICBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbyk7XG4gIC8vIFVwZGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gY2FsY3VsYXRlZCBmb3JjZXNcbiAgdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8pO1xufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBDb21wdXRlcyB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzXG4gKi9cbnZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXNcbiAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICB2YXIgbm9kZTEgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhba11dXTtcbiAgICAgICAgbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciByYW5kb21EaXN0YW5jZSA9IGZ1bmN0aW9uIHJhbmRvbURpc3RhbmNlKG1heCkge1xuICByZXR1cm4gLTEgKyAyICogbWF4ICogTWF0aC5yYW5kb20oKTtcbn07XG5cbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gKi9cbnZhciBub2RlUmVwdWxzaW9uID0gZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSBcIk5vZGUgcmVwdWxzaW9uLiBOb2RlMTogXCIgKyBub2RlMS5pZCArIFwiIE5vZGUyOiBcIiArIG5vZGUyLmlkO1xuXG4gIHZhciBjbXB0SWQxID0gbm9kZTEuY21wdElkO1xuICB2YXIgY21wdElkMiA9IG5vZGUyLmNtcHRJZDtcbiAgaWYgKGNtcHRJZDEgIT09IGNtcHRJZDIgJiYgIWxheW91dEluZm8uaXNDb21wb3VuZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgdmFyIG1heFJhbmREaXN0ID0gMTtcbiAgLy8gcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG5cbiAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgYXBwbHkgYSByYW5kb20gZm9yY2VcbiAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgIGRpcmVjdGlvblggPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gICAgZGlyZWN0aW9uWSA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgfVxuICB2YXIgb3ZlcmxhcCA9IG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICBpZiAob3ZlcmxhcCA+IDApIHtcbiAgICAvLyBzICs9IFwiXFxuTm9kZXMgRE8gb3ZlcmxhcC5cIjtcbiAgICAvLyBzICs9IFwiXFxuT3ZlcmxhcDogXCIgKyBvdmVybGFwO1xuICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWxcbiAgICAvLyB0byB0aGUgb3ZlcmxhcFxuICAgIHZhciBmb3JjZSA9IG9wdGlvbnMubm9kZU92ZXJsYXAgKiBvdmVybGFwO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlyZWN0aW9uWCAqIGRpcmVjdGlvblggKyBkaXJlY3Rpb25ZICogZGlyZWN0aW9uWSk7XG4gICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpcmVjdGlvblggLyBkaXN0YW5jZTtcbiAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXJlY3Rpb25ZIC8gZGlzdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gcyArPSBcIlxcbk5vZGVzIGRvIE5PVCBvdmVybGFwLlwiO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gb3ZlcmxhcCwgZm9yY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbFxuICAgIC8vIHRvIHNxdWFyZWQgZGlzdGFuY2VcblxuICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuXG4gICAgLy8gVXNlIGNsaXBwaW5nIHBvaW50cyB0byBjb21wdXRlIGRpc3RhbmNlXG4gICAgdmFyIGRpc3RhbmNlWCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgdmFyIGRpc3RhbmNlWSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxcik7XG4gICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICB2YXIgZm9yY2UgPSAobm9kZTEubm9kZVJlcHVsc2lvbiArIG5vZGUyLm5vZGVSZXB1bHNpb24pIC8gZGlzdGFuY2VTcXI7XG4gICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG4gIH1cblxuICAvLyBBcHBseSBmb3JjZVxuICBpZiAoIW5vZGUxLmlzTG9ja2VkKSB7XG4gICAgbm9kZTEub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgbm9kZTEub2Zmc2V0WSAtPSBmb3JjZVk7XG4gIH1cbiAgaWYgKCFub2RlMi5pc0xvY2tlZCkge1xuICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICB9XG5cbiAgLy8gcyArPSBcIlxcbkZvcmNlWDogXCIgKyBmb3JjZVggKyBcIiBGb3JjZVk6IFwiICsgZm9yY2VZO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICByZXR1cm47XG59O1xuXG4vKipcbiAqIEBicmllZiAgOiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG5vZGVzIG92ZXJsYXAgb3Igbm90XG4gKiBAcmV0dXJuIDogQW1vdW50IG9mIG92ZXJsYXBwaW5nICgwID0+IG5vIG92ZXJsYXApXG4gKi9cbnZhciBub2Rlc092ZXJsYXAgPSBmdW5jdGlvbiBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkWCwgZFkpIHtcbiAgaWYgKGRYID4gMCkge1xuICAgIHZhciBvdmVybGFwWCA9IG5vZGUxLm1heFggLSBub2RlMi5taW5YO1xuICB9IGVsc2Uge1xuICAgIHZhciBvdmVybGFwWCA9IG5vZGUyLm1heFggLSBub2RlMS5taW5YO1xuICB9XG4gIGlmIChkWSA+IDApIHtcbiAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMS5tYXhZIC0gbm9kZTIubWluWTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMi5tYXhZIC0gbm9kZTEubWluWTtcbiAgfVxuICBpZiAob3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHNcbiAqICAgICAgICAgIHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBib3ggb2YgaXQncyBzb3VyY2UvdGFyZ2V0IG5vZGVcbiAqL1xudmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24gZmluZENsaXBwaW5nUG9pbnQobm9kZSwgZFgsIGRZKSB7XG4gIC8vIFNob3JjdXRzXG4gIHZhciBYID0gbm9kZS5wb3NpdGlvblg7XG4gIHZhciBZID0gbm9kZS5wb3NpdGlvblk7XG4gIHZhciBIID0gbm9kZS5oZWlnaHQgfHwgMTtcbiAgdmFyIFcgPSBub2RlLndpZHRoIHx8IDE7XG4gIHZhciBkaXJTbG9wZSA9IGRZIC8gZFg7XG4gIHZhciBub2RlU2xvcGUgPSBIIC8gVztcblxuICAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArXG4gIC8vICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArXG4gIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAvL1xuICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuICB2YXIgcmVzID0ge307XG5cbiAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcbiAgaWYgKDAgPT09IGRYICYmIDAgPCBkWSkge1xuICAgIHJlcy54ID0gWDtcbiAgICAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcbiAgaWYgKDAgPT09IGRYICYmIDAgPiBkWSkge1xuICAgIHJlcy54ID0gWDtcbiAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAvLyBzICs9IFwiXFxuRG93biBkaXJlY3Rpb25cIjtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSByaWdodCBib3JkZXJcbiAgaWYgKDAgPCBkWCAmJiAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICByZXMueCA9IFggKyBXIC8gMjtcbiAgICByZXMueSA9IFkgKyBXICogZFkgLyAyIC8gZFg7XG4gICAgLy8gcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcbiAgaWYgKDAgPiBkWCAmJiAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICByZXMueCA9IFggLSBXIC8gMjtcbiAgICByZXMueSA9IFkgLSBXICogZFkgLyAyIC8gZFg7XG4gICAgLy8gcyArPSBcIlxcbkxlZnRib3JkZXJcIjtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG4gIGlmICgwIDwgZFkgJiYgKGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8IGRpclNsb3BlID49IG5vZGVTbG9wZSkpIHtcbiAgICByZXMueCA9IFggKyBIICogZFggLyAyIC8gZFk7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgLy8gcyArPSBcIlxcblRvcCBib3JkZXJcIjtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBib3R0b20gYm9yZGVyXG4gIGlmICgwID4gZFkgJiYgKGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8IGRpclNsb3BlID49IG5vZGVTbG9wZSkpIHtcbiAgICByZXMueCA9IFggLSBIICogZFggLyAyIC8gZFk7XG4gICAgcmVzLnkgPSBZIC0gSCAvIDI7XG4gICAgLy8gcyArPSBcIlxcbkJvdHRvbSBib3JkZXJcIjtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogQGJyaWVmIDogQ2FsY3VsYXRlcyBhbGwgZWRnZSBmb3JjZXNcbiAqL1xudmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICB2YXIgZWRnZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHNvdXJjZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciB0YXJnZXQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcblxuICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgdmFyIGRpcmVjdGlvblggPSB0YXJnZXQucG9zaXRpb25YIC0gc291cmNlLnBvc2l0aW9uWDtcbiAgICB2YXIgZGlyZWN0aW9uWSA9IHRhcmdldC5wb3NpdGlvblkgLSBzb3VyY2UucG9zaXRpb25ZO1xuXG4gICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cbiAgICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KHNvdXJjZSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KHRhcmdldCwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuICAgIHZhciBseCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgdmFyIGx5ID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICB2YXIgbCA9IE1hdGguc3FydChseCAqIGx4ICsgbHkgKiBseSk7XG4gICAgdmFyIGZvcmNlID0gTWF0aC5wb3coZWRnZS5pZGVhbExlbmd0aCAtIGwsIDIpIC8gZWRnZS5lbGFzdGljaXR5O1xuICAgIGlmICgwICE9PSBsKSB7XG4gICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBseCAvIGw7XG4gICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBseSAvIGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmb3JjZVggPSAwO1xuICAgICAgdmFyIGZvcmNlWSA9IDA7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcbiAgICBpZiAoIXNvdXJjZS5pc0xvY2tlZCkge1xuICAgICAgc291cmNlLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgc291cmNlLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldC5pc0xvY2tlZCkge1xuICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuICAgIH1cblxuICAgIC8vIHZhciBzID0gJ0VkZ2UgZm9yY2UgYmV0d2VlbiBub2RlcyAnICsgc291cmNlLmlkICsgJyBhbmQgJyArIHRhcmdldC5pZDtcbiAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgbCArIFwiIEZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIilcIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBDb21wdXRlcyBncmF2aXR5IGZvcmNlcyBmb3IgYWxsIG5vZGVzXG4gKi9cbnZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmdyYXZpdHkgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxO1xuXG4gIC8vIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIC8vIENvbXB1dGUgZ3JhcGggY2VudGVyXG4gICAgaWYgKDAgPT09IGkpIHtcbiAgICAgIHZhciBjZW50ZXJYID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgdmFyIGNlbnRlclkgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgIHZhciB0ZW1wID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFswXV1dO1xuICAgICAgdmFyIHBhcmVudCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcC5wYXJlbnRJZF1dO1xuICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgdmFyIGNlbnRlclkgPSBwYXJlbnQucG9zaXRpb25ZO1xuICAgIH1cbiAgICAvLyBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAvLyBBcHBseSBmb3JjZSB0byBhbGwgbm9kZXMgaW4gZ3JhcGhcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dO1xuICAgICAgLy8gcyA9IFwiTm9kZTogXCIgKyBub2RlLmlkO1xuXG4gICAgICBpZiAobm9kZS5pc0xvY2tlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkeCA9IGNlbnRlclggLSBub2RlLnBvc2l0aW9uWDtcbiAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgIHZhciBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGlmIChkID4gZGlzdFRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZnggPSBvcHRpb25zLmdyYXZpdHkgKiBkeCAvIGQ7XG4gICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICBub2RlLm9mZnNldFkgKz0gZnk7XG4gICAgICAgIC8vIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgIH1cbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbVxuICogICAgICAgICAgICAgICAgICAgcGFyZW50IG5vZGVzIHRvIGl0cyBkZXNjZW5kZW50cy5cbiAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gT2JqZWN0XG4gKiBAYXJnIGN5ICAgICAgICAgOiBjeXRvc2NhcGUgT2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG52YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24gcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgdmFyIGVuZCA9IC0xOyAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICAvLyBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG5cbiAgLy8gU3RhcnQgYnkgdmlzaXRpbmcgdGhlIG5vZGVzIGluIHRoZSByb290IGdyYXBoXG4gIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIGxheW91dEluZm8uZ3JhcGhTZXRbMF0pO1xuICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZUlkID0gcXVldWVbc3RhcnQrK107XG4gICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJbmRleF07XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBub2RlIGlmIGl0J3MgY29tcG91bmRcbiAgICBpZiAoMCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhbm9kZS5pc0xvY2tlZCkge1xuICAgICAgdmFyIG9mZlggPSBub2RlLm9mZnNldFg7XG4gICAgICB2YXIgb2ZmWSA9IG5vZGUub2Zmc2V0WTtcblxuICAgICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG9mZnNldCBmcm9tIHBhcmVudCBub2RlIDogXCIgKyBub2RlLmlkICtcbiAgICAgIC8vICAgXCIuIE9mZnNldFg6IFwiICsgb2ZmWCArIFwiLiBPZmZzZXRZOiBcIiArIG9mZlk7XG4gICAgICAvLyBzICs9IFwiXFxuIENoaWxkcmVuOiBcIiArIGNoaWxkcmVuLnRvU3RyaW5nKCk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlbltpXV1dO1xuICAgICAgICAvLyBQcm9wYWdhdGUgb2Zmc2V0XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7XG4gICAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCBwYXJlbnQgb2Zmc2V0c1xuICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uXG4gKiAgICAgICAgICB0aGUgYWNjdW11bGF0ZWQgZm9yY2VzXG4gKi9cbnZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyB2YXIgcyA9ICdVcGRhdGluZyBwb3NpdGlvbnMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlJlc2V0dGluZyBib3VuZGFyaWVzIG9mIGNvbXBvdW5kIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICBuLm1heFggPSB1bmRlZmluZWQ7XG4gICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICBuLm1heFkgPSB1bmRlZmluZWQ7XG4gICAgICBuLm1pblkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggfHwgbi5pc0xvY2tlZCkge1xuICAgICAgLy8gTm8gbmVlZCB0byBzZXQgY29tcG91bmQgb3IgbG9ja2VkIG5vZGUgcG9zaXRpb25cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU2tpcHBpbmcgcG9zaXRpb24gdXBkYXRlIG9mIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gcyA9IFwiTm9kZTogXCIgKyBuLmlkICsgXCIgUHJldmlvdXMgcG9zaXRpb246IChcIiArXG4gICAgLy8gbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcblxuICAgIC8vIExpbWl0IGRpc3BsYWNlbWVudCBpbiBvcmRlciB0byBpbXByb3ZlIHN0YWJpbGl0eVxuICAgIHZhciB0ZW1wRm9yY2UgPSBsaW1pdEZvcmNlKG4ub2Zmc2V0WCwgbi5vZmZzZXRZLCBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcbiAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDtcbiAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICBuLm9mZnNldFggPSAwO1xuICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgbi5taW5YID0gbi5wb3NpdGlvblggLSBuLndpZHRoO1xuICAgIG4ubWF4WCA9IG4ucG9zaXRpb25YICsgbi53aWR0aDtcbiAgICBuLm1pblkgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0O1xuICAgIG4ubWF4WSA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7XG4gICAgLy8gcyArPSBcIiBOZXcgUG9zaXRpb246IChcIiArIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAvLyBVcGRhdGUgYW5jZXN0cnkgYm91ZGFyaWVzXG4gICAgX3VwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgbi5wb3NpdGlvblkgPSAobi5tYXhZICsgbi5taW5ZKSAvIDI7XG4gICAgICBuLndpZHRoID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgbi5oZWlnaHQgPSBuLm1heFkgLSBuLm1pblk7XG4gICAgICAvLyBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IExpbWl0cyBhIGZvcmNlIChmb3JjZVgsIGZvcmNlWSkgdG8gYmUgbm90XG4gKiAgICAgICAgICBncmVhdGVyIChpbiBtb2R1bG8pIHRoYW4gbWF4LlxuIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi5cbiAgKi9cbnZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24gbGltaXRGb3JjZShmb3JjZVgsIGZvcmNlWSwgbWF4KSB7XG4gIC8vIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZKTtcbiAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHg6IG1heCAqIGZvcmNlWCAvIGZvcmNlLFxuICAgICAgeTogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSB7XG4gICAgICB4OiBmb3JjZVgsXG4gICAgICB5OiBmb3JjZVlcbiAgICB9O1xuICB9XG5cbiAgLy8gcyArPSBcIi5cXG5SZXN1bHQ6IChcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnkgKyBcIilcIjtcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogQGJyaWVmIDogRnVuY3Rpb24gdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBjb21wb3VuZCBub2RlXG4gKiAgICAgICAgICBzaXplcywgc2luY2UgdGhleSBzaG91bGQgYm91bmQgYWxsIHRoZWlyIHN1Ym5vZGVzLlxuICovXG52YXIgX3VwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyA9IGZ1bmN0aW9uIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhub2RlLCBsYXlvdXRJbmZvKSB7XG4gIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBuZXcgcG9zaXRpb24vc2l6ZSBvZiBub2RlIFwiICsgbm9kZS5pZDtcbiAgdmFyIHBhcmVudElkID0gbm9kZS5wYXJlbnRJZDtcbiAgaWYgKG51bGwgPT0gcGFyZW50SWQpIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UgYXJlIGRvbmVcbiAgICAvLyBzICs9IFwiLiBObyBwYXJlbnQgbm9kZS5cIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHZXQgUGFyZW50IE5vZGVcbiAgdmFyIHAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BhcmVudElkXV07XG4gIHZhciBmbGFnID0gZmFsc2U7XG5cbiAgLy8gTWF4WFxuICBpZiAobnVsbCA9PSBwLm1heFggfHwgbm9kZS5tYXhYICsgcC5wYWRSaWdodCA+IHAubWF4WCkge1xuICAgIHAubWF4WCA9IG5vZGUubWF4WCArIHAucGFkUmlnaHQ7XG4gICAgZmxhZyA9IHRydWU7XG4gICAgLy8gcyArPSBcIlxcbk5ldyBtYXhYIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFg7XG4gIH1cblxuICAvLyBNaW5YXG4gIGlmIChudWxsID09IHAubWluWCB8fCBub2RlLm1pblggLSBwLnBhZExlZnQgPCBwLm1pblgpIHtcbiAgICBwLm1pblggPSBub2RlLm1pblggLSBwLnBhZExlZnQ7XG4gICAgZmxhZyA9IHRydWU7XG4gICAgLy8gcyArPSBcIlxcbk5ldyBtaW5YIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblg7XG4gIH1cblxuICAvLyBNYXhZXG4gIGlmIChudWxsID09IHAubWF4WSB8fCBub2RlLm1heFkgKyBwLnBhZEJvdHRvbSA+IHAubWF4WSkge1xuICAgIHAubWF4WSA9IG5vZGUubWF4WSArIHAucGFkQm90dG9tO1xuICAgIGZsYWcgPSB0cnVlO1xuICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhZO1xuICB9XG5cbiAgLy8gTWluWVxuICBpZiAobnVsbCA9PSBwLm1pblkgfHwgbm9kZS5taW5ZIC0gcC5wYWRUb3AgPCBwLm1pblkpIHtcbiAgICBwLm1pblkgPSBub2RlLm1pblkgLSBwLnBhZFRvcDtcbiAgICBmbGFnID0gdHJ1ZTtcbiAgICAvLyBzICs9IFwiXFxuTmV3IG1pblkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWTtcbiAgfVxuXG4gIC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG4gIGlmIChmbGFnKSB7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuIF91cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMocCwgbGF5b3V0SW5mbyk7XG4gIH1cblxuICAvLyBzICs9IFwiLiBObyBjaGFuZ2VzIGluIGJvdW5kYXJpZXMvcG9zaXRpb24gb2YgcGFyZW50IG5vZGUgXCIgKyBwLmlkO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgcmV0dXJuO1xufTtcbnZhciBzZXBhcmF0ZUNvbXBvbmVudHMgPSBmdW5jdGlvbiBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICB2YXIgbm9kZXMgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgY2lkID0gbm9kZS5jbXB0SWQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY2lkXSA9IGNvbXBvbmVudHNbY2lkXSB8fCBbXTtcbiAgICBjb21wb25lbnQucHVzaChub2RlKTtcbiAgfVxuICB2YXIgdG90YWxBID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuICAgIGlmICghYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGMueDEgPSBJbmZpbml0eTtcbiAgICBjLngyID0gLUluZmluaXR5O1xuICAgIGMueTEgPSBJbmZpbml0eTtcbiAgICBjLnkyID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG4gPSBjW2pdO1xuICAgICAgYy54MSA9IE1hdGgubWluKGMueDEsIG4ucG9zaXRpb25YIC0gbi53aWR0aCAvIDIpO1xuICAgICAgYy54MiA9IE1hdGgubWF4KGMueDIsIG4ucG9zaXRpb25YICsgbi53aWR0aCAvIDIpO1xuICAgICAgYy55MSA9IE1hdGgubWluKGMueTEsIG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQgLyAyKTtcbiAgICAgIGMueTIgPSBNYXRoLm1heChjLnkyLCBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0IC8gMik7XG4gICAgfVxuICAgIGMudyA9IGMueDIgLSBjLngxO1xuICAgIGMuaCA9IGMueTIgLSBjLnkxO1xuICAgIHRvdGFsQSArPSBjLncgKiBjLmg7XG4gIH1cbiAgY29tcG9uZW50cy5zb3J0KGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICByZXR1cm4gYzIudyAqIGMyLmggLSBjMS53ICogYzEuaDtcbiAgfSk7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuICB2YXIgdXNlZFcgPSAwO1xuICB2YXIgcm93SCA9IDA7XG4gIHZhciBtYXhSb3dXID0gTWF0aC5zcXJ0KHRvdGFsQSkgKiBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcbiAgICBpZiAoIWMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuID0gY1tqXTtcbiAgICAgIGlmICghbi5pc0xvY2tlZCkge1xuICAgICAgICBuLnBvc2l0aW9uWCArPSB4IC0gYy54MTtcbiAgICAgICAgbi5wb3NpdGlvblkgKz0geSAtIGMueTE7XG4gICAgICB9XG4gICAgfVxuICAgIHggKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgIHVzZWRXICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICByb3dIID0gTWF0aC5tYXgocm93SCwgYy5oKTtcbiAgICBpZiAodXNlZFcgPiBtYXhSb3dXKSB7XG4gICAgICB5ICs9IHJvd0ggKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICB4ID0gMDtcbiAgICAgIHVzZWRXID0gMDtcbiAgICAgIHJvd0ggPSAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRlZmF1bHRzJDMgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gcGFkZGluZyB1c2VkIG9uIGZpdFxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIGF2b2lkT3ZlcmxhcFBhZGRpbmc6IDEwLFxuICAvLyBleHRyYSBzcGFjaW5nIGFyb3VuZCBub2RlcyB3aGVuIGF2b2lkT3ZlcmxhcDogdHJ1ZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIGNvbmRlbnNlOiBmYWxzZSxcbiAgLy8gdXNlcyBhbGwgYXZhaWxhYmxlIHNwYWNlIG9uIGZhbHNlLCB1c2VzIG1pbmltYWwgc3BhY2Ugb24gdHJ1ZVxuICByb3dzOiB1bmRlZmluZWQsXG4gIC8vIGZvcmNlIG51bSBvZiByb3dzIGluIHRoZSBncmlkXG4gIGNvbHM6IHVuZGVmaW5lZCxcbiAgLy8gZm9yY2UgbnVtIG9mIGNvbHVtbnMgaW4gdGhlIGdyaWRcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKG5vZGUpIHt9LFxuICAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICBzb3J0OiB1bmRlZmluZWQsXG4gIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcbn07XG5mdW5jdGlvbiBHcmlkTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQzLCBvcHRpb25zKTtcbn1cbkdyaWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICBpZiAoYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwKSB7XG4gICAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSxcbiAgICAgICAgeTogYmIueTFcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoY2VsbHMgKiBiYi5oIC8gYmIudyk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKHNwbGl0cyk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKGJiLncgLyBiYi5oICogc3BsaXRzKTtcbiAgICB2YXIgc21hbGwgPSBmdW5jdGlvbiBzbWFsbCh2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICAgIGlmIChtaW4gPT0gcm93cykge1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGxhcmdlID0gZnVuY3Rpb24gbGFyZ2UodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgICBpZiAobWF4ID09IHJvd3MpIHtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvUm93cyA9IG9wdGlvbnMucm93cztcbiAgICB2YXIgb0NvbHMgPSBvcHRpb25zLmNvbHMgIT0gbnVsbCA/IG9wdGlvbnMuY29scyA6IG9wdGlvbnMuY29sdW1ucztcblxuICAgIC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG4gICAgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IG9Db2xzO1xuICAgIH0gZWxzZSBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyA9PSBudWxsKSB7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gTWF0aC5jZWlsKGNlbGxzIC8gcm93cyk7XG4gICAgfSBlbHNlIGlmIChvUm93cyA9PSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoY2VsbHMgLyBjb2xzKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcblxuICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgZWxzZSBpZiAoY29scyAqIHJvd3MgPiBjZWxscykge1xuICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG5cbiAgICAgIC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuICAgICAgaWYgKChzbSAtIDEpICogbGcgPj0gY2VsbHMpIHtcbiAgICAgICAgc21hbGwoc20gLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoKGxnIC0gMSkgKiBzbSA+PSBjZWxscykge1xuICAgICAgICBsYXJnZShsZyAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgd2hpbGUgKGNvbHMgKiByb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgdmFyIF9zbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBfbGcgPSBsYXJnZSgpO1xuXG4gICAgICAgIC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcbiAgICAgICAgaWYgKChfbGcgKyAxKSAqIF9zbSA+PSBjZWxscykge1xuICAgICAgICAgIGxhcmdlKF9sZyArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYWxsKF9zbSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuICAgIGlmIChvcHRpb25zLmNvbmRlbnNlKSB7XG4gICAgICBjZWxsV2lkdGggPSAwO1xuICAgICAgY2VsbEhlaWdodCA9IDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGZvciBiYlxuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5iYiA9IG5vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHAgPSBvcHRpb25zLmF2b2lkT3ZlcmxhcFBhZGRpbmc7XG4gICAgICAgIHZhciB3ID0gbmJiLncgKyBwO1xuICAgICAgICB2YXIgaCA9IG5iYi5oICsgcDtcbiAgICAgICAgY2VsbFdpZHRoID0gTWF0aC5tYXgoY2VsbFdpZHRoLCB3KTtcbiAgICAgICAgY2VsbEhlaWdodCA9IE1hdGgubWF4KGNlbGxIZWlnaHQsIGgpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcblxuICAgIHZhciB1c2VkID0gZnVuY3Rpb24gdXNlZChyb3csIGNvbCkge1xuICAgICAgcmV0dXJuIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uIHVzZShyb3csIGNvbCkge1xuICAgICAgY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPSB0cnVlO1xuICAgIH07XG5cbiAgICAvLyB0byBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgY2VsbCBwb3NpdGlvblxuICAgIHZhciByb3cgPSAwO1xuICAgIHZhciBjb2wgPSAwO1xuICAgIHZhciBtb3ZlVG9OZXh0Q2VsbCA9IGZ1bmN0aW9uIG1vdmVUb05leHRDZWxsKCkge1xuICAgICAgY29sKys7XG4gICAgICBpZiAoY29sID49IGNvbHMpIHtcbiAgICAgICAgY29sID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKF9ub2RlKTtcbiAgICAgIGlmIChyY1BvcyAmJiAocmNQb3Mucm93ICE9PSB1bmRlZmluZWQgfHwgcmNQb3MuY29sICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIC8vIG11c3QgaGF2ZSBhdCBsZWFzdCByb3cgb3IgY29sIGRlZidkXG4gICAgICAgIHZhciBfcG9zID0ge1xuICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChfcG9zLmNvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmluZCB1bnVzZWQgY29sXG4gICAgICAgICAgX3Bvcy5jb2wgPSAwO1xuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3MuY29sKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9wb3Mucm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICBfcG9zLnJvdyA9IDA7XG4gICAgICAgICAgd2hpbGUgKHVzZWQoX3Bvcy5yb3csIF9wb3MuY29sKSkge1xuICAgICAgICAgICAgX3Bvcy5yb3crKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWQybWFuUG9zW19ub2RlLmlkKCldID0gX3BvcztcbiAgICAgICAgdXNlKF9wb3Mucm93LCBfcG9zLmNvbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlbWVudCwgaSkge1xuICAgICAgdmFyIHgsIHk7XG4gICAgICBpZiAoZWxlbWVudC5sb2NrZWQoKSB8fCBlbGVtZW50LmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWUgaWYgd2UgaGF2ZSBhIG1hbnVhbCBwb3NpdGlvbiBzZXRcbiAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1tlbGVtZW50LmlkKCldO1xuICAgICAgaWYgKHJjUG9zKSB7XG4gICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuXG4gICAgICAgIHdoaWxlICh1c2VkKHJvdywgY29sKSkge1xuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IGNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgeSA9IHJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgICB1c2Uocm93LCBjb2wpO1xuICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9O1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xudmFyIGRlZmF1bHRzJDIgPSB7XG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAvLyBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30gLy8gb24gbGF5b3V0c3RvcFxufTtcblxuLy8gY29uc3RydWN0b3Jcbi8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuZnVuY3Rpb24gTnVsbExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMiwgb3B0aW9ucyk7XG59XG5cbi8vIHJ1bnMgdGhlIGxheW91dFxuTnVsbExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIGVsZW1lbnRzIHRvIGNvbnNpZGVyIGluIHRoZSBsYXlvdXRcbiAgdmFyIGxheW91dCA9IHRoaXM7XG5cbiAgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAvLyAoZGlzYWJsZSBlc2xpbnQgZm9yIG5leHQgbGluZSBhcyB0aGlzIHNlcnZlcyBhcyBleGFtcGxlIGxheW91dCBjb2RlIHRvIGV4dGVybmFsIGRldmVsb3BlcnMpXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBvcHRpb25zLmN5O1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RhcnQnKTtcblxuICAvLyBwdXRzIGFsbCBub2RlcyBhdCAoMCwgMClcbiAgLy8gbi5iLiBtb3N0IGxheW91dHMgd291bGQgdXNlIGxheW91dFBvc2l0aW9ucygpLCBpbnN0ZWFkIG9mIHBvc2l0aW9ucygpIGFuZCBtYW51YWwgZXZlbnRzXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0pO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcbiAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHJlYWR5Jyk7XG5cbiAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5OdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyQxID0ge1xuICBwb3NpdGlvbnM6IHVuZGVmaW5lZCxcbiAgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgem9vbTogdW5kZWZpbmVkLFxuICAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIHBhbjogdW5kZWZpbmVkLFxuICAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gcGFkZGluZyBvbiBmaXRcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcbn07XG5mdW5jdGlvbiBQcmVzZXRMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDEsIG9wdGlvbnMpO1xufVxuUHJlc2V0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICB2YXIgcG9zSXNGbiA9IGZuJDYob3B0aW9ucy5wb3NpdGlvbnMpO1xuICBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb25zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb3B5UG9zaXRpb24obm9kZS5wb3NpdGlvbigpKTtcbiAgICB9XG4gICAgaWYgKHBvc0lzRm4pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucyhub2RlKTtcbiAgICB9XG4gICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb25zW25vZGUuX3ByaXZhdGUuZGF0YS5pZF07XG4gICAgaWYgKHBvcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcbiAgICBpZiAobm9kZS5sb2NrZWQoKSB8fCBwb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBmaXQgcGFkZGluZ1xuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxufTtcbmZ1bmN0aW9uIFJhbmRvbUxheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuUmFuZG9tTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3Mobm9kZSwgaSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBiYi54MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLncpLFxuICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi5oKVxuICAgIH07XG4gIH07XG4gIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgbGF5b3V0ID0gW3tcbiAgbmFtZTogJ2JyZWFkdGhmaXJzdCcsXG4gIGltcGw6IEJyZWFkdGhGaXJzdExheW91dFxufSwge1xuICBuYW1lOiAnY2lyY2xlJyxcbiAgaW1wbDogQ2lyY2xlTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdjb25jZW50cmljJyxcbiAgaW1wbDogQ29uY2VudHJpY0xheW91dFxufSwge1xuICBuYW1lOiAnY29zZScsXG4gIGltcGw6IENvc2VMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2dyaWQnLFxuICBpbXBsOiBHcmlkTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdudWxsJyxcbiAgaW1wbDogTnVsbExheW91dFxufSwge1xuICBuYW1lOiAncHJlc2V0JyxcbiAgaW1wbDogUHJlc2V0TGF5b3V0XG59LCB7XG4gIG5hbWU6ICdyYW5kb20nLFxuICBpbXBsOiBSYW5kb21MYXlvdXRcbn1dO1xuXG5mdW5jdGlvbiBOdWxsUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLm5vdGlmaWNhdGlvbnMgPSAwOyAvLyBmb3IgdGVzdGluZ1xufVxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgdGhyb3dJbWdFcnIgPSBmdW5jdGlvbiB0aHJvd0ltZ0VycigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdBIGhlYWRsZXNzIGluc3RhbmNlIGNhbiBub3QgcmVuZGVyIGltYWdlcycpO1xufTtcbk51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCxcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKys7XG4gIH0sXG4gIGluaXQ6IG5vb3AsXG4gIGlzSGVhZGxlc3M6IGZ1bmN0aW9uIGlzSGVhZGxlc3MoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHBuZzogdGhyb3dJbWdFcnIsXG4gIGpwZzogdGhyb3dJbWdFcnJcbn07XG5cbnZhciBCUnAkZiA9IHt9O1xuQlJwJGYuYXJyb3dTaGFwZVdpZHRoID0gMC4zO1xuQlJwJGYucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gIC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gIC8vICgxLCAwKSBpcyByaWdodFxuICAvL1xuICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24gYmJDb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgdmFyIHgxID0gdHJhbnNsYXRpb24ueCAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSB0cmFuc2xhdGlvbi54ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuICAgIHZhciB5MSA9IHRyYW5zbGF0aW9uLnkgLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHkyID0gdHJhbnNsYXRpb24ueSArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgaW5zaWRlID0geDEgPD0geCAmJiB4IDw9IHgyICYmIHkxIDw9IHkgJiYgeSA8PSB5MjtcbiAgICByZXR1cm4gaW5zaWRlO1xuICB9O1xuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgfTtcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwdHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgIHZhciByZXRQdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIHggPSBwdHNbaV07XG4gICAgICB2YXIgeSA9IHB0c1tpICsgMV07XG4gICAgICByZXRQdHMucHVzaCh0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgfVxuICAgIHJldHVybiByZXRQdHM7XG4gIH07XG4gIHZhciBwb2ludHNUb0FyciA9IGZ1bmN0aW9uIHBvaW50c1RvQXJyKHB0cykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwdHNbaV07XG4gICAgICByZXQucHVzaChwLngsIHAueSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIHZhciBzdGFuZGFyZEdhcCA9IGZ1bmN0aW9uIHN0YW5kYXJkR2FwKGVkZ2UpIHtcbiAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnBmVmFsdWUgKiAyO1xuICB9O1xuICB2YXIgZGVmaW5lQXJyb3dTaGFwZSA9IGZ1bmN0aW9uIGRlZmluZUFycm93U2hhcGUobmFtZSwgZGVmbikge1xuICAgIGlmIChzdHJpbmcoZGVmbikpIHtcbiAgICAgIGRlZm4gPSBhcnJvd1NoYXBlc1tkZWZuXTtcbiAgICB9XG4gICAgYXJyb3dTaGFwZXNbbmFtZV0gPSBleHRlbmQoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLjE1LCAtMC4zLCAwLjE1LCAwLjMsIC0wLjE1LCAwLjNdLFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoJ3BvbHlnb24nKShjb250ZXh0LCBwb2ludHMpO1xuICAgICAgfSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBnYXA6IHN0YW5kYXJkR2FwXG4gICAgfSwgZGVmbik7XG4gIH07XG4gIGRlZmluZUFycm93U2hhcGUoJ25vbmUnLCB7XG4gICAgY29sbGlkZTogZmFsc2lmeSxcbiAgICByb3VnaENvbGxpZGU6IGZhbHNpZnksXG4gICAgZHJhdzogbm9vcCQxLFxuICAgIHNwYWNpbmc6IHplcm9pZnksXG4gICAgZ2FwOiB6ZXJvaWZ5XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuM11cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2Fycm93JywgJ3RyaWFuZ2xlJyk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsIHtcbiAgICBwb2ludHM6IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLnBvaW50cyxcbiAgICBjb250cm9sUG9pbnQ6IFswLCAtMC4xNV0sXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIGN0cmxQdCA9IHRoaXMuY29udHJvbFBvaW50O1xuICAgICAgdmFyIGN0cmxQdFRyYW5zID0gdHJhbnNmb3JtKGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMpO1xuICAgIH0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC44O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLXRlZScsIHtcbiAgICBwb2ludHM6IFswLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuMywgMCwgMF0sXG4gICAgcG9pbnRzVGVlOiBbLTAuMTUsIC0wLjQsIC0wLjE1LCAtMC41LCAwLjE1LCAtMC41LCAwLjE1LCAtMC40XSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCB0ZWVQdHMpO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2NpcmNsZS10cmlhbmdsZScsIHtcbiAgICByYWRpdXM6IDAuMTUsXG4gICAgcG9pbnRzVHI6IFswLCAtMC4xNSwgMC4xNSwgLTAuNDUsIC0wLjE1LCAtMC40NSwgMCwgLTAuMTVdLFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgY2lyY2xlSW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgY2lyY2xlSW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RyLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSk7XG4gICAgfSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWNyb3NzJywge1xuICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICBiYXNlQ3Jvc3NMaW5lUHRzOiBbLTAuMTUsIC0wLjQsXG4gICAgLy8gZmlyc3QgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgLTAuMTUsIC0wLjQsIDAuMTUsIC0wLjQsXG4gICAgLy8gc2Vjb25kIGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgIDAuMTUsIC0wLjRdLFxuICAgIGNyb3NzTGluZVB0czogZnVuY3Rpb24gY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCkge1xuICAgICAgLy8gc2hpZnQgcG9pbnRzIHNvIHRoYXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNyb3NzIHBvaW50cyBtYXRjaGVzIGVkZ2Ugd2lkdGhcbiAgICAgIHZhciBwID0gdGhpcy5iYXNlQ3Jvc3NMaW5lUHRzLnNsaWNlKCk7XG4gICAgICB2YXIgc2hpZnRGYWN0b3IgPSBlZGdlV2lkdGggLyBzaXplO1xuICAgICAgdmFyIHkwID0gMztcbiAgICAgIHZhciB5MSA9IDU7XG4gICAgICBwW3kwXSA9IHBbeTBdIC0gc2hpZnRGYWN0b3I7XG4gICAgICBwW3kxXSA9IHBbeTFdIC0gc2hpZnRGYWN0b3I7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgdGVlUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMuY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCksIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRlZVB0cyk7XG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHZhciBjcm9zc0xpbmVQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCBjcm9zc0xpbmVQdHMpO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3ZlZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuMywgMCwgLTAuMTVdLFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiBzdGFuZGFyZEdhcChlZGdlKSAqIDAuNTI1O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2NpcmNsZScsIHtcbiAgICByYWRpdXM6IDAuMTUsXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgIHZhciBpbnNpZGUgPSBNYXRoLnBvdyh0LnggLSB4LCAyKSArIE1hdGgucG93KHQueSAtIHksIDIpIDw9IE1hdGgucG93KChzaXplICsgMiAqIHBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplKTtcbiAgICB9LFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndGVlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAwLCAtMC4xNSwgLTAuMSwgMC4xNSwgLTAuMSwgMC4xNSwgMF0sXG4gICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3NxdWFyZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgMC4wMCwgMC4xNSwgMC4wMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjNdXG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdkaWFtb25kJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4xNSwgMCwgLTAuMywgMC4xNSwgLTAuMTUsIDAsIDBdLFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2hldnJvbicsIHtcbiAgICBwb2ludHM6IFswLCAwLCAtMC4xNSwgLTAuMTUsIC0wLjEsIC0wLjIsIDAsIC0wLjEsIDAuMSwgLTAuMiwgMC4xNSwgLTAuMTVdLFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwLjk1ICogZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgQlJwJGUgPSB7fTtcblxuLy8gUHJvamVjdCBtb3VzZVxuQlJwJGUucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gIHZhciBzY2FsZSA9IG9mZnNldHNbNF07XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciB4ID0gKChjbGllbnRYIC0gb2Zmc2V0TGVmdCkgLyBzY2FsZSAtIHBhbi54KSAvIHpvb207XG4gIHZhciB5ID0gKChjbGllbnRZIC0gb2Zmc2V0VG9wKSAvIHNjYWxlIC0gcGFuLnkpIC8gem9vbTtcbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5CUnAkZS5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb250YWluZXJCQikge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJCO1xuICB9XG4gIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzdHlsZSA9IHRoaXMuY3kud2luZG93KCkuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICB2YXIgc3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHN0eWxlVmFsdWUobmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICB9O1xuICB2YXIgcGFkZGluZyA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLWxlZnQnKSxcbiAgICByaWdodDogc3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpLFxuICAgIHRvcDogc3R5bGVWYWx1ZSgncGFkZGluZy10b3AnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ3BhZGRpbmctYm90dG9tJylcbiAgfTtcbiAgdmFyIGJvcmRlciA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpLFxuICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdib3JkZXItcmlnaHQtd2lkdGgnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKVxuICB9O1xuICB2YXIgY2xpZW50V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gIHZhciBjbGllbnRIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICB2YXIgcGFkZGluZ0hvciA9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gIHZhciBwYWRkaW5nVmVyID0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgdmFyIGJvcmRlckhvciA9IGJvcmRlci5sZWZ0ICsgYm9yZGVyLnJpZ2h0O1xuICB2YXIgc2NhbGUgPSByZWN0LndpZHRoIC8gKGNsaWVudFdpZHRoICsgYm9yZGVySG9yKTtcbiAgdmFyIHVuc2NhbGVkVyA9IGNsaWVudFdpZHRoIC0gcGFkZGluZ0hvcjtcbiAgdmFyIHVuc2NhbGVkSCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdWZXI7XG4gIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgcGFkZGluZy5sZWZ0ICsgYm9yZGVyLmxlZnQ7XG4gIHZhciB0b3AgPSByZWN0LnRvcCArIHBhZGRpbmcudG9wICsgYm9yZGVyLnRvcDtcbiAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkIgPSBbbGVmdCwgdG9wLCB1bnNjYWxlZFcsIHVuc2NhbGVkSCwgc2NhbGVdO1xufTtcbkJScCRlLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG59O1xuQlJwJGUuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gIHJldHVybiB0aGlzLmZpbmROZWFyZXN0RWxlbWVudHMoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpWzBdO1xufTtcbkJScCRlLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbmVhciA9IFtdOyAvLyAxIG5vZGUgbWF4LCAxIGVkZ2UgbWF4XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gIHZhciBuZWFyRWRnZTtcbiAgdmFyIG5lYXJOb2RlO1xuICBpZiAoaW50ZXJhY3RpdmVFbGVtZW50c09ubHkpIHtcbiAgICBlbGVzID0gZWxlcy5pbnRlcmFjdGl2ZTtcbiAgfVxuICBmdW5jdGlvbiBhZGRFbGUoZWxlLCBzcURpc3QpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBpZiAobmVhck5vZGUpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCByZXBsYWNlIG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXJOb2RlID0gZWxlO1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoc3FEaXN0ID09IG51bGwgfHwgc3FEaXN0IDwgbWluU3FEaXN0KSkge1xuICAgICAgaWYgKG5lYXJFZGdlKSB7XG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBleGlzdGluZyBlZGdlXG4gICAgICAgIC8vIGNhbiByZXBsYWNlIG9ubHkgaWYgc2FtZSB6LWluZGV4XG4gICAgICAgIGlmIChuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlICYmIG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWFyW2ldLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICAgIG5lYXJbaV0gPSBlbGU7XG4gICAgICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjaGVja05vZGUobm9kZSkge1xuICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIGlmIChwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAmJiBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICApIHtcbiAgICAgIHZhciBzaGFwZSA9IHIubm9kZVNoYXBlc1tzZWxmLmdldE5vZGVTaGFwZShub2RlKV07XG4gICAgICBpZiAoc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnksIGNvcm5lclJhZGl1cywgcnMpKSB7XG4gICAgICAgIGFkZEVsZShub2RlLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNoZWNrRWRnZShlZGdlKSB7XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgc3R5bGVXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgdmFyIHdpZHRoID0gc3R5bGVXaWR0aCAvIDIgKyBlZGdlVGhyZXNob2xkOyAvLyBtb3JlIGxpa2UgYSBkaXN0YW5jZSByYWRpdXMgZnJvbSBjZW50cmVcbiAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNxRGlzdDtcbiAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGluTGluZVZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgd2lkdGgyKSAmJiB3aWR0aFNxID4gKHNxRGlzdCA9IHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBpZiAoaW5CZXppZXJWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgY2xvc2UgdG8gdGhlIGVkZ2UgYnV0IGRpZG4ndCBoaXQgaXQsIG1heWJlIHdlIGhpdCBpdHMgYXJyb3dzXG5cbiAgICB2YXIgc3JjID0gc3JjIHx8IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gdGd0IHx8IF9wLnRhcmdldDtcbiAgICB2YXIgYXJTaXplID0gc2VsZi5nZXRBcnJvd1dpZHRoKHN0eWxlV2lkdGgsIHNjYWxlKTtcbiAgICB2YXIgYXJyb3dzID0gW3tcbiAgICAgIG5hbWU6ICdzb3VyY2UnLFxuICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICB5OiBycy5hcnJvd1N0YXJ0WSxcbiAgICAgIGFuZ2xlOiBycy5zcmNBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICB4OiBycy5hcnJvd0VuZFgsXG4gICAgICB5OiBycy5hcnJvd0VuZFksXG4gICAgICBhbmdsZTogcnMudGd0QXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaWQtc291cmNlJyxcbiAgICAgIHg6IHJzLm1pZFgsXG4gICAgICB5OiBycy5taWRZLFxuICAgICAgYW5nbGU6IHJzLm1pZHNyY0Fycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWlkLXRhcmdldCcsXG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWSxcbiAgICAgIGFuZ2xlOiBycy5taWR0Z3RBcnJvd0FuZ2xlXG4gICAgfV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhciA9IGFycm93c1tpXTtcbiAgICAgIHZhciBzaGFwZSA9IHIuYXJyb3dTaGFwZXNbZWRnZS5wc3R5bGUoYXIubmFtZSArICctYXJyb3ctc2hhcGUnKS52YWx1ZV07XG4gICAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIGlmIChzaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICB4OiBhci54LFxuICAgICAgICB5OiBhci55XG4gICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpICYmIHNoYXBlLmNvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICB4OiBhci54LFxuICAgICAgICB5OiBhci55XG4gICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpKSB7XG4gICAgICAgIGFkZEVsZShlZGdlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG4gICAgaWYgKGhhc0NvbXBvdW5kcyAmJiBuZWFyLmxlbmd0aCA+IDApIHtcbiAgICAgIGNoZWNrTm9kZShzcmMpO1xuICAgICAgY2hlY2tOb2RlKHRndCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByZXByb3Aob2JqLCBuYW1lLCBwcmUpIHtcbiAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIG5hbWUsIHByZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcbiAgICB2YXIgcHJlZml4RGFzaDtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXhEYXNoID0gJyc7XG4gICAgfVxuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHZhciBiYiA9IF9wLmxhYmVsQm91bmRzW3ByZWZpeCB8fCAnbWFpbiddO1xuICAgIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykudmFsdWU7XG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSBlbGUucHN0eWxlKCd0ZXh0LWV2ZW50cycpLnN0clZhbHVlID09PSAneWVzJztcbiAgICBpZiAoIWV2ZW50c0VuYWJsZWQgfHwgIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGx4ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgdmFyIGx5ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIHRoZXRhID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHZhciBveCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgb3kgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGx4MSA9IGJiLngxIC0gdGggLSBveDsgLy8gKC1veCwgLW95KSBhcyBiYiBhbHJlYWR5IGluY2x1ZGVzIG1hcmdpblxuICAgIHZhciBseDIgPSBiYi54MiArIHRoIC0gb3g7IC8vIGFuZCByb3RhdGlvbiBpcyBhYm91dCAobHgsIGx5KVxuICAgIHZhciBseTEgPSBiYi55MSAtIHRoIC0gb3k7XG4gICAgdmFyIGx5MiA9IGJiLnkyICsgdGggLSBveTtcbiAgICBpZiAodGhldGEpIHtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgIHkgPSB5IC0gbHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAvLyB3aXRoIHRoZSBtYXJnaW4gYWRkZWQgYWZ0ZXIgdGhlIHJvdGF0aW9uIGlzIGFwcGxpZWRcbiAgICAgIHB4MXkxLnggKyBveCwgcHgxeTEueSArIG95LCBweDJ5MS54ICsgb3gsIHB4MnkxLnkgKyBveSwgcHgyeTIueCArIG94LCBweDJ5Mi55ICsgb3ksIHB4MXkyLnggKyBveCwgcHgxeTIueSArIG95XTtcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvIGEgY2hlYXBlciBiYiBjaGVja1xuICAgICAgaWYgKGluQm91bmRpbmdCb3goYmIsIHgsIHkpKSB7XG4gICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IGVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgY2hlY2tOb2RlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGVkZ2VcbiAgICAgIGNoZWNrRWRnZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3NvdXJjZScpIHx8IGNoZWNrTGFiZWwoZWxlLCAndGFyZ2V0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWFyO1xufTtcblxuLy8gJ0dpdmUgbWUgZXZlcnl0aGluZyBmcm9tIHRoaXMgYm94J1xuQlJwJGUuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuaW50ZXJhY3RpdmU7XG4gIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG4gIHZhciBsYWJlbFRocmVzaG9sZCA9IDIgLyB6b29tO1xuICB2YXIgYm94ID0gW107XG4gIHZhciB4MWMgPSBNYXRoLm1pbih4MSwgeDIpO1xuICB2YXIgeDJjID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgdmFyIHkxYyA9IE1hdGgubWluKHkxLCB5Mik7XG4gIHZhciB5MmMgPSBNYXRoLm1heCh5MSwgeTIpO1xuICB4MSA9IHgxYztcbiAgeDIgPSB4MmM7XG4gIHkxID0geTFjO1xuICB5MiA9IHkyYztcbiAgdmFyIGJveEJiID0gbWFrZUJvdW5kaW5nQm94KHtcbiAgICB4MTogeDEsXG4gICAgeTE6IHkxLFxuICAgIHgyOiB4MixcbiAgICB5MjogeTJcbiAgfSk7XG4gIHZhciBzZWxlY3Rpb25Cb3ggPSBbe1xuICAgIHg6IGJveEJiLngxLFxuICAgIHk6IGJveEJiLnkxXG4gIH0sIHtcbiAgICB4OiBib3hCYi54MixcbiAgICB5OiBib3hCYi55MVxuICB9LCB7XG4gICAgeDogYm94QmIueDIsXG4gICAgeTogYm94QmIueTJcbiAgfSwge1xuICAgIHg6IGJveEJiLngxLFxuICAgIHk6IGJveEJiLnkyXG4gIH1dO1xuICB2YXIgYm94RWRnZXMgPSBbW3NlbGVjdGlvbkJveFswXSwgc2VsZWN0aW9uQm94WzFdXSwgW3NlbGVjdGlvbkJveFsxXSwgc2VsZWN0aW9uQm94WzJdXSwgW3NlbGVjdGlvbkJveFsyXSwgc2VsZWN0aW9uQm94WzNdXSwgW3NlbGVjdGlvbkJveFszXSwgc2VsZWN0aW9uQm94WzBdXV07XG4gIGZ1bmN0aW9uIHByZXByb3Aob2JqLCBuYW1lLCBwcmUpIHtcbiAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIG5hbWUsIHByZSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um90YXRlZExhYmVsQm94KGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciB0aCA9IGxhYmVsVGhyZXNob2xkO1xuICAgIHZhciBwcmVmaXhEYXNoID0gJyc7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIGJiID0gX3AubGFiZWxCb3VuZHNbJ21haW4nXTtcblxuICAgIC8vIElmIHRoZSBib3VuZGluZyBib3ggaXMgbm90IGF2YWlsYWJsZSwgcmV0dXJuIG51bGwuXG4gICAgLy8gVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgbGFiZWwgYm94IGNhbm5vdCBiZSBjYWxjdWxhdGVkLCB3aGljaCBpcyBjb25zaXN0ZW50XG4gICAgLy8gd2l0aCB0aGUgZXhwZWN0ZWQgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbi4gUmV0dXJuaW5nIG51bGwgYWxsb3dzIHRoZSBjYWxsZXJcbiAgICAvLyB0byBoYW5kbGUgdGhlIGFic2VuY2Ugb2YgYSBib3VuZGluZyBib3ggZXhwbGljaXRseS5cbiAgICBpZiAoIWJiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGx4ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgdmFyIGx5ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIHRoZXRhID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHZhciBveCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgb3kgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGx4MSA9IGJiLngxIC0gdGggLSBveDtcbiAgICB2YXIgbHgyID0gYmIueDIgKyB0aCAtIG94O1xuICAgIHZhciBseTEgPSBiYi55MSAtIHRoIC0gb3k7XG4gICAgdmFyIGx5MiA9IGJiLnkyICsgdGggLSBveTtcbiAgICBpZiAodGhldGEpIHtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgIHkgPSB5IC0gbHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFtyb3RhdGUobHgxLCBseTEpLCByb3RhdGUobHgyLCBseTEpLCByb3RhdGUobHgyLCBseTIpLCByb3RhdGUobHgxLCBseTIpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHg6IGx4MSxcbiAgICAgICAgeTogbHkxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IGx4MixcbiAgICAgICAgeTogbHkxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IGx4MixcbiAgICAgICAgeTogbHkyXG4gICAgICB9LCB7XG4gICAgICAgIHg6IGx4MSxcbiAgICAgICAgeTogbHkyXG4gICAgICB9XTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZG9MaW5lc0ludGVyc2VjdChwMSwgcDIsIHExLCBxMikge1xuICAgIGZ1bmN0aW9uIGNjdyhhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gKGMueSAtIGEueSkgKiAoYi54IC0gYS54KSA+IChiLnkgLSBhLnkpICogKGMueCAtIGEueCk7XG4gICAgfVxuICAgIHJldHVybiBjY3cocDEsIHExLCBxMikgIT09IGNjdyhwMiwgcTEsIHEyKSAmJiBjY3cocDEsIHAyLCBxMSkgIT09IGNjdyhwMSwgcDIsIHEyKTtcbiAgfVxuICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgbm9kZSA9IGVsZTtcbiAgICAgIHZhciB0ZXh0RXZlbnRzID0gbm9kZS5wc3R5bGUoJ3RleHQtZXZlbnRzJykuc3RyVmFsdWUgPT09ICd5ZXMnO1xuICAgICAgdmFyIG5vZGVCb3hTZWxlY3RNb2RlID0gbm9kZS5wc3R5bGUoJ2JveC1zZWxlY3Rpb24nKS5zdHJWYWx1ZTtcbiAgICAgIHZhciBsYWJlbEJveFNlbGVjdEVuYWJsZWQgPSBub2RlLnBzdHlsZSgnYm94LXNlbGVjdC1sYWJlbHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG4gICAgICBpZiAobm9kZUJveFNlbGVjdE1vZGUgPT09ICdub25lJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gKG5vZGVCb3hTZWxlY3RNb2RlID09PSAnb3ZlcmxhcCcgfHwgbGFiZWxCb3hTZWxlY3RFbmFibGVkKSAmJiB0ZXh0RXZlbnRzO1xuICAgICAgdmFyIG5vZGVCYiA9IG5vZGUuYm91bmRpbmdCb3goe1xuICAgICAgICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVFZGdlczogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHNcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vZGVCb3hTZWxlY3RNb2RlID09PSAnY29udGFpbicpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChsYWJlbEJveFNlbGVjdEVuYWJsZWQgJiYgdGV4dEV2ZW50cykge1xuICAgICAgICAgIHZhciByb3RhdGVkTGFiZWxCb3ggPSBnZXRSb3RhdGVkTGFiZWxCb3gobm9kZSk7XG4gICAgICAgICAgaWYgKHJvdGF0ZWRMYWJlbEJveCAmJiBzYXRQb2x5Z29uSW50ZXJzZWN0aW9uKHJvdGF0ZWRMYWJlbEJveCwgc2VsZWN0aW9uQm94KSkge1xuICAgICAgICAgICAgYm94LnB1c2gobm9kZSk7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZWN0ZWQgJiYgYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGJveEJiLCBub2RlQmIpKSB7XG4gICAgICAgICAgYm94LnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZUJveFNlbGVjdE1vZGUgPT09ICdvdmVybGFwJykge1xuICAgICAgICBpZiAoYm91bmRpbmdCb3hlc0ludGVyc2VjdChib3hCYiwgbm9kZUJiKSkge1xuICAgICAgICAgIHZhciBub2RlQm9keUJiID0gbm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICAgICAgICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlRWRnZXM6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGluY2x1ZGVNYWluTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGluY2x1ZGVTb3VyY2VMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgaW5jbHVkZVRhcmdldExhYmVsczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbm9kZUJvZHlDb3JuZXJzID0gW3tcbiAgICAgICAgICAgIHg6IG5vZGVCb2R5QmIueDEsXG4gICAgICAgICAgICB5OiBub2RlQm9keUJiLnkxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogbm9kZUJvZHlCYi54MixcbiAgICAgICAgICAgIHk6IG5vZGVCb2R5QmIueTFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBub2RlQm9keUJiLngyLFxuICAgICAgICAgICAgeTogbm9kZUJvZHlCYi55MlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IG5vZGVCb2R5QmIueDEsXG4gICAgICAgICAgICB5OiBub2RlQm9keUJiLnkyXG4gICAgICAgICAgfV07XG5cbiAgICAgICAgICAvLyBpZiBub2RlIGJvZHkgaW50ZXJzZWN0cywgbm8gbmVlZCB0byBjaGVjayBsYWJlbFxuICAgICAgICAgIGlmIChzYXRQb2x5Z29uSW50ZXJzZWN0aW9uKG5vZGVCb2R5Q29ybmVycywgc2VsZWN0aW9uQm94KSkge1xuICAgICAgICAgICAgYm94LnB1c2gobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgbGFiZWwgaWYgbm9kZSBib2R5IGRpZG4ndCBpbnRlcnNlY3RcbiAgICAgICAgICAgIHZhciBfcm90YXRlZExhYmVsQm94ID0gZ2V0Um90YXRlZExhYmVsQm94KG5vZGUpO1xuICAgICAgICAgICAgaWYgKF9yb3RhdGVkTGFiZWxCb3ggJiYgc2F0UG9seWdvbkludGVyc2VjdGlvbihfcm90YXRlZExhYmVsQm94LCBzZWxlY3Rpb25Cb3gpKSB7XG4gICAgICAgICAgICAgIGJveC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWRnZSA9IGVsZTtcbiAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICAgIHZhciBlZGdlQm94U2VsZWN0TW9kZSA9IGVkZ2UucHN0eWxlKCdib3gtc2VsZWN0aW9uJykuc3RyVmFsdWU7XG4gICAgICBpZiAoZWRnZUJveFNlbGVjdE1vZGUgPT09ICdub25lJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGdlQm94U2VsZWN0TW9kZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIGlmIChycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJzLmVuZFggIT0gbnVsbCAmJiBycy5lbmRZICE9IG51bGwgJiYgIWluQm91bmRpbmdCb3goYm94QmIsIHJzLmVuZFgsIHJzLmVuZFkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgdmFyIHB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgfHwgX3AucnN0eWxlLmxpbmVQdHMgfHwgX3AucnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgICAgIHZhciBhbGxJbnNpZGUgPSB0cnVlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXBvaW50SW5Cb3VuZGluZ0JveChib3hCYiwgcHRzW2ldKSkge1xuICAgICAgICAgICAgICBhbGxJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhbGxJbnNpZGUpIHtcbiAgICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVkZ2VCb3hTZWxlY3RNb2RlID09PSAnb3ZlcmxhcCcpIHtcbiAgICAgICAgdmFyIF9zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENoZWNrOiBlaXRoZXIgZW5kcG9pbnQgaW5zaWRlIGJveFxuICAgICAgICBpZiAocnMuc3RhcnRYICE9IG51bGwgJiYgcnMuc3RhcnRZICE9IG51bGwgJiYgcnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAoaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkpIHx8IGluQm91bmRpbmdCb3goYm94QmIsIHJzLmVuZFgsIHJzLmVuZFkpKSkge1xuICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICAgIF9zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYXlzdGFjayBmYWxsYmFjayAob25seSBjaGVjayBpZiBub3QgYWxyZWFkeSBzZWxlY3RlZClcbiAgICAgICAgZWxzZSBpZiAoIV9zZWxlY3RlZCAmJiBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICAgIHZhciBoYXlzdGFja1B0cyA9IF9wLnJzdHlsZS5oYXlzdGFja1B0cztcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaGF5c3RhY2tQdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9pbnRJbkJvdW5kaW5nQm94KGJveEJiLCBoYXlzdGFja1B0c1tfaV0pKSB7XG4gICAgICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgICBfc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWdtZW50IGludGVyc2VjdGlvbiBjaGVjayAob25seSBpZiBub3QgYWxyZWFkeSBzZWxlY3RlZClcbiAgICAgICAgaWYgKCFfc2VsZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgX3B0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgfHwgX3AucnN0eWxlLmxpbmVQdHMgfHwgX3AucnN0eWxlLmhheXN0YWNrUHRzO1xuXG4gICAgICAgICAgLy8gc3RyYWlnaHQgZWRnZXNcbiAgICAgICAgICBpZiAoKCFfcHRzIHx8IF9wdHMubGVuZ3RoIDwgMikgJiYgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgICAgIGlmIChycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiBycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9wdHMgPSBbe1xuICAgICAgICAgICAgICAgIHg6IHJzLnN0YXJ0WCxcbiAgICAgICAgICAgICAgICB5OiBycy5zdGFydFlcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IHJzLmVuZFgsXG4gICAgICAgICAgICAgICAgeTogcnMuZW5kWVxuICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfcHRzIHx8IF9wdHMubGVuZ3RoIDwgMikgY29udGludWU7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX3B0cy5sZW5ndGggLSAxOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIHNlZ1N0YXJ0ID0gX3B0c1tfaTJdO1xuICAgICAgICAgICAgdmFyIHNlZ0VuZCA9IF9wdHNbX2kyICsgMV07XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJveEVkZ2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgIHZhciBfYm94RWRnZXMkYiA9IF9zbGljZWRUb0FycmF5KGJveEVkZ2VzW2JdLCAyKSxcbiAgICAgICAgICAgICAgICBib3hTdGFydCA9IF9ib3hFZGdlcyRiWzBdLFxuICAgICAgICAgICAgICAgIGJveEVuZCA9IF9ib3hFZGdlcyRiWzFdO1xuICAgICAgICAgICAgICBpZiAoZG9MaW5lc0ludGVyc2VjdChzZWdTdGFydCwgc2VnRW5kLCBib3hTdGFydCwgYm94RW5kKSkge1xuICAgICAgICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgICAgIF9zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfc2VsZWN0ZWQpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYm94O1xufTtcblxudmFyIEJScCRkID0ge307XG5CUnAkZC5jYWxjdWxhdGVBcnJvd0FuZ2xlcyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gIHZhciBpc0JlemllciA9IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJztcbiAgdmFyIGlzTXVsdGliZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJztcbiAgdmFyIGlzU2VnbWVudHMgPSBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGlzQ29tcG91bmQgPSBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGlzU2VsZiA9IHJzLmVkZ2VUeXBlID09PSAnc2VsZic7XG5cbiAgLy8gRGlzcGxhY2VtZW50IGdpdmVzIGRpcmVjdGlvbiBmb3IgYXJyb3doZWFkIG9yaWVudGF0aW9uXG4gIHZhciBkaXNwWCwgZGlzcFk7XG4gIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgbWlkWCwgbWlkWTtcbiAgaWYgKGlzSGF5c3RhY2spIHtcbiAgICBzdGFydFggPSBycy5oYXlzdGFja1B0c1swXTtcbiAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgZW5kWSA9IHJzLmhheXN0YWNrUHRzWzNdO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHN0YXJ0WSA9IHJzLmFycm93U3RhcnRZO1xuICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgfVxuICBtaWRYID0gcnMubWlkWDtcbiAgbWlkWSA9IHJzLm1pZFk7XG5cbiAgLy8gc291cmNlXG4gIC8vXG5cbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIHJzLnNlZ3B0c1swXTtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIHJzLnNlZ3B0c1sxXTtcbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4xKTtcbiAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4xKTtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIGJYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBzdGFydFggLSBtaWRYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gbWlkWTtcbiAgfVxuICBycy5zcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuXG4gIC8vIG1pZCB0YXJnZXRcbiAgLy9cblxuICB2YXIgbWlkWCA9IHJzLm1pZFg7XG4gIHZhciBtaWRZID0gcnMubWlkWTtcbiAgaWYgKGlzSGF5c3RhY2spIHtcbiAgICBtaWRYID0gKHN0YXJ0WCArIGVuZFgpIC8gMjtcbiAgICBtaWRZID0gKHN0YXJ0WSArIGVuZFkpIC8gMjtcbiAgfVxuICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIGlmIChwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgZGlzcFggPSBwdHNbaTJdIC0gcHRzW2kxXTtcbiAgICAgIGRpc3BZID0gcHRzW2kyICsgMV0gLSBwdHNbaTEgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHJzLmlzUm91bmQpIHtcbiAgICAgIGRpc3BYID0gcnMubWlkVmVjdG9yWzFdO1xuICAgICAgZGlzcFkgPSAtcnMubWlkVmVjdG9yWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgdmFyIGJwMXgsIGJwMXk7XG4gICAgaWYgKGNwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgIHZhciBwMCA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gc3RhcnRwdFxuICAgICAgdmFyIGljID0gcDAgKyAyO1xuICAgICAgdmFyIHAxID0gaWMgKyAyO1xuICAgICAgYnAweCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjApO1xuICAgICAgYnAweSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjApO1xuICAgICAgYnAxeCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjAwMDEpO1xuICAgICAgYnAxeSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjAwMDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWMgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIGN0cnB0XG4gICAgICB2YXIgcDAgPSBpYyAtIDI7IC8vIHN0YXJ0cHRcbiAgICAgIHZhciBwMSA9IGljICsgMjsgLy8gZW5kcHRcblxuICAgICAgYnAweCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjQ5OTkpO1xuICAgICAgYnAweSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjQ5OTkpO1xuICAgICAgYnAxeCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjUpO1xuICAgICAgYnAxeSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjUpO1xuICAgIH1cbiAgICBkaXNwWCA9IGJwMXggLSBicDB4O1xuICAgIGRpc3BZID0gYnAxeSAtIGJwMHk7XG4gIH1cbiAgcnMubWlkdGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbiAgcnMubWlkRGlzcFggPSBkaXNwWDtcbiAgcnMubWlkRGlzcFkgPSBkaXNwWTtcblxuICAvLyBtaWQgc291cmNlXG4gIC8vXG5cbiAgZGlzcFggKj0gLTE7XG4gIGRpc3BZICo9IC0xO1xuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkgOyBlbHNlIGlmICghcnMuaXNSb3VuZCkge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdmFyIGkzID0gaTIgKyAyO1xuICAgICAgZGlzcFggPSAtKHB0c1tpM10gLSBwdHNbaTJdKTtcbiAgICAgIGRpc3BZID0gLShwdHNbaTMgKyAxXSAtIHB0c1tpMiArIDFdKTtcbiAgICB9XG4gIH1cbiAgcnMubWlkc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcblxuICAvLyB0YXJnZXRcbiAgLy9cblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIGRpc3BYID0gZW5kWCAtIHJzLnNlZ3B0c1tycy5zZWdwdHMubGVuZ3RoIC0gMl07XG4gICAgZGlzcFkgPSBlbmRZIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgbCA9IHB0cy5sZW5ndGg7XG4gICAgdmFyIGJYID0gcWJlemllckF0KHB0c1tsIC0gNl0sIHB0c1tsIC0gNF0sIHB0c1tsIC0gMl0sIDAuOSk7XG4gICAgdmFyIGJZID0gcWJlemllckF0KHB0c1tsIC0gNV0sIHB0c1tsIC0gM10sIHB0c1tsIC0gMV0sIDAuOSk7XG4gICAgZGlzcFggPSBlbmRYIC0gYlg7XG4gICAgZGlzcFkgPSBlbmRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBlbmRYIC0gbWlkWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBtaWRZO1xuICB9XG4gIHJzLnRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG59O1xuQlJwJGQuZ2V0QXJyb3dXaWR0aCA9IEJScCRkLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24gKGVkZ2VXaWR0aCwgc2NhbGUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV07XG4gIGlmIChjYWNoZWRWYWwpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG4gIGNhY2hlZFZhbCA9IE1hdGgubWF4KE1hdGgucG93KGVkZ2VXaWR0aCAqIDEzLjM3LCAwLjkpLCAyOSkgKiBzY2FsZTtcbiAgY2FjaGVbZWRnZVdpZHRoICsgJywgJyArIHNjYWxlXSA9IGNhY2hlZFZhbDtcbiAgcmV0dXJuIGNhY2hlZFZhbDtcbn07XG5cbi8qKlxuICogRXhwbGFpbmVkIGJ5IEJsaW5kbWFuNjcgYXQgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ0ODU2OTI1LzExMDI4ODI4XG4gKi9cblxuLy8gRGVjbGFyZSByZXVzZWQgdmFyaWFibGUgdG8gYXZvaWQgcmVhbGxvY2F0aW5nIHZhcmlhYmxlcyBldmVyeSB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWRcbnZhciB4LFxuICB5LFxuICB2MSA9IHt9LFxuICB2MiA9IHt9LFxuICBzaW5BLFxuICBzaW5BOTAsXG4gIHJhZERpcmVjdGlvbixcbiAgZHJhd0RpcmVjdGlvbixcbiAgYW5nbGUsXG4gIGhhbGZBbmdsZSxcbiAgY1JhZGl1cyxcbiAgbGVuT3V0LFxuICByYWRpdXMsXG4gIGxpbWl0O1xudmFyIHN0YXJ0WCwgc3RhcnRZLCBzdG9wWCwgc3RvcFk7XG52YXIgbGFzdFBvaW50O1xuXG4vLyBjb252ZXJ0IDIgcG9pbnRzIGludG8gdmVjdG9yIGZvcm0sIHBvbGFyIGZvcm0sIGFuZCBub3JtYWxpc2VkXG52YXIgYXNWZWMgPSBmdW5jdGlvbiBhc1ZlYyhwLCBwcCwgdikge1xuICB2LnggPSBwcC54IC0gcC54O1xuICB2LnkgPSBwcC55IC0gcC55O1xuICB2LmxlbiA9IE1hdGguc3FydCh2LnggKiB2LnggKyB2LnkgKiB2LnkpO1xuICB2Lm54ID0gdi54IC8gdi5sZW47XG4gIHYubnkgPSB2LnkgLyB2LmxlbjtcbiAgdi5hbmcgPSBNYXRoLmF0YW4yKHYubnksIHYubngpO1xufTtcbnZhciBpbnZlcnRWZWMgPSBmdW5jdGlvbiBpbnZlcnRWZWMob3JpZ2luYWxWLCBpbnZlcnRlZFYpIHtcbiAgaW52ZXJ0ZWRWLnggPSBvcmlnaW5hbFYueCAqIC0xO1xuICBpbnZlcnRlZFYueSA9IG9yaWdpbmFsVi55ICogLTE7XG4gIGludmVydGVkVi5ueCA9IG9yaWdpbmFsVi5ueCAqIC0xO1xuICBpbnZlcnRlZFYubnkgPSBvcmlnaW5hbFYubnkgKiAtMTtcbiAgaW52ZXJ0ZWRWLmFuZyA9IG9yaWdpbmFsVi5hbmcgPiAwID8gLShNYXRoLlBJIC0gb3JpZ2luYWxWLmFuZykgOiBNYXRoLlBJICsgb3JpZ2luYWxWLmFuZztcbn07XG52YXIgY2FsY0Nvcm5lckFyYyA9IGZ1bmN0aW9uIGNhbGNDb3JuZXJBcmMocHJldmlvdXNQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQsIHJhZGl1c01heCwgaXNBcmNSYWRpdXMpIHtcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQYXJ0IDFcbiAgcHJldmlvdXNQb2ludCAhPT0gbGFzdFBvaW50ID8gYXNWZWMoY3VycmVudFBvaW50LCBwcmV2aW91c1BvaW50LCB2MSkgOiBpbnZlcnRWZWModjIsIHYxKTsgLy8gQXZvaWQgcmVjYWxjdWxhdGluZyB2ZWMgaWYgaXQgaXMgdGhlIGludmVydCBvZiB0aGUgbGFzdCBvbmUgY2FsY3VsYXRlZFxuICBhc1ZlYyhjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgdjIpO1xuICBzaW5BID0gdjEubnggKiB2Mi5ueSAtIHYxLm55ICogdjIubng7XG4gIHNpbkE5MCA9IHYxLm54ICogdjIubnggLSB2MS5ueSAqIC12Mi5ueTtcbiAgYW5nbGUgPSBNYXRoLmFzaW4oTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIHNpbkEpKSk7XG4gIGlmIChNYXRoLmFicyhhbmdsZSkgPCAxZS02KSB7XG4gICAgeCA9IGN1cnJlbnRQb2ludC54O1xuICAgIHkgPSBjdXJyZW50UG9pbnQueTtcbiAgICBjUmFkaXVzID0gcmFkaXVzID0gMDtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByYWREaXJlY3Rpb24gPSAxO1xuICBkcmF3RGlyZWN0aW9uID0gZmFsc2U7XG4gIGlmIChzaW5BOTAgPCAwKSB7XG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgYW5nbGUgPSBNYXRoLlBJICsgYW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gTWF0aC5QSSAtIGFuZ2xlO1xuICAgICAgcmFkRGlyZWN0aW9uID0gLTE7XG4gICAgICBkcmF3RGlyZWN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFuZ2xlID4gMCkge1xuICAgICAgcmFkRGlyZWN0aW9uID0gLTE7XG4gICAgICBkcmF3RGlyZWN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnRQb2ludC5yYWRpdXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJhZGl1cyA9IGN1cnJlbnRQb2ludC5yYWRpdXM7XG4gIH0gZWxzZSB7XG4gICAgcmFkaXVzID0gcmFkaXVzTWF4O1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUGFydCAyXG4gIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMjtcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGxpbWl0ID0gTWF0aC5taW4odjEubGVuIC8gMiwgdjIubGVuIC8gMik7XG4gIGlmIChpc0FyY1JhZGl1cykge1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQYXJ0IDNcbiAgICBsZW5PdXQgPSBNYXRoLmFicyhNYXRoLmNvcyhoYWxmQW5nbGUpICogcmFkaXVzIC8gTWF0aC5zaW4oaGFsZkFuZ2xlKSk7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3BlY2lhbCBwYXJ0IEFcbiAgICBpZiAobGVuT3V0ID4gbGltaXQpIHtcbiAgICAgIGxlbk91dCA9IGxpbWl0O1xuICAgICAgY1JhZGl1cyA9IE1hdGguYWJzKGxlbk91dCAqIE1hdGguc2luKGhhbGZBbmdsZSkgLyBNYXRoLmNvcyhoYWxmQW5nbGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1JhZGl1cyA9IHJhZGl1cztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuT3V0ID0gTWF0aC5taW4obGltaXQsIHJhZGl1cyk7XG4gICAgY1JhZGl1cyA9IE1hdGguYWJzKGxlbk91dCAqIE1hdGguc2luKGhhbGZBbmdsZSkgLyBNYXRoLmNvcyhoYWxmQW5nbGUpKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQYXJ0IDRcbiAgc3RvcFggPSBjdXJyZW50UG9pbnQueCArIHYyLm54ICogbGVuT3V0O1xuICBzdG9wWSA9IGN1cnJlbnRQb2ludC55ICsgdjIubnkgKiBsZW5PdXQ7XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUGFydCA1XG4gIHggPSBzdG9wWCAtIHYyLm55ICogY1JhZGl1cyAqIHJhZERpcmVjdGlvbjtcbiAgeSA9IHN0b3BZICsgdjIubnggKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFkZGl0aW9uYWwgUGFydCA6IGNhbGN1bGF0ZSBzdGFydCBwb2ludCBFXG4gIHN0YXJ0WCA9IGN1cnJlbnRQb2ludC54ICsgdjEubnggKiBsZW5PdXQ7XG4gIHN0YXJ0WSA9IGN1cnJlbnRQb2ludC55ICsgdjEubnkgKiBsZW5PdXQ7XG5cbiAgLy8gU2F2ZSBsYXN0IHBvaW50IHRvIGF2b2lkIHJlY2FsY3VsYXRpbmcgdmVjdG9yIHdoZW4gbm90IG5lZWRlZFxuICBsYXN0UG9pbnQgPSBjdXJyZW50UG9pbnQ7XG59O1xuXG4vKipcbiAqIERyYXcgY29ybmVyIHByb3ZpZGVkIGJ5IHtAbGluayBnZXRSb3VuZENvcm5lcn1cbiAqXG4gKiBAcGFyYW0gY3R4IDpDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAqIEBwYXJhbSByb3VuZENvcm5lciB7e2N4Om51bWJlciwgY3k6bnVtYmVyLCByYWRpdXM6bnVtYmVyLCBlbmRBbmdsZTogbnVtYmVyLCBzdGFydEFuZ2xlOiBudW1iZXIsIGNvdW50ZXJDbG9ja3dpc2U6IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBkcmF3UHJlcGFyZWRSb3VuZENvcm5lcihjdHgsIHJvdW5kQ29ybmVyKSB7XG4gIGlmIChyb3VuZENvcm5lci5yYWRpdXMgPT09IDApIGN0eC5saW5lVG8ocm91bmRDb3JuZXIuY3gsIHJvdW5kQ29ybmVyLmN5KTtlbHNlIGN0eC5hcmMocm91bmRDb3JuZXIuY3gsIHJvdW5kQ29ybmVyLmN5LCByb3VuZENvcm5lci5yYWRpdXMsIHJvdW5kQ29ybmVyLnN0YXJ0QW5nbGUsIHJvdW5kQ29ybmVyLmVuZEFuZ2xlLCByb3VuZENvcm5lci5jb3VudGVyQ2xvY2t3aXNlKTtcbn1cblxuLyoqXG4gKiBHZXQgcm91bmQgY29ybmVyIGZyb20gYSBwb2ludCBhbmQgaXRzIHByZXZpb3VzIGFuZCBuZXh0IG5laWdoYm91cnMgaW4gYSBwYXRoXG4gKlxuICogQHBhcmFtIHByZXZpb3VzUG9pbnQge3t4OiBudW1iZXIsIHk6bnVtYmVyLCByYWRpdXM6IG51bWJlcj99fVxuICogQHBhcmFtIGN1cnJlbnRQb2ludCB7e3g6IG51bWJlciwgeTpudW1iZXIsIHJhZGl1czogbnVtYmVyP319XG4gKiBAcGFyYW0gbmV4dFBvaW50IHt7eDogbnVtYmVyLCB5Om51bWJlciwgcmFkaXVzOiBudW1iZXI/fX1cbiAqIEBwYXJhbSByYWRpdXNNYXggOm51bWJlclxuICogQHBhcmFtIGlzQXJjUmFkaXVzIDpib29sZWFuXG4gKiBAcmV0dXJuIHt7XG4gKiBjeDpudW1iZXIsIGN5Om51bWJlciwgcmFkaXVzOm51bWJlcixcbiAqIHN0YXJ0WDpudW1iZXIsIHN0YXJ0WTpudW1iZXIsXG4gKiBzdG9wWDpudW1iZXIsIHN0b3BZOiBudW1iZXIsXG4gKiBlbmRBbmdsZTogbnVtYmVyLCBzdGFydEFuZ2xlOiBudW1iZXIsIGNvdW50ZXJDbG9ja3dpc2U6IGJvb2xlYW5cbiAqIH19XG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kQ29ybmVyKHByZXZpb3VzUG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCByYWRpdXNNYXgpIHtcbiAgdmFyIGlzQXJjUmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICBpZiAocmFkaXVzTWF4ID09PSAwIHx8IGN1cnJlbnRQb2ludC5yYWRpdXMgPT09IDApIHJldHVybiB7XG4gICAgY3g6IGN1cnJlbnRQb2ludC54LFxuICAgIGN5OiBjdXJyZW50UG9pbnQueSxcbiAgICByYWRpdXM6IDAsXG4gICAgc3RhcnRYOiBjdXJyZW50UG9pbnQueCxcbiAgICBzdGFydFk6IGN1cnJlbnRQb2ludC55LFxuICAgIHN0b3BYOiBjdXJyZW50UG9pbnQueCxcbiAgICBzdG9wWTogY3VycmVudFBvaW50LnksXG4gICAgc3RhcnRBbmdsZTogdW5kZWZpbmVkLFxuICAgIGVuZEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgY291bnRlckNsb2Nrd2lzZTogdW5kZWZpbmVkXG4gIH07XG4gIGNhbGNDb3JuZXJBcmMocHJldmlvdXNQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQsIHJhZGl1c01heCwgaXNBcmNSYWRpdXMpO1xuICByZXR1cm4ge1xuICAgIGN4OiB4LFxuICAgIGN5OiB5LFxuICAgIHJhZGl1czogY1JhZGl1cyxcbiAgICBzdGFydFg6IHN0YXJ0WCxcbiAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICBzdG9wWDogc3RvcFgsXG4gICAgc3RvcFk6IHN0b3BZLFxuICAgIHN0YXJ0QW5nbGU6IHYxLmFuZyArIE1hdGguUEkgLyAyICogcmFkRGlyZWN0aW9uLFxuICAgIGVuZEFuZ2xlOiB2Mi5hbmcgLSBNYXRoLlBJIC8gMiAqIHJhZERpcmVjdGlvbixcbiAgICBjb3VudGVyQ2xvY2t3aXNlOiBkcmF3RGlyZWN0aW9uXG4gIH07XG59XG5cbnZhciBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCA9IDAuMDE7XG52YXIgQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlRfTCA9IE1hdGguc3FydCgyICogQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlQpO1xudmFyIEJScCRjID0ge307XG5CUnAkYy5maW5kTWlkcHRQdHNFdGMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMsXG4gICAgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZTtcbiAgdmFyIG1pZHB0UHRzO1xuXG4gIC8vIG4uYi4gYXNzdW1lcyBhbGwgZWRnZXMgaW4gYmV6aWVyIGJ1bmRsZSBoYXZlIHNhbWUgZW5kcG9pbnRzIHNwZWNpZmllZFxuICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcbiAgdmFyIGhhdmVNYW51YWxFbmRQdHMgPSBzcmNNYW5FbmRwdC51bml0cyAhPSBudWxsICYmIHRndE1hbkVuZHB0LnVuaXRzICE9IG51bGw7XG4gIHZhciByZWNhbGNWZWN0b3JOb3JtSW52ZXJzZSA9IGZ1bmN0aW9uIHJlY2FsY1ZlY3Rvck5vcm1JbnZlcnNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLWR5IC8gbCxcbiAgICAgIHk6IGR4IC8gbFxuICAgIH07XG4gIH07XG4gIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gIHN3aXRjaCAoZWRnZURpc3RhbmNlcykge1xuICAgIGNhc2UgJ25vZGUtcG9zaXRpb24nOlxuICAgICAgbWlkcHRQdHMgPSBwb3NQdHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnRlcnNlY3Rpb24nOlxuICAgICAgbWlkcHRQdHMgPSBpbnRlcnNlY3Rpb25QdHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmRwb2ludHMnOlxuICAgICAge1xuICAgICAgICBpZiAoaGF2ZU1hbnVhbEVuZFB0cykge1xuICAgICAgICAgIHZhciBfdGhpcyRtYW51YWxFbmRwdFRvUHggPSB0aGlzLm1hbnVhbEVuZHB0VG9QeChlZGdlLnNvdXJjZSgpWzBdLCBzcmNNYW5FbmRwdCksXG4gICAgICAgICAgICBfdGhpcyRtYW51YWxFbmRwdFRvUHgyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkbWFudWFsRW5kcHRUb1B4LCAyKSxcbiAgICAgICAgICAgIHgxID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4MlswXSxcbiAgICAgICAgICAgIHkxID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4MlsxXTtcbiAgICAgICAgICB2YXIgX3RoaXMkbWFudWFsRW5kcHRUb1B4MyA9IHRoaXMubWFudWFsRW5kcHRUb1B4KGVkZ2UudGFyZ2V0KClbMF0sIHRndE1hbkVuZHB0KSxcbiAgICAgICAgICAgIF90aGlzJG1hbnVhbEVuZHB0VG9QeDQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRtYW51YWxFbmRwdFRvUHgzLCAyKSxcbiAgICAgICAgICAgIHgyID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4NFswXSxcbiAgICAgICAgICAgIHkyID0gX3RoaXMkbWFudWFsRW5kcHRUb1B4NFsxXTtcbiAgICAgICAgICB2YXIgZW5kUHRzID0ge1xuICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHJlY2FsY1ZlY3Rvck5vcm1JbnZlcnNlKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICBtaWRwdFB0cyA9IGVuZFB0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFwiRWRnZSBcIi5jb25jYXQoZWRnZS5pZCgpLCBcIiBoYXMgZWRnZS1kaXN0YW5jZXM6ZW5kcG9pbnRzIHNwZWNpZmllZCB3aXRob3V0IG1hbnVhbCBlbmRwb2ludHMgc3BlY2lmaWVkIHZpYSBzb3VyY2UtZW5kcG9pbnQgYW5kIHRhcmdldC1lbmRwb2ludC4gIEZhbGxpbmcgYmFjayBvbiBlZGdlLWRpc3RhbmNlczppbnRlcnNlY3Rpb24gKGRlZmF1bHQpLlwiKSk7XG4gICAgICAgICAgbWlkcHRQdHMgPSBpbnRlcnNlY3Rpb25QdHM7IC8vIGJhY2sgdG8gZGVmYXVsdFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWlkcHRQdHM6IG1pZHB0UHRzLFxuICAgIHZlY3Rvck5vcm1JbnZlcnNlOiB2ZWN0b3JOb3JtSW52ZXJzZVxuICB9O1xufTtcbkJScCRjLmZpbmRIYXlzdGFja1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIGlmICghcnMuaGF5c3RhY2spIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgIHJzLnNvdXJjZSA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgIH07XG4gICAgICBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgIHJzLnRhcmdldCA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3JjUG9zID0gc3JjLnBvc2l0aW9uKCk7XG4gICAgdmFyIHRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcbiAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoJ2hheXN0YWNrLXJhZGl1cycpLnZhbHVlO1xuICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzIC8gMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgIHJzLmhheXN0YWNrUHRzID0gcnMuYWxscHRzID0gW3JzLnNvdXJjZS54ICogc3JjVyAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueCwgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cyArIHNyY1Bvcy55LCBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsIHJzLnRhcmdldC55ICogdGd0SCAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueV07XG4gICAgcnMubWlkWCA9IChycy5hbGxwdHNbMF0gKyBycy5hbGxwdHNbMl0pIC8gMjtcbiAgICBycy5taWRZID0gKHJzLmFsbHB0c1sxXSArIHJzLmFsbHB0c1szXSkgLyAyO1xuXG4gICAgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcbiAgICBycy5lZGdlVHlwZSA9ICdoYXlzdGFjayc7XG4gICAgcnMuaGF5c3RhY2sgPSB0cnVlO1xuICAgIHRoaXMuc3RvcmVFZGdlUHJvamVjdGlvbnMoZWRnZSk7XG4gICAgdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyhlZGdlKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoZWRnZSk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhlZGdlKTtcbiAgfVxufTtcbkJScCRjLmZpbmRTZWdtZW50c1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAvLyBTZWdtZW50cyAobXVsdGlwbGUgc3RyYWlnaHQgbGluZXMpXG5cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHNlZ21lbnRXcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LXdlaWdodHMnKTtcbiAgdmFyIHNlZ21lbnREcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LWRpc3RhbmNlcycpO1xuICB2YXIgc2VnbWVudFJzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtcmFkaWknKTtcbiAgdmFyIHNlZ21lbnRUcyA9IGVkZ2UucHN0eWxlKCdyYWRpdXMtdHlwZScpO1xuICB2YXIgc2VnbWVudHNOID0gTWF0aC5taW4oc2VnbWVudFdzLnBmVmFsdWUubGVuZ3RoLCBzZWdtZW50RHMucGZWYWx1ZS5sZW5ndGgpO1xuICB2YXIgbGFzdFJhZGl1cyA9IHNlZ21lbnRScy5wZlZhbHVlW3NlZ21lbnRScy5wZlZhbHVlLmxlbmd0aCAtIDFdO1xuICB2YXIgbGFzdFJhZGl1c1R5cGUgPSBzZWdtZW50VHMucGZWYWx1ZVtzZWdtZW50VHMucGZWYWx1ZS5sZW5ndGggLSAxXTtcbiAgcnMuZWRnZVR5cGUgPSAnc2VnbWVudHMnO1xuICBycy5zZWdwdHMgPSBbXTtcbiAgcnMucmFkaWkgPSBbXTtcbiAgcnMuaXNBcmNSYWRpdXMgPSBbXTtcbiAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWdtZW50c047IHMrKykge1xuICAgIHZhciB3ID0gc2VnbWVudFdzLnBmVmFsdWVbc107XG4gICAgdmFyIGQgPSBzZWdtZW50RHMucGZWYWx1ZVtzXTtcbiAgICB2YXIgdzEgPSAxIC0gdztcbiAgICB2YXIgdzIgPSB3O1xuICAgIHZhciBfdGhpcyRmaW5kTWlkcHRQdHNFdGMgPSB0aGlzLmZpbmRNaWRwdFB0c0V0YyhlZGdlLCBwYWlySW5mbyksXG4gICAgICBtaWRwdFB0cyA9IF90aGlzJGZpbmRNaWRwdFB0c0V0Yy5taWRwdFB0cyxcbiAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0gX3RoaXMkZmluZE1pZHB0UHRzRXRjLnZlY3Rvck5vcm1JbnZlcnNlO1xuICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgeDogbWlkcHRQdHMueDEgKiB3MSArIG1pZHB0UHRzLngyICogdzIsXG4gICAgICB5OiBtaWRwdFB0cy55MSAqIHcxICsgbWlkcHRQdHMueTIgKiB3MlxuICAgIH07XG4gICAgcnMuc2VncHRzLnB1c2goYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGQsIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkKTtcbiAgICBycy5yYWRpaS5wdXNoKHNlZ21lbnRScy5wZlZhbHVlW3NdICE9PSB1bmRlZmluZWQgPyBzZWdtZW50UnMucGZWYWx1ZVtzXSA6IGxhc3RSYWRpdXMpO1xuICAgIHJzLmlzQXJjUmFkaXVzLnB1c2goKHNlZ21lbnRUcy5wZlZhbHVlW3NdICE9PSB1bmRlZmluZWQgPyBzZWdtZW50VHMucGZWYWx1ZVtzXSA6IGxhc3RSYWRpdXNUeXBlKSA9PT0gJ2FyYy1yYWRpdXMnKTtcbiAgfVxufTtcbkJScCRjLmZpbmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgLy8gU2VsZi1lZGdlXG5cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGRpckNvdW50cyA9IHBhaXJJbmZvLmRpckNvdW50cyxcbiAgICBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3M7XG4gIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGxvb3BEaXIgPSBlZGdlLnBzdHlsZSgnbG9vcC1kaXJlY3Rpb24nKS5wZlZhbHVlO1xuICB2YXIgbG9vcFN3cCA9IGVkZ2UucHN0eWxlKCdsb29wLXN3ZWVwJykucGZWYWx1ZTtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG4gIHZhciBqID0gaTtcbiAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG4gIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICBqID0gMDtcbiAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gIH1cbiAgdmFyIGxvb3BBbmdsZSA9IGxvb3BEaXIgLSBNYXRoLlBJIC8gMjtcbiAgdmFyIG91dEFuZ2xlID0gbG9vcEFuZ2xlIC0gbG9vcFN3cCAvIDI7XG4gIHZhciBpbkFuZ2xlID0gbG9vcEFuZ2xlICsgbG9vcFN3cCAvIDI7XG5cbiAgLy8gaW5jcmVhc2UgYnkgc3RlcCBzaXplIGZvciBvdmVybGFwcGluZyBsb29wcywga2V5ZWQgb24gZGlyZWN0aW9uIGFuZCBzd2VlcCB2YWx1ZXNcbiAgdmFyIGRjID0gU3RyaW5nKGxvb3BEaXIgKyAnXycgKyBsb29wU3dwKTtcbiAgaiA9IGRpckNvdW50c1tkY10gPT09IHVuZGVmaW5lZCA/IGRpckNvdW50c1tkY10gPSAwIDogKytkaXJDb3VudHNbZGNdO1xuICBycy5jdHJscHRzID0gW3NyY1Bvcy54ICsgTWF0aC5jb3Mob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnkgKyBNYXRoLnNpbihvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueCArIE1hdGguY29zKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnkgKyBNYXRoLnNpbihpbkFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSldO1xufTtcbkJScCRjLmZpbmRDb21wb3VuZExvb3BQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAvLyBDb21wb3VuZCBlZGdlXG5cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgcnMuZWRnZVR5cGUgPSAnY29tcG91bmQnO1xuICB2YXIgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zLFxuICAgIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyxcbiAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgaiA9IGk7XG4gIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgaiA9IDA7XG4gICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICB9XG4gIHZhciBsb29wVyA9IDUwO1xuICB2YXIgbG9vcGFQb3MgPSB7XG4gICAgeDogc3JjUG9zLnggLSBzcmNXIC8gMixcbiAgICB5OiBzcmNQb3MueSAtIHNyY0ggLyAyXG4gIH07XG4gIHZhciBsb29wYlBvcyA9IHtcbiAgICB4OiB0Z3RQb3MueCAtIHRndFcgLyAyLFxuICAgIHk6IHRndFBvcy55IC0gdGd0SCAvIDJcbiAgfTtcbiAgdmFyIGxvb3BQb3MgPSB7XG4gICAgeDogTWF0aC5taW4obG9vcGFQb3MueCwgbG9vcGJQb3MueCksXG4gICAgeTogTWF0aC5taW4obG9vcGFQb3MueSwgbG9vcGJQb3MueSlcbiAgfTtcblxuICAvLyBhdm9pZHMgY2FzZXMgd2l0aCBpbXBvc3NpYmxlIGJlemllcnNcbiAgdmFyIG1pbkNvbXBvdW5kU3RyZXRjaCA9IDAuNTtcbiAgdmFyIGNvbXBvdW5kU3RyZXRjaEEgPSBNYXRoLm1heChtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHNyY1cgKiBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCkpO1xuICB2YXIgY29tcG91bmRTdHJldGNoQiA9IE1hdGgubWF4KG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2codGd0VyAqIEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UKSk7XG4gIHJzLmN0cmxwdHMgPSBbbG9vcFBvcy54LCBsb29wUG9zLnkgLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQSwgbG9vcFBvcy54IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEIsIGxvb3BQb3MueV07XG59O1xuQlJwJGMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIC8vIFN0cmFpZ2h0IGVkZ2Ugd2l0aGluIGJ1bmRsZVxuXG4gIGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPSAnc3RyYWlnaHQnO1xufTtcbkJScCRjLmZpbmRCZXppZXJQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdFdzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycpO1xuICB2YXIgYmV6aWVyTiA9IGN0cmxwdERpc3RzICYmIGN0cmxwdFdzID8gTWF0aC5taW4oY3RybHB0RGlzdHMudmFsdWUubGVuZ3RoLCBjdHJscHRXcy52YWx1ZS5sZW5ndGgpIDogMTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVswXTtcblxuICAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgdmFyIG11bHRpID0gZWRnZUlzVW5idW5kbGVkO1xuICBycy5lZGdlVHlwZSA9IG11bHRpID8gJ211bHRpYmV6aWVyJyA6ICdiZXppZXInO1xuICBycy5jdHJscHRzID0gW107XG4gIGZvciAodmFyIGIgPSAwOyBiIDwgYmV6aWVyTjsgYisrKSB7XG4gICAgdmFyIG5vcm1jdHJscHREaXN0ID0gKDAuNSAtIHBhaXJJbmZvLmVsZXMubGVuZ3RoIC8gMiArIGkpICogc3RlcFNpemUgKiAoZWRnZUlzU3dhcHBlZCA/IC0xIDogMSk7XG4gICAgdmFyIG1hbmN0cmxwdERpc3QgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHNpZ24gPSBzaWdudW0obm9ybWN0cmxwdERpc3QpO1xuICAgIGlmIChtdWx0aSkge1xuICAgICAgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVtiXSA6IHN0ZXBTaXplOyAvLyBmYWxsIGJhY2sgb24gc3RlcCBzaXplXG4gICAgICBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVtiXTtcbiAgICB9XG4gICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgLy8gbXVsdGkgb3Igc2luZ2xlIHVuYnVuZGxlZFxuICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0ICE9PSB1bmRlZmluZWQgPyBzaWduICogY3RybHB0RGlzdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuICAgIHZhciB3MSA9IDEgLSBjdHJscHRXZWlnaHQ7XG4gICAgdmFyIHcyID0gY3RybHB0V2VpZ2h0O1xuICAgIHZhciBfdGhpcyRmaW5kTWlkcHRQdHNFdGMyID0gdGhpcy5maW5kTWlkcHRQdHNFdGMoZWRnZSwgcGFpckluZm8pLFxuICAgICAgbWlkcHRQdHMgPSBfdGhpcyRmaW5kTWlkcHRQdHNFdGMyLm1pZHB0UHRzLFxuICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSBfdGhpcyRmaW5kTWlkcHRQdHNFdGMyLnZlY3Rvck5vcm1JbnZlcnNlO1xuICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgeDogbWlkcHRQdHMueDEgKiB3MSArIG1pZHB0UHRzLngyICogdzIsXG4gICAgICB5OiBtaWRwdFB0cy55MSAqIHcxICsgbWlkcHRQdHMueTIgKiB3MlxuICAgIH07XG4gICAgcnMuY3RybHB0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkaXN0YW5jZUZyb21NaWRwb2ludCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRpc3RhbmNlRnJvbU1pZHBvaW50KTtcbiAgfVxufTtcbkJScCRjLmZpbmRUYXhpUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIC8vIFRheGljYWIgZ2VvbWV0cnkgd2l0aCB0d28gdHVybnMgbWF4aW11bVxuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgdmFyIFZFUlRJQ0FMID0gJ3ZlcnRpY2FsJztcbiAgdmFyIEhPUklaT05UQUwgPSAnaG9yaXpvbnRhbCc7XG4gIHZhciBMRUZUV0FSRCA9ICdsZWZ0d2FyZCc7XG4gIHZhciBSSUdIVFdBUkQgPSAncmlnaHR3YXJkJztcbiAgdmFyIERPV05XQVJEID0gJ2Rvd253YXJkJztcbiAgdmFyIFVQV0FSRCA9ICd1cHdhcmQnO1xuICB2YXIgQVVUTyA9ICdhdXRvJztcbiAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIGRJbmNsdWRlc05vZGVCb2R5ID0gZWRnZURpc3RhbmNlcyAhPT0gJ25vZGUtcG9zaXRpb24nO1xuICB2YXIgdGF4aURpciA9IGVkZ2UucHN0eWxlKCd0YXhpLWRpcmVjdGlvbicpLnZhbHVlO1xuICB2YXIgcmF3VGF4aURpciA9IHRheGlEaXI7IC8vIHVucHJvY2Vzc2VkIHZhbHVlXG4gIHZhciB0YXhpVHVybiA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4nKTtcbiAgdmFyIHR1cm5Jc1BlcmNlbnQgPSB0YXhpVHVybi51bml0cyA9PT0gJyUnO1xuICB2YXIgdGF4aVR1cm5QZlZhbCA9IHRheGlUdXJuLnBmVmFsdWU7XG4gIHZhciB0dXJuSXNOZWdhdGl2ZSA9IHRheGlUdXJuUGZWYWwgPCAwOyAvLyBpLmUuIGZyb20gdGFyZ2V0IHNpZGVcbiAgdmFyIG1pbkQgPSBlZGdlLnBzdHlsZSgndGF4aS10dXJuLW1pbi1kaXN0YW5jZScpLnBmVmFsdWU7XG4gIHZhciBkdyA9IGRJbmNsdWRlc05vZGVCb2R5ID8gKHNyY1cgKyB0Z3RXKSAvIDIgOiAwO1xuICB2YXIgZGggPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNIICsgdGd0SCkgLyAyIDogMDtcbiAgdmFyIHBkeCA9IHBvc1B0cy54MiAtIHBvc1B0cy54MTtcbiAgdmFyIHBkeSA9IHBvc1B0cy55MiAtIHBvc1B0cy55MTtcblxuICAvLyB0YWtlIGF3YXkgdGhlIGVmZmVjdGl2ZSB3L2ggZnJvbSB0aGUgbWFnbml0dWRlIG9mIHRoZSBkZWx0YSB2YWx1ZVxuICB2YXIgc3ViRFdIID0gZnVuY3Rpb24gc3ViRFdIKGR4eSwgZHdoKSB7XG4gICAgaWYgKGR4eSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChkeHkgLSBkd2gsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oZHh5ICsgZHdoLCAwKTtcbiAgICB9XG4gIH07XG4gIHZhciBkeCA9IHN1YkRXSChwZHgsIGR3KTtcbiAgdmFyIGR5ID0gc3ViRFdIKHBkeSwgZGgpO1xuICB2YXIgaXNFeHBsaWNpdERpciA9IGZhbHNlO1xuICBpZiAocmF3VGF4aURpciA9PT0gQVVUTykge1xuICAgIHRheGlEaXIgPSBNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkgPyBIT1JJWk9OVEFMIDogVkVSVElDQUw7XG4gIH0gZWxzZSBpZiAocmF3VGF4aURpciA9PT0gVVBXQVJEIHx8IHJhd1RheGlEaXIgPT09IERPV05XQVJEKSB7XG4gICAgdGF4aURpciA9IFZFUlRJQ0FMO1xuICAgIGlzRXhwbGljaXREaXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHJhd1RheGlEaXIgPT09IExFRlRXQVJEIHx8IHJhd1RheGlEaXIgPT09IFJJR0hUV0FSRCkge1xuICAgIHRheGlEaXIgPSBIT1JJWk9OVEFMO1xuICAgIGlzRXhwbGljaXREaXIgPSB0cnVlO1xuICB9XG4gIHZhciBpc1ZlcnQgPSB0YXhpRGlyID09PSBWRVJUSUNBTDtcbiAgdmFyIGwgPSBpc1ZlcnQgPyBkeSA6IGR4O1xuICB2YXIgcGwgPSBpc1ZlcnQgPyBwZHkgOiBwZHg7XG4gIHZhciBzZ25MID0gc2lnbnVtKHBsKTtcbiAgdmFyIGZvcmNlZERpciA9IGZhbHNlO1xuICBpZiAoIShpc0V4cGxpY2l0RGlyICYmICh0dXJuSXNQZXJjZW50IHx8IHR1cm5Jc05lZ2F0aXZlKSkgLy8gZm9yY2luZyBpbiB0aGlzIGNhc2Ugd291bGQgY2F1c2Ugd2VpcmQgZ3Jvd2luZyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICYmIChyYXdUYXhpRGlyID09PSBET1dOV0FSRCAmJiBwbCA8IDAgfHwgcmF3VGF4aURpciA9PT0gVVBXQVJEICYmIHBsID4gMCB8fCByYXdUYXhpRGlyID09PSBMRUZUV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEICYmIHBsIDwgMCkpIHtcbiAgICBzZ25MICo9IC0xO1xuICAgIGwgPSBzZ25MICogTWF0aC5hYnMobCk7XG4gICAgZm9yY2VkRGlyID0gdHJ1ZTtcbiAgfVxuICB2YXIgZDtcbiAgaWYgKHR1cm5Jc1BlcmNlbnQpIHtcbiAgICB2YXIgcCA9IHRheGlUdXJuUGZWYWwgPCAwID8gMSArIHRheGlUdXJuUGZWYWwgOiB0YXhpVHVyblBmVmFsO1xuICAgIGQgPSBwICogbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgayA9IHRheGlUdXJuUGZWYWwgPCAwID8gbCA6IDA7XG4gICAgZCA9IGsgKyB0YXhpVHVyblBmVmFsICogc2duTDtcbiAgfVxuICB2YXIgZ2V0SXNUb29DbG9zZSA9IGZ1bmN0aW9uIGdldElzVG9vQ2xvc2UoZCkge1xuICAgIHJldHVybiBNYXRoLmFicyhkKSA8IG1pbkQgfHwgTWF0aC5hYnMoZCkgPj0gTWF0aC5hYnMobCk7XG4gIH07XG4gIHZhciBpc1Rvb0Nsb3NlU3JjID0gZ2V0SXNUb29DbG9zZShkKTtcbiAgdmFyIGlzVG9vQ2xvc2VUZ3QgPSBnZXRJc1Rvb0Nsb3NlKE1hdGguYWJzKGwpIC0gTWF0aC5hYnMoZCkpO1xuICB2YXIgaXNUb29DbG9zZSA9IGlzVG9vQ2xvc2VTcmMgfHwgaXNUb29DbG9zZVRndDtcbiAgaWYgKGlzVG9vQ2xvc2UgJiYgIWZvcmNlZERpcikge1xuICAgIC8vIG5vbi1pZGVhbCByb3V0aW5nXG4gICAgaWYgKGlzVmVydCkge1xuICAgICAgLy8gdmVydGljYWwgZmFsbGJhY2tzXG4gICAgICB2YXIgbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY0ggLyAyO1xuICAgICAgdmFyIGxTaGFwZUluc2lkZVRndCA9IE1hdGguYWJzKHBkeCkgPD0gdGd0VyAvIDI7XG4gICAgICBpZiAobFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciB4ID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuICAgICAgICB2YXIgeTEgPSBwb3NQdHMueTEsXG4gICAgICAgICAgeTIgPSBwb3NQdHMueTI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFt4LCB5MSwgeCwgeTJdO1xuICAgICAgfSBlbHNlIGlmIChsU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgLy8gdmVydGljYWwgWi1zaGFwZSAoZGlzdGFuY2Ugbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIHkgPSAocG9zUHRzLnkxICsgcG9zUHRzLnkyKSAvIDI7XG4gICAgICAgIHZhciB4MSA9IHBvc1B0cy54MSxcbiAgICAgICAgICB4MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW3gxLCB5LCB4MiwgeV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMLXNoYXBlIGZhbGxiYWNrICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIHdpdGggdHJlZSBzaWJsaW5ncylcbiAgICAgICAgcnMuc2VncHRzID0gW3Bvc1B0cy54MSwgcG9zUHRzLnkyXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9yaXpvbnRhbCBmYWxsYmFja3NcbiAgICAgIHZhciBfbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY1cgLyAyO1xuICAgICAgdmFyIF9sU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHkpIDw9IHRndEggLyAyO1xuICAgICAgaWYgKF9sU2hhcGVJbnNpZGVTcmMpIHtcbiAgICAgICAgLy8gdmVydGljYWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciBfeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcbiAgICAgICAgdmFyIF94ID0gcG9zUHRzLngxLFxuICAgICAgICAgIF94MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194LCBfeSwgX3gyLCBfeV07XG4gICAgICB9IGVsc2UgaWYgKF9sU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciBfeDMgPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG4gICAgICAgIHZhciBfeTIgPSBwb3NQdHMueTEsXG4gICAgICAgICAgX3kzID0gcG9zUHRzLnkyO1xuICAgICAgICBycy5zZWdwdHMgPSBbX3gzLCBfeTIsIF94MywgX3kzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEwtc2hhcGUgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZCwgYnV0IHdvcmtzIHdlbGwgZm9yIHRyZWUgc2libGluZ3MpXG4gICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDIsIHBvc1B0cy55MV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlkZWFsIHJvdXRpbmdcbiAgICBpZiAoaXNWZXJ0KSB7XG4gICAgICB2YXIgX3k0ID0gcG9zUHRzLnkxICsgZCArIChkSW5jbHVkZXNOb2RlQm9keSA/IHNyY0ggLyAyICogc2duTCA6IDApO1xuICAgICAgdmFyIF94NCA9IHBvc1B0cy54MSxcbiAgICAgICAgX3g1ID0gcG9zUHRzLngyO1xuICAgICAgcnMuc2VncHRzID0gW194NCwgX3k0LCBfeDUsIF95NF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvcml6b250YWxcbiAgICAgIHZhciBfeDYgPSBwb3NQdHMueDEgKyBkICsgKGRJbmNsdWRlc05vZGVCb2R5ID8gc3JjVyAvIDIgKiBzZ25MIDogMCk7XG4gICAgICB2YXIgX3k1ID0gcG9zUHRzLnkxLFxuICAgICAgICBfeTYgPSBwb3NQdHMueTI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g2LCBfeTUsIF94NiwgX3k2XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJzLmlzUm91bmQpIHtcbiAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoJ3RheGktcmFkaXVzJykudmFsdWU7XG4gICAgdmFyIGlzQXJjUmFkaXVzID0gZWRnZS5wc3R5bGUoJ3JhZGl1cy10eXBlJykudmFsdWVbMF0gPT09ICdhcmMtcmFkaXVzJztcbiAgICBycy5yYWRpaSA9IG5ldyBBcnJheShycy5zZWdwdHMubGVuZ3RoIC8gMikuZmlsbChyYWRpdXMpO1xuICAgIHJzLmlzQXJjUmFkaXVzID0gbmV3IEFycmF5KHJzLnNlZ3B0cy5sZW5ndGggLyAyKS5maWxsKGlzQXJjUmFkaXVzKTtcbiAgfVxufTtcbkJScCRjLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAvLyBjYW4gb25seSBjb3JyZWN0IGJlemllcnMgZm9yIG5vdy4uLlxuICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInKSB7XG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyxcbiAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICAgIHRndEggPSBwYWlySW5mby50Z3RILFxuICAgICAgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSxcbiAgICAgIHRndFNoYXBlID0gcGFpckluZm8udGd0U2hhcGUsXG4gICAgICBzcmNDb3JuZXJSYWRpdXMgPSBwYWlySW5mby5zcmNDb3JuZXJSYWRpdXMsXG4gICAgICB0Z3RDb3JuZXJSYWRpdXMgPSBwYWlySW5mby50Z3RDb3JuZXJSYWRpdXMsXG4gICAgICBzcmNScyA9IHBhaXJJbmZvLnNyY1JzLFxuICAgICAgdGd0UnMgPSBwYWlySW5mby50Z3RScztcbiAgICB2YXIgYmFkU3RhcnQgPSAhbnVtYmVyJDEocnMuc3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuc3RhcnRZKTtcbiAgICB2YXIgYmFkQVN0YXJ0ID0gIW51bWJlciQxKHJzLmFycm93U3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuYXJyb3dTdGFydFkpO1xuICAgIHZhciBiYWRFbmQgPSAhbnVtYmVyJDEocnMuZW5kWCkgfHwgIW51bWJlciQxKHJzLmVuZFkpO1xuICAgIHZhciBiYWRBRW5kID0gIW51bWJlciQxKHJzLmFycm93RW5kWCkgfHwgIW51bWJlciQxKHJzLmFycm93RW5kWSk7XG4gICAgdmFyIG1pbkNwQURpc3RGYWN0b3IgPSAzO1xuICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG4gICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuICAgIHZhciBzdGFydEFDcERpc3QgPSBkaXN0KHtcbiAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogcnMuc3RhcnRYLFxuICAgICAgeTogcnMuc3RhcnRZXG4gICAgfSk7XG4gICAgdmFyIGNsb3NlU3RhcnRBQ3AgPSBzdGFydEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgIHZhciBlbmRBQ3BEaXN0ID0gZGlzdCh7XG4gICAgICB4OiBycy5jdHJscHRzWzBdLFxuICAgICAgeTogcnMuY3RybHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IHJzLmVuZFgsXG4gICAgICB5OiBycy5lbmRZXG4gICAgfSk7XG4gICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgdmFyIG92ZXJsYXBwaW5nID0gZmFsc2U7XG4gICAgaWYgKGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwKSB7XG4gICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gc3JjIGNlbnRyZSB0byBvdXRzaWRlIHRoZSBzcmMgc2hhcGVcbiAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgIHZhciBjcEQgPSB7XG4gICAgICAgIC8vIGRlbHRhXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSBzcmNQb3MueCxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICB9O1xuICAgICAgdmFyIGNwTCA9IE1hdGguc3FydChjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICB2YXIgY3BNID0ge1xuICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgfTtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgIHZhciBjcFByb2ogPSB7XG4gICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgfTtcbiAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIGNwUHJvai54LCBjcFByb2oueSwgMCwgc3JjQ29ybmVyUmFkaXVzLCBzcmNScyk7XG4gICAgICBpZiAoY2xvc2VTdGFydEFDcCkge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBzcmNDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3ApIHtcbiAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgdmFyIF9jcEQgPSB7XG4gICAgICAgIC8vIGRlbHRhXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSB0Z3RQb3MueCxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHRndFBvcy55XG4gICAgICB9O1xuICAgICAgdmFyIF9jcEwgPSBNYXRoLnNxcnQoX2NwRC54ICogX2NwRC54ICsgX2NwRC55ICogX2NwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgIHZhciBfY3BNID0ge1xuICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgIHg6IF9jcEQueCAvIF9jcEwsXG4gICAgICAgIHk6IF9jcEQueSAvIF9jcExcbiAgICAgIH07XG4gICAgICB2YXIgX3JhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgdmFyIF9jcFByb2ogPSB7XG4gICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIDIgKiBfcmFkaXVzLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgX2NwTS55ICogMiAqIF9yYWRpdXNcbiAgICAgIH07XG4gICAgICB2YXIgdGd0Q3RybFB0SW50biA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBfY3BQcm9qLngsIF9jcFByb2oueSwgMCwgdGd0Q29ybmVyUmFkaXVzLCB0Z3RScyk7XG4gICAgICBpZiAoY2xvc2VFbmRBQ3ApIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBfY3BNLnggKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIF9jcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIF9jcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSB0Z3RDdHJsUHRJbnRuWzFdICsgX2NwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJsYXBwaW5nKSB7XG4gICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICB0aGlzLmZpbmRFbmRwb2ludHMoZWRnZSk7XG4gICAgfVxuICB9XG59O1xuQlJwJGMuc3RvcmVBbGxwdHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBpZiAocnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICBycy5hbGxwdHMgPSBbXTtcbiAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgKyAxIDwgcnMuY3RybHB0cy5sZW5ndGg7IGIgKz0gMikge1xuICAgICAgLy8gY3RybCBwdCBpdHNlbGZcbiAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLmN0cmxwdHNbYl0sIHJzLmN0cmxwdHNbYiArIDFdKTtcblxuICAgICAgLy8gdGhlIG1pZHB0IGJldHdlZW4gY3RybHB0cyBhcyBpbnRlcm1lZGlhdGUgZGVzdGluYXRpb24gcHRzXG4gICAgICBpZiAoYiArIDMgPCBycy5jdHJscHRzLmxlbmd0aCkge1xuICAgICAgICBycy5hbGxwdHMucHVzaCgocnMuY3RybHB0c1tiXSArIHJzLmN0cmxwdHNbYiArIDJdKSAvIDIsIChycy5jdHJscHRzW2IgKyAxXSArIHJzLmN0cmxwdHNbYiArIDNdKSAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBycy5hbGxwdHMucHVzaChycy5lbmRYLCBycy5lbmRZKTtcbiAgICB2YXIgbSwgbXQ7XG4gICAgaWYgKHJzLmN0cmxwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICBycy5taWRYID0gcnMuYWxscHRzW21dO1xuICAgICAgcnMubWlkWSA9IHJzLmFsbHB0c1ttICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDM7XG4gICAgICBtdCA9IDAuNTtcbiAgICAgIHJzLm1pZFggPSBxYmV6aWVyQXQocnMuYWxscHRzW21dLCBycy5hbGxwdHNbbSArIDJdLCBycy5hbGxwdHNbbSArIDRdLCBtdCk7XG4gICAgICBycy5taWRZID0gcWJlemllckF0KHJzLmFsbHB0c1ttICsgMV0sIHJzLmFsbHB0c1ttICsgM10sIHJzLmFsbHB0c1ttICsgNV0sIG10KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAvLyBuZWVkIHRvIGNhbGMgdGhlc2UgYWZ0ZXIgZW5kcHRzXG4gICAgcnMuYWxscHRzID0gW3JzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZXTtcblxuICAgIC8vIGRlZmF1bHQgbWlkcHQgZm9yIGxhYmVscyBldGNcbiAgICBycy5taWRYID0gKHJzLnN0YXJ0WCArIHJzLmVuZFggKyBycy5hcnJvd1N0YXJ0WCArIHJzLmFycm93RW5kWCkgLyA0O1xuICAgIHJzLm1pZFkgPSAocnMuc3RhcnRZICsgcnMuZW5kWSArIHJzLmFycm93U3RhcnRZICsgcnMuYXJyb3dFbmRZKSAvIDQ7XG4gIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycpIHtcbiAgICBycy5hbGxwdHMgPSBbXTtcbiAgICBycy5hbGxwdHMucHVzaChycy5zdGFydFgsIHJzLnN0YXJ0WSk7XG4gICAgcnMuYWxscHRzLnB1c2guYXBwbHkocnMuYWxscHRzLCBycy5zZWdwdHMpO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuICAgIGlmIChycy5pc1JvdW5kKSB7XG4gICAgICBycy5yb3VuZENvcm5lcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpICsgMyA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgcmFkaXVzID0gcnMucmFkaWlbaSAvIDIgLSAxXTtcbiAgICAgICAgdmFyIGlzQXJjUmFkaXVzID0gcnMuaXNBcmNSYWRpdXNbaSAvIDIgLSAxXTtcbiAgICAgICAgcnMucm91bmRDb3JuZXJzLnB1c2goZ2V0Um91bmRDb3JuZXIoe1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpIC0gMl0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgLSAxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV0sXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXNcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpICsgMl0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgKyAzXVxuICAgICAgICB9LCByYWRpdXMsIGlzQXJjUmFkaXVzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChycy5zZWdwdHMubGVuZ3RoICUgNCA9PT0gMCkge1xuICAgICAgdmFyIGkyID0gcnMuc2VncHRzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBycy5taWRYID0gKHJzLnNlZ3B0c1tpMV0gKyBycy5zZWdwdHNbaTJdKSAvIDI7XG4gICAgICBycy5taWRZID0gKHJzLnNlZ3B0c1tpMSArIDFdICsgcnMuc2VncHRzW2kyICsgMV0pIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgaWYgKCFycy5pc1JvdW5kKSB7XG4gICAgICAgIHJzLm1pZFggPSBycy5zZWdwdHNbX2ldO1xuICAgICAgICBycy5taWRZID0gcnMuc2VncHRzW19pICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgeDogcnMuc2VncHRzW19pXSxcbiAgICAgICAgICB5OiBycy5zZWdwdHNbX2kgKyAxXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29ybmVyID0gcnMucm91bmRDb3JuZXJzW19pIC8gMl07XG4gICAgICAgIGlmIChjb3JuZXIucmFkaXVzID09PSAwKSB7XG4gICAgICAgICAgLy8gT24gY29sbGluZWFyIHBvaW50c1xuICAgICAgICAgIHZhciBuZXh0UG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBycy5zZWdwdHNbX2kgKyAyXSxcbiAgICAgICAgICAgIHk6IHJzLnNlZ3B0c1tfaSArIDNdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBycy5taWRYID0gcG9pbnQueDtcbiAgICAgICAgICBycy5taWRZID0gcG9pbnQueTtcbiAgICAgICAgICBycy5taWRWZWN0b3IgPSBbcG9pbnQueSAtIG5leHRQb2ludC55LCBuZXh0UG9pbnQueCAtIHBvaW50LnhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9uIHJvdW5kZWQgcG9pbnRzXG4gICAgICAgICAgdmFyIHYgPSBbcG9pbnQueCAtIGNvcm5lci5jeCwgcG9pbnQueSAtIGNvcm5lci5jeV07XG4gICAgICAgICAgdmFyIGZhY3RvciA9IGNvcm5lci5yYWRpdXMgLyBNYXRoLnNxcnQoTWF0aC5wb3codlswXSwgMikgKyBNYXRoLnBvdyh2WzFdLCAyKSk7XG4gICAgICAgICAgdiA9IHYubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqIGZhY3RvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBycy5taWRYID0gY29ybmVyLmN4ICsgdlswXTtcbiAgICAgICAgICBycy5taWRZID0gY29ybmVyLmN5ICsgdlsxXTtcbiAgICAgICAgICBycy5taWRWZWN0b3IgPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuQlJwJGMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICBpZiAocnMubm9kZXNPdmVybGFwIHx8IG51bWJlciQxKHJzLnN0YXJ0WCkgJiYgbnVtYmVyJDEocnMuc3RhcnRZKSAmJiBudW1iZXIkMShycy5lbmRYKSAmJiBudW1iZXIkMShycy5lbmRZKSkge1xuICAgIHJzLmxvZ2dlZEVyciA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlmICghcnMubG9nZ2VkRXJyKSB7XG4gICAgICBycy5sb2dnZWRFcnIgPSB0cnVlO1xuICAgICAgd2FybignRWRnZSBgJyArIGVkZ2UuaWQoKSArICdgIGhhcyBpbnZhbGlkIGVuZHBvaW50cyBhbmQgc28gaXQgaXMgaW1wb3NzaWJsZSB0byBkcmF3LiAgQWRqdXN0IHlvdXIgZWRnZSBzdHlsZSAoZS5nLiBjb250cm9sIHBvaW50cykgYWNjb3JkaW5nbHkgb3IgdXNlIGFuIGFsdGVybmF0aXZlIGVkZ2UgdHlwZS4gIFRoaXMgaXMgZXhwZWN0ZWQgYmVoYXZpb3VyIHdoZW4gdGhlIHNvdXJjZSBub2RlIGFuZCB0aGUgdGFyZ2V0IG5vZGUgb3ZlcmxhcC4nKTtcbiAgICB9XG4gIH1cbn07XG5CUnAkYy5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgaWYgKCFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaGFzaFRhYmxlID0gbmV3IE1hcCQxKCk7XG4gIHZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkocGFpcklkLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYWlySWQpLCBbZWRnZUlzVW5idW5kbGVkID8gMSA6IDBdKS5qb2luKCctJyk7XG4gIH07XG4gIHZhciBwYWlySWRzID0gW107XG4gIHZhciBoYXlzdGFja0VkZ2VzID0gW107XG5cbiAgLy8gY3JlYXRlIGEgdGFibGUgb2YgZWRnZSAoc3JjLCB0Z3QpID0+IGxpc3Qgb2YgZWRnZXMgYmV0d2VlbiB0aGVtXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcblxuICAgIC8vIGlnbm9yZSBlZGdlcyB3aG8gYXJlIG5vdCB0byBiZSBkaXNwbGF5ZWRcbiAgICAvLyB0aGV5IHNob3VsZG4ndCB0YWtlIHVwIHNwYWNlXG4gICAgaWYgKGVkZ2UucmVtb3ZlZCgpIHx8ICFlZGdlLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIGhheXN0YWNrRWRnZXMucHVzaChlZGdlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGVuZHNXaXRoKGN1cnZlU3R5bGUsICdzZWdtZW50cycpIHx8IGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0LXRyaWFuZ2xlJyB8fCBlbmRzV2l0aChjdXJ2ZVN0eWxlLCAndGF4aScpO1xuICAgIHZhciBlZGdlSXNCZXppZXIgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ2Jlemllcic7XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNJbmRleCA9IHNyYy5wb29sSW5kZXgoKTtcbiAgICB2YXIgdGd0SW5kZXggPSB0Z3QucG9vbEluZGV4KCk7XG4gICAgdmFyIHBhaXJJZCA9IFtzcmNJbmRleCwgdGd0SW5kZXhdLnNvcnQoKTtcbiAgICB2YXIga2V5ID0gZ2V0S2V5KHBhaXJJZCwgZWRnZUlzVW5idW5kbGVkKTtcbiAgICB2YXIgdGFibGVFbnRyeSA9IGhhc2hUYWJsZS5nZXQoa2V5KTtcbiAgICBpZiAodGFibGVFbnRyeSA9PSBudWxsKSB7XG4gICAgICB0YWJsZUVudHJ5ID0ge1xuICAgICAgICBlbGVzOiBbXVxuICAgICAgfTtcbiAgICAgIHBhaXJJZHMucHVzaCh7XG4gICAgICAgIHBhaXJJZDogcGFpcklkLFxuICAgICAgICBlZGdlSXNVbmJ1bmRsZWQ6IGVkZ2VJc1VuYnVuZGxlZFxuICAgICAgfSk7XG4gICAgICBoYXNoVGFibGUuc2V0KGtleSwgdGFibGVFbnRyeSk7XG4gICAgfVxuICAgIHRhYmxlRW50cnkuZWxlcy5wdXNoKGVkZ2UpO1xuICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgIHRhYmxlRW50cnkuaGFzVW5idW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVkZ2VJc0Jlemllcikge1xuICAgICAgdGFibGVFbnRyeS5oYXNCZXppZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZvciBlYWNoIHBhaXIgKHNyYywgdGd0KSwgY3JlYXRlIHRoZSBjdHJsIHB0c1xuICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBfcGFpcklkcyRwID0gcGFpcklkc1twXSxcbiAgICAgIHBhaXJJZCA9IF9wYWlySWRzJHAucGFpcklkLFxuICAgICAgZWRnZUlzVW5idW5kbGVkID0gX3BhaXJJZHMkcC5lZGdlSXNVbmJ1bmRsZWQ7XG4gICAgdmFyIGtleSA9IGdldEtleShwYWlySWQsIGVkZ2VJc1VuYnVuZGxlZCk7XG4gICAgdmFyIHBhaXJJbmZvID0gaGFzaFRhYmxlLmdldChrZXkpO1xuICAgIHZhciBzd2FwcGVkcGFpckluZm87XG4gICAgaWYgKCFwYWlySW5mby5oYXNVbmJ1bmRsZWQpIHtcbiAgICAgIHZhciBwbGxFZGdlcyA9IHBhaXJJbmZvLmVsZXNbMF0ucGFyYWxsZWxFZGdlcygpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5pc0J1bmRsZWRCZXppZXIoKTtcbiAgICAgIH0pO1xuICAgICAgY2xlYXJBcnJheShwYWlySW5mby5lbGVzKTtcbiAgICAgIHBsbEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJJbmZvLmVsZXMucHVzaChlZGdlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBmb3IgZWFjaCBwYWlyIGlkLCB0aGUgZWRnZXMgc2hvdWxkIGJlIHNvcnRlZCBieSBpbmRleFxuICAgICAgcGFpckluZm8uZWxlcy5zb3J0KGZ1bmN0aW9uIChlZGdlMSwgZWRnZTIpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UxLnBvb2xJbmRleCgpIC0gZWRnZTIucG9vbEluZGV4KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGZpcnN0RWRnZSA9IHBhaXJJbmZvLmVsZXNbMF07XG4gICAgdmFyIHNyYyA9IGZpcnN0RWRnZS5zb3VyY2UoKTtcbiAgICB2YXIgdGd0ID0gZmlyc3RFZGdlLnRhcmdldCgpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHNyYy90Z3QgZGlzdGluY3Rpb24gaXMgY29uc2lzdGVudCB3LnIudC4gcGFpcklkXG4gICAgaWYgKHNyYy5wb29sSW5kZXgoKSA+IHRndC5wb29sSW5kZXgoKSkge1xuICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICBzcmMgPSB0Z3Q7XG4gICAgICB0Z3QgPSB0ZW1wO1xuICAgIH1cbiAgICB2YXIgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zID0gc3JjLnBvc2l0aW9uKCk7XG4gICAgdmFyIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgIHZhciBzcmNXID0gcGFpckluZm8uc3JjVyA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgdmFyIHNyY0ggPSBwYWlySW5mby5zcmNIID0gc3JjLm91dGVySGVpZ2h0KCk7XG4gICAgdmFyIHRndFcgPSBwYWlySW5mby50Z3RXID0gdGd0Lm91dGVyV2lkdGgoKTtcbiAgICB2YXIgdGd0SCA9IHBhaXJJbmZvLnRndEggPSB0Z3Qub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUoc3JjKV07XG4gICAgdmFyIHRndFNoYXBlID0gcGFpckluZm8udGd0U2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHRndCldO1xuICAgIHZhciBzcmNDb3JuZXJSYWRpdXMgPSBwYWlySW5mby5zcmNDb3JuZXJSYWRpdXMgPSBzcmMucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IHNyYy5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlO1xuICAgIHZhciB0Z3RDb3JuZXJSYWRpdXMgPSBwYWlySW5mby50Z3RDb3JuZXJSYWRpdXMgPSB0Z3QucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IHRndC5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlO1xuICAgIHZhciB0Z3RScyA9IHBhaXJJbmZvLnRndFJzID0gdGd0Ll9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBzcmNScyA9IHBhaXJJbmZvLnNyY1JzID0gc3JjLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHBhaXJJbmZvLmRpckNvdW50cyA9IHtcbiAgICAgICdub3J0aCc6IDAsXG4gICAgICAnd2VzdCc6IDAsXG4gICAgICAnc291dGgnOiAwLFxuICAgICAgJ2Vhc3QnOiAwLFxuICAgICAgJ25vcnRod2VzdCc6IDAsXG4gICAgICAnc291dGh3ZXN0JzogMCxcbiAgICAgICdub3J0aGVhc3QnOiAwLFxuICAgICAgJ3NvdXRoZWFzdCc6IDBcbiAgICB9O1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhaXJJbmZvLmVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9lZGdlID0gcGFpckluZm8uZWxlc1tfaTJdO1xuICAgICAgdmFyIHJzID0gX2VkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgX2N1cnZlU3R5bGUgPSBfZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gICAgICB2YXIgX2VkZ2VJc1VuYnVuZGxlZCA9IF9jdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgZW5kc1dpdGgoX2N1cnZlU3R5bGUsICdzZWdtZW50cycpIHx8IGVuZHNXaXRoKF9jdXJ2ZVN0eWxlLCAndGF4aScpO1xuXG4gICAgICAvLyB3aGV0aGVyIHRoZSBub3JtYWxpc2VkIHBhaXIgb3JkZXIgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGVkZ2UncyBzcmMtdGd0IG9yZGVyXG4gICAgICB2YXIgZWRnZUlzU3dhcHBlZCA9ICFzcmMuc2FtZShfZWRnZS5zb3VyY2UoKSk7XG4gICAgICBpZiAoIXBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gJiYgc3JjICE9PSB0Z3QgJiYgKHBhaXJJbmZvLmhhc0JlemllciB8fCBwYWlySW5mby5oYXNVbmJ1bmRsZWQpKSB7XG4gICAgICAgIHBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gPSB0cnVlO1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCB0Z3RQb3MueCwgdGd0UG9zLnksIDAsIHNyY0Nvcm5lclJhZGl1cywgc3JjUnMpO1xuICAgICAgICB2YXIgc3JjSW50biA9IHBhaXJJbmZvLnNyY0ludG4gPSBzcmNPdXRzaWRlO1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBzcmNQb3MueCwgc3JjUG9zLnksIDAsIHRndENvcm5lclJhZGl1cywgdGd0UnMpO1xuICAgICAgICB2YXIgdGd0SW50biA9IHBhaXJJbmZvLnRndEludG4gPSB0Z3RPdXRzaWRlO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzID0ge1xuICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY1Bvcy54LFxuICAgICAgICAgIHgyOiB0Z3RQb3MueCxcbiAgICAgICAgICB5MTogc3JjUG9zLnksXG4gICAgICAgICAgeTI6IHRndFBvcy55XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkeSA9IHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdO1xuICAgICAgICB2YXIgZHggPSB0Z3RPdXRzaWRlWzBdIC0gc3JjT3V0c2lkZVswXTtcbiAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBpZiAobnVtYmVyJDEobCkgJiYgbCA+PSBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVF9MKSA7IGVsc2Uge1xuICAgICAgICAgIGwgPSBNYXRoLnNxcnQoTWF0aC5tYXgoZHggKiBkeCwgQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlQpICsgTWF0aC5tYXgoZHkgKiBkeSwgQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlQpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVjdG9yID0gcGFpckluZm8udmVjdG9yID0ge1xuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtID0gcGFpckluZm8udmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgICAgeTogdmVjdG9yLnkgLyBsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgICB4OiAtdmVjdG9yTm9ybS55LFxuICAgICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIG5vZGUgc2hhcGVzIG92ZXJsYXAsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuICAgICAgICBwYWlySW5mby5ub2Rlc092ZXJsYXAgPSAhbnVtYmVyJDEobCkgfHwgdGd0U2hhcGUuY2hlY2tQb2ludChzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCAwLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnksIHRndENvcm5lclJhZGl1cywgdGd0UnMpIHx8IHNyY1NoYXBlLmNoZWNrUG9pbnQodGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgMCwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNDb3JuZXJSYWRpdXMsIHNyY1JzKTtcbiAgICAgICAgcGFpckluZm8udmVjdG9yTm9ybUludmVyc2UgPSB2ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICAgICAgc3dhcHBlZHBhaXJJbmZvID0ge1xuICAgICAgICAgIG5vZGVzT3ZlcmxhcDogcGFpckluZm8ubm9kZXNPdmVybGFwLFxuICAgICAgICAgIGRpckNvdW50czogcGFpckluZm8uZGlyQ291bnRzLFxuICAgICAgICAgIGNhbGN1bGF0ZWRJbnRlcnNlY3Rpb246IHRydWUsXG4gICAgICAgICAgaGFzQmV6aWVyOiBwYWlySW5mby5oYXNCZXppZXIsXG4gICAgICAgICAgaGFzVW5idW5kbGVkOiBwYWlySW5mby5oYXNVbmJ1bmRsZWQsXG4gICAgICAgICAgZWxlczogcGFpckluZm8uZWxlcyxcbiAgICAgICAgICBzcmNQb3M6IHRndFBvcyxcbiAgICAgICAgICBzcmNSczogdGd0UnMsXG4gICAgICAgICAgdGd0UG9zOiBzcmNQb3MsXG4gICAgICAgICAgdGd0UnM6IHNyY1JzLFxuICAgICAgICAgIHNyY1c6IHRndFcsXG4gICAgICAgICAgc3JjSDogdGd0SCxcbiAgICAgICAgICB0Z3RXOiBzcmNXLFxuICAgICAgICAgIHRndEg6IHNyY0gsXG4gICAgICAgICAgc3JjSW50bjogdGd0SW50bixcbiAgICAgICAgICB0Z3RJbnRuOiBzcmNJbnRuLFxuICAgICAgICAgIHNyY1NoYXBlOiB0Z3RTaGFwZSxcbiAgICAgICAgICB0Z3RTaGFwZTogc3JjU2hhcGUsXG4gICAgICAgICAgcG9zUHRzOiB7XG4gICAgICAgICAgICB4MTogcG9zUHRzLngyLFxuICAgICAgICAgICAgeTE6IHBvc1B0cy55MixcbiAgICAgICAgICAgIHgyOiBwb3NQdHMueDEsXG4gICAgICAgICAgICB5MjogcG9zUHRzLnkxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnRlcnNlY3Rpb25QdHM6IHtcbiAgICAgICAgICAgIHgxOiBpbnRlcnNlY3Rpb25QdHMueDIsXG4gICAgICAgICAgICB5MTogaW50ZXJzZWN0aW9uUHRzLnkyLFxuICAgICAgICAgICAgeDI6IGludGVyc2VjdGlvblB0cy54MSxcbiAgICAgICAgICAgIHkyOiBpbnRlcnNlY3Rpb25QdHMueTFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvcjoge1xuICAgICAgICAgICAgeDogLXZlY3Rvci54LFxuICAgICAgICAgICAgeTogLXZlY3Rvci55XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3JOb3JtOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yTm9ybS54LFxuICAgICAgICAgICAgeTogLXZlY3Rvck5vcm0ueVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yTm9ybUludmVyc2U6IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtSW52ZXJzZS54LFxuICAgICAgICAgICAgeTogLXZlY3Rvck5vcm1JbnZlcnNlLnlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgcGFzc2VkUGFpckluZm8gPSBlZGdlSXNTd2FwcGVkID8gc3dhcHBlZHBhaXJJbmZvIDogcGFpckluZm87XG4gICAgICBycy5ub2Rlc092ZXJsYXAgPSBwYXNzZWRQYWlySW5mby5ub2Rlc092ZXJsYXA7XG4gICAgICBycy5zcmNJbnRuID0gcGFzc2VkUGFpckluZm8uc3JjSW50bjtcbiAgICAgIHJzLnRndEludG4gPSBwYXNzZWRQYWlySW5mby50Z3RJbnRuO1xuICAgICAgcnMuaXNSb3VuZCA9IF9jdXJ2ZVN0eWxlLnN0YXJ0c1dpdGgoJ3JvdW5kJyk7XG4gICAgICBpZiAoaGFzQ29tcG91bmRzICYmIChzcmMuaXNQYXJlbnQoKSB8fCBzcmMuaXNDaGlsZCgpIHx8IHRndC5pc1BhcmVudCgpIHx8IHRndC5pc0NoaWxkKCkpICYmIChzcmMucGFyZW50cygpLmFueVNhbWUodGd0KSB8fCB0Z3QucGFyZW50cygpLmFueVNhbWUoc3JjKSB8fCBzcmMuc2FtZSh0Z3QpICYmIHNyYy5pc1BhcmVudCgpKSkge1xuICAgICAgICBfdGhpcy5maW5kQ29tcG91bmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgX3RoaXMuZmluZExvb3BQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZS5lbmRzV2l0aCgnc2VnbWVudHMnKSkge1xuICAgICAgICBfdGhpcy5maW5kU2VnbWVudHNQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUuZW5kc1dpdGgoJ3RheGknKSkge1xuICAgICAgICBfdGhpcy5maW5kVGF4aVBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0JyB8fCAhX2VkZ2VJc1VuYnVuZGxlZCAmJiBwYWlySW5mby5lbGVzLmxlbmd0aCAlIDIgPT09IDEgJiYgX2kyID09PSBNYXRoLmZsb29yKHBhaXJJbmZvLmVsZXMubGVuZ3RoIC8gMikpIHtcbiAgICAgICAgX3RoaXMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyhfZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5maW5kQmV6aWVyUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkLCBlZGdlSXNTd2FwcGVkKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmZpbmRFbmRwb2ludHMoX2VkZ2UpO1xuICAgICAgX3RoaXMudHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgX3RoaXMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcoX2VkZ2UpO1xuICAgICAgX3RoaXMuc3RvcmVBbGxwdHMoX2VkZ2UpO1xuICAgICAgX3RoaXMuc3RvcmVFZGdlUHJvamVjdGlvbnMoX2VkZ2UpO1xuICAgICAgX3RoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoX2VkZ2UpO1xuICAgICAgX3RoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhfZWRnZSk7XG4gICAgICBfdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhfZWRnZSk7XG4gICAgfSAvLyBmb3IgcGFpciBlZGdlc1xuICB9O1xuICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICBfbG9vcCgpO1xuICB9IC8vIGZvciBwYWlyIGlkc1xuXG4gIC8vIGhheXN0YWNrcyBhdm9pZCB0aGUgZXhwZW5zZSBvZiBwYWlySW5mbyBzdHVmZiAoaW50ZXJzZWN0aW9ucyBldGMuKVxuICB0aGlzLmZpbmRIYXlzdGFja1BvaW50cyhoYXlzdGFja0VkZ2VzKTtcbn07XG5mdW5jdGlvbiBnZXRQdHMocHRzKSB7XG4gIHZhciByZXRQdHMgPSBbXTtcbiAgaWYgKHB0cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHggPSBwdHNbaV07XG4gICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgIHJldFB0cy5wdXNoKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJldFB0cztcbn1cbkJScCRjLmdldFNlZ21lbnRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcbiAgaWYgKHR5cGUgPT09ICdzZWdtZW50cycpIHtcbiAgICByZXR1cm4gZ2V0UHRzKHJzLnNlZ3B0cyk7XG4gIH1cbn07XG5CUnAkYy5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG4gIGlmICh0eXBlID09PSAnYmV6aWVyJyB8fCB0eXBlID09PSAnbXVsdGliZXppZXInIHx8IHR5cGUgPT09ICdzZWxmJyB8fCB0eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgcmV0dXJuIGdldFB0cyhycy5jdHJscHRzKTtcbiAgfVxufTtcbkJScCRjLmdldEVkZ2VNaWRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICByZXR1cm4ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xufTtcblxudmFyIEJScCRiID0ge307XG5CUnAkYi5tYW51YWxFbmRwdFRvUHggPSBmdW5jdGlvbiAobm9kZSwgcHJvcCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBucG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgdyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgaWYgKHByb3AudmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAgPSBbcHJvcC5wZlZhbHVlWzBdLCBwcm9wLnBmVmFsdWVbMV1dO1xuICAgIGlmIChwcm9wLnVuaXRzWzBdID09PSAnJScpIHtcbiAgICAgIHBbMF0gPSBwWzBdICogdztcbiAgICB9XG4gICAgaWYgKHByb3AudW5pdHNbMV0gPT09ICclJykge1xuICAgICAgcFsxXSA9IHBbMV0gKiBoO1xuICAgIH1cbiAgICBwWzBdICs9IG5wb3MueDtcbiAgICBwWzFdICs9IG5wb3MueTtcbiAgICByZXR1cm4gcDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5nbGUgPSBwcm9wLnBmVmFsdWVbMF07XG4gICAgYW5nbGUgPSAtTWF0aC5QSSAvIDIgKyBhbmdsZTsgLy8gc3RhcnQgYXQgMTIgbydjbG9ja1xuXG4gICAgdmFyIGwgPSAyICogTWF0aC5tYXgodywgaCk7XG4gICAgdmFyIF9wID0gW25wb3MueCArIE1hdGguY29zKGFuZ2xlKSAqIGwsIG5wb3MueSArIE1hdGguc2luKGFuZ2xlKSAqIGxdO1xuICAgIHJldHVybiByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUobm9kZSldLmludGVyc2VjdExpbmUobnBvcy54LCBucG9zLnksIHcsIGgsIF9wWzBdLCBfcFsxXSwgMCwgbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlLCBycyk7XG4gIH1cbn07XG5CUnAkYi5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIF9yZWYsIF90Z3RNYW5FbmRwdCRwZlZhbHVlLCBfcmVmMiwgX3NyY01hbkVuZHB0JHBmVmFsdWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGludGVyc2VjdDtcbiAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpWzBdO1xuICB2YXIgc3JjUG9zID0gc291cmNlLnBvc2l0aW9uKCk7XG4gIHZhciB0Z3RQb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciBzcmNBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgdGd0RGlzdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgdmFyIHNyY0Rpc3QgPSBlZGdlLnBzdHlsZSgnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gIHZhciBzcmNScyA9IHNvdXJjZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHRndFJzID0gdGFyZ2V0Ll9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcbiAgdmFyIHRheGkgPSBlbmRzV2l0aChjdXJ2ZVN0eWxlLCAndGF4aScpOyAvLyBDb3ZlcnMgdGF4aSBhbmQgcm91bmQtdGF4aVxuICB2YXIgc2VsZiA9IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCc7XG4gIHZhciBiZXppZXIgPSBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdtdWx0aWJlemllcicgfHwgc2VsZjtcbiAgdmFyIG11bHRpID0gZXQgIT09ICdiZXppZXInO1xuICB2YXIgbGluZXMgPSBldCA9PT0gJ3N0cmFpZ2h0JyB8fCBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIHNlZ21lbnRzID0gZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBoYXNFbmRwdHMgPSBiZXppZXIgfHwgbXVsdGkgfHwgbGluZXM7XG4gIHZhciBvdmVycmlkZUVuZHB0cyA9IHNlbGYgfHwgdGF4aTtcbiAgdmFyIHNyY01hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1lbmRwb2ludCcpO1xuICB2YXIgc3JjTWFuRW5kcHRWYWwgPSBvdmVycmlkZUVuZHB0cyA/ICdvdXRzaWRlLXRvLW5vZGUnIDogc3JjTWFuRW5kcHQudmFsdWU7XG4gIHZhciBzcmNDb3JuZXJSYWRpdXMgPSBzb3VyY2UucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IHNvdXJjZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlO1xuICB2YXIgdGd0TWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWVuZHBvaW50Jyk7XG4gIHZhciB0Z3RNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiB0Z3RNYW5FbmRwdC52YWx1ZTtcbiAgdmFyIHRndENvcm5lclJhZGl1cyA9IHRhcmdldC5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogdGFyZ2V0LnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gIHJzLnNyY01hbkVuZHB0ID0gc3JjTWFuRW5kcHQ7XG4gIHJzLnRndE1hbkVuZHB0ID0gdGd0TWFuRW5kcHQ7XG4gIHZhciBwMTsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHRhcmdldCBzaWRlXG4gIHZhciBwMjsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHNvdXJjZSBzaWRlXG5cbiAgdmFyIHAxX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHRhcmdldCBzaGFwZVxuICB2YXIgcDJfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggc291cmNlIHNoYXBlXG5cbiAgdmFyIHRndE1hbkVuZHB0UHQgPSAoX3JlZiA9ICh0Z3RNYW5FbmRwdCA9PT0gbnVsbCB8fCB0Z3RNYW5FbmRwdCA9PT0gdW5kZWZpbmVkIHx8IChfdGd0TWFuRW5kcHQkcGZWYWx1ZSA9IHRndE1hbkVuZHB0LnBmVmFsdWUpID09PSBudWxsIHx8IF90Z3RNYW5FbmRwdCRwZlZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfdGd0TWFuRW5kcHQkcGZWYWx1ZS5sZW5ndGgpID09PSAyID8gdGd0TWFuRW5kcHQucGZWYWx1ZSA6IG51bGwpICE9PSBudWxsICYmIF9yZWYgIT09IHVuZGVmaW5lZCA/IF9yZWYgOiBbMCwgMF07XG4gIHZhciBzcmNNYW5FbmRwdFB0ID0gKF9yZWYyID0gKHNyY01hbkVuZHB0ID09PSBudWxsIHx8IHNyY01hbkVuZHB0ID09PSB1bmRlZmluZWQgfHwgKF9zcmNNYW5FbmRwdCRwZlZhbHVlID0gc3JjTWFuRW5kcHQucGZWYWx1ZSkgPT09IG51bGwgfHwgX3NyY01hbkVuZHB0JHBmVmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9zcmNNYW5FbmRwdCRwZlZhbHVlLmxlbmd0aCkgPT09IDIgPyBzcmNNYW5FbmRwdC5wZlZhbHVlIDogbnVsbCkgIT09IG51bGwgJiYgX3JlZjIgIT09IHVuZGVmaW5lZCA/IF9yZWYyIDogWzAsIDBdO1xuICBpZiAoYmV6aWVyKSB7XG4gICAgdmFyIGNwU3RhcnQgPSBbcnMuY3RybHB0c1swXSwgcnMuY3RybHB0c1sxXV07XG4gICAgdmFyIGNwRW5kID0gbXVsdGkgPyBbcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDJdLCBycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMV1dIDogY3BTdGFydDtcbiAgICBwMSA9IGNwRW5kO1xuICAgIHAyID0gY3BTdGFydDtcbiAgfSBlbHNlIGlmIChsaW5lcykge1xuICAgIHZhciBzcmNBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFt0Z3RQb3MueCArIHRndE1hbkVuZHB0UHRbMF0sIHRndFBvcy55ICsgdGd0TWFuRW5kcHRQdFsxXV0gOiBycy5zZWdwdHMuc2xpY2UoMCwgMik7XG4gICAgdmFyIHRndEFycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gW3NyY1Bvcy54ICsgc3JjTWFuRW5kcHRQdFswXSwgc3JjUG9zLnkgKyBzcmNNYW5FbmRwdFB0WzFdXSA6IHJzLnNlZ3B0cy5zbGljZShycy5zZWdwdHMubGVuZ3RoIC0gMik7XG4gICAgcDEgPSB0Z3RBcnJvd0Zyb21QdDtcbiAgICBwMiA9IHNyY0Fycm93RnJvbVB0O1xuICB9XG4gIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ2luc2lkZS10by1ub2RlJykge1xuICAgIGludGVyc2VjdCA9IFt0Z3RQb3MueCwgdGd0UG9zLnldO1xuICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0LnVuaXRzKSB7XG4gICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgodGFyZ2V0LCB0Z3RNYW5FbmRwdCk7XG4gIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnKSB7XG4gICAgaW50ZXJzZWN0ID0gcnMudGd0SW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gIH0gZWxzZSB7XG4gICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcpIHtcbiAgICAgIHAxX2kgPSBwMTtcbiAgICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHAxX2kgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgICB9XG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0YXJnZXQub3V0ZXJXaWR0aCgpLCB0YXJnZXQub3V0ZXJIZWlnaHQoKSwgcDFfaVswXSwgcDFfaVsxXSwgMCwgdGd0Q29ybmVyUmFkaXVzLCB0Z3RScyk7XG4gICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHZhciB0cnMgPSB0YXJnZXQuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgbHcgPSB0cnMubGFiZWxXaWR0aDtcbiAgICAgIHZhciBsaCA9IHRycy5sYWJlbEhlaWdodDtcbiAgICAgIHZhciBseCA9IHRycy5sYWJlbFg7XG4gICAgICB2YXIgbHkgPSB0cnMubGFiZWxZO1xuICAgICAgdmFyIGx3MiA9IGx3IC8gMjtcbiAgICAgIHZhciBsaDIgPSBsaCAvIDI7XG4gICAgICB2YXIgdmEgPSB0YXJnZXQucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuICAgICAgaWYgKHZhID09PSAndG9wJykge1xuICAgICAgICBseSAtPSBsaDI7XG4gICAgICB9IGVsc2UgaWYgKHZhID09PSAnYm90dG9tJykge1xuICAgICAgICBseSArPSBsaDI7XG4gICAgICB9XG4gICAgICB2YXIgaGEgPSB0YXJnZXQucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuICAgICAgaWYgKGhhID09PSAnbGVmdCcpIHtcbiAgICAgICAgbHggLT0gbHcyO1xuICAgICAgfSBlbHNlIGlmIChoYSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBseCArPSBsdzI7XG4gICAgICB9XG4gICAgICB2YXIgbGFiZWxJbnRlcnNlY3QgPSBwb2x5Z29uSW50ZXJzZWN0TGluZShwMV9pWzBdLCBwMV9pWzFdLCBbbHggLSBsdzIsIGx5IC0gbGgyLCBseCArIGx3MiwgbHkgLSBsaDIsIGx4ICsgbHcyLCBseSArIGxoMiwgbHggLSBsdzIsIGx5ICsgbGgyXSwgdGd0UG9zLngsIHRndFBvcy55KTtcbiAgICAgIGlmIChsYWJlbEludGVyc2VjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciByZWZQdCA9IHNyY1BvcztcbiAgICAgICAgdmFyIGludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQoaW50ZXJzZWN0KSk7XG4gICAgICAgIHZhciBsYWJJbnRTcWRpc3QgPSBzcWRpc3QocmVmUHQsIGFycmF5MnBvaW50KGxhYmVsSW50ZXJzZWN0KSk7XG4gICAgICAgIHZhciBtaW5TcURpc3QgPSBpbnRTcWRpc3Q7XG4gICAgICAgIGlmIChsYWJJbnRTcWRpc3QgPCBpbnRTcWRpc3QpIHtcbiAgICAgICAgICBpbnRlcnNlY3QgPSBsYWJlbEludGVyc2VjdDtcbiAgICAgICAgICBtaW5TcURpc3QgPSBsYWJJbnRTcWRpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgbGFiSW50MlNxRGlzdCA9IHNxZGlzdChyZWZQdCwge1xuICAgICAgICAgICAgeDogbGFiZWxJbnRlcnNlY3RbMl0sXG4gICAgICAgICAgICB5OiBsYWJlbEludGVyc2VjdFszXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChsYWJJbnQyU3FEaXN0IDwgbWluU3FEaXN0KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3QgPSBbbGFiZWxJbnRlcnNlY3RbMl0sIGxhYmVsSW50ZXJzZWN0WzNdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGFycm93RW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkgKyB0Z3REaXN0KTtcbiAgdmFyIGVkZ2VFbmQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpICsgdGd0RGlzdCk7XG4gIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICBpbnRlcnNlY3QgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdC51bml0cykge1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHNvdXJjZSwgc3JjTWFuRW5kcHQpO1xuICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgIGludGVyc2VjdCA9IHJzLnNyY0ludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gcDI7XG4gICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gICAgfVxuICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShzb3VyY2UpXS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc291cmNlLm91dGVyV2lkdGgoKSwgc291cmNlLm91dGVySGVpZ2h0KCksIHAyX2lbMF0sIHAyX2lbMV0sIDAsIHNyY0Nvcm5lclJhZGl1cywgc3JjUnMpO1xuICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICB2YXIgc3JzID0gc291cmNlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIF9sdyA9IHNycy5sYWJlbFdpZHRoO1xuICAgICAgdmFyIF9saCA9IHNycy5sYWJlbEhlaWdodDtcbiAgICAgIHZhciBfbHggPSBzcnMubGFiZWxYO1xuICAgICAgdmFyIF9seSA9IHNycy5sYWJlbFk7XG4gICAgICB2YXIgX2x3MiA9IF9sdyAvIDI7XG4gICAgICB2YXIgX2xoMiA9IF9saCAvIDI7XG4gICAgICB2YXIgX3ZhID0gc291cmNlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcbiAgICAgIGlmIChfdmEgPT09ICd0b3AnKSB7XG4gICAgICAgIF9seSAtPSBfbGgyO1xuICAgICAgfSBlbHNlIGlmIChfdmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgIF9seSArPSBfbGgyO1xuICAgICAgfVxuICAgICAgdmFyIF9oYSA9IHNvdXJjZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG4gICAgICBpZiAoX2hhID09PSAnbGVmdCcpIHtcbiAgICAgICAgX2x4IC09IF9sdzI7XG4gICAgICB9IGVsc2UgaWYgKF9oYSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBfbHggKz0gX2x3MjtcbiAgICAgIH1cbiAgICAgIHZhciBfbGFiZWxJbnRlcnNlY3QgPSBwb2x5Z29uSW50ZXJzZWN0TGluZShwMl9pWzBdLCBwMl9pWzFdLCBbX2x4IC0gX2x3MiwgX2x5IC0gX2xoMiwgX2x4ICsgX2x3MiwgX2x5IC0gX2xoMiwgX2x4ICsgX2x3MiwgX2x5ICsgX2xoMiwgX2x4IC0gX2x3MiwgX2x5ICsgX2xoMl0sIHNyY1Bvcy54LCBzcmNQb3MueSk7XG4gICAgICBpZiAoX2xhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF9yZWZQdCA9IHRndFBvcztcbiAgICAgICAgdmFyIF9pbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIF9sYWJJbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChfbGFiZWxJbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIF9taW5TcURpc3QgPSBfaW50U3FkaXN0O1xuICAgICAgICBpZiAoX2xhYkludFNxZGlzdCA8IF9pbnRTcWRpc3QpIHtcbiAgICAgICAgICBpbnRlcnNlY3QgPSBbX2xhYmVsSW50ZXJzZWN0WzBdLCBfbGFiZWxJbnRlcnNlY3RbMV1dO1xuICAgICAgICAgIF9taW5TcURpc3QgPSBfbGFiSW50U3FkaXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhciBfbGFiSW50MlNxRGlzdCA9IHNxZGlzdChfcmVmUHQsIHtcbiAgICAgICAgICAgIHg6IF9sYWJlbEludGVyc2VjdFsyXSxcbiAgICAgICAgICAgIHk6IF9sYWJlbEludGVyc2VjdFszXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChfbGFiSW50MlNxRGlzdCA8IF9taW5TcURpc3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdCA9IFtfbGFiZWxJbnRlcnNlY3RbMl0sIF9sYWJlbEludGVyc2VjdFszXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBhcnJvd1N0YXJ0ID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAyLCByLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLnNwYWNpbmcoZWRnZSkgKyBzcmNEaXN0KTtcbiAgdmFyIGVkZ2VTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSkgKyBzcmNEaXN0KTtcbiAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG4gIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuICBpZiAoaGFzRW5kcHRzKSB7XG4gICAgaWYgKCFudW1iZXIkMShycy5zdGFydFgpIHx8ICFudW1iZXIkMShycy5zdGFydFkpIHx8ICFudW1iZXIkMShycy5lbmRYKSB8fCAhbnVtYmVyJDEocnMuZW5kWSkpIHtcbiAgICAgIHJzLmJhZExpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBycy5iYWRMaW5lID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuQlJwJGIuZ2V0U291cmNlRW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmhheXN0YWNrUHRzWzBdLFxuICAgICAgICB5OiBycy5oYXlzdGFja1B0c1sxXVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICAgIHk6IHJzLmFycm93U3RhcnRZXG4gICAgICB9O1xuICB9XG59O1xuQlJwJGIuZ2V0VGFyZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmhheXN0YWNrUHRzWzJdLFxuICAgICAgICB5OiBycy5oYXlzdGFja1B0c1szXVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgICB5OiBycy5hcnJvd0VuZFlcbiAgICAgIH07XG4gIH1cbn07XG5cbnZhciBCUnAkYSA9IHt9O1xuZnVuY3Rpb24gcHVzaEJlemllclB0cyhyLCBlZGdlLCBwdHMpIHtcbiAgdmFyIHFiZXppZXJBdCQxID0gZnVuY3Rpb24gcWJlemllckF0JDEocDEsIHAyLCBwMywgdCkge1xuICAgIHJldHVybiBxYmV6aWVyQXQocDEsIHAyLCBwMywgdCk7XG4gIH07XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJlemllclByb2pQY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSByLmJlemllclByb2pQY3RzW2ldO1xuICAgIGJwdHMucHVzaCh7XG4gICAgICB4OiBxYmV6aWVyQXQkMShwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCBwKSxcbiAgICAgIHk6IHFiZXppZXJBdCQxKHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIHApXG4gICAgfSk7XG4gIH1cbn1cbkJScCRhLnN0b3JlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuXG4gIC8vIGNsZWFyIHRoZSBjYWNoZWQgcG9pbnRzIHN0YXRlXG4gIF9wLnJzdHlsZS5iZXppZXJQdHMgPSBudWxsO1xuICBfcC5yc3R5bGUubGluZVB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IG51bGw7XG4gIGlmIChldCA9PT0gJ211bHRpYmV6aWVyJyB8fCBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdzZWxmJyB8fCBldCA9PT0gJ2NvbXBvdW5kJykge1xuICAgIF9wLnJzdHlsZS5iZXppZXJQdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHB1c2hCZXppZXJQdHModGhpcywgZWRnZSwgcnMuYWxscHRzLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV0ID09PSAnc2VnbWVudHMnKSB7XG4gICAgdmFyIGxwdHMgPSBfcC5yc3R5bGUubGluZVB0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICsgMSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgbHB0cy5wdXNoKHtcbiAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSArIDFdXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXQgPT09ICdoYXlzdGFjaycpIHtcbiAgICB2YXIgaHB0cyA9IHJzLmhheXN0YWNrUHRzO1xuICAgIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IFt7XG4gICAgICB4OiBocHRzWzBdLFxuICAgICAgeTogaHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IGhwdHNbMl0sXG4gICAgICB5OiBocHRzWzNdXG4gICAgfV07XG4gIH1cbiAgX3AucnN0eWxlLmFycm93V2lkdGggPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG59O1xuQlJwJGEucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgdGhpcy5maW5kRWRnZUNvbnRyb2xQb2ludHMoZWRnZXMpO1xufTtcblxudmFyIEJScCQ5ID0ge307XG5CUnAkOS5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgY29udGVudCA9IG5vZGUucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlO1xuICBpZiAoZW1wdHlTdHJpbmcoY29udGVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICB2YXIgbm9kZVBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIHRleHRIYWxpZ24gPSBub2RlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRWYWxpZ24gPSBub2RlLnBzdHlsZSgndGV4dC12YWxpZ24nKS5zdHJWYWx1ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHRleHRYID0gbm9kZVBvcy54ICsgbm9kZVdpZHRoIC8gMiArIHBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZS5nLiBjZW50ZXJcbiAgICAgIHRleHRYID0gbm9kZVBvcy54O1xuICB9XG4gIHN3aXRjaCAodGV4dFZhbGlnbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSArIG5vZGVIZWlnaHQgLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBlLmcuIG1pZGRsZVxuICAgICAgdGV4dFkgPSBub2RlUG9zLnk7XG4gIH1cbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcbiAgdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhub2RlKTtcbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhub2RlKTtcbn07XG52YXIgbGluZUFuZ2xlRnJvbURlbHRhID0gZnVuY3Rpb24gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSkge1xuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oZHkgLyBkeCk7XG4gIGlmIChkeCA9PT0gMCAmJiBhbmdsZSA8IDApIHtcbiAgICBhbmdsZSA9IGFuZ2xlICogLTE7XG4gIH1cbiAgcmV0dXJuIGFuZ2xlO1xufTtcbnZhciBsaW5lQW5nbGUgPSBmdW5jdGlvbiBsaW5lQW5nbGUocDAsIHAxKSB7XG4gIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICB2YXIgZHkgPSBwMS55IC0gcDAueTtcbiAgcmV0dXJuIGxpbmVBbmdsZUZyb21EZWx0YShkeCwgZHkpO1xufTtcbnZhciBiZXppZXJBbmdsZSA9IGZ1bmN0aW9uIGJlemllckFuZ2xlKHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIHQwID0gYm91bmQoMCwgdCAtIDAuMDAxLCAxKTtcbiAgdmFyIHQxID0gYm91bmQoMCwgdCArIDAuMDAxLCAxKTtcbiAgdmFyIGxwMCA9IHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQwKTtcbiAgdmFyIGxwMSA9IHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQxKTtcbiAgcmV0dXJuIGxpbmVBbmdsZShscDAsIGxwMSk7XG59O1xuQlJwJDkucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBwO1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGVudCA9IHtcbiAgICBtaWQ6IGVkZ2UucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlLFxuICAgIHNvdXJjZTogZWRnZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpLnN0clZhbHVlLFxuICAgIHRhcmdldDogZWRnZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpLnN0clZhbHVlXG4gIH07XG4gIGlmIChjb250ZW50Lm1pZCB8fCBjb250ZW50LnNvdXJjZSB8fCBjb250ZW50LnRhcmdldCkgOyBlbHNlIHtcbiAgICByZXR1cm47IC8vIG5vIGxhYmVscyA9PiBubyBjYWxjc1xuICB9XG5cbiAgLy8gYWRkIGNlbnRlciBwb2ludCB0byBzdHlsZSBzbyBib3VuZGluZyBib3ggY2FsY3VsYXRpb25zIGNhbiB1c2UgaXRcbiAgLy9cbiAgcCA9IHtcbiAgICB4OiBycy5taWRYLFxuICAgIHk6IHJzLm1pZFlcbiAgfTtcbiAgdmFyIHNldFJzID0gZnVuY3Rpb24gc2V0UnMocHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpIHtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgfTtcbiAgc2V0UnMoJ2xhYmVsWCcsIG51bGwsIHAueCk7XG4gIHNldFJzKCdsYWJlbFknLCBudWxsLCBwLnkpO1xuICB2YXIgbWlkQW5nbGUgPSBsaW5lQW5nbGVGcm9tRGVsdGEocnMubWlkRGlzcFgsIHJzLm1pZERpc3BZKTtcbiAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgbnVsbCwgbWlkQW5nbGUpO1xuICB2YXIgX2NyZWF0ZUNvbnRyb2xQb2ludEluZm8gPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCkge1xuICAgIGlmIChfY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSkge1xuICAgICAgcmV0dXJuIF9jcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlO1xuICAgIH0gLy8gdXNlIGNhY2hlIHNvIG9ubHkgMXggcGVyIGVkZ2VcblxuICAgIHZhciBjdHJscHRzID0gW107XG5cbiAgICAvLyBzdG9yZSBlYWNoIGN0cmxwdCBpbmZvIGluaXRcbiAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHZhciBwMCA9IHtcbiAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSArIDFdXG4gICAgICB9O1xuICAgICAgdmFyIHAxID0ge1xuICAgICAgICB4OiBycy5hbGxwdHNbaSArIDJdLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSArIDNdXG4gICAgICB9OyAvLyBjdHJscHRcbiAgICAgIHZhciBwMiA9IHtcbiAgICAgICAgeDogcnMuYWxscHRzW2kgKyA0XSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyA1XVxuICAgICAgfTtcbiAgICAgIGN0cmxwdHMucHVzaCh7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICBwMjogcDIsXG4gICAgICAgIHN0YXJ0RGlzdDogMCxcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICBzZWdtZW50czogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG4gICAgdmFyIG5Qcm9qcyA9IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIGFkZFNlZ21lbnQoY3AsIHAwLCBwMSwgdDAsIHQxKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGlzdChwMCwgcDEpO1xuICAgICAgdmFyIHByZXZTZWdtZW50ID0gY3Auc2VnbWVudHNbY3Auc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgICAgcDA6IHAwLFxuICAgICAgICBwMTogcDEsXG4gICAgICAgIHQwOiB0MCxcbiAgICAgICAgdDE6IHQxLFxuICAgICAgICBzdGFydERpc3Q6IHByZXZTZWdtZW50ID8gcHJldlNlZ21lbnQuc3RhcnREaXN0ICsgcHJldlNlZ21lbnQubGVuZ3RoIDogMCxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgIH07XG4gICAgICBjcC5zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgY3AubGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZWFjaCBjdHJscHQgd2l0aCBzZWdtZW50IGluZm9cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY3RybHB0cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBjcCA9IGN0cmxwdHNbX2ldO1xuICAgICAgdmFyIHByZXZDcCA9IGN0cmxwdHNbX2kgLSAxXTtcbiAgICAgIGlmIChwcmV2Q3ApIHtcbiAgICAgICAgY3Auc3RhcnREaXN0ID0gcHJldkNwLnN0YXJ0RGlzdCArIHByZXZDcC5sZW5ndGg7XG4gICAgICB9XG4gICAgICBhZGRTZWdtZW50KGNwLCBjcC5wMCwgYnB0c1tfaSAqIG5Qcm9qc10sIDAsIHIuYmV6aWVyUHJvalBjdHNbMF0pOyAvLyBmaXJzdFxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5Qcm9qcyAtIDE7IGorKykge1xuICAgICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgal0sIGJwdHNbX2kgKiBuUHJvanMgKyBqICsgMV0sIHIuYmV6aWVyUHJvalBjdHNbal0sIHIuYmV6aWVyUHJvalBjdHNbaiArIDFdKTtcbiAgICAgIH1cbiAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbX2kgKiBuUHJvanMgKyBuUHJvanMgLSAxXSwgY3AucDIsIHIuYmV6aWVyUHJvalBjdHNbblByb2pzIC0gMV0sIDEpOyAvLyBsYXN0XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSA9IGN0cmxwdHM7XG4gIH07XG4gIHZhciBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uID0gZnVuY3Rpb24gY2FsY3VsYXRlRW5kUHJvamVjdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgYW5nbGU7XG4gICAgdmFyIGlzU3JjID0gcHJlZml4ID09PSAnc291cmNlJztcbiAgICBpZiAoIWNvbnRlbnRbcHJlZml4XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy10ZXh0LW9mZnNldCcpLnBmVmFsdWU7XG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNwcyA9IF9jcmVhdGVDb250cm9sUG9pbnRJbmZvKCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIHZhciBzdGFydERpc3QgPSAwO1xuICAgICAgICAgIHZhciB0b3RhbERpc3QgPSAwO1xuXG4gICAgICAgICAgLy8gZmluZCB0aGUgc2VnbWVudCB3ZSdyZSBvblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2NwID0gY3BzW2lzU3JjID8gaSA6IGNwcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9jcC5zZWdtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgX3NlZyA9IF9jcC5zZWdtZW50c1tpc1NyYyA/IGogOiBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMSAtIGpdO1xuICAgICAgICAgICAgICB2YXIgbGFzdFNlZyA9IGkgPT09IGNwcy5sZW5ndGggLSAxICYmIGogPT09IF9jcC5zZWdtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBzdGFydERpc3QgPSB0b3RhbERpc3Q7XG4gICAgICAgICAgICAgIHRvdGFsRGlzdCArPSBfc2VnLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKHRvdGFsRGlzdCA+PSBvZmZzZXQgfHwgbGFzdFNlZykge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0ge1xuICAgICAgICAgICAgICAgICAgY3A6IF9jcCxcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IF9zZWdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjcCA9IHNlbGVjdGVkLmNwO1xuICAgICAgICAgIHZhciBzZWcgPSBzZWxlY3RlZC5zZWdtZW50O1xuICAgICAgICAgIHZhciB0U2VnbWVudCA9IChvZmZzZXQgLSBzdGFydERpc3QpIC8gc2VnLmxlbmd0aDtcbiAgICAgICAgICB2YXIgc2VnRHQgPSBzZWcudDEgLSBzZWcudDA7XG4gICAgICAgICAgdmFyIHQgPSBpc1NyYyA/IHNlZy50MCArIHNlZ0R0ICogdFNlZ21lbnQgOiBzZWcudDEgLSBzZWdEdCAqIHRTZWdtZW50O1xuICAgICAgICAgIHQgPSBib3VuZCgwLCB0LCAxKTtcbiAgICAgICAgICBwID0gcWJlemllclB0QXQoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgYW5nbGUgPSBiZXppZXJBbmdsZShjcC5wMCwgY3AucDEsIGNwLnAyLCB0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGQgPSAwLFxuICAgICAgICAgICAgZGksXG4gICAgICAgICAgICBkMDtcbiAgICAgICAgICB2YXIgcDAsIHAxO1xuICAgICAgICAgIHZhciBsID0gcnMuYWxscHRzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgKyAzIDwgbDsgX2kyICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChpc1NyYykge1xuICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbX2kyICsgMV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW19pMiArIDJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAzXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSAyIC0gX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDEgLSBfaTJdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHAxID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tsIC0gNCAtIF9pMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW2wgLSAzIC0gX2kyXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGkgPSBkaXN0KHAwLCBwMSk7XG4gICAgICAgICAgICBkMCA9IGQ7XG4gICAgICAgICAgICBkICs9IGRpO1xuICAgICAgICAgICAgaWYgKGQgPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcEQgPSBvZmZzZXQgLSBkMDtcbiAgICAgICAgICB2YXIgX3QgPSBwRCAvIGRpO1xuICAgICAgICAgIF90ID0gYm91bmQoMCwgX3QsIDEpO1xuICAgICAgICAgIHAgPSBsaW5lQXQocDAsIHAxLCBfdCk7XG4gICAgICAgICAgYW5nbGUgPSBsaW5lQW5nbGUocDAsIHAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRScygnbGFiZWxYJywgcHJlZml4LCBwLngpO1xuICAgIHNldFJzKCdsYWJlbFknLCBwcmVmaXgsIHAueSk7XG4gICAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgcHJlZml4LCBhbmdsZSk7XG4gIH07XG4gIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oJ3NvdXJjZScpO1xuICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCd0YXJnZXQnKTtcbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhlZGdlKTtcbn07XG5CUnAkOS5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSk7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAnc291cmNlJyk7XG4gICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuQlJwJDkuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoZWxlLCBwcmVmaXgpO1xuICB2YXIgY2FjaGVLZXkgPSBoYXNoU3RyaW5nKHRleHQsIGVsZS5fcHJpdmF0ZS5sYWJlbERpbXNLZXkpO1xuXG4gIC8vIHNhdmUgcmVjYWxjIGlmIHRoZSBsYWJlbCBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgaWYgKGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdwcmVmaXhlZExhYmVsRGltc0tleScsIHByZWZpeCkgPT09IGNhY2hlS2V5KSB7XG4gICAgcmV0dXJuOyAvLyB0aGVuIHRoZSBsYWJlbCBkaW1lbnNpb25zICsgdGV4dCBhcmUgdGhlIHNhbWVcbiAgfVxuXG4gIC8vIHNhdmUgdGhlIGtleVxuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAncHJlZml4ZWRMYWJlbERpbXNLZXknLCBwcmVmaXgsIGNhY2hlS2V5KTtcbiAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGV4dCk7XG4gIHZhciBsaW5lSGVpZ2h0ID0gZWxlLnBzdHlsZSgnbGluZS1oZWlnaHQnKS5wZlZhbHVlO1xuICB2YXIgdGV4dFdyYXAgPSBlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS5zdHJWYWx1ZTtcbiAgdmFyIGxpbmVzID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KSB8fCBbXTtcbiAgdmFyIG51bUxpbmVzID0gdGV4dFdyYXAgIT09ICd3cmFwJyA/IDEgOiBNYXRoLm1heChsaW5lcy5sZW5ndGgsIDEpO1xuICB2YXIgbm9ybVBlckxpbmVIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0IC8gbnVtTGluZXM7XG4gIHZhciBsYWJlbExpbmVIZWlnaHQgPSBub3JtUGVyTGluZUhlaWdodCAqIGxpbmVIZWlnaHQ7XG4gIHZhciB3aWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQgKyAobnVtTGluZXMgLSAxKSAqIChsaW5lSGVpZ2h0IC0gMSkgKiBub3JtUGVyTGluZUhlaWdodDtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCwgaGVpZ2h0KTtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsTGluZUhlaWdodCcsIHByZWZpeCwgbGFiZWxMaW5lSGVpZ2h0KTtcbn07XG5CUnAkOS5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGZkID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwZmQgKyAnbGFiZWwnKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRUcmFuc2Zvcm0gPSBlbGUucHN0eWxlKCd0ZXh0LXRyYW5zZm9ybScpLnZhbHVlO1xuICB2YXIgcnNjcmF0Y2ggPSBmdW5jdGlvbiByc2NyYXRjaChwcm9wTmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBmb3IgZW1wdHkgdGV4dCwgc2tpcCBhbGwgcHJvY2Vzc2luZ1xuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSA7IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHZhciB3cmFwU3R5bGUgPSBlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS52YWx1ZTtcbiAgaWYgKHdyYXBTdHlsZSA9PT0gJ3dyYXAnKSB7XG4gICAgdmFyIGxhYmVsS2V5ID0gcnNjcmF0Y2goJ2xhYmVsS2V5Jyk7XG5cbiAgICAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gICAgaWYgKGxhYmVsS2V5ICE9IG51bGwgJiYgcnNjcmF0Y2goJ2xhYmVsV3JhcEtleScpID09PSBsYWJlbEtleSkge1xuICAgICAgcmV0dXJuIHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRUZXh0Jyk7XG4gICAgfVxuICAgIHZhciB6d3NwID0gXCJcXHUyMDBCXCI7XG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIG1heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIG92ZXJmbG93ID0gZWxlLnBzdHlsZSgndGV4dC1vdmVyZmxvdy13cmFwJykudmFsdWU7XG4gICAgdmFyIG92ZXJmbG93QW55ID0gb3ZlcmZsb3cgPT09ICdhbnl3aGVyZSc7XG4gICAgdmFyIHdyYXBwZWRMaW5lcyA9IFtdO1xuICAgIHZhciBzZXBhcmF0b3JSZWdleCA9IC9bXFxzXFx1MjAwYl0rfCQvZzsgLy8gSW5jbHVkZSBlbmQgb2Ygc3RyaW5nIHRvIGFkZCBsYXN0IHdvcmRcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgIHZhciBsaW5lID0gbGluZXNbbF07XG4gICAgICB2YXIgbGluZURpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGxpbmUpO1xuICAgICAgdmFyIGxpbmVXID0gbGluZURpbXMud2lkdGg7XG4gICAgICBpZiAob3ZlcmZsb3dBbnkpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZExpbmUgPSBsaW5lLnNwbGl0KCcnKS5qb2luKHp3c3ApO1xuICAgICAgICBsaW5lID0gcHJvY2Vzc2VkTGluZTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lVyA+IG1heFcpIHtcbiAgICAgICAgLy8gbGluZSBpcyB0b28gbG9uZ1xuICAgICAgICB2YXIgc2VwYXJhdG9yTWF0Y2hlcyA9IGxpbmUubWF0Y2hBbGwoc2VwYXJhdG9yUmVnZXgpO1xuICAgICAgICB2YXIgc3VibGluZSA9ICcnO1xuICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IDA7XG4gICAgICAgIC8vIEFkZCBmYWtlIG1hdGNoXG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzZXBhcmF0b3JNYXRjaGVzKSxcbiAgICAgICAgICBfc3RlcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvck1hdGNoID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgd29yZFNlcGFyYXRvciA9IHNlcGFyYXRvck1hdGNoWzBdO1xuICAgICAgICAgICAgdmFyIHdvcmQgPSBsaW5lLnN1YnN0cmluZyhwcmV2aW91c0luZGV4LCBzZXBhcmF0b3JNYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBwcmV2aW91c0luZGV4ID0gc2VwYXJhdG9yTWF0Y2guaW5kZXggKyB3b3JkU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0ZXN0TGluZSA9IHN1YmxpbmUubGVuZ3RoID09PSAwID8gd29yZCA6IHN1YmxpbmUgKyB3b3JkICsgd29yZFNlcGFyYXRvcjtcbiAgICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGVzdExpbmUpO1xuICAgICAgICAgICAgdmFyIHRlc3RXID0gdGVzdERpbXMud2lkdGg7XG4gICAgICAgICAgICBpZiAodGVzdFcgPD0gbWF4Vykge1xuICAgICAgICAgICAgICAvLyB3b3JkIGZpdHMgb24gY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB3b3JkIHN0YXJ0cyBuZXcgbGluZVxuICAgICAgICAgICAgICBpZiAoc3VibGluZSkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN1YmxpbmUgPSB3b3JkICsgd29yZFNlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSdzIHJlbWFpbmluZyB0ZXh0LCBwdXQgaXQgaW4gYSB3cmFwcGVkIGxpbmVcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VibGluZS5tYXRjaCgvXltcXHNcXHUyMDBiXSskLykpIHtcbiAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICB3cmFwcGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuXG4gICAgcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgd3JhcHBlZExpbmVzKTtcbiAgICB0ZXh0ID0gcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZFRleHQnLCB3cmFwcGVkTGluZXMuam9pbignXFxuJykpO1xuICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknLCBsYWJlbEtleSk7XG4gIH0gZWxzZSBpZiAod3JhcFN0eWxlID09PSAnZWxsaXBzaXMnKSB7XG4gICAgdmFyIF9tYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBlbGxpcHNpemVkID0gJyc7XG4gICAgdmFyIGVsbGlwc2lzID0gXCJcXHUyMDI2XCI7XG4gICAgdmFyIGluY0xhc3RDaCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpLndpZHRoIDwgX21heFcpIHtcbiAgICAgIC8vIHRoZSBsYWJlbCBhbHJlYWR5IGZpdHNcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3aWR0aFdpdGhOZXh0Q2ggPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGVsbGlwc2l6ZWQgKyB0ZXh0W2ldICsgZWxsaXBzaXMpLndpZHRoO1xuICAgICAgaWYgKHdpZHRoV2l0aE5leHRDaCA+IF9tYXhXKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxsaXBzaXplZCArPSB0ZXh0W2ldO1xuICAgICAgaWYgKGkgPT09IHRleHQubGVuZ3RoIC0gMSkge1xuICAgICAgICBpbmNMYXN0Q2ggPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluY0xhc3RDaCkge1xuICAgICAgZWxsaXBzaXplZCArPSBlbGxpcHNpcztcbiAgICB9XG4gICAgcmV0dXJuIGVsbGlwc2l6ZWQ7XG4gIH0gLy8gaWYgZWxsaXBzaXplXG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuQlJwJDkuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIganVzdGlmaWNhdGlvbiA9IGVsZS5wc3R5bGUoJ3RleHQtanVzdGlmaWNhdGlvbicpLnN0clZhbHVlO1xuICB2YXIgdGV4dEhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG4gIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBzd2l0Y2ggKHRleHRIYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ganVzdGlmaWNhdGlvbjtcbiAgfVxufTtcbkJScCQ5LmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUsIHRleHQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcbiAgdmFyIGRvY3VtZW50ID0gY29udGFpbmVyV2luZG93LmRvY3VtZW50O1xuICB2YXIgcGFkZGluZyA9IDA7IC8vIGFkZCBwYWRkaW5nIGFyb3VuZCB0ZXh0IGRpbXMsIGFzIHRoZSBtZWFzdXJlbWVudCBpc24ndCB0aGF0IGFjY3VyYXRlXG4gIHZhciBmU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gIHZhciBzaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciB3ZWlnaHQgPSBlbGUucHN0eWxlKCdmb250LXdlaWdodCcpLnN0clZhbHVlO1xuICB2YXIgY2FudmFzID0gdGhpcy5sYWJlbENhbGNDYW52YXM7XG4gIHZhciBjMmQgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhc0NvbnRleHQ7XG4gIGlmICghY2FudmFzKSB7XG4gICAgY2FudmFzID0gdGhpcy5sYWJlbENhbGNDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjMmQgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgZHMgPSBjYW52YXMuc3R5bGU7XG4gICAgZHMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRzLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZHMudG9wID0gJy05OTk5cHgnO1xuICAgIGRzLnpJbmRleCA9ICctMSc7XG4gICAgZHMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIH1cbiAgYzJkLmZvbnQgPSBcIlwiLmNvbmNhdChmU3R5bGUsIFwiIFwiKS5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmYW1pbHkpO1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgIHZhciBtZXRyaWNzID0gYzJkLm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIHZhciB3ID0gTWF0aC5jZWlsKG1ldHJpY3Mud2lkdGgpO1xuICAgIHZhciBoID0gc2l6ZTtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHcsIHdpZHRoKTtcbiAgICBoZWlnaHQgKz0gaDtcbiAgfVxuICB3aWR0aCArPSBwYWRkaW5nO1xuICBoZWlnaHQgKz0gcGFkZGluZztcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn07XG5CUnAkOS5jYWxjdWxhdGVMYWJlbEFuZ2xlID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBwcmVmaXhEYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciByb3QgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICB2YXIgcm90U3RyID0gcm90LnN0clZhbHVlO1xuICBpZiAocm90U3RyID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgcm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICByZXR1cm4gcnMubGFiZWxBdXRvQW5nbGU7XG4gIH0gZWxzZSBpZiAocm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm90LnBmVmFsdWU7XG4gIH1cbn07XG5CUnAkOS5jYWxjdWxhdGVMYWJlbEFuZ2xlcyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICBycy5sYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSk7XG4gIGlmIChpc0VkZ2UpIHtcbiAgICBycy5zb3VyY2VMYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSwgJ3NvdXJjZScpO1xuICAgIHJzLnRhcmdldExhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlLCAndGFyZ2V0Jyk7XG4gIH1cbn07XG5cbnZhciBCUnAkOCA9IHt9O1xudmFyIFRPT19TTUFMTF9DVVRfUkVDVCA9IDI4O1xudmFyIHdhcm5lZEN1dFJlY3QgPSBmYWxzZTtcbkJScCQ4LmdldE5vZGVTaGFwZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykudmFsdWU7XG4gIGlmIChzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZScgJiYgKG5vZGUud2lkdGgoKSA8IFRPT19TTUFMTF9DVVRfUkVDVCB8fCBub2RlLmhlaWdodCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUKSkge1xuICAgIGlmICghd2FybmVkQ3V0UmVjdCkge1xuICAgICAgd2FybignVGhlIGBjdXRyZWN0YW5nbGVgIG5vZGUgc2hhcGUgY2FuIG5vdCBiZSB1c2VkIGF0IHNtYWxsIHNpemVzIHNvIGByZWN0YW5nbGVgIGlzIHVzZWQgaW5zdGVhZCcpO1xuICAgICAgd2FybmVkQ3V0UmVjdCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgfVxuICBpZiAobm9kZS5pc1BhcmVudCgpKSB7XG4gICAgaWYgKHNoYXBlID09PSAncmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kLXJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnY3V0LXJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdiYXJyZWwnKSB7XG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICB9XG4gIH1cbiAgaWYgKHNoYXBlID09PSAncG9seWdvbicpIHtcbiAgICB2YXIgcG9pbnRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykudmFsdWU7XG4gICAgcmV0dXJuIHIubm9kZVNoYXBlcy5tYWtlUG9seWdvbihwb2ludHMpLm5hbWU7XG4gIH1cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxudmFyIEJScCQ3ID0ge307XG5CUnAkNy5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShlbGVzKSB7XG4gICAgdmFyIGRpcnR5U3R5bGVDYWNoZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgZWxlc1RvVXBkYXRlLm1lcmdlKGVsZXMpO1xuICAgIGlmIChkaXJ0eVN0eWxlQ2FjaGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgICAgIHJzdHlsZS5jbGVhbkNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgci5iaW5kZXIoY3kpLm9uKCdib3VuZHMuKiBkaXJ0eS4qJywgZnVuY3Rpb24gb25EaXJ0eUJvdW5kcyhlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgIGVucXVldWUoZWxlKTtcbiAgfSkub24oJ3N0eWxlLiogYmFja2dyb3VuZC4qJywgZnVuY3Rpb24gb25EaXJ0eVN0eWxlKGUpIHtcbiAgICB2YXIgZWxlID0gZS50YXJnZXQ7XG4gICAgZW5xdWV1ZShlbGUsIGZhbHNlKTtcbiAgfSk7XG4gIHZhciB1cGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZUNhbGNzKHdpbGxEcmF3KSB7XG4gICAgaWYgKHdpbGxEcmF3KSB7XG4gICAgICB2YXIgZm5zID0gci5vblVwZGF0ZUVsZUNhbGNzRm5zO1xuXG4gICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gaGF2ZSB1cC10by1kYXRlIHN0eWxlIChlLmcuIHN0eWxlc2hlZXQgbWFwcGVycylcbiAgICAgIC8vIGJlZm9yZSBjYWxjdWxhdGluZyByZW5kZXJlZCBzdHlsZSAoYW5kIHBzdHlsZSBtaWdodCBub3QgYmUgY2FsbGVkIHlldClcbiAgICAgIGVsZXNUb1VwZGF0ZS5jbGVhblN0eWxlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1RvVXBkYXRlW2ldO1xuICAgICAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSAmJiAhcnN0eWxlLmNsZWFuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgZW5xdWV1ZShlbGUuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICAgICAgcnN0eWxlLmNsZWFuQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZucykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZm5zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBmbiA9IGZuc1tfaV07XG4gICAgICAgICAgZm4od2lsbERyYXcsIGVsZXNUb1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVsZXNUb1VwZGF0ZSk7XG4gICAgICBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9O1xuICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZUVsZUNhbGNzKHRydWUpO1xuICB9O1xuICByLmJlZm9yZVJlbmRlcih1cGRhdGVFbGVDYWxjcywgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZUNhbGNzKTtcbn07XG5CUnAkNy5vblVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBmbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSB0aGlzLm9uVXBkYXRlRWxlQ2FsY3NGbnMgfHwgW107XG4gIGZucy5wdXNoKGZuKTtcbn07XG5CUnAkNy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlcywgdXNlQ2FjaGUpIHtcbiAgdmFyIGlzQ2xlYW5Db25uZWN0ZWQgPSBmdW5jdGlvbiBpc0NsZWFuQ29ubmVjdGVkKGVsZSkge1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUucnN0eWxlLmNsZWFuQ29ubmVjdGVkO1xuICB9O1xuICBpZiAoZWxlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSB1c2VkIGZvciBjYWxjcyB3aGVuIGRlc3Ryb3llZCwgZS5nLiBlbGUuYm91bmRpbmdCb3goKVxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1c2UgY2FjaGUgYnkgZGVmYXVsdCBmb3IgcGVyZlxuICBpZiAodXNlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHVzZUNhY2hlID0gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcblxuICAgIC8vIGFuIGVkZ2UgbWF5IGJlIGltcGxpY2l0bHkgZGlydHkgYi9jIG9mIG9uZSBvZiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgLy8gKGFuZCBhIHJlcXVlc3QgZm9yIHJlY2FsYyBtYXkgY29tZSBpbiBiZXR3ZWVuIGZyYW1lcylcbiAgICBpZiAoZWxlLmlzRWRnZSgpICYmICghaXNDbGVhbkNvbm5lY3RlZChlbGUuc291cmNlKCkpIHx8ICFpc0NsZWFuQ29ubmVjdGVkKGVsZS50YXJnZXQoKSkpKSB7XG4gICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiBlbGUuaXNCdW5kbGVkQmV6aWVyKCkpIHtcbiAgICAgIGlmIChlbGUucGFyYWxsZWxFZGdlcygpLnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gIWVsZS5fcHJpdmF0ZS5yc3R5bGUuY2xlYW4gJiYgZWxlLmlzQnVuZGxlZEJlemllcigpO1xuICAgICAgfSkpIHtcbiAgICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb25seSB1cGRhdGUgaWYgZGlydHkgYW5kIGluIGdyYXBoXG4gICAgaWYgKHVzZUNhY2hlICYmIHJzdHlsZS5jbGVhbiB8fCBlbGUucmVtb3ZlZCgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHVwZGF0ZSBpZiBub3QgZGlzcGxheTogbm9uZVxuICAgIGlmIChlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlZGdlc1xuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cbiAgICByc3R5bGUuY2xlYW4gPSB0cnVlO1xuICB9XG5cbiAgLy8gdXBkYXRlIG5vZGUgZGF0YSBmcm9tIHByb2plY3Rpb25zXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2VsZSA9IG5vZGVzW19pMl07XG4gICAgdmFyIF9wMiA9IF9lbGUuX3ByaXZhdGU7XG4gICAgdmFyIF9yc3R5bGUgPSBfcDIucnN0eWxlO1xuICAgIHZhciBwb3MgPSBfZWxlLnBvc2l0aW9uKCk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oX2VsZSk7XG4gICAgX3JzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgIF9yc3R5bGUubm9kZVkgPSBwb3MueTtcbiAgICBfcnN0eWxlLm5vZGVXID0gX2VsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICBfcnN0eWxlLm5vZGVIID0gX2VsZS5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWU7XG4gIH1cbiAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyhlZGdlcyk7XG5cbiAgLy8gdXBkYXRlIGVkZ2UgZGF0YSBmcm9tIHByb2plY3Rpb25zXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgX2VsZTIgPSBlZGdlc1tfaTNdO1xuICAgIHZhciBfcDMgPSBfZWxlMi5fcHJpdmF0ZTtcbiAgICB2YXIgX3JzdHlsZTIgPSBfcDMucnN0eWxlO1xuICAgIHZhciBycyA9IF9wMy5yc2NyYXRjaDtcblxuICAgIC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG4gICAgX3JzdHlsZTIuc3JjWCA9IHJzLmFycm93U3RhcnRYO1xuICAgIF9yc3R5bGUyLnNyY1kgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICBfcnN0eWxlMi50Z3RYID0gcnMuYXJyb3dFbmRYO1xuICAgIF9yc3R5bGUyLnRndFkgPSBycy5hcnJvd0VuZFk7XG4gICAgX3JzdHlsZTIubWlkWCA9IHJzLm1pZFg7XG4gICAgX3JzdHlsZTIubWlkWSA9IHJzLm1pZFk7XG4gICAgX3JzdHlsZTIubGFiZWxBbmdsZSA9IHJzLmxhYmVsQW5nbGU7XG4gICAgX3JzdHlsZTIuc291cmNlTGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGU7XG4gICAgX3JzdHlsZTIudGFyZ2V0TGFiZWxBbmdsZSA9IHJzLnRhcmdldExhYmVsQW5nbGU7XG4gIH1cbn07XG5cbnZhciBCUnAkNiA9IHt9O1xuQlJwJDYudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgaWYgKCFlbGVzKSB7XG4gICAgLy8ganVzdCBsZXQgdGhpcyBiZSByZWNhbGN1bGF0ZWQgb24gdGhlIG5leHQgeiBzb3J0IHRpY2tcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlcy5kcmFnID0gW107XG4gIGVsZXMubm9uZHJhZyA9IFtdO1xuICB2YXIgZ3JhYlRhcmdldHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIGlmIChlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgZ3JhYlRhcmdldHMucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAocnMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMubm9uZHJhZy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHV0IHRoZSBncmFiIHRhcmdldCBub2RlcyBsYXN0IHNvIGl0J3Mgb24gdG9wIG9mIGl0cyBuZWlnaGJvdXJob29kXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhYlRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZ3JhYlRhcmdldHNbaV07XG4gICAgZWxlcy5kcmFnLnB1c2goZWxlKTtcbiAgfVxufTtcbkJScCQ2LmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IG51bGw7XG59O1xuQlJwJDYuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoZm9yY2VSZWNhbGMpIHtcbiAgaWYgKGZvcmNlUmVjYWxjIHx8ICF0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLmN5Lm11dGFibGVFbGVtZW50cygpLnRvQXJyYXkoKTtcbiAgICBlbGVzLnNvcnQoekluZGV4U29ydCk7XG4gICAgZWxlcy5pbnRlcmFjdGl2ZSA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaW50ZXJhY3RpdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICB0aGlzLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gIH1cbiAgcmV0dXJuIGVsZXM7XG59O1xuXG52YXIgQlJwJDUgPSB7fTtcbltCUnAkZSwgQlJwJGQsIEJScCRjLCBCUnAkYiwgQlJwJGEsIEJScCQ5LCBCUnAkOCwgQlJwJDcsIEJScCQ2XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoQlJwJDUsIHByb3BzKTtcbn0pO1xuXG52YXIgQlJwJDQgPSB7fTtcbkJScCQ0LmdldENhY2hlZEltYWdlID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NPcmlnaW4sIG9uTG9hZCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuICB2YXIgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF07XG4gIGlmIChjYWNoZSkge1xuICAgIGlmICghY2FjaGUuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgIGNhY2hlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuaW1hZ2U7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF0gPSBpbWFnZUNhY2hlW3VybF0gfHwge307XG4gICAgdmFyIGltYWdlID0gY2FjaGUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpbWFnZS5lcnJvciA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyAjMTU4MiBzYWZhcmkgZG9lc24ndCBsb2FkIGRhdGEgdXJpcyB3aXRoIGNyb3NzT3JpZ2luIHByb3Blcmx5XG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEyMzk3OFxuICAgIHZhciBkYXRhVXJpUHJlZml4ID0gJ2RhdGE6JztcbiAgICB2YXIgaXNEYXRhVXJpID0gdXJsLnN1YnN0cmluZygwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gZGF0YVVyaVByZWZpeDtcbiAgICBpZiAoIWlzRGF0YVVyaSkge1xuICAgICAgLy8gaWYgY3Jvc3NvcmlnaW4gaXMgJ251bGwnKHN0cmluZ2lmaWVkKSwgdGhlbiBtYW51YWxseSBzZXQgaXQgdG8gbnVsbCBcbiAgICAgIGNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW4gPT09ICdudWxsJyA/IG51bGwgOiBjcm9zc09yaWdpbjtcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47IC8vIHByZXZlbnQgdGFpbnRlZCBjYW52YXNcbiAgICB9XG4gICAgaW1hZ2Uuc3JjID0gdXJsO1xuICAgIHJldHVybiBpbWFnZTtcbiAgfVxufTtcblxudmFyIEJScCQzID0ge307XG5cbi8qIGdsb2JhbCBkb2N1bWVudCwgUmVzaXplT2JzZXJ2ZXIsIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuQlJwJDMucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsxXSk7IC8vIGNvcHlcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHRhcmdldFtpXTtcbiAgICAgIGlmICh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJpbmRlcih0KTtcbiAgICAgICAgcmVzLnB1c2goYi5vbi5hcHBseShiLCBhcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgdmFyIGIgPSB0aGlzLmJpbmRlcih0YXJnZXQpO1xuICByZXR1cm4gYi5vbi5hcHBseShiLCBhcmdzKTtcbn07XG5CUnAkMy5iaW5kZXIgPSBmdW5jdGlvbiAodGd0KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG4gIHZhciB0Z3RJc0RvbSA9IHRndCA9PT0gY29udGFpbmVyV2luZG93IHx8IHRndCA9PT0gY29udGFpbmVyV2luZG93LmRvY3VtZW50IHx8IHRndCA9PT0gY29udGFpbmVyV2luZG93LmRvY3VtZW50LmJvZHkgfHwgZG9tRWxlbWVudCh0Z3QpO1xuICBpZiAoci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPT0gbnVsbCkge1xuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250YWluZXJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gbm90IHN1cHBvcnRlZFxuICAgIH1cbiAgICByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9IHN1cHBvcnRzUGFzc2l2ZTtcbiAgfVxuICB2YXIgb24gPSBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAodGd0SXNEb20gJiYgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMpIHtcbiAgICAgIC8vIHJlcGxhY2UgdXNlQ2FwdHVyZSB3LyBvcHRzIG9ialxuICAgICAgYXJnc1syXSA9IHtcbiAgICAgICAgY2FwdHVyZTogdXNlQ2FwdHVyZSAhPSBudWxsID8gdXNlQ2FwdHVyZSA6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHIuYmluZGluZ3MucHVzaCh7XG4gICAgICB0YXJnZXQ6IHRndCxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbiAgICAodGd0LmFkZEV2ZW50TGlzdGVuZXIgfHwgdGd0Lm9uKS5hcHBseSh0Z3QsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG9uOiBvbixcbiAgICBhZGRFdmVudExpc3RlbmVyOiBvbixcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgYmluZDogb25cbiAgfTtcbn07XG5CUnAkMy5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLmlzTm9kZSgpICYmICFub2RlLmxvY2tlZCgpICYmIG5vZGUuZ3JhYmJhYmxlKCk7XG59O1xuQlJwJDMubm9kZUlzR3JhYmJhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHRoaXMubm9kZUlzRHJhZ2dhYmxlKG5vZGUpICYmIG5vZGUuaW50ZXJhY3RpdmUoKTtcbn07XG5CUnAkMy5sb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSByLmN5LndpbmRvdygpO1xuICB2YXIgaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpO1xuICB9O1xuICB2YXIgZ2V0U2hhZG93Um9vdCA9IGZ1bmN0aW9uIGdldFNoYWRvd1Jvb3QoZWxlbWVudCkge1xuICAgIHZhciByb290Tm9kZSA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgcm9vdCBub2RlIGlzIGEgc2hhZG93IHJvb3RcbiAgICBpZiAocm9vdE5vZGUgJiYgcm9vdE5vZGUubm9kZVR5cGUgPT09IDExICYmIHJvb3ROb2RlLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJvb3ROb2RlO1xuICAgIH1cbiAgfTtcbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiB0cmlnZ2VyRXZlbnRzKHRhcmdldCwgbmFtZXMsIGUsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICB0YXJnZXQgPSByLmN5O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgdGFyZ2V0LmVtaXQoe1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgdmFyIGlzTXVsdFNlbEtleURvd24gPSBmdW5jdGlvbiBpc011bHRTZWxLZXlEb3duKGUpIHtcbiAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5OyAvLyBtYXliZSBlLmFsdEtleVxuICB9O1xuICB2YXIgYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2ggPSBmdW5jdGlvbiBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCBkb3ducykge1xuICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcbiAgICBpZiAoci5jeS5oYXNDb21wb3VuZE5vZGVzKCkgJiYgZG93biAmJiBkb3duLnBhbm5hYmxlKCkpIHtcbiAgICAgIC8vIGEgZ3JhYmJhYmxlIGNvbXBvdW5kIG5vZGUgYmVsb3cgdGhlIGVsZSA9PiBubyBwYXNzdGhyb3VnaCBwYW5uaW5nXG4gICAgICBmb3IgKHZhciBpID0gMDsgZG93bnMgJiYgaSA8IGRvd25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkb3duID0gZG93bnNbaV07XG5cbiAgICAgICAgLy9pZiBhbnkgcGFyZW50IG5vZGUgaW4gZXZlbnQgaGllcmFyY2h5IGlzbid0IHBhbm5hYmxlLCByZWplY3QgcGFzc3Rocm91Z2hcbiAgICAgICAgaWYgKGRvd24uaXNOb2RlKCkgJiYgZG93bi5pc1BhcmVudCgpICYmICFkb3duLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhbGxvd1Bhc3N0aHJvdWdoO1xuICB9O1xuICB2YXIgc2V0R3JhYmJlZCA9IGZ1bmN0aW9uIHNldEdyYWJiZWQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICB9O1xuICB2YXIgc2V0RnJlZWQgPSBmdW5jdGlvbiBzZXRGcmVlZChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICB9O1xuICB2YXIgc2V0SW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRJbkRyYWdMYXllcihlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICB9O1xuICB2YXIgc2V0T3V0RHJhZ0xheWVyID0gZnVuY3Rpb24gc2V0T3V0RHJhZ0xheWVyKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICB9O1xuICB2YXIgc2V0R3JhYlRhcmdldCA9IGZ1bmN0aW9uIHNldEdyYWJUYXJnZXQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IHRydWU7XG4gIH07XG4gIHZhciByZW1vdmVHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlR3JhYlRhcmdldChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gZmFsc2U7XG4gIH07XG4gIHZhciBhZGRUb0RyYWdMaXN0ID0gZnVuY3Rpb24gYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpIHtcbiAgICB2YXIgbGlzdCA9IG9wdHMuYWRkVG9MaXN0O1xuICAgIHZhciBsaXN0SGFzRWxlID0gbGlzdC5oYXMoZWxlKTtcbiAgICBpZiAoIWxpc3RIYXNFbGUgJiYgZWxlLmdyYWJiYWJsZSgpICYmICFlbGUubG9ja2VkKCkpIHtcbiAgICAgIGxpc3QubWVyZ2UoZWxlKTtcbiAgICAgIHNldEdyYWJiZWQoZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcbiAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24gYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZSwgb3B0cykge1xuICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBpbm5lck5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgaW5uZXJOb2Rlcy5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIGFkZFRvRHJhZ0xpc3QoaW5uZXJOb2Rlcywgb3B0cyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzIGFuZCBpdHMgbmVpZ2hib3VyaG9vZCB0byB0aGUgZHJhZyBsYXllclxuICB2YXIgYWRkTm9kZXNUb0RyYWcgPSBmdW5jdGlvbiBhZGROb2Rlc1RvRHJhZyhub2Rlcywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gbm9kZXMuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgbm9kZXMubmVpZ2hib3Job29kKCkuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuICFoYXNDb21wb3VuZE5vZGVzIHx8IGVsZS5pc0VkZ2UoKTtcbiAgICAgIH0pLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZXMsIG9wdHMpOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcblxuICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG4gICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZXMsIHtcbiAgICAgIGluRHJhZ0xheWVyOiBvcHRzLmluRHJhZ0xheWVyXG4gICAgfSk7XG4gICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9O1xuICB2YXIgYWRkTm9kZVRvRHJhZyA9IGFkZE5vZGVzVG9EcmFnO1xuICB2YXIgZnJlZURyYWdnZWRFbGVtZW50cyA9IGZ1bmN0aW9uIGZyZWVEcmFnZ2VkRWxlbWVudHMoZ3JhYmJlZEVsZXMpIHtcbiAgICBpZiAoIWdyYWJiZWRFbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8ganVzdCBnbyBvdmVyIGFsbCBlbGVtZW50cyByYXRoZXIgdGhhbiBkb2luZyBhIGJ1bmNoIG9mIChwb3NzaWJseSBleHBlbnNpdmUpIHRyYXZlcnNhbHNcbiAgICByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBzZXRGcmVlZChlbGUpO1xuICAgICAgc2V0T3V0RHJhZ0xheWVyKGVsZSk7XG4gICAgICByZW1vdmVHcmFiVGFyZ2V0KGVsZSk7XG4gICAgfSk7XG4gICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9O1xuXG4gIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYW5jZXN0b3Igbm9kZXMgYW5kIGVkZ2VzIHNob3VsZCBnb1xuICAvLyB0byB0aGUgZHJhZyBsYXllciAob3Igc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkcmFnIGxheWVyKS5cbiAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZSwgb3B0cykge1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG4gICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZmluZCB0b3AtbGV2ZWwgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IG5vZGUuYW5jZXN0b3JzKCkub3JwaGFucygpO1xuXG4gICAgLy8gbm8gcGFyZW50IG5vZGU6IG5vIG5vZGVzIHRvIGFkZCB0byB0aGUgZHJhZyBsYXllclxuICAgIGlmIChwYXJlbnQuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKS5zcGF3blNlbGYoKS5tZXJnZShwYXJlbnQpLnVubWVyZ2Uobm9kZSkudW5tZXJnZShub2RlLmRlc2NlbmRhbnRzKCkpO1xuICAgIHZhciBlZGdlcyA9IG5vZGVzLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVkZ2VzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgdmFyIGJsdXJBY3RpdmVEb21FbGVtZW50ID0gZnVuY3Rpb24gYmx1ckFjdGl2ZURvbUVsZW1lbnQoKSB7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gbnVsbCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgIT0gbnVsbCkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9O1xuICB2YXIgaGF2ZU11dGF0aW9uc0FwaSA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGhhdmVSZXNpemVPYnNlcnZlckFwaSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgLy8gd2F0Y2ggZm9yIHdoZW4gdGhlIGN5IGNvbnRhaW5lciBpcyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0bnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG11dG4gPSBtdXRuc1tpXTtcbiAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAock5vZGVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcbiAgICAgICAgICAgIGlmIChyTm9kZSA9PT0gci5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICByLnJlbW92ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIucGFyZW50Tm9kZSwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHIuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG4gIHZhciBvblJlc2l6ZSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICByLmN5LnJlc2l6ZSgpO1xuICB9LCAxMDApO1xuICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgIHIuc3R5bGVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5zdHlsZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGF1dG8gcmVzaXplXG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3Jlc2l6ZScsIG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGlmIChoYXZlUmVzaXplT2JzZXJ2ZXJBcGkpIHtcbiAgICByLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyKTtcbiAgfVxuICB2YXIgZm9yRWFjaFVwID0gZnVuY3Rpb24gZm9yRWFjaFVwKGRvbUVsZSwgZm4pIHtcbiAgICB3aGlsZSAoZG9tRWxlICE9IG51bGwpIHtcbiAgICAgIGZuKGRvbUVsZSk7XG4gICAgICBkb21FbGUgPSBkb21FbGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH07XG4gIHZhciBpbnZhbGlkYXRlQ29vcmRzID0gZnVuY3Rpb24gaW52YWxpZGF0ZUNvb3JkcygpIHtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICB9O1xuICBmb3JFYWNoVXAoci5jb250YWluZXIsIGZ1bmN0aW9uIChkb21FbGUpIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICd0cmFuc2l0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnYW5pbWF0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gIH0pO1xuXG4gIC8vIHN0b3AgcmlnaHQgY2xpY2sgbWVudSBmcm9tIGFwcGVhcmluZyBvbiBjeVxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSBmdW5jdGlvbiBpbkJveFNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gci5zZWxlY3Rpb25bNF0gIT09IDA7XG4gIH07XG4gIHZhciBldmVudEluQ29udGFpbmVyID0gZnVuY3Rpb24gZXZlbnRJbkNvbnRhaW5lcihlKSB7XG4gICAgLy8gc2F2ZSBjeWNsZXMgaWYgbW91c2UgZXZlbnRzIGFyZW4ndCB0byBiZSBjYXB0dXJlZFxuICAgIHZhciBjb250YWluZXJQYWdlQ29vcmRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgdmFyIHggPSBjb250YWluZXJQYWdlQ29vcmRzWzBdO1xuICAgIHZhciB5ID0gY29udGFpbmVyUGFnZUNvb3Jkc1sxXTtcbiAgICB2YXIgd2lkdGggPSBjb250YWluZXJQYWdlQ29vcmRzWzJdO1xuICAgIHZhciBoZWlnaHQgPSBjb250YWluZXJQYWdlQ29vcmRzWzNdO1xuICAgIHZhciBwb3NpdGlvbnMgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXMgOiBbZV07XG4gICAgdmFyIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG4gICAgICBpZiAoeCA8PSBwLmNsaWVudFggJiYgcC5jbGllbnRYIDw9IHggKyB3aWR0aCAmJiB5IDw9IHAuY2xpZW50WSAmJiBwLmNsaWVudFkgPD0geSArIGhlaWdodCkge1xuICAgICAgICBhdExlYXN0T25lUG9zSW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXRMZWFzdE9uZVBvc0luc2lkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG4gICAgd2hpbGUgKHRQYXJlbnQpIHtcbiAgICAgIGlmICh0UGFyZW50ID09PSBjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVySXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRQYXJlbnQgPSB0UGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGlmICghY29udGFpbmVySXNUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFByaW1hcnkga2V5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gbW91c2Vkb3duSGFuZGxlcihlKSB7XG4gICAgaWYgKCFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZHVyaW5nIGxlZnQgbW91c2UgYnV0dG9uIGdlc3R1cmVzLCBpZ25vcmUgb3RoZXIgYnV0dG9uc1xuICAgIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMSAmJiBlLndoaWNoICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBncG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGdwb3NbMF0sIGdwb3NbMV0pO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IGdwb3M7XG4gICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBjaGVja0ZvclRhcGhvbGQgPSBmdW5jdGlvbiBjaGVja0ZvclRhcGhvbGQoKSB7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICBjbGVhclRpbWVvdXQoci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQpO1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgICAgZWxlLmVtaXQobWFrZUV2ZW50KCd0YXBob2xkJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgndGFwaG9sZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICB9O1xuXG4gICAgLy8gUmlnaHQgY2xpY2sgYnV0dG9uXG4gICAgaWYgKGUud2hpY2ggPT0gMykge1xuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IHRydWU7XG4gICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgbmVhci5lbWl0KGN4dEV2dCk7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcblxuICAgICAgLy8gUHJpbWFyeSBidXR0b25cbiAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHIubm9kZUlzR3JhYmJhYmxlKG5lYXIpKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlckdyYWIgPSBmdW5jdGlvbiB0cmlnZ2VyR3JhYihlbGUpIHtcbiAgICAgICAgICAgICAgZWxlLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldEdyYWJUYXJnZXQobmVhcik7XG4gICAgICAgICAgICBpZiAoIW5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKHRyaWdnZXJHcmFiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3ducyA9IG5lYXJzO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlZG93bicsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH0pO1xuICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSBlbHNlIGlmIChuZWFyLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTsgLy8gZm9yIGZ1dHVyZSBwYW5cbiAgICAgIH1cbiAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uIGJveCBjb29yZGluYXRlc1xuICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHNoYWRvd1Jvb3QgPSBnZXRTaGFkb3dSb290KHIuY29udGFpbmVyKTtcbiAgci5yZWdpc3RlckJpbmRpbmcoW2NvbnRhaW5lcldpbmRvdywgc2hhZG93Um9vdF0sICdtb3VzZW1vdmUnLCBmdW5jdGlvbiBtb3VzZW1vdmVIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBncG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGdwb3NbMF0sIGdwb3NbMV0pO1xuICAgIHZhciBtZG93blBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuICAgIHZhciBtZG93bkdQb3MgPSByLmhvdmVyRGF0YS5tZG93bkdQb3M7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFyID0gbnVsbDtcbiAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuICAgIGlmIChtZG93bkdQb3MpIHtcbiAgICAgIHZhciBkeCA9IGdwb3NbMF0gLSBtZG93bkdQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IGdwb3NbMV0gLSBtZG93bkdQb3NbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgPSBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci5kZXNrdG9wVGFwVGhyZXNob2xkMjtcbiAgICB9XG4gICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93bihlKTtcbiAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciB1cGRhdGVEcmFnRGVsdGEgPSBmdW5jdGlvbiB1cGRhdGVEcmFnRGVsdGEoKSB7XG4gICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuICAgICAgaWYgKGRyYWdEZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFswXSk7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgfVxuICAgIH07XG4gICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW1vdmUnLCAndm1vdXNlbW92ZScsICd0YXBkcmFnJ10sIGUsIHtcbiAgICAgIHg6IHBvc1swXSxcbiAgICAgIHk6IHBvc1sxXVxuICAgIH0pO1xuICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZ29JbnRvQm94TW9kZSA9IGZ1bmN0aW9uIGdvSW50b0JveE1vZGUoKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgnYm94c3RhcnQnKSk7XG4gICAgICB9XG4gICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH07XG5cbiAgICAvLyB0cmlnZ2VyIGNvbnRleHQgZHJhZyBpZiBybW91c2UgZG93blxuICAgIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMykge1xuICAgICAgLy8gYnV0IG9ubHkgaWYgb3ZlciB0aHJlc2hvbGRcbiAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgIHZhciBjeHRFdnQgPSBtYWtlRXZlbnQoJ2N4dGRyYWcnKTtcbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLmhvdmVyRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIuZW1pdChtYWtlRXZlbnQoJ2N4dGRyYWdvdXQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIgPSBuZWFyO1xuICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdjeHRkcmFnb3ZlcicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgYXJlIGRyYWcgcGFubmluZyB0aGUgZW50aXJlIGdyYXBoXG4gICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGRlbHRhUDtcbiAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuKSB7XG4gICAgICAgICAgdmFyIG1kUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgeDogKHBvc1swXSAtIG1kUG9zWzBdKSAqIHpvb20sXG4gICAgICAgICAgICB5OiAocG9zWzFdIC0gbWRQb3NbMV0pICogem9vbVxuICAgICAgICAgIH07XG4gICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjeS5wYW5CeShkZWx0YVApO1xuICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgnZHJhZ3BhbicpKTtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG4gICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICB9IGVsc2UgaWYgKHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5wYW5uYWJsZSgpKSkge1xuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgKG11bHRTZWxLZXlEb3duIHx8ICFjeS5wYW5uaW5nRW5hYmxlZCgpIHx8ICFjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkpIHtcbiAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCByLmhvdmVyRGF0YS5kb3ducyk7XG4gICAgICAgICAgaWYgKGFsbG93UGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChtZG93blBvcyk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvd24gJiYgZG93bi5wYW5uYWJsZSgpICYmIGRvd24uYWN0aXZlKCkpIHtcbiAgICAgICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG93biAmJiBkb3duLnBhbm5hYmxlKCkgJiYgZG93bi5hY3RpdmUoKSkge1xuICAgICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoIWRvd24gfHwgIWRvd24uZ3JhYmJlZCgpKSAmJiBuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGxhc3QsIFsnbW91c2VvdXQnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW92ZXInLCAndGFwZHJhZ292ZXInXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgci5ob3ZlckRhdGEubGFzdCA9IG5lYXI7XG4gICAgICB9XG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHRha2UgYWN0aW9uXG5cbiAgICAgICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIG11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAvLyB0aGVuIHNlbGVjdGlvbiBvdmVycmlkZXNcbiAgICAgICAgICAgIGlmIChkb3duICYmIGRvd24uZ3JhYmJlZCgpKSB7XG4gICAgICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgZG93bi5lbWl0KG1ha2VFdmVudCgnZnJlZW9uJykpO1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdChtYWtlRXZlbnQoJ2ZyZWUnKSk7XG4gICAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgICBkb3duLmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZW9uJykpO1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWUnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZG93bikpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgbm9kZVxuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG4gICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTsgLy8gaW5kaWNhdGUgdGhhdCB3ZSBhY3R1YWxseSBkaWQgZHJhZyB0aGUgbm9kZVxuXG4gICAgICAgICAgICAvLyBub3csIGFkZCB0aGUgZWxlbWVudHMgdG8gdGhlIGRyYWcgbGF5ZXIgaWYgbm90IGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpIHtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZW1lbnRzLCB7XG4gICAgICAgICAgICAgICAgaW5EcmFnTGF5ZXI6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChudW1iZXIkMShkaXNwWzBdKSAmJiBudW1iZXIkMShkaXNwWzFdKSkge1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG4gICAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnRGVsdGEgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzBdKSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuc2lsZW50U2hpZnQodG90YWxTaGlmdCkuZW1pdChtYWtlRXZlbnQoJ3Bvc2l0aW9uJykpLmVtaXQobWFrZUV2ZW50KCdkcmFnJykpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugc2F2ZSBkcmFnIGRlbHRhIGZvciB3aGVuIHdlIGFjdHVhbGx5IHN0YXJ0IGRyYWdnaW5nIHNvIHRoZSByZWxhdGl2ZSBncmFiIHBvcyBpcyBjb25zdGFudFxuICAgICAgICAgIHVwZGF0ZURyYWdEZWx0YSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXZlbnQgdGhlIGRyYWdnaW5nIGZyb20gdHJpZ2dlcmluZyB0ZXh0IHNlbGVjdGlvbiBvbiB0aGUgcGFnZVxuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIH1cbiAgICBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgc2VsZWN0WzNdID0gcG9zWzFdO1xuICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIGNsaWNrVGltZW91dCwgZGlkRG91YmxlQ2xpY2ssIHByZXZDbGlja1RpbWVTdGFtcDtcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uIG1vdXNldXBIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgLy8gZHVyaW5nIGxlZnQgbW91c2UgYnV0dG9uIGdlc3R1cmVzLCBpZ25vcmUgb3RoZXIgYnV0dG9uc1xuICAgIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMSAmJiBlLndoaWNoICE9PSAxICYmIHIuaG92ZXJEYXRhLmNhcHR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuICAgIGlmICghY2FwdHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKGUpO1xuICAgIGlmIChyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24pIHtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cbiAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7IC8vIG5vdCBhY3RpdmUgYmcgbm93XG5cbiAgICBpZiAoZG93bikge1xuICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgIHZhciBjeHRFdnQgPSBtYWtlRXZlbnQoJ2N4dHRhcGVuZCcpO1xuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dERyYWdnZWQpIHtcbiAgICAgICAgdmFyIGN4dFRhcCA9IG1ha2VFdmVudCgnY3h0dGFwJyk7XG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dFRhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRUYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMSkge1xuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNldXAnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJ10sIGUsIHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyLmRyYWdEYXRhLmRpZERyYWcgJiZcbiAgICAgIC8vIGRpZG4ndCBtb3ZlIGEgbm9kZSBhcm91bmRcbiAgICAgICFyLmhvdmVyRGF0YS5kcmFnZ2VkICYmXG4gICAgICAvLyBkaWRuJ3QgcGFuXG4gICAgICAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICYmXG4gICAgICAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgIXIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgLy8gZGlkbid0IG1vdmUgdG9vIG11Y2hcbiAgICAgICkge1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcImNsaWNrXCIsIFwidGFwXCIsIFwidmNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgZGlkRG91YmxlQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKGUudGltZVN0YW1wIC0gcHJldkNsaWNrVGltZVN0YW1wIDw9IGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSkge1xuICAgICAgICAgIGNsaWNrVGltZW91dCAmJiBjbGVhclRpbWVvdXQoY2xpY2tUaW1lb3V0KTtcbiAgICAgICAgICBkaWREb3VibGVDbGljayA9IHRydWU7XG4gICAgICAgICAgcHJldkNsaWNrVGltZVN0YW1wID0gbnVsbDtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcImRibGNsaWNrXCIsIFwiZGJsdGFwXCIsIFwidmRibGNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkaWREb3VibGVDbGljaykgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbXCJvbmVjbGlja1wiLCBcIm9uZXRhcFwiLCBcInZvbmVjbGlja1wiXSwgZSwge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKTtcbiAgICAgICAgICBwcmV2Q2xpY2tUaW1lU3RhbXAgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuICAgICAgaWYgKGRvd24gPT0gbnVsbCAvLyBub3QgbW91c2Vkb3duIG9uIG5vZGVcbiAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAmJiAhaXNNdWx0U2VsS2V5RG93bihlKSkge1xuICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgIGlmIChkcmFnZ2VkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbmdsZSBzZWxlY3Rpb25cbiAgICAgIGlmIChuZWFyID09IGRvd24gJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIGlmIChuZWFyICE9IG51bGwgJiYgbmVhci5fcHJpdmF0ZS5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSA7IGVsc2UgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyB8fCBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBuZWFyLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWFyLnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2UobmVhcikudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKHIuZ2V0QWxsSW5Cb3goc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdKSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIGlmIChib3gubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdib3hlbmQnKSk7XG4gICAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiBlbGVXb3VsZEJlU2VsZWN0ZWQoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnKSB7XG4gICAgICAgICAgYm94LmVtaXQobWFrZUV2ZW50KCdib3gnKSkuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdChtYWtlRXZlbnQoJ2JveHNlbGVjdCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2UoYm94KS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib3guZW1pdChtYWtlRXZlbnQoJ2JveCcpKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KG1ha2VFdmVudCgnYm94c2VsZWN0JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWx3YXlzIG5lZWQgcmVkcmF3IGluIGNhc2UgZWxlcyB1bnNlbGVjdGFibGVcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGRyYWcgcGFuXG4gICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXNlbGVjdFs0XSkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHZhciBkb3duV2FzR3JhYmJlZCA9IGRvd24gJiYgZG93bi5ncmFiYmVkKCk7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZW1lbnRzKTtcbiAgICAgICAgaWYgKGRvd25XYXNHcmFiYmVkKSB7XG4gICAgICAgICAgZG93bi5lbWl0KG1ha2VFdmVudCgnZnJlZW9uJykpO1xuICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KG1ha2VFdmVudCgnZnJlZScpKTtcbiAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICBkb3duLmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZW9uJykpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGVsc2Ugbm90IHJpZ2h0IG1vdXNlXG5cbiAgICBzZWxlY3RbNF0gPSAwO1xuICAgIHIuaG92ZXJEYXRhLmRvd24gPSBudWxsO1xuICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnID0gZmFsc2U7XG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBudWxsO1xuICAgIHIuaG92ZXJEYXRhLndoaWNoID0gbnVsbDtcbiAgfSwgZmFsc2UpO1xuICB2YXIgd2hlZWxEZWx0YXMgPSBbXTsgLy8gbG9nIG9mIGZpcnN0IE4gd2hlZWwgZGVsdGFzXG4gIHZhciB3aGVlbERlbHRhTiA9IDQ7IC8vIGhvdyBtYW55IGV2ZW50cyB0byBsb2dcbiAgdmFyIGluYWNjdXJhdGVTY3JvbGxEZXZpY2U7XG4gIHZhciBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yID0gMTAwMDAwOyAvLyBiYXNlIG9mIGluYWNjdXJhdGUgd2hlZWwgZGVsdGFzIChlLmcuIGJhc2UgNSBjb3VsZCB5aWVsZCB3aGVlbHMgb2YgMTAsIDI1LCA1MCwgZXRjLilcblxuICB2YXIgYWxsQXJlRGl2aXNpYmxlQnkgPSBmdW5jdGlvbiBhbGxBcmVEaXZpc2libGVCeShsaXN0LCBmYWN0b3IpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldICUgZmFjdG9yICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHZhciBhbGxBcmVTYW1lTWFnbml0dWRlID0gZnVuY3Rpb24gYWxsQXJlU2FtZU1hZ25pdHVkZShsaXN0KSB7XG4gICAgdmFyIGZpcnN0TWFnID0gTWF0aC5hYnMobGlzdFswXSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5hYnMobGlzdFtpXSkgIT09IGZpcnN0TWFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbiB3aGVlbEhhbmRsZXIoZSkge1xuICAgIHZhciBjbGFtcCA9IGZhbHNlO1xuICAgIHZhciBkZWx0YSA9IGUuZGVsdGFZO1xuICAgIGlmIChkZWx0YSA9PSBudWxsKSB7XG4gICAgICAvLyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGJyb3dzZXJzXG4gICAgICBpZiAoZS53aGVlbERlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgIGRlbHRhID0gZS53aGVlbERlbHRhWSAvIDQ7XG4gICAgICB9IGVsc2UgaWYgKGUud2hlZWxEZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIGRlbHRhID0gZS53aGVlbERlbHRhIC8gNDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIG5vIGNoYW5nZSBpbiB6b29tIChCdWc6IFpvb20gYmVjb21lcyBlcnJhdGljIG9uIHJhcGlkIHNjcm9sbCBkdWUgdG8gZGVsdGFZOiAwIGV2ZW50ICMzMzk0KVxuICAgIH1cbiAgICBpZiAoaW5hY2N1cmF0ZVNjcm9sbERldmljZSA9PSBudWxsKSB7XG4gICAgICBpZiAod2hlZWxEZWx0YXMubGVuZ3RoID49IHdoZWVsRGVsdGFOKSB7XG4gICAgICAgIC8vIHVzZSBsb2cgdG8gZGV0ZXJtaW5lIGlmIGluYWNjdXJhdGVcbiAgICAgICAgdmFyIHdkcyA9IHdoZWVsRGVsdGFzO1xuICAgICAgICBpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlID0gYWxsQXJlRGl2aXNpYmxlQnkod2RzLCA1KTtcbiAgICAgICAgaWYgKCFpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGFsbCBsYXJnZSB2YWx1ZXMgb2YgZXhhY3Qgc2FtZSBtYWduaXR1ZGVcbiAgICAgICAgICB2YXIgZmlyc3RNYWcgPSBNYXRoLmFicyh3ZHNbMF0pO1xuICAgICAgICAgIGluYWNjdXJhdGVTY3JvbGxEZXZpY2UgPSBhbGxBcmVTYW1lTWFnbml0dWRlKHdkcykgJiYgZmlyc3RNYWcgPiA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3ZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IgPSBNYXRoLm1pbihNYXRoLmFicyh3ZHNbaV0pLCBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnU2FtcGxlZCB3aGVlbCBkZWx0YXM6Jywgd2RzKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2luYWNjdXJhdGVTY3JvbGxEZXZpY2U6JywgaW5hY2N1cmF0ZVNjcm9sbERldmljZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yOicsIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2xhbXAgYW5kIGxvZyB1bnRpbCB3ZSByZWFjaCBOXG4gICAgICAgIHdoZWVsRGVsdGFzLnB1c2goZGVsdGEpO1xuICAgICAgICBjbGFtcCA9IHRydWU7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDbGFtcGluZyBpbml0aWFsIHdoZWVsIGV2ZW50cyB1bnRpbCB3ZSBnZXQgYSBnb29kIHNhbXBsZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5hY2N1cmF0ZVNjcm9sbERldmljZSkge1xuICAgICAgLy8ga2VlcCB1cGRhdGluZ1xuICAgICAgaW5hY2N1cmF0ZVNjcm9sbEZhY3RvciA9IE1hdGgubWluKE1hdGguYWJzKGRlbHRhKSwgaW5hY2N1cmF0ZVNjcm9sbEZhY3Rvcik7XG4gICAgICAvLyBjb25zb2xlLmxvZygnS2VlcCB1cGRhdGluZyBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yIGJleW9uZCBzYW1wbGUgaW4gY2FzZSB3ZSBkaWQgbm90IGdldCB0aGUgc21hbGxlc3QgcG9zc2libGUgdmFsOicsIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IpO1xuICAgIH1cbiAgICBpZiAoci5zY3JvbGxpbmdQYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB3aGlsZSBzY3JvbGxpbmcsIGlnbm9yZSB3aGVlbC10by16b29tXG5cbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgcnBvcyA9IFtwb3NbMF0gKiB6b29tICsgcGFuLngsIHBvc1sxXSAqIHpvb20gKyBwYW4ueV07XG4gICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkpIHtcbiAgICAgIC8vIGlmIHBhbiBkcmFnZ2luZyBvciBjeHQgZHJhZ2dpbmcsIHdoZWVsIG1vdmVtZW50cyBtYWtlIG5vIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoci5kYXRhLndoZWVsVGltZW91dCk7XG4gICAgICByLmRhdGEud2hlZWxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCAxNTApO1xuICAgICAgdmFyIGRpZmY7XG4gICAgICBpZiAoY2xhbXAgJiYgTWF0aC5hYnMoZGVsdGEpID4gNSkge1xuICAgICAgICBkZWx0YSA9IHNpZ251bShkZWx0YSkgKiA1O1xuICAgICAgfVxuICAgICAgZGlmZiA9IGRlbHRhIC8gLTI1MDtcbiAgICAgIGlmIChpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlKSB7XG4gICAgICAgIGRpZmYgLz0gaW5hY2N1cmF0ZVNjcm9sbEZhY3RvcjtcbiAgICAgICAgZGlmZiAqPSAzO1xuICAgICAgfVxuICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKGBkZWx0YSA9ICR7ZGVsdGF9LCBkaWZmID0gJHtkaWZmfSwgbW9kZSA9ICR7ZS5kZWx0YU1vZGV9YClcblxuICAgICAgdmFyIG5lZWRzV2hlZWxGaXggPSBlLmRlbHRhTW9kZSA9PT0gMTtcbiAgICAgIGlmIChuZWVkc1doZWVsRml4KSB7XG4gICAgICAgIC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3Wm9vbSA9IGN5Lnpvb20oKSAqIE1hdGgucG93KDEwLCBkaWZmKTtcbiAgICAgIGlmIChlLnR5cGUgPT09ICdnZXN0dXJlY2hhbmdlJykge1xuICAgICAgICBuZXdab29tID0gci5nZXN0dXJlU3RhcnRab29tICogZS5zY2FsZTtcbiAgICAgIH1cbiAgICAgIGN5Lnpvb20oe1xuICAgICAgICBsZXZlbDogbmV3Wm9vbSxcbiAgICAgICAgcmVuZGVyZWRQb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHJwb3NbMF0sXG4gICAgICAgICAgeTogcnBvc1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN5LmVtaXQoe1xuICAgICAgICB0eXBlOiBlLnR5cGUgPT09ICdnZXN0dXJlY2hhbmdlJyA/ICdwaW5jaHpvb20nIDogJ3Njcm9sbHpvb20nLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gIC8vIC0tXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuXG4gIC8vIGRpc2FibGUgbm9uc3RhbmRhcmQgd2hlZWwgZXZlbnRzXG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTW91c2VTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBvbGRlciBmaXJlZm94XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAnc2Nyb2xsJywgZnVuY3Rpb24gc2Nyb2xsSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHIuc2Nyb2xsaW5nUGFnZSA9IHRydWU7XG4gICAgY2xlYXJUaW1lb3V0KHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQpO1xuICAgIHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IGZhbHNlO1xuICAgIH0sIDI1MCk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIGRlc2t0b3Agc2FmYXJpIHBpbmNoIHRvIHpvb20gc3RhcnRcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdnZXN0dXJlc3RhcnQnLCBmdW5jdGlvbiBnZXN0dXJlU3RhcnRIYW5kbGVyKGUpIHtcbiAgICByLmdlc3R1cmVTdGFydFpvb20gPSByLmN5Lnpvb20oKTtcbiAgICBpZiAoIXIuaGFzVG91Y2hTdGFydGVkKSB7XG4gICAgICAvLyBkb24ndCBhZmZlY3QgdG91Y2ggZGV2aWNlcyBsaWtlIGlwaG9uZVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnZ2VzdHVyZWNoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCFyLmhhc1RvdWNoU3RhcnRlZCkge1xuICAgICAgLy8gZG9uJ3QgYWZmZWN0IHRvdWNoIGRldmljZXMgbGlrZSBpcGhvbmVcbiAgICAgIHdoZWVsSGFuZGxlcihlKTtcbiAgICB9XG4gIH0sIHRydWUpO1xuXG4gIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gIC8vIEhhbmRsZSBtb3VzZW91dCBvbiBDeXRvc2NhcGUgY29udGFpbmVyXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdXQnLCBmdW5jdGlvbiBtb3VzZU91dEhhbmRsZXIoZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHIuY3kuZW1pdCh7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGZhbHNlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW92ZXInLCBmdW5jdGlvbiBtb3VzZU92ZXJIYW5kbGVyKGUpIHtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICByLmN5LmVtaXQoe1xuICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuICB2YXIgZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MTsgLy8gc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gIHZhciBkaXN0YW5jZTEsIGRpc3RhbmNlMVNxOyAvLyBpbml0aWFsIGRpc3RhbmNlIGJldHdlZW4gZmluZ2VyIDEgYW5kIGZpbmdlciAyIGZvciBwaW5jaC10by16b29tXG4gIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG4gIHZhciBvZmZzZXRMZWZ0LCBvZmZzZXRUb3A7XG4gIHZhciBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0O1xuICB2YXIgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlO1xuICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfTtcbiAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbiBkaXN0YW5jZVNxKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKTtcbiAgfTtcbiAgdmFyIHRvdWNoc3RhcnRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0SGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoc3RhcnRIYW5kbGVyKGUpIHtcbiAgICByLmhhc1RvdWNoU3RhcnRlZCA9IHRydWU7XG4gICAgaWYgKCFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG4gICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gcmVjb3JkIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhyLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMpO1xuICAgICAgdmFyIG9mZnNldHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICAgIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gb2Zmc2V0c1syXTtcbiAgICAgIGNvbnRhaW5lckhlaWdodCA9IG9mZnNldHNbM107XG4gICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjF5MSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgZjJ4MSA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHR3b0ZpbmdlcnNTdGFydEluc2lkZSA9IDAgPD0gZjF4MSAmJiBmMXgxIDw9IGNvbnRhaW5lcldpZHRoICYmIDAgPD0gZjJ4MSAmJiBmMngxIDw9IGNvbnRhaW5lcldpZHRoICYmIDAgPD0gZjF5MSAmJiBmMXkxIDw9IGNvbnRhaW5lckhlaWdodCAmJiAwIDw9IGYyeTEgJiYgZjJ5MSA8PSBjb250YWluZXJIZWlnaHQ7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlKGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEpO1xuICAgICAgZGlzdGFuY2UxU3EgPSBkaXN0YW5jZVNxKGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEpO1xuICAgICAgY2VudGVyMSA9IFsoZjF4MSArIGYyeDEpIC8gMiwgKGYxeTEgKyBmMnkxKSAvIDJdO1xuICAgICAgbW9kZWxDZW50ZXIxID0gWyhjZW50ZXIxWzBdIC0gcGFuLngpIC8gem9vbSwgKGNlbnRlcjFbMV0gLSBwYW4ueSkgLyB6b29tXTtcblxuICAgICAgLy8gY29uc2lkZXIgY29udGV4dCB0YXBcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkID0gMjAwO1xuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGRTcSA9IGN4dERpc3RUaHJlc2hvbGQgKiBjeHREaXN0VGhyZXNob2xkO1xuICAgICAgaWYgKGRpc3RhbmNlMVNxIDwgY3h0RGlzdFRocmVzaG9sZFNxICYmICFlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMl0sIG5vd1szXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChuZWFyMSAmJiBuZWFyMS5pc05vZGUoKSkge1xuICAgICAgICAgIG5lYXIxLmFjdGl2YXRlKCkuZW1pdChtYWtlRXZlbnQoJ2N4dHRhcHN0YXJ0JykpO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG4gICAgICAgIH0gZWxzZSBpZiAobmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkpIHtcbiAgICAgICAgICBuZWFyMi5hY3RpdmF0ZSgpLmVtaXQobWFrZUV2ZW50KCdjeHR0YXBzdGFydCcpKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdjeHR0YXBzdGFydCcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gdHJ1ZTtcbiAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgLy8gaWdub3JlXG5cbiAgICAgIC8vIHNhZmFyaSBvbiBpb3MgcGFucyB0aGUgcGFnZSBvdGhlcndpc2UgKG5vcm1hbGx5IHlvdSBzaG91bGQgYmUgYWJsZSB0byBwcmV2ZW50ZGVmYXVsdCBvbiB0b3VjaG1vdmUuLi4pXG4gICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnRzID0gbmVhcnM7XG4gICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IG51bGw7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG5cbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKHNlbGVjdGVkTm9kZXMsIHtcbiAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcobmVhciwge1xuICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcbiAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZXMpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICBuLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hzdGFydCcsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgeDogbm93WzBdLFxuICAgICAgICB5OiBub3dbMV1cbiAgICAgIH0pO1xuICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICAvLyBUYXAsIHRhcGhvbGRcbiAgICAgIC8vIC0tLS0tXG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICBjbGVhclRpbWVvdXQoci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQpO1xuICAgICAgci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPT09IGZhbHNlICYmICFyLnBpbmNoaW5nIC8vIGlmIHBpbmNoaW5nLCB0aGVuIHRhcGhvbGQgdW5zZWxlY3Qgc2hvdWxkbid0IHRha2UgZWZmZWN0XG4gICAgICAgICYmICFyLnRvdWNoRGF0YS5zZWxlY3RpbmcgLy8gYm94IHNlbGVjdGlvbiBzaG91bGRuJ3QgYWxsb3cgdGFwaG9sZCB0aHJvdWdoXG4gICAgICAgICkge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoci50b3VjaERhdGEuc3RhcnQsIFsndGFwaG9sZCddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICB2YXIgc1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzUG9zW2ldID0gZWFybGllcltpXSA9IG5vd1tpXTtcbiAgICAgIH1cbiAgICAgIHZhciB0b3VjaDAgPSBlLnRvdWNoZXNbMF07XG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFt0b3VjaDAuY2xpZW50WCwgdG91Y2gwLmNsaWVudFldO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICB2YXIgdG91Y2htb3ZlSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAndG91Y2htb3ZlJywgdG91Y2htb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNobW92ZUhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG4gICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgfVxuICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3RhcnRHUG9zID0gci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb247XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG4gICAgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzBdICYmIHN0YXJ0R1Bvcykge1xuICAgICAgdmFyIGRpc3AgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRpc3Bbal0gPSBub3dbal0gLSBlYXJsaWVyW2pdO1xuICAgICAgfVxuICAgICAgdmFyIGR4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBzdGFydEdQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gc3RhcnRHUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDI7XG4gICAgfVxuXG4gICAgLy8gY29udGV4dCBzd2lwZSBjYW5jZWxsaW5nXG4gICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIC8vIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcShmMXgyLCBmMXkyLCBmMngyLCBmMnkyKTtcbiAgICAgIHZhciBmYWN0b3JTcSA9IGRpc3RhbmNlMlNxIC8gZGlzdGFuY2UxU3E7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkU3EgPSBkaXN0VGhyZXNob2xkICogZGlzdFRocmVzaG9sZDtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7XG5cbiAgICAgIC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcbiAgICAgIGlmIChmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EpIHtcbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgdmFyIGN4dEV2dCA9IG1ha2VFdmVudCgnY3h0dGFwZW5kJyk7XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnRleHQgc3dpcGVcbiAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIHZhciBjeHRFdnQgPSBtYWtlRXZlbnQoJ2N4dGRyYWcnKTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuZW1pdChjeHRFdnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICBpZiAoci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIuZW1pdChtYWtlRXZlbnQoJ2N4dGRyYWdvdXQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgci50b3VjaERhdGEuY3h0T3ZlciA9IG5lYXI7XG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnY3h0ZHJhZ292ZXInKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYm94IHNlbGVjdGlvblxuICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG4gICAgICBpZiAoIXIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgnYm94c3RhcnQnKSk7XG4gICAgICB9XG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gdHJ1ZTtcbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICBpZiAoIXNlbGVjdCB8fCBzZWxlY3QubGVuZ3RoID09PSAwIHx8IHNlbGVjdFswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdFswXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDMgKyAxO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDMgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICB9XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgLy8gcGluY2ggdG8gem9vbVxuICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gcGluY2gtdG8tem9vbVxuICAgICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgIGlmIChkcmFnZ2VkRWxlcykge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkZV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG4gICAgICAgICAgZGVfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgZGVfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgX3N0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICAgIC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgLy8gdmFyIGZhY3RvciA9IE1hdGguc3FydCggZGlzdGFuY2UyU3EgKSAvIE1hdGguc3FydCggZGlzdGFuY2UxU3EgKTtcbiAgICAgIHZhciBmYWN0b3IgPSBkaXN0YW5jZTIgLyBkaXN0YW5jZTE7XG4gICAgICBpZiAodHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKSB7XG4gICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTtcblxuICAgICAgICAvLyBkZWx0YSBmaW5nZXIgMlxuICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxO1xuXG4gICAgICAgIC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcbiAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KSAvIDI7XG4gICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkgLyAyO1xuXG4gICAgICAgIC8vIG5vdyBjYWxjdWxhdGUgdGhlIHpvb21cbiAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTtcblxuICAgICAgICAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcbiAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcbiAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG4gICAgICAgIGlmIChfc3RhcnQgJiYgX3N0YXJ0LmFjdGl2ZSgpKSB7XG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIF9zdGFydC51bmFjdGl2YXRlKCkuZW1pdChtYWtlRXZlbnQoJ2ZyZWVvbicpKTtcbiAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KG1ha2VFdmVudCgnZnJlZScpKTtcbiAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICBfc3RhcnQuZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlb24nKSk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWUnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN5LnZpZXdwb3J0KHtcbiAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICBwYW46IHBhbjIsXG4gICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgncGluY2h6b29tJykpO1xuICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZTI7XG4gICAgICAgIGYxeDEgPSBmMXgyO1xuICAgICAgICBmMXkxID0gZjF5MjtcbiAgICAgICAgZjJ4MSA9IGYyeDI7XG4gICAgICAgIGYyeTEgPSBmMnkyO1xuICAgICAgICByLnBpbmNoaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgICAgfVxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdICYmICFyLnRvdWNoRGF0YS5kaWRTZWxlY3QgLy8gZG9uJ3QgYWxsb3cgYm94IHNlbGVjdGlvbiB0byBkZWdyYWRlIHRvIHNpbmdsZSBmaW5nZXIgZXZlbnRzIGxpa2UgcGFubmluZ1xuICAgICkge1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICB2YXIgbGFzdCA9IHIudG91Y2hEYXRhLmxhc3Q7XG4gICAgICB2YXIgbmVhcjtcbiAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZykge1xuICAgICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRyYWdnaW5nIG5vZGVzXG4gICAgICBpZiAoY2FwdHVyZSAmJiBzdGFydCAhPSBudWxsICYmIHIubm9kZUlzRHJhZ2dhYmxlKHN0YXJ0KSkge1xuICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgIC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcbiAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhkcmFnZ2VkRWxlcywge1xuICAgICAgICAgICAgICBpbkRyYWdMYXllcjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7XG4gICAgICAgICAgdmFyIHRvdGFsU2hpZnQgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG51bWJlciQxKGRpc3BbMF0pICYmIG51bWJlciQxKGRpc3BbMV0pKSB7XG4gICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcbiAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMF0pICYmIG51bWJlciQxKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICBkcmFnZ2VkRWxlcy5zaWxlbnRTaGlmdCh0b3RhbFNoaWZ0KS5lbWl0KG1ha2VFdmVudCgncG9zaXRpb24nKSkuZW1pdChtYWtlRXZlbnQoJ2RyYWcnKSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gPT0gZWFybGllclswXSAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdID09IGVhcmxpZXJbMV0pIHtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBrZWVwIHRyYWNrIG9mIGRyYWcgZGVsdGEgZm9yIGxhdGVyXG4gICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcbiAgICAgICAgICBpZiAoZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFswXSk7XG4gICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdG91Y2htb3ZlXG4gICAgICB7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQgfHwgbmVhciwgWyd0b3VjaG1vdmUnLCAndGFwZHJhZycsICd2bW91c2Vtb3ZlJ10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKCFzdGFydCB8fCAhc3RhcnQuZ3JhYmJlZCgpKSAmJiBuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgbGFzdC5lbWl0KG1ha2VFdmVudCgndGFwZHJhZ291dCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ3RhcGRyYWdvdmVyJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByLnRvdWNoRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcbiAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vd1tpXSAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldICYmIGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYW5uaW5nXG4gICAgICBpZiAoY2FwdHVyZSAmJiAoc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5wYW5uYWJsZSgpKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goc3RhcnQsIHIudG91Y2hEYXRhLnN0YXJ0cyk7XG4gICAgICAgIGlmIChhbGxvd1Bhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICghci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uKSB7XG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgnZHJhZ3BhbicpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZHggKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkeSAqIHpvb21cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2RyYWdwYW4nKSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgZWFybGllcltqXSA9IG5vd1tqXTtcbiAgICB9XG5cbiAgICAvLyB0aGUgYWN0aXZlIGJnIGluZGljYXRvciBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG1ha2luZyBhIHN3aXBlIHRoYXQgaXMgbmVpdGhlciBmb3IgZHJhZ2dpbmcgbm9kZXMgb3IgcGFubmluZ1xuICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlcy5sZW5ndGggPiAwICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nICYmIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAhPSBudWxsKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHRvdWNoY2FuY2VsSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGNhbmNlbEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRvdWNoZW5kSGFuZGxlciwgZGlkRG91YmxlVG91Y2gsIHRvdWNoVGltZW91dCwgcHJldlRvdWNoVGltZVN0YW1wO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICd0b3VjaGVuZCcsIHRvdWNoZW5kSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoZW5kSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcbiAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG4gICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGlmIChzdGFydCkge1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICB2YXIgY3R4VGFwZW5kO1xuICAgIGlmIChyLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIGN0eFRhcGVuZCA9IG1ha2VFdmVudCgnY3h0dGFwZW5kJyk7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgc3RhcnQuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkKSB7XG4gICAgICAgIHZhciBjdHhUYXAgPSBtYWtlRXZlbnQoJ2N4dHRhcCcpO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBzdGFydC5lbWl0KGN0eFRhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjdHhUYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICByLnJlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcbiAgICBpZiAoIWUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgci50b3VjaERhdGEuc2VsZWN0aW5nKSB7XG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKHIuZ2V0QWxsSW5Cb3goc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdKSk7XG4gICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMV0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICBzZWxlY3RbNF0gPSAwO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdib3hlbmQnKSk7XG4gICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24gZWxlV291bGRCZVNlbGVjdGVkKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgICB9O1xuICAgICAgYm94LmVtaXQobWFrZUV2ZW50KCdib3gnKSkuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdChtYWtlRXZlbnQoJ2JveHNlbGVjdCcpKTtcbiAgICAgIGlmIChib3gubm9uZW1wdHkoKSkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIDsgZWxzZSBpZiAoZS50b3VjaGVzWzBdKSA7IGVsc2UgaWYgKCFlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgaWYgKHN0YXJ0V2FzR3JhYmJlZCkge1xuICAgICAgICAgIHN0YXJ0LmVtaXQobWFrZUV2ZW50KCdmcmVlb24nKSk7XG4gICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdChtYWtlRXZlbnQoJ2ZyZWUnKSk7XG4gICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgc3RhcnQuZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlb24nKSk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWUnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBkeCA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gLSBub3dbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICAvLyBUYXAgZXZlbnQsIHJvdWdobHkgc2FtZSBhcyBtb3VzZSBjbGljayBldmVudCBmb3IgdG91Y2hcbiAgICAgIGlmICghci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCkge1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ3RhcCcsICd2Y2xpY2snXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpZERvdWJsZVRvdWNoID0gZmFsc2U7XG4gICAgICAgIGlmIChlLnRpbWVTdGFtcCAtIHByZXZUb3VjaFRpbWVTdGFtcCA8PSBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpIHtcbiAgICAgICAgICB0b3VjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRvdWNoVGltZW91dCk7XG4gICAgICAgICAgZGlkRG91YmxlVG91Y2ggPSB0cnVlO1xuICAgICAgICAgIHByZXZUb3VjaFRpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWydkYmx0YXAnLCAndmRibGNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRpZERvdWJsZVRvdWNoKSByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ29uZXRhcCcsICd2b25lY2xpY2snXSwgZSwge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKTtcbiAgICAgICAgICBwcmV2VG91Y2hUaW1lU3RhbXAgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBkcmFnIG5vZGVzIGFyb3VuZFxuICAgICAgJiYgc3RhcnQuX3ByaXZhdGUuc2VsZWN0YWJsZSAmJiByZGlzdDIgPCByLnRvdWNoVGFwVGhyZXNob2xkMiAmJiAhci5waW5jaGluZyAvLyBwaW5jaCB0byB6b29tIHNob3VsZCBub3QgYWZmZWN0IHNlbGVjdGlvblxuICAgICAgKSB7XG4gICAgICAgIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKHN0YXJ0KS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgIHN0YXJ0LnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RhcnQuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgc3RhcnQudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgZWFybGllcltqXSA9IG5vd1tqXTtcbiAgICB9XG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IHRvdWNoc3RhcnRcblxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IG51bGw7XG4gICAgICByLnRvdWNoRGF0YS5kaWRTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGUgb2xkIHN0YXJ0IGdsb2JhbCBwb3MnbiBtYXkgbm90IGJlIHRoZSBzYW1lIGZpbmdlciB0aGF0IHJlbWFpbnNcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXTtcbiAgICAgIH1cbiAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvL3IucmVkcmF3KCk7XG4gIH0sIGZhbHNlKTtcblxuICAvLyBmYWxsYmFjayBjb21wYXRpYmlsaXR5IGxheWVyIGZvciBtcyBwb2ludGVyIGV2ZW50c1xuICBpZiAodHlwZW9mIFRvdWNoRXZlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIG1ha2VUb3VjaCA9IGZ1bmN0aW9uIG1ha2VUb3VjaChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgZm9yY2U6IDEsXG4gICAgICAgIGlkZW50aWZpZXI6IGUucG9pbnRlcklkLFxuICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IGUucGFnZVksXG4gICAgICAgIHJhZGl1c1g6IGUud2lkdGggLyAyLFxuICAgICAgICByYWRpdXNZOiBlLmhlaWdodCAvIDIsXG4gICAgICAgIHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIG1ha2VQb2ludGVyID0gZnVuY3Rpb24gbWFrZVBvaW50ZXIoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgIHRvdWNoOiBtYWtlVG91Y2goZSlcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgYWRkUG9pbnRlciA9IGZ1bmN0aW9uIGFkZFBvaW50ZXIoZSkge1xuICAgICAgcG9pbnRlcnMucHVzaChtYWtlUG9pbnRlcihlKSk7XG4gICAgfTtcbiAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXIoZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBvaW50ZXJzW2ldO1xuICAgICAgICBpZiAocC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgICAgcG9pbnRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHVwZGF0ZVBvaW50ZXIgPSBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGUpIHtcbiAgICAgIHZhciBwID0gcG9pbnRlcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQ7XG4gICAgICB9KVswXTtcbiAgICAgIHAuZXZlbnQgPSBlO1xuICAgICAgcC50b3VjaCA9IG1ha2VUb3VjaChlKTtcbiAgICB9O1xuICAgIHZhciBhZGRUb3VjaGVzVG9FdmVudCA9IGZ1bmN0aW9uIGFkZFRvdWNoZXNUb0V2ZW50KGUpIHtcbiAgICAgIGUudG91Y2hlcyA9IHBvaW50ZXJzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC50b3VjaDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHBvaW50ZXJJc01vdXNlID0gZnVuY3Rpb24gcG9pbnRlcklzTW91c2UoZSkge1xuICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZS5wb2ludGVyVHlwZSA9PT0gNDtcbiAgICB9O1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGFkZFBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoc3RhcnRIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcnVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICByZW1vdmVQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaGVuZEhhbmRsZXIoZSk7XG4gICAgfSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyY2FuY2VsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICByZW1vdmVQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaGNhbmNlbEhhbmRsZXIoZSk7XG4gICAgfSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVybW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdXBkYXRlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2htb3ZlSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIEJScCQyID0ge307XG5CUnAkMi5nZW5lcmF0ZVBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCdwb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHRoaXMucG9pbnRzLCBub2RlWCwgbm9kZVksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBoYXNNaXRlckJvdW5kczogbmFtZSAhPT0gJ3JlY3RhbmdsZScsXG4gICAgbWl0ZXJCb3VuZHM6IGZ1bmN0aW9uIG1pdGVyQm91bmRzKGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHN0cm9rZVdpZHRoLCBzdHJva2VQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIG1pdGVyQm94KHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBzdHJva2VXaWR0aCk7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlRWxsaXBzZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snZWxsaXBzZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdlbGxpcHNlJyxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIgKyBwYWRkaW5nLCBoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIGNoZWNrSW5FbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZVJvdW5kUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBvaW50czogcG9pbnRzLFxuICAgIGdldE9yQ3JlYXRlQ29ybmVyczogZnVuY3Rpb24gZ2V0T3JDcmVhdGVDb3JuZXJzKGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cywgcnMsIGZpZWxkKSB7XG4gICAgICBpZiAocnNbZmllbGRdICE9PSB1bmRlZmluZWQgJiYgcnNbZmllbGQgKyAnLWN4J10gPT09IGNlbnRlclggJiYgcnNbZmllbGQgKyAnLWN5J10gPT09IGNlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIHJzW2ZpZWxkXTtcbiAgICAgIH1cbiAgICAgIHJzW2ZpZWxkXSA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoIC8gMik7XG4gICAgICByc1tmaWVsZCArICctY3gnXSA9IGNlbnRlclg7XG4gICAgICByc1tmaWVsZCArICctY3knXSA9IGNlbnRlclk7XG4gICAgICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgcCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcG9pbnRzLmxlbmd0aCAvIDI7IF9pKyspIHtcbiAgICAgICAgcFtfaV0gPSB7XG4gICAgICAgICAgeDogY2VudGVyWCArIGhhbGZXICogcG9pbnRzW19pICogMl0sXG4gICAgICAgICAgeTogY2VudGVyWSArIGhhbGZIICogcG9pbnRzW19pICogMiArIDFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgaSxcbiAgICAgICAgcDEsXG4gICAgICAgIHAyLFxuICAgICAgICBwMyxcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICBwMSA9IHBbbGVuIC0gMV07XG4gICAgICAvLyBmb3IgZWFjaCBwb2ludFxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHAyID0gcFtpICUgbGVuXTtcbiAgICAgICAgcDMgPSBwWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICByc1tmaWVsZF1baV0gPSBnZXRSb3VuZENvcm5lcihwMSwgcDIsIHAzLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICBwMSA9IHAyO1xuICAgICAgICBwMiA9IHAzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJzW2ZpZWxkXTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzLCBycykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCdyb3VuZC1wb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMsIHRoaXMuZ2V0T3JDcmVhdGVDb3JuZXJzKGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cywgcnMsICdkcmF3Q29ybmVycycpKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMsIHJzKSB7XG4gICAgICByZXR1cm4gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nLCB0aGlzLmdldE9yQ3JlYXRlQ29ybmVycyhub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cywgcnMsICdjb3JuZXJzJykpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMsIHJzKSB7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMuZ2V0T3JDcmVhdGVDb3JuZXJzKGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cywgcnMsICdjb3JuZXJzJykpO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydyb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMsIGNvcm5lclJhZGl1cyk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZywgY29ybmVyUmFkaXVzKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IGNvcm5lclJhZGl1cztcbiAgICAgIGNvcm5lclJhZGl1cyA9IE1hdGgubWluKGhhbGZXaWR0aCwgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgICAgIHZhciBkaWFtID0gY29ybmVyUmFkaXVzICogMjtcblxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIGRpYW0sIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIGRpYW0sIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlQ3V0UmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydjdXQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ2N1dHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdjdXQtcmVjdGFuZ2xlJyxcbiAgICBjb3JuZXJMZW5ndGg6IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBudWxsLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVDdXRUcmlhbmdsZVB0czogZnVuY3Rpb24gZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciBjbCA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gdGhpcy5jb3JuZXJMZW5ndGggOiBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoO1xuXG4gICAgICAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgdHJpYW5nbGUgcHQgb24gWzQsIDVdXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBjbCwgeEJlZ2luICsgY2wsIHlCZWdpbiwgeEJlZ2luICsgY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gY2wsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgY2wsIHhFbmQgLSBjbCwgeUJlZ2luICsgY2xdLFxuICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBjbCwgeEVuZCAtIGNsLCB5RW5kLCB4RW5kIC0gY2wsIHlFbmQgLSBjbF0sXG4gICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyBjbCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gY2wsIHhCZWdpbiArIGNsLCB5RW5kIC0gY2xdXG4gICAgICB9O1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIGNQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSwgY29ybmVyUmFkaXVzKTtcbiAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtjUHRzLnRvcExlZnQuc3BsaWNlKDAsIDQpLCBjUHRzLnRvcFJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21SaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tTGVmdC5zcGxpY2UoMCwgNCldKTtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIGNsID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyB0aGlzLmNvcm5lckxlbmd0aCA6IGNvcm5lclJhZGl1cztcbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogY2wsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiBjbCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXRUcmlhbmdsZVB0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMudG9wTGVmdCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcFJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tUmlnaHQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21MZWZ0KTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVCYXJyZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JhcnJlbCddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdiYXJyZWwnLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIC8vIHVzZSB0d28gZml4ZWQgdCB2YWx1ZXMgZm9yIHRoZSBiZXppZXIgY3VydmUgYXBwcm94aW1hdGlvblxuXG4gICAgICB2YXIgdDAgPSAwLjE1O1xuICAgICAgdmFyIHQxID0gMC41O1xuICAgICAgdmFyIHQyID0gMC44NTtcbiAgICAgIHZhciBiUHRzID0gdGhpcy5nZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCArIDIgKiBwYWRkaW5nLCBoZWlnaHQgKyAyICogcGFkZGluZywgbm9kZVgsIG5vZGVZKTtcbiAgICAgIHZhciBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzID0gZnVuY3Rpb24gYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhwdHMpIHtcbiAgICAgICAgLy8gYXBwcm94aW1hdGUgY3VydmUgcHRzIGJhc2VkIG9uIHRoZSB0d28gdCB2YWx1ZXNcbiAgICAgICAgdmFyIG0wID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDApO1xuICAgICAgICB2YXIgbTEgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0MSk7XG4gICAgICAgIHZhciBtMiA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQyKTtcbiAgICAgICAgcmV0dXJuIFtwdHNbMF0sIHB0c1sxXSwgbTAueCwgbTAueSwgbTEueCwgbTEueSwgbTIueCwgbTIueSwgcHRzWzRdLCBwdHNbNV1dO1xuICAgICAgfTtcbiAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQoYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcExlZnQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tTGVmdCkpO1xuICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzOiBmdW5jdGlvbiBnZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoO1xuICAgICAgdmFyIGN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG4gICAgICB2YXIgY3RybFB0WE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmN0cmxQdE9mZnNldFBjdCAqIHdpZHRoO1xuXG4gICAgICAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgY29udHJvbCBwdCBvbiBbNCwgNV1cbiAgICAgIHZhciBwdHMgPSB7XG4gICAgICAgIHRvcExlZnQ6IFt4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luICsgd09mZnNldCwgeUJlZ2luXSxcbiAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gd09mZnNldCwgeUJlZ2luLCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0XSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gaE9mZnNldCwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQgLSB3T2Zmc2V0LCB5RW5kXSxcbiAgICAgICAgYm90dG9tTGVmdDogW3hCZWdpbiArIHdPZmZzZXQsIHlFbmQsIHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGhPZmZzZXRdXG4gICAgICB9O1xuICAgICAgcHRzLnRvcExlZnQuaXNUb3AgPSB0cnVlO1xuICAgICAgcHRzLnRvcFJpZ2h0LmlzVG9wID0gdHJ1ZTtcbiAgICAgIHB0cy5ib3R0b21MZWZ0LmlzQm90dG9tID0gdHJ1ZTtcbiAgICAgIHB0cy5ib3R0b21SaWdodC5pc0JvdHRvbSA9IHRydWU7XG4gICAgICByZXR1cm4gcHRzO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuXG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGhPZmZzZXQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiB3T2Zmc2V0LCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGJhcnJlbEN1cnZlUHRzID0gdGhpcy5nZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIHZhciBnZXRDdXJ2ZVQgPSBmdW5jdGlvbiBnZXRDdXJ2ZVQoeCwgeSwgY3VydmVQdHMpIHtcbiAgICAgICAgdmFyIHgwID0gY3VydmVQdHNbNF07XG4gICAgICAgIHZhciB4MSA9IGN1cnZlUHRzWzJdO1xuICAgICAgICB2YXIgeDIgPSBjdXJ2ZVB0c1swXTtcbiAgICAgICAgdmFyIHkwID0gY3VydmVQdHNbNV07XG4gICAgICAgIC8vIHZhciB5MSA9IGN1cnZlUHRzWyAzIF07XG4gICAgICAgIHZhciB5MiA9IGN1cnZlUHRzWzFdO1xuICAgICAgICB2YXIgeE1pbiA9IE1hdGgubWluKHgwLCB4Mik7XG4gICAgICAgIHZhciB4TWF4ID0gTWF0aC5tYXgoeDAsIHgyKTtcbiAgICAgICAgdmFyIHlNaW4gPSBNYXRoLm1pbih5MCwgeTIpO1xuICAgICAgICB2YXIgeU1heCA9IE1hdGgubWF4KHkwLCB5Mik7XG4gICAgICAgIGlmICh4TWluIDw9IHggJiYgeCA8PSB4TWF4ICYmIHlNaW4gPD0geSAmJiB5IDw9IHlNYXgpIHtcbiAgICAgICAgICB2YXIgY29lZmYgPSBiZXppZXJQdHNUb1F1YWRDb2VmZih4MCwgeDEsIHgyKTtcbiAgICAgICAgICB2YXIgcm9vdHMgPSBzb2x2ZVF1YWRyYXRpYyhjb2VmZlswXSwgY29lZmZbMV0sIGNvZWZmWzJdLCB4KTtcbiAgICAgICAgICB2YXIgdmFsaWRSb290cyA9IHJvb3RzLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuIDAgPD0gciAmJiByIDw9IDE7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHZhbGlkUm9vdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkUm9vdHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHZhciBjdXJ2ZVJlZ2lvbnMgPSBPYmplY3Qua2V5cyhiYXJyZWxDdXJ2ZVB0cyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlUmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29ybmVyID0gY3VydmVSZWdpb25zW2ldO1xuICAgICAgICB2YXIgY29ybmVyUHRzID0gYmFycmVsQ3VydmVQdHNbY29ybmVyXTtcbiAgICAgICAgdmFyIHQgPSBnZXRDdXJ2ZVQoeCwgeSwgY29ybmVyUHRzKTtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5MCA9IGNvcm5lclB0c1s1XTtcbiAgICAgICAgdmFyIHkxID0gY29ybmVyUHRzWzNdO1xuICAgICAgICB2YXIgeTIgPSBjb3JuZXJQdHNbMV07XG4gICAgICAgIHZhciBiZXpZID0gcWJlemllckF0KHkwLCB5MSwgeTIsIHQpO1xuICAgICAgICBpZiAoY29ybmVyUHRzLmlzVG9wICYmIGJlelkgPD0geSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JuZXJQdHMuaXNCb3R0b20gJiYgeSA8PSBiZXpZKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVCb3R0b21Sb3VuZHJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snYm90dG9tLXJvdW5kLXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydib3R0b21yb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMsIGNvcm5lclJhZGl1cyk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcEVuZFkgPSB0b3BTdGFydFk7XG4gICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcEludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG4gICAgICBpZiAodG9wSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0b3BJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcsIGNvcm5lclJhZGl1cyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBkaWFtID0gMiAqIGNvcm5lclJhZGl1cztcblxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIGRpYW0sIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIGRpYW0sIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIG5vbi1yb3VuZGVkIHRvcCBzaWRlXG4gICAgICB2YXIgb3V0ZXJXaWR0aCA9IHdpZHRoIC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0IC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgdmFyIHBvaW50cyA9IFtjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0LCBjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHRdO1xuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5yZWdpc3Rlck5vZGVTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlU2hhcGVzID0gdGhpcy5ub2RlU2hhcGVzID0ge307XG4gIHZhciByZW5kZXJlciA9IHRoaXM7XG4gIHRoaXMuZ2VuZXJhdGVFbGxpcHNlKCk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0cmlhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRyaWFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3JlY3RhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSk7XG4gIG5vZGVTaGFwZXNbJ3NxdWFyZSddID0gbm9kZVNoYXBlc1sncmVjdGFuZ2xlJ107XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSgpO1xuICB0aGlzLmdlbmVyYXRlQ3V0UmVjdGFuZ2xlKCk7XG4gIHRoaXMuZ2VuZXJhdGVCYXJyZWwoKTtcbiAgdGhpcy5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlKCk7XG4gIHtcbiAgICB2YXIgZGlhbW9uZFBvaW50cyA9IFswLCAxLCAxLCAwLCAwLCAtMSwgLTEsIDBdO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdkaWFtb25kJywgZGlhbW9uZFBvaW50cyk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtZGlhbW9uZCcsIGRpYW1vbmRQb2ludHMpO1xuICB9XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdwZW50YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXBlbnRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2hleGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1oZXhhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2hlcHRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtaGVwdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignb2N0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLW9jdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkpO1xuICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoMjApO1xuICB7XG4gICAgdmFyIG91dGVyUG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCAwKTtcbiAgICB2YXIgaW5uZXJQb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIE1hdGguUEkgLyA1KTtcblxuICAgIC8vIE91dGVyIHJhZGl1cyBpcyAxOyBpbm5lciByYWRpdXMgb2Ygc3RhciBpcyBzbWFsbGVyXG4gICAgdmFyIGlubmVyUmFkaXVzID0gMC41ICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lclBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGlubmVyUG9pbnRzW2kgKiAyXSAqPSBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUG9pbnRzW2kgKiAyICsgMV0gKj0gaW5uZXJSYWRpdXM7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjAgLyA0OyBpKyspIHtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0XSA9IG91dGVyUG9pbnRzW2kgKiAyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMV0gPSBvdXRlclBvaW50c1tpICogMiArIDFdO1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAyXSA9IGlubmVyUG9pbnRzW2kgKiAyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgM10gPSBpbm5lclBvaW50c1tpICogMiArIDFdO1xuICAgIH1cbiAgfVxuICBzdGFyNVBvaW50cyA9IGZpdFBvbHlnb25Ub1NxdWFyZShzdGFyNVBvaW50cyk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdzdGFyJywgc3RhcjVQb2ludHMpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigndmVlJywgWy0xLCAtMSwgMCwgLTAuMzMzLCAxLCAtMSwgMCwgMV0pO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmhvbWJvaWQnLCBbLTEsIC0xLCAwLjMzMywgLTEsIDEsIDEsIC0wLjMzMywgMV0pO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmlnaHQtcmhvbWJvaWQnLCBbLTAuMzMzLCAtMSwgMSwgLTEsIDAuMzMzLCAxLCAtMSwgMV0pO1xuICB0aGlzLm5vZGVTaGFwZXNbJ2NvbmNhdmVoZXhhZ29uJ10gPSB0aGlzLmdlbmVyYXRlUG9seWdvbignY29uY2F2ZS1oZXhhZ29uJywgWy0xLCAtMC45NSwgLTAuNzUsIDAsIC0xLCAwLjk1LCAxLCAwLjk1LCAwLjc1LCAwLCAxLCAtMC45NV0pO1xuICB7XG4gICAgdmFyIHRhZ1BvaW50cyA9IFstMSwgLTEsIDAuMjUsIC0xLCAxLCAwLCAwLjI1LCAxLCAtMSwgMV07XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3RhZycsIHRhZ1BvaW50cyk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtdGFnJywgdGFnUG9pbnRzKTtcbiAgfVxuICBub2RlU2hhcGVzLm1ha2VQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgIC8vIHVzZSBjYWNoaW5nIG9uIHVzZXItc3BlY2lmaWVkIHBvbHlnb25zIHNvIHRoZXkgYXJlIGFzIGZhc3QgYXMgbmF0aXZlIHNoYXBlc1xuXG4gICAgdmFyIGtleSA9IHBvaW50cy5qb2luKCckJyk7XG4gICAgdmFyIG5hbWUgPSAncG9seWdvbi0nICsga2V5O1xuICAgIHZhciBzaGFwZTtcbiAgICBpZiAoc2hhcGUgPSB0aGlzW25hbWVdKSB7XG4gICAgICAvLyBnb3QgY2FjaGVkIHNoYXBlXG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFuZCBjYWNoZSBuZXcgc2hhcGVcbiAgICByZXR1cm4gcmVuZGVyZXIuZ2VuZXJhdGVQb2x5Z29uKG5hbWUsIHBvaW50cyk7XG4gIH07XG59O1xuXG52YXIgQlJwJDEgPSB7fTtcbkJScCQxLnRpbWVUb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVkcmF3VG90YWxUaW1lIC8gdGhpcy5yZWRyYXdDb3VudDtcbn07XG5CUnAkMS5yZWRyYXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICB2YXIgciA9IHRoaXM7XG4gIGlmIChyLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDtcbiAgfVxuICBpZiAoci5sYXN0UmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5sYXN0UmVkcmF3VGltZSA9IDA7XG4gIH1cbiAgaWYgKHIubGFzdERyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmxhc3REcmF3VGltZSA9IDA7XG4gIH1cbiAgci5yZXF1ZXN0ZWRGcmFtZSA9IHRydWU7XG4gIHIucmVuZGVyT3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuQlJwJDEuYmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKGZuLCBwcmlvcml0eSkge1xuICAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYWRkIHRpY2sgY2FsbGJhY2tzIHdoZW4gZGVzdHJveWVkXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJpb3JpdHkgPT0gbnVsbCkge1xuICAgIGVycm9yKCdQcmlvcml0eSBpcyBub3Qgb3B0aW9uYWwgZm9yIGJlZm9yZVJlbmRlcicpO1xuICB9XG4gIHZhciBjYnMgPSB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcbiAgY2JzLnB1c2goe1xuICAgIGZuOiBmbixcbiAgICBwcmlvcml0eTogcHJpb3JpdHlcbiAgfSk7XG5cbiAgLy8gaGlnaGVyIHByaW9yaXR5IGNhbGxiYWNrcyBleGVjdXRlZCBmaXJzdFxuICBjYnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcbiAgfSk7XG59O1xudmFyIGJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IGZ1bmN0aW9uIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCB3aWxsRHJhdywgc3RhcnRUaW1lKSB7XG4gIHZhciBjYnMgPSByLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICBjYnNbaV0uZm4od2lsbERyYXcsIHN0YXJ0VGltZSk7XG4gIH1cbn07XG5CUnAkMS5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcbiAgaWYgKHIucmVuZGVyTG9vcFN0YXJ0ZWQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgci5yZW5kZXJMb29wU3RhcnRlZCA9IHRydWU7XG4gIH1cbiAgdmFyIF9yZW5kZXJGbiA9IGZ1bmN0aW9uIHJlbmRlckZuKHJlcXVlc3RUaW1lKSB7XG4gICAgaWYgKHIuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjeS5iYXRjaGluZygpKSA7IGVsc2UgaWYgKHIucmVxdWVzdGVkRnJhbWUgJiYgIXIuc2tpcEZyYW1lKSB7XG4gICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgdHJ1ZSwgcmVxdWVzdFRpbWUpO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICByLnJlbmRlcihyLnJlbmRlck9wdGlvbnMpO1xuICAgICAgdmFyIGVuZFRpbWUgPSByLmxhc3REcmF3VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgICAgaWYgKHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHIucmVkcmF3Q291bnQrKztcbiAgICAgIGlmIChyLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBkdXJhdGlvbjtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBkdXJhdGlvbjtcblxuICAgICAgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUgLyAyICsgZHVyYXRpb24gLyAyO1xuICAgICAgci5yZXF1ZXN0ZWRGcmFtZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgZmFsc2UsIHJlcXVlc3RUaW1lKTtcbiAgICB9XG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3JlbmRlckZuKTtcbiAgfTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9yZW5kZXJGbik7XG59O1xuXG52YXIgQmFzZVJlbmRlcmVyID0gZnVuY3Rpb24gQmFzZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5pbml0KG9wdGlvbnMpO1xufTtcbnZhciBCUiA9IEJhc2VSZW5kZXJlcjtcbnZhciBCUnAgPSBCUi5wcm90b3R5cGU7XG5CUnAuY2xpZW50RnVuY3Rpb25zID0gWydyZWRyYXdIaW50JywgJ3JlbmRlcicsICdyZW5kZXJUbycsICdtYXRjaENhbnZhc1NpemUnLCAnbm9kZVNoYXBlSW1wbCcsICdhcnJvd1NoYXBlSW1wbCddO1xuQlJwLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgciA9IHRoaXM7XG4gIHIub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHIuY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgY3RyID0gci5jb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcblxuICAvLyBwcmVwZW5kIGEgc3R5bGVzaGVldCBpbiB0aGUgaGVhZCBzdWNoIHRoYXRcbiAgaWYgKGNvbnRhaW5lcldpbmRvdykge1xuICAgIHZhciBkb2N1bWVudCA9IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgdmFyIHN0eWxlc2hlZXRJZCA9ICdfX19fX19fX19fY3l0b3NjYXBlX3N0eWxlc2hlZXQnO1xuICAgIHZhciBjbGFzc05hbWUgPSAnX19fX19fX19fX2N5dG9zY2FwZV9jb250YWluZXInO1xuICAgIHZhciBzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlc2hlZXRJZCkgIT0gbnVsbDtcbiAgICBpZiAoY3RyLmNsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSkgPCAwKSB7XG4gICAgICBjdHIuY2xhc3NOYW1lID0gKGN0ci5jbGFzc05hbWUgfHwgJycpICsgJyAnICsgY2xhc3NOYW1lO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzKSB7XG4gICAgICB2YXIgc3R5bGVzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZXNoZWV0LmlkID0gc3R5bGVzaGVldElkO1xuICAgICAgc3R5bGVzaGVldC50ZXh0Q29udGVudCA9ICcuJyArIGNsYXNzTmFtZSArICcgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH0nO1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVzaGVldCwgaGVhZC5jaGlsZHJlblswXSk7IC8vIGZpcnN0IHNvIGxvd2VzdCBwcmlvcml0eVxuICAgIH1cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGNvbnRhaW5lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN0cik7XG4gICAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIHdhcm4oJ0EgQ3l0b3NjYXBlIGNvbnRhaW5lciBoYXMgc3R5bGUgcG9zaXRpb246c3RhdGljIGFuZCBzbyBjYW4gbm90IHVzZSBVSSBleHRlbnNpb25zIHByb3Blcmx5Jyk7XG4gICAgfVxuICB9XG4gIHIuc2VsZWN0aW9uID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gIHIuYmV6aWVyUHJvalBjdHMgPSBbMC4wNSwgMC4yMjUsIDAuNCwgMC41LCAwLjYsIDAuNzc1LCAwLjk1XTtcblxuICAvLy0tUG9pbnRlci1yZWxhdGVkIGRhdGFcbiAgci5ob3ZlckRhdGEgPSB7XG4gICAgZG93bjogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGRvd25UaW1lOiBudWxsLFxuICAgIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sXG4gICAgY2FwdHVyZTogZmFsc2VcbiAgfTtcbiAgci5kcmFnRGF0YSA9IHtcbiAgICBwb3NzaWJsZURyYWdFbGVtZW50czogW11cbiAgfTtcbiAgci50b3VjaERhdGEgPSB7XG4gICAgc3RhcnQ6IG51bGwsXG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgc3RhcnRQb3NpdGlvbjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgZWFybGllcjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdXG4gIH07XG4gIHIucmVkcmF3cyA9IDA7XG4gIHIuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcbiAgci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIHIud2ViZ2wgPSBvcHRpb25zLndlYmdsO1xuICByLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gIHIudGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICByLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gIHIubW90aW9uQmx1ckVuYWJsZWQgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIG9uIGJ5IGRlZmF1bHRcbiAgci5mb3JjZWRQaXhlbFJhdGlvID0gbnVtYmVyJDEob3B0aW9ucy5waXhlbFJhdGlvKSA/IG9wdGlvbnMucGl4ZWxSYXRpbyA6IG51bGw7XG4gIHIubW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gZm9yIGluaXRpYWwga2ljayBvZmZcbiAgci5tb3Rpb25CbHVyT3BhY2l0eSA9IG9wdGlvbnMubW90aW9uQmx1ck9wYWNpdHk7XG4gIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSA9IDEgLSByLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgci5tYlB4UkJsdXJyeSA9IDE7IC8vMC44O1xuICByLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gIHIuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyID0gW107XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCAqIG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZCA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudGFwaG9sZER1cmF0aW9uID0gNTAwO1xuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcyA9IHtcbiAgICAvLyBoaWdoZXIgcHJpb3JpdHkgZXhlY3MgYmVmb3JlIGxvd2VyIG9uZVxuICAgIGFuaW1hdGlvbnM6IDQwMCxcbiAgICBlbGVDYWxjczogMzAwLFxuICAgIGVsZVR4ckRlcTogMjAwLFxuICAgIGx5clR4ckRlcTogMTUwLFxuICAgIGx5clR4clNraXA6IDEwMFxuICB9O1xuICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgci5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzKCk7XG59O1xuQlJwLm5vdGlmeSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsZXMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuXG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSBub3RpZmllZCBhZnRlciBpdCdzIGRlc3Ryb3llZFxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2luaXQnKSB7XG4gICAgci5sb2FkKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChldmVudE5hbWUgPT09ICdkZXN0cm95Jykge1xuICAgIHIuZGVzdHJveSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAnYWRkJyB8fCBldmVudE5hbWUgPT09ICdyZW1vdmUnIHx8IGV2ZW50TmFtZSA9PT0gJ21vdmUnICYmIGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSB8fCBldmVudE5hbWUgPT09ICdsb2FkJyB8fCBldmVudE5hbWUgPT09ICd6b3JkZXInIHx8IGV2ZW50TmFtZSA9PT0gJ21vdW50Jykge1xuICAgIHIuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIH1cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gIH1cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2djJykge1xuICAgIHIucmVkcmF3SGludCgnZ2MnLCB0cnVlKTtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAncmVzaXplJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgfVxuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuQlJwLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5kZXN0cm95ZWQgPSB0cnVlO1xuICByLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5iaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiaW5kaW5nID0gci5iaW5kaW5nc1tpXTtcbiAgICB2YXIgYiA9IGJpbmRpbmc7XG4gICAgdmFyIHRndCA9IGIudGFyZ2V0O1xuICAgICh0Z3Qub2ZmIHx8IHRndC5yZW1vdmVFdmVudExpc3RlbmVyKS5hcHBseSh0Z3QsIGIuYXJncyk7XG4gIH1cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSBbXTtcbiAgaWYgKHIucmVtb3ZlT2JzZXJ2ZXIpIHtcbiAgICByLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAoci5zdHlsZU9ic2VydmVyKSB7XG4gICAgci5zdHlsZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAoci5yZXNpemVPYnNlcnZlcikge1xuICAgIHIucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmIChyLmxhYmVsQ2FsY0Rpdikge1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIubGFiZWxDYWxjRGl2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5CUnAuaXNIZWFkbGVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbltCUnAkZiwgQlJwJDUsIEJScCQ0LCBCUnAkMywgQlJwJDIsIEJScCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoQlJwLCBwcm9wcyk7XG59KTtcblxudmFyIGZ1bGxGcHNUaW1lID0gMTAwMCAvIDYwOyAvLyBhc3N1bWUgNjAgZnJhbWVzIHBlciBzZWNvbmRcblxudmFyIGRlZnMgPSB7XG4gIHNldHVwRGVxdWV1ZWluZzogZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nKG9wdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nSW1wbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgIGlmIChzZWxmLmRlcXVldWVpbmdTZXR1cCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmRlcXVldWVpbmdTZXR1cCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcXVldWVSZWRyYXcgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIG9wdHMuZGVxUmVkcmF3VGhyZXNob2xkKTtcbiAgICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSh3aWxsRHJhdywgZnJhbWVTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHZhciBhdmdSZW5kZXJUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZTtcbiAgICAgICAgdmFyIHJlbmRlclRpbWUgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgZGVxZCA9IFtdO1xuICAgICAgICB2YXIgZXh0ZW50ID0gci5jeS5leHRlbnQoKTtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmVuJ3QgaW4gYSB0aWNrIHRoYXQgY2F1c2VzIGEgZHJhdywgdGhlbiB0aGUgcmVuZGVyZWQgc3R5bGVcbiAgICAgICAgLy8gcXVldWUgd29uJ3QgYXV0b21hdGljYWxseSBiZSBmbHVzaGVkIGJlZm9yZSBkZXF1ZXVlaW5nIHN0YXJ0c1xuICAgICAgICBpZiAoIXdpbGxEcmF3KSB7XG4gICAgICAgICAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBub3cgLSBmcmFtZVN0YXJ0VGltZTtcbiAgICAgICAgICBpZiAocmVuZGVyVGltZSA8IGZ1bGxGcHNUaW1lKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSByZW5kZXJpbmcgZmFzdGVyIHRoYW4gdGhlIGlkZWFsIGZwcywgdGhlbiBkbyBkZXF1ZXVlaW5nXG4gICAgICAgICAgICAvLyBkdXJpbmcgYWxsIG9mIHRoZSByZW1haW5pbmcgZnJhbWUgdGltZVxuXG4gICAgICAgICAgICB2YXIgdGltZUF2YWlsYWJsZSA9IGZ1bGxGcHNUaW1lIC0gKHdpbGxEcmF3ID8gYXZnUmVuZGVyVGltZSA6IDApO1xuICAgICAgICAgICAgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFGYXN0Q29zdCAqIHRpbWVBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3aWxsRHJhdykge1xuICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPj0gb3B0cy5kZXFDb3N0ICogcmVuZGVyVGltZSB8fCBkdXJhdGlvbiA+PSBvcHRzLmRlcUF2Z0Nvc3QgKiBhdmdSZW5kZXJUaW1lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcU5vRHJhd0Nvc3QgKiBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRoaXNEZXFkID0gb3B0cy5kZXEoc2VsZiwgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICAgICAgICBpZiAodGhpc0RlcWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzRGVxZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBkZXFkLnB1c2godGhpc0RlcWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsYmFja3Mgb24gZGVxdWV1ZVxuICAgICAgICBpZiAoZGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0cy5vbkRlcWQoc2VsZiwgZGVxZCk7XG4gICAgICAgICAgaWYgKCF3aWxsRHJhdyAmJiBvcHRzLnNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBwaXhlbFJhdGlvLCBleHRlbnQpKSB7XG4gICAgICAgICAgICBxdWV1ZVJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBwcmlvcml0eSA9IG9wdHMucHJpb3JpdHkgfHwgbm9vcCQxO1xuICAgICAgci5iZWZvcmVSZW5kZXIoZGVxdWV1ZSwgcHJpb3JpdHkoc2VsZikpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vIEFsbG93cyBsb29rdXBzIGZvciAoZWxlLCBsdmwpID0+IGNhY2hlLlxuLy8gVXNlcyBrZXlzIHNvIGVsZW1lbnRzIG1heSBzaGFyZSB0aGUgc2FtZSBjYWNoZS5cbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChnZXRLZXkpIHtcbiAgICB2YXIgZG9lc0VsZUludmFsaWRhdGVLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNpZnk7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXApO1xuICAgIHRoaXMuaWRzQnlLZXkgPSBuZXcgTWFwJDEoKTtcbiAgICB0aGlzLmtleUZvcklkID0gbmV3IE1hcCQxKCk7XG4gICAgdGhpcy5jYWNoZXNCeUx2bCA9IG5ldyBNYXAkMSgpO1xuICAgIHRoaXMubHZscyA9IFtdO1xuICAgIHRoaXMuZ2V0S2V5ID0gZ2V0S2V5O1xuICAgIHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkgPSBkb2VzRWxlSW52YWxpZGF0ZUtleTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAsIFt7XG4gICAga2V5OiBcImdldElkc0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZHNGb3Ioa2V5KSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoXCJDYW4gbm90IGdldCBpZCBsaXN0IGZvciBudWxsIGtleVwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHNCeUtleSA9IHRoaXMuaWRzQnlLZXk7XG4gICAgICB2YXIgaWRzID0gdGhpcy5pZHNCeUtleS5nZXQoa2V5KTtcbiAgICAgIGlmICghaWRzKSB7XG4gICAgICAgIGlkcyA9IG5ldyBTZXQkMSgpO1xuICAgICAgICBpZHNCeUtleS5zZXQoa2V5LCBpZHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkSWRGb3JLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSWRGb3JLZXkoa2V5LCBpZCkge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZ2V0SWRzRm9yKGtleSkuYWRkKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlSWRGb3JLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlSWRGb3JLZXkoa2V5LCBpZCkge1xuICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZ2V0SWRzRm9yKGtleSlbXCJkZWxldGVcIl0oaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROdW1iZXJPZklkc0ZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROdW1iZXJPZklkc0ZvcktleShrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldElkc0ZvcihrZXkpLnNpemU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUtleU1hcHBpbmdGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB2YXIgY3VycktleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLmRlbGV0ZUlkRm9yS2V5KHByZXZLZXksIGlkKTtcbiAgICAgIHRoaXMuYWRkSWRGb3JLZXkoY3VycktleSwgaWQpO1xuICAgICAgdGhpcy5rZXlGb3JJZC5zZXQoaWQsIGN1cnJLZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVLZXlNYXBwaW5nRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUtleU1hcHBpbmdGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdGhpcy5kZWxldGVJZEZvcktleShwcmV2S2V5LCBpZCk7XG4gICAgICB0aGlzLmtleUZvcklkW1wiZGVsZXRlXCJdKGlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2V5SGFzQ2hhbmdlZEZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlIYXNDaGFuZ2VkRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHZhciBuZXdLZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgcmV0dXJuIHByZXZLZXkgIT09IG5ld0tleTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbnZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW52YWxpZChlbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleUhhc0NoYW5nZWRGb3IoZWxlKSB8fCB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KGVsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENhY2hlc0F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhY2hlc0F0KGx2bCkge1xuICAgICAgdmFyIGNhY2hlc0J5THZsID0gdGhpcy5jYWNoZXNCeUx2bCxcbiAgICAgICAgbHZscyA9IHRoaXMubHZscztcbiAgICAgIHZhciBjYWNoZXMgPSBjYWNoZXNCeUx2bC5nZXQobHZsKTtcbiAgICAgIGlmICghY2FjaGVzKSB7XG4gICAgICAgIGNhY2hlcyA9IG5ldyBNYXAkMSgpO1xuICAgICAgICBjYWNoZXNCeUx2bC5zZXQobHZsLCBjYWNoZXMpO1xuICAgICAgICBsdmxzLnB1c2gobHZsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhY2hlKGtleSwgbHZsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZXNBdChsdmwpLmdldChrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoa2V5LCBsdmwpO1xuXG4gICAgICAvLyBnZXR0aW5nIGZvciBhbiBlbGVtZW50IG1heSBuZWVkIHRvIGFkZCB0byB0aGUgaWQgbGlzdCBiL2MgZWxlcyBjYW4gc2hhcmUga2V5c1xuICAgICAgaWYgKGNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvckNhY2hlZEtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChlbGUuaWQoKSk7IC8vIG4uYi4gdXNlIGNhY2hlZCBrZXksIG5vdCBuZXdseSBjb21wdXRlZCBrZXlcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoa2V5LCBsdmwpO1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNDYWNoZShrZXksIGx2bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5oYXMoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICByZXR1cm4gdGhpcy5oYXNDYWNoZShrZXksIGx2bCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhY2hlKGtleSwgbHZsLCBjYWNoZSkge1xuICAgICAgY2FjaGUua2V5ID0ga2V5O1xuICAgICAgdGhpcy5nZXRDYWNoZXNBdChsdmwpLnNldChrZXksIGNhY2hlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChlbGUsIGx2bCwgY2FjaGUpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdGhpcy5zZXRDYWNoZShrZXksIGx2bCwgY2FjaGUpO1xuICAgICAgdGhpcy51cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUNhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlKGtleSwgbHZsKSB7XG4gICAgICB0aGlzLmdldENhY2hlc0F0KGx2bClbXCJkZWxldGVcIl0oa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdGhpcy5kZWxldGVDYWNoZShrZXksIGx2bCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRhdGVLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZUtleShrZXkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmx2bHMuZm9yRWFjaChmdW5jdGlvbiAobHZsKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5kZWxldGVDYWNoZShrZXksIGx2bCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIHRydWUgaWYgbm8gb3RoZXIgZWxlcyByZWZlcmVuY2UgdGhlIGludmFsaWRhdGVkIGNhY2hlIChuLmIuIG90aGVyIGVsZXMgbWF5IG5lZWQgdGhlIGNhY2hlIHdpdGggdGhlIHNhbWUga2V5KVxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZShlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTsgLy8gbi5iLiB1c2Ugc3RvcmVkIGtleSByYXRoZXIgdGhhbiBjdXJyZW50IChwb3RlbnRpYWwga2V5KVxuXG4gICAgICB0aGlzLmRlbGV0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICAgIHZhciBlbnRpcmVLZXlJbnZhbGlkYXRlZCA9IHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkoZWxlKTtcbiAgICAgIGlmIChlbnRpcmVLZXlJbnZhbGlkYXRlZCkge1xuICAgICAgICAvLyBjbGVhciBtYXBwaW5nIGZvciBjdXJyZW50IGtleVxuICAgICAgICB0aGlzLmludmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRpcmVLZXlJbnZhbGlkYXRlZCB8fCB0aGlzLmdldE51bWJlck9mSWRzRm9yS2V5KGtleSkgPT09IDA7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBtaW5UeHJIID0gMjU7IC8vIHRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlIGNhY2hlIGZvciBzbWFsbCBoZWlnaHQgZWxlcyAoc3BlY2lhbCBjYXNlKVxudmFyIHR4clN0ZXBIID0gNTA7IC8vIHRoZSBtaW4gc2l6ZSBvZiB0aGUgcmVndWxhciBjYWNoZSwgYW5kIHRoZSBzaXplIGl0IGluY3JlYXNlcyB3aXRoIGVhY2ggc3RlcCB1cFxudmFyIG1pbkx2bCQxID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxudmFyIG1heEx2bCQxID0gMzsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxudmFyIG1heFpvb20kMSA9IDcuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG52YXIgZWxlVHhyU3BhY2luZyA9IDg7IC8vIHNwYWNpbmcgYmV0d2VlbiBlbGVtZW50cyBvbiB0ZXh0dXJlcyB0byBhdm9pZCBibGl0dGluZyBvdmVybGFwc1xudmFyIGRlZlR4cldpZHRoID0gMTAyNDsgLy8gZGVmYXVsdC9taW5pbXVtIHRleHR1cmUgd2lkdGhcbnZhciBtYXhUeHJXID0gMTAyNDsgLy8gdGhlIG1heGltdW0gd2lkdGggb2YgYSB0ZXh0dXJlXG52YXIgbWF4VHhySCA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIHRleHR1cmVcbnZhciBtaW5VdGlsaXR5ID0gMC4yOyAvLyBpZiB1c2FnZSBvZiB0ZXh0dXJlIGlzIGxlc3MgdGhhbiB0aGlzLCBpdCBpcyByZXRpcmVkXG52YXIgbWF4RnVsbG5lc3MgPSAwLjg7IC8vIGZ1bGxuZXNzIG9mIHRleHR1cmUgYWZ0ZXIgd2hpY2ggcXVldWUgcmVtb3ZhbCBpcyBjaGVja2VkXG52YXIgbWF4RnVsbG5lc3NDaGVja3MgPSAxMDsgLy8gZGVxdWV1ZWQgYWZ0ZXIgdGhpcyBtYW55IGNoZWNrc1xudmFyIGRlcUNvc3QkMSA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxudmFyIGRlcUF2Z0Nvc3QkMSA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcbnZhciBkZXFOb0RyYXdDb3N0JDEgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG52YXIgZGVxRmFzdENvc3QkMSA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQkMSA9IDEwMDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcbnZhciBtYXhEZXFTaXplJDEgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG52YXIgZ2V0VHhyUmVhc29ucyA9IHtcbiAgZGVxdWV1ZTogJ2RlcXVldWUnLFxuICBkb3duc2NhbGU6ICdkb3duc2NhbGUnLFxuICBoaWdoUXVhbGl0eTogJ2hpZ2hRdWFsaXR5J1xufTtcbnZhciBpbml0RGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgZ2V0S2V5OiBudWxsLFxuICBkb2VzRWxlSW52YWxpZGF0ZUtleTogZmFsc2lmeSxcbiAgZHJhd0VsZW1lbnQ6IG51bGwsXG4gIGdldEJvdW5kaW5nQm94OiBudWxsLFxuICBnZXRSb3RhdGlvblBvaW50OiBudWxsLFxuICBnZXRSb3RhdGlvbk9mZnNldDogbnVsbCxcbiAgaXNWaXNpYmxlOiB0cnVlaWZ5LFxuICBhbGxvd0VkZ2VUeHJDYWNoaW5nOiB0cnVlLFxuICBhbGxvd1BhcmVudFR4ckNhY2hpbmc6IHRydWVcbn0pO1xudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiBFbGVtZW50VGV4dHVyZUNhY2hlKHJlbmRlcmVyLCBpbml0T3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgc2VsZi5vbkRlcXVldWVzID0gW107XG4gIHZhciBvcHRzID0gaW5pdERlZmF1bHRzKGluaXRPcHRpb25zKTtcbiAgZXh0ZW5kKHNlbGYsIG9wdHMpO1xuICBzZWxmLmxvb2t1cCA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKG9wdHMuZ2V0S2V5LCBvcHRzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KTtcbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG52YXIgRVRDcCA9IEVsZW1lbnRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xuRVRDcC5yZWFzb25zID0gZ2V0VHhyUmVhc29ucztcblxuLy8gdGhlIGxpc3Qgb2YgdGV4dHVyZXMgaW4gd2hpY2ggbmV3IHN1YnRleHR1cmVzIGZvciBlbGVtZW50cyBjYW4gYmUgcGxhY2VkXG5FVENwLmdldFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lbGVJbWdDYWNoZXMgPSBzZWxmLmVsZUltZ0NhY2hlcyB8fCB7fTtcbiAgcmV0dXJuIHNlbGYuZWxlSW1nQ2FjaGVzW3R4ckhdID0gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gfHwgW107XG59O1xuXG4vLyB0aGUgbGlzdCBvZiB1c3VzZWQgdGV4dHVyZXMgd2hpY2ggY2FuIGJlIHJlY3ljbGVkIChpbiB1c2UgaW4gdGV4dHVyZSBxdWV1ZSlcbkVUQ3AuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJ0eHRyUXMgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCB8fCB7fTtcbiAgdmFyIHJ0eHRyUSA9IHJ0eHRyUXNbdHhySF0gPSBydHh0clFzW3R4ckhdIHx8IFtdO1xuICByZXR1cm4gcnR4dHJRO1xufTtcblxuLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHNcbkVUQ3AuZ2V0RWxlbWVudFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5lbGVDYWNoZVF1ZXVlID0gc2VsZi5lbGVDYWNoZVF1ZXVlIHx8IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgfSk7XG4gIHJldHVybiBxO1xufTtcblxuLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHMgKGVsZW1lbnQgaWQgbG9va3VwKVxuRVRDcC5nZXRFbGVtZW50S2V5VG9RdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgazJxID0gc2VsZi5lbGVLZXlUb0NhY2hlUXVldWUgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSB8fCB7fTtcbiAgcmV0dXJuIGsycTtcbn07XG5FVENwLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDtcbiAgaWYgKCFiYiB8fCBiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgaXNOYU4oYmIudykgfHwgaXNOYU4oYmIuaCkgfHwgIWVsZS52aXNpYmxlKCkgfHwgZWxlLnJlbW92ZWQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghc2VsZi5hbGxvd0VkZ2VUeHJDYWNoaW5nICYmIGVsZS5pc0VkZ2UoKSB8fCAhc2VsZi5hbGxvd1BhcmVudFR4ckNhY2hpbmcgJiYgZWxlLmlzUGFyZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAobHZsID09IG51bGwpIHtcbiAgICBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpO1xuICB9XG4gIGlmIChsdmwgPCBtaW5MdmwkMSkge1xuICAgIGx2bCA9IG1pbkx2bCQxO1xuICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSQxIHx8IGx2bCA+IG1heEx2bCQxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIGVsZVNjYWxlZEggPSBiYi5oICogc2NhbGU7XG4gIHZhciBlbGVTY2FsZWRXID0gYmIudyAqIHNjYWxlO1xuICB2YXIgc2NhbGVkTGFiZWxTaG93biA9IHIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlLCBzY2FsZSk7XG4gIGlmICghdGhpcy5pc1Zpc2libGUoZWxlLCBzY2FsZWRMYWJlbFNob3duKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBlbGVDYWNoZSA9IGxvb2t1cC5nZXQoZWxlLCBsdmwpO1xuXG4gIC8vIGlmIHRoaXMgZ2V0IHdhcyBvbiBhbiB1bnVzZWQvaW52YWxpZGF0ZWQgY2FjaGUsIHRoZW4gcmVzdG9yZSB0aGUgdGV4dHVyZSB1c2FnZSBtZXRyaWNcbiAgaWYgKGVsZUNhY2hlICYmIGVsZUNhY2hlLmludmFsaWRhdGVkKSB7XG4gICAgZWxlQ2FjaGUuaW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICBlbGVDYWNoZS50ZXh0dXJlLmludmFsaWRhdGVkV2lkdGggLT0gZWxlQ2FjaGUud2lkdGg7XG4gIH1cbiAgaWYgKGVsZUNhY2hlKSB7XG4gICAgcmV0dXJuIGVsZUNhY2hlO1xuICB9XG4gIHZhciB0eHJIOyAvLyB3aGljaCB0ZXh0dXJlIGhlaWdodCB0aGlzIGVsZSBiZWxvbmdzIHRvXG5cbiAgaWYgKGVsZVNjYWxlZEggPD0gbWluVHhySCkge1xuICAgIHR4ckggPSBtaW5UeHJIO1xuICB9IGVsc2UgaWYgKGVsZVNjYWxlZEggPD0gdHhyU3RlcEgpIHtcbiAgICB0eHJIID0gdHhyU3RlcEg7XG4gIH0gZWxzZSB7XG4gICAgdHhySCA9IE1hdGguY2VpbChlbGVTY2FsZWRIIC8gdHhyU3RlcEgpICogdHhyU3RlcEg7XG4gIH1cbiAgaWYgKGVsZVNjYWxlZEggPiBtYXhUeHJIIHx8IGVsZVNjYWxlZFcgPiBtYXhUeHJXKSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIGNhY2hpbmcgbGFyZ2UgZWxlbWVudHMgaXMgbm90IGVmZmljaWVudFxuICB9XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG5cbiAgLy8gZmlyc3QgdHJ5IHRoZSBzZWNvbmQgbGFzdCBvbmUgaW4gY2FzZSBpdCBoYXMgc3BhY2UgYXQgdGhlIGVuZFxuICB2YXIgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDJdO1xuICB2YXIgYWRkTmV3VHhyID0gZnVuY3Rpb24gYWRkTmV3VHhyKCkge1xuICAgIHJldHVybiBzZWxmLnJlY3ljbGVUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpIHx8IHNlbGYuYWRkVGV4dHVyZSh0eHJILCBlbGVTY2FsZWRXKTtcbiAgfTtcblxuICAvLyB0cnkgdGhlIGxhc3Qgb25lIGlmIHRoZXJlIGlzIG5vIHNlY29uZCBsYXN0IG9uZVxuICBpZiAoIXR4cikge1xuICAgIHR4ciA9IHR4clFbdHhyUS5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBsYXN0IG9uZSBkb2Vzbid0IGV4aXN0LCB3ZSBuZWVkIGEgZmlyc3Qgb25lXG4gIGlmICghdHhyKSB7XG4gICAgdHhyID0gYWRkTmV3VHhyKCk7XG4gIH1cblxuICAvLyBpZiB0aGVyZSdzIG5vIHJvb20gaW4gdGhlIGN1cnJlbnQgdGV4dHVyZSwgd2UgbmVlZCBhIG5ldyBvbmVcbiAgaWYgKHR4ci53aWR0aCAtIHR4ci51c2VkV2lkdGggPCBlbGVTY2FsZWRXKSB7XG4gICAgdHhyID0gYWRkTmV3VHhyKCk7XG4gIH1cbiAgdmFyIHNjYWxhYmxlRnJvbSA9IGZ1bmN0aW9uIHNjYWxhYmxlRnJvbShvdGhlckNhY2hlKSB7XG4gICAgcmV0dXJuIG90aGVyQ2FjaGUgJiYgb3RoZXJDYWNoZS5zY2FsZWRMYWJlbFNob3duID09PSBzY2FsZWRMYWJlbFNob3duO1xuICB9O1xuICB2YXIgZGVxaW5nID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kZXF1ZXVlO1xuICB2YXIgaGlnaFF1YWxpdHlSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmhpZ2hRdWFsaXR5O1xuICB2YXIgZG93bnNjYWxlUmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kb3duc2NhbGU7XG4gIHZhciBoaWdoZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGhpZ2hlciBsZXZlbFxuICBmb3IgKHZhciBsID0gbHZsICsgMTsgbCA8PSBtYXhMdmwkMTsgbCsrKSB7XG4gICAgdmFyIGMgPSBsb29rdXAuZ2V0KGVsZSwgbCk7XG4gICAgaWYgKGMpIHtcbiAgICAgIGhpZ2hlckNhY2hlID0gYztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgb25lVXBDYWNoZSA9IGhpZ2hlckNhY2hlICYmIGhpZ2hlckNhY2hlLmxldmVsID09PSBsdmwgKyAxID8gaGlnaGVyQ2FjaGUgOiBudWxsO1xuICB2YXIgZG93bnNjYWxlID0gZnVuY3Rpb24gZG93bnNjYWxlKCkge1xuICAgIHR4ci5jb250ZXh0LmRyYXdJbWFnZShvbmVVcENhY2hlLnRleHR1cmUuY2FudmFzLCBvbmVVcENhY2hlLngsIDAsIG9uZVVwQ2FjaGUud2lkdGgsIG9uZVVwQ2FjaGUuaGVpZ2h0LCB0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCBlbGVTY2FsZWRIKTtcbiAgfTtcblxuICAvLyByZXNldCBlbGUgYXJlYSBpbiB0ZXh0dXJlXG4gIHR4ci5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KHR4ci51c2VkV2lkdGgsIDAsIGVsZVNjYWxlZFcsIHR4ckgpO1xuICBpZiAoc2NhbGFibGVGcm9tKG9uZVVwQ2FjaGUpKSB7XG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVsYXRpdmVseSBjaGVhcGx5IHJlc2NhbGUgdGhlIGV4aXN0aW5nIGltYWdlIHcvbyByZXJlbmRlcmluZ1xuICAgIGRvd25zY2FsZSgpO1xuICB9IGVsc2UgaWYgKHNjYWxhYmxlRnJvbShoaWdoZXJDYWNoZSkpIHtcbiAgICAvLyB0aGVuIHVzZSB0aGUgaGlnaGVyIGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBuZXh0IGxldmVsIGRvd25cbiAgICAvLyB0byBjaGVhcGx5IHNjYWxlIHRvd2FyZHMgdGhlIHNtYWxsZXIgbGV2ZWxcblxuICAgIGlmIChoaWdoUXVhbGl0eVJlcSkge1xuICAgICAgZm9yICh2YXIgX2wgPSBoaWdoZXJDYWNoZS5sZXZlbDsgX2wgPiBsdmw7IF9sLS0pIHtcbiAgICAgICAgb25lVXBDYWNoZSA9IHNlbGYuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCBfbCwgZ2V0VHhyUmVhc29ucy5kb3duc2NhbGUpO1xuICAgICAgfVxuICAgICAgZG93bnNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgaGlnaGVyQ2FjaGUubGV2ZWwgLSAxKTtcbiAgICAgIHJldHVybiBoaWdoZXJDYWNoZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd2VyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBsb3dlciBsZXZlbFxuICAgIGlmICghZGVxaW5nICYmICFoaWdoUXVhbGl0eVJlcSAmJiAhZG93bnNjYWxlUmVxKSB7XG4gICAgICBmb3IgKHZhciBfbDIgPSBsdmwgLSAxOyBfbDIgPj0gbWluTHZsJDE7IF9sMi0tKSB7XG4gICAgICAgIHZhciBfYyA9IGxvb2t1cC5nZXQoZWxlLCBfbDIpO1xuICAgICAgICBpZiAoX2MpIHtcbiAgICAgICAgICBsb3dlckNhY2hlID0gX2M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjYWxhYmxlRnJvbShsb3dlckNhY2hlKSkge1xuICAgICAgLy8gdGhlbiB1c2UgdGhlIGxvd2VyIHF1YWxpdHkgY2FjaGUgZm9yIG5vdyBhbmQgcXVldWUgdGhlIGJldHRlciBvbmUgZm9yIGxhdGVyXG5cbiAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgbHZsKTtcbiAgICAgIHJldHVybiBsb3dlckNhY2hlO1xuICAgIH1cbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUodHhyLnVzZWRXaWR0aCwgMCk7XG4gICAgdHhyLmNvbnRleHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICB0aGlzLmRyYXdFbGVtZW50KHR4ci5jb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCBmYWxzZSk7XG4gICAgdHhyLmNvbnRleHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSgtdHhyLnVzZWRXaWR0aCwgMCk7XG4gIH1cbiAgZWxlQ2FjaGUgPSB7XG4gICAgeDogdHhyLnVzZWRXaWR0aCxcbiAgICB0ZXh0dXJlOiB0eHIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgd2lkdGg6IGVsZVNjYWxlZFcsXG4gICAgaGVpZ2h0OiBlbGVTY2FsZWRILFxuICAgIHNjYWxlZExhYmVsU2hvd246IHNjYWxlZExhYmVsU2hvd25cbiAgfTtcbiAgdHhyLnVzZWRXaWR0aCArPSBNYXRoLmNlaWwoZWxlU2NhbGVkVyArIGVsZVR4clNwYWNpbmcpO1xuICB0eHIuZWxlQ2FjaGVzLnB1c2goZWxlQ2FjaGUpO1xuICBsb29rdXAuc2V0KGVsZSwgbHZsLCBlbGVDYWNoZSk7XG4gIHNlbGYuY2hlY2tUZXh0dXJlRnVsbG5lc3ModHhyKTtcbiAgcmV0dXJuIGVsZUNhY2hlO1xufTtcbkVUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlRWxlbWVudChlbGVzW2ldKTtcbiAgfVxufTtcbkVUQ3AuaW52YWxpZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuICB2YXIgY2FjaGVzID0gW107XG4gIHZhciBpbnZhbGlkID0gbG9va3VwLmlzSW52YWxpZChlbGUpO1xuICBpZiAoIWludmFsaWQpIHtcbiAgICByZXR1cm47IC8vIG92ZXJyaWRlIHRoZSBpbnZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgZWxlbWVudCBrZXkgaGFzIG5vdCBjaGFuZ2VkXG4gIH1cbiAgZm9yICh2YXIgbHZsID0gbWluTHZsJDE7IGx2bCA8PSBtYXhMdmwkMTsgbHZsKyspIHtcbiAgICB2YXIgY2FjaGUgPSBsb29rdXAuZ2V0Rm9yQ2FjaGVkS2V5KGVsZSwgbHZsKTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgICB9XG4gIH1cbiAgdmFyIG5vT3RoZXJFbGVzVXNlQ2FjaGUgPSBsb29rdXAuaW52YWxpZGF0ZShlbGUpO1xuICBpZiAobm9PdGhlckVsZXNVc2VDYWNoZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2NhY2hlID0gY2FjaGVzW2ldO1xuICAgICAgdmFyIHR4ciA9IF9jYWNoZS50ZXh0dXJlO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgZnJvbSB0aGUgdGV4dHVyZSBpdCBiZWxvbmdzIHRvXG4gICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCArPSBfY2FjaGUud2lkdGg7XG5cbiAgICAgIC8vIG1hcmsgdGhlIGNhY2hlIGFzIGludmFsaWRhdGVkXG4gICAgICBfY2FjaGUuaW52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyByZXRpcmUgdGhlIHRleHR1cmUgaWYgaXRzIHV0aWxpdHkgaXMgbG93XG4gICAgICBzZWxmLmNoZWNrVGV4dHVyZVV0aWxpdHkodHhyKTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgZnJvbSBxdWV1ZSBzaW5jZSB0aGUgb2xkIHJlcSB3YXMgZm9yIHRoZSBvbGQgc3RhdGVcbiAgc2VsZi5yZW1vdmVGcm9tUXVldWUoZWxlKTtcbn07XG5FVENwLmNoZWNrVGV4dHVyZVV0aWxpdHkgPSBmdW5jdGlvbiAodHhyKSB7XG4gIC8vIGludmFsaWRhdGUgYWxsIGVudHJpZXMgaW4gdGhlIGNhY2hlIGlmIHRoZSBjYWNoZSBzaXplIGlzIHNtYWxsXG4gIGlmICh0eHIuaW52YWxpZGF0ZWRXaWR0aCA+PSBtaW5VdGlsaXR5ICogdHhyLndpZHRoKSB7XG4gICAgdGhpcy5yZXRpcmVUZXh0dXJlKHR4cik7XG4gIH1cbn07XG5FVENwLmNoZWNrVGV4dHVyZUZ1bGxuZXNzID0gZnVuY3Rpb24gKHR4cikge1xuICAvLyBpZiB0ZXh0dXJlIGhhcyBiZWVuIG1vc3RseSBmaWxsZWQgYW5kIHBhc3NlZCBvdmVyIHNldmVyYWwgdGltZXMsIHJlbW92ZVxuICAvLyBpdCBmcm9tIHRoZSBxdWV1ZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhc3RlIHRpbWUgbG9va2luZyBhdCBpdCB0byBwdXQgbmV3IHRoaW5nc1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHIuaGVpZ2h0KTtcbiAgaWYgKHR4ci51c2VkV2lkdGggLyB0eHIud2lkdGggPiBtYXhGdWxsbmVzcyAmJiB0eHIuZnVsbG5lc3NDaGVja3MgPj0gbWF4RnVsbG5lc3NDaGVja3MpIHtcbiAgICByZW1vdmVGcm9tQXJyYXkodHhyUSwgdHhyKTtcbiAgfSBlbHNlIHtcbiAgICB0eHIuZnVsbG5lc3NDaGVja3MrKztcbiAgfVxufTtcbkVUQ3AucmV0aXJlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhySCA9IHR4ci5oZWlnaHQ7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDtcblxuICAvLyByZXRpcmUgdGhlIHRleHR1cmUgZnJvbSB0aGUgYWN0aXZlIC8gc2VhcmNoYWJsZSBxdWV1ZTpcblxuICByZW1vdmVGcm9tQXJyYXkodHhyUSwgdHhyKTtcbiAgdHhyLnJldGlyZWQgPSB0cnVlO1xuXG4gIC8vIHJlbW92ZSB0aGUgcmVmcyBmcm9tIHRoZSBlbGVzIHRvIHRoZSBjYWNoZXM6XG5cbiAgdmFyIGVsZUNhY2hlcyA9IHR4ci5lbGVDYWNoZXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlQ2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZUNhY2hlID0gZWxlQ2FjaGVzW2ldO1xuICAgIGxvb2t1cC5kZWxldGVDYWNoZShlbGVDYWNoZS5rZXksIGVsZUNhY2hlLmxldmVsKTtcbiAgfVxuICBjbGVhckFycmF5KGVsZUNhY2hlcyk7XG5cbiAgLy8gYWRkIHRoZSB0ZXh0dXJlIHRvIGEgcmV0aXJlZCBxdWV1ZSBzbyBpdCBjYW4gYmUgcmVjeWNsZWQgaW4gZnV0dXJlOlxuXG4gIHZhciBydHh0clEgPSBzZWxmLmdldFJldGlyZWRUZXh0dXJlUXVldWUodHhySCk7XG4gIHJ0eHRyUS5wdXNoKHR4cik7XG59O1xuRVRDcC5hZGRUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgdHhyID0ge307XG4gIHR4clEucHVzaCh0eHIpO1xuICB0eHIuZWxlQ2FjaGVzID0gW107XG4gIHR4ci5oZWlnaHQgPSB0eHJIO1xuICB0eHIud2lkdGggPSBNYXRoLm1heChkZWZUeHJXaWR0aCwgbWluVyk7XG4gIHR4ci51c2VkV2lkdGggPSAwO1xuICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gIHR4ci5jYW52YXMgPSBzZWxmLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHJldHVybiB0eHI7XG59O1xuRVRDcC5yZWN5Y2xlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydHh0clEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHhyID0gcnR4dHJRW2ldO1xuICAgIGlmICh0eHIud2lkdGggPj0gbWluVykge1xuICAgICAgdHhyLnJldGlyZWQgPSBmYWxzZTtcbiAgICAgIHR4ci51c2VkV2lkdGggPSAwO1xuICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICAgICAgdHhyLmZ1bGxuZXNzQ2hlY2tzID0gMDtcbiAgICAgIGNsZWFyQXJyYXkodHhyLmVsZUNhY2hlcyk7XG4gICAgICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0eHIuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgICAgIHJlbW92ZUZyb21BcnJheShydHh0clEsIHR4cik7XG4gICAgICB0eHJRLnB1c2godHhyKTtcbiAgICAgIHJldHVybiB0eHI7XG4gICAgfVxuICB9XG59O1xuRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICB2YXIgZXhpc3RpbmdSZXEgPSBrMnFba2V5XTtcbiAgaWYgKGV4aXN0aW5nUmVxKSB7XG4gICAgLy8gdXNlIHRoZSBtYXggbHZsIGIvYyBpbiBiZXR3ZWVuIGx2bHMgYXJlIGNoZWFwIHRvIG1ha2VcbiAgICBleGlzdGluZ1JlcS5sZXZlbCA9IE1hdGgubWF4KGV4aXN0aW5nUmVxLmxldmVsLCBsdmwpO1xuICAgIGV4aXN0aW5nUmVxLmVsZXMubWVyZ2UoZWxlKTtcbiAgICBleGlzdGluZ1JlcS5yZXFzKys7XG4gICAgcS51cGRhdGVJdGVtKGV4aXN0aW5nUmVxKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVxID0ge1xuICAgICAgZWxlczogZWxlLnNwYXduKCkubWVyZ2UoZWxlKSxcbiAgICAgIGxldmVsOiBsdmwsXG4gICAgICByZXFzOiAxLFxuICAgICAga2V5OiBrZXlcbiAgICB9O1xuICAgIHEucHVzaChyZXEpO1xuICAgIGsycVtrZXldID0gcmVxO1xuICB9XG59O1xuRVRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW8gLyosIGV4dGVudCovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIgZGVxdWV1ZWQgPSBbXTtcbiAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heERlcVNpemUkMTsgaSsrKSB7XG4gICAgaWYgKHEuc2l6ZSgpID4gMCkge1xuICAgICAgdmFyIHJlcSA9IHEucG9wKCk7XG4gICAgICB2YXIga2V5ID0gcmVxLmtleTtcbiAgICAgIHZhciBlbGUgPSByZXEuZWxlc1swXTsgLy8gYWxsIGVsZXMgaGF2ZSB0aGUgc2FtZSBrZXlcbiAgICAgIHZhciBjYWNoZUV4aXN0cyA9IGxvb2t1cC5oYXNDYWNoZShlbGUsIHJlcS5sZXZlbCk7XG5cbiAgICAgIC8vIGNsZWFyIG91dCB0aGUga2V5IHRvIHJlcSBsb29rdXBcbiAgICAgIGsycVtrZXldID0gbnVsbDtcblxuICAgICAgLy8gZGVxdWV1ZWluZyBpc24ndCBuZWNlc3Nhcnkgd2l0aCBhbiBleGlzdGluZyBjYWNoZVxuICAgICAgaWYgKGNhY2hlRXhpc3RzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZGVxdWV1ZWQucHVzaChyZXEpO1xuICAgICAgdmFyIGJiID0gc2VsZi5nZXRCb3VuZGluZ0JveChlbGUpO1xuICAgICAgc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIHJlcS5sZXZlbCwgZ2V0VHhyUmVhc29ucy5kZXF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXF1ZXVlZDtcbn07XG5FVENwLnJlbW92ZUZyb21RdWV1ZSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICB2YXIgcmVxID0gazJxW2tleV07XG4gIGlmIChyZXEgIT0gbnVsbCkge1xuICAgIGlmIChyZXEuZWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHJlbW92ZSBpZiBsYXN0IGVsZSBpbiB0aGUgcmVxXG4gICAgICAvLyBicmluZyB0byBmcm9udCBvZiBxdWV1ZVxuICAgICAgcmVxLnJlcXMgPSBNQVhfSU5UJDE7XG4gICAgICBxLnVwZGF0ZUl0ZW0ocmVxKTtcbiAgICAgIHEucG9wKCk7IC8vIHJlbW92ZSBmcm9tIHF1ZXVlXG5cbiAgICAgIGsycVtrZXldID0gbnVsbDsgLy8gcmVtb3ZlIGZyb20gbG9va3VwIG1hcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCByZW1vdmUgZWxlIGZyb20gcmVxXG4gICAgICByZXEuZWxlcy51bm1lcmdlKGVsZSk7XG4gICAgfVxuICB9XG59O1xuRVRDcC5vbkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5vbkRlcXVldWVzLnB1c2goZm4pO1xufTtcbkVUQ3Aub2ZmRGVxdWV1ZSA9IGZ1bmN0aW9uIChmbikge1xuICByZW1vdmVGcm9tQXJyYXkodGhpcy5vbkRlcXVldWVzLCBmbik7XG59O1xuRVRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkJDEsXG4gIGRlcUNvc3Q6IGRlcUNvc3QkMSxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCQxLFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0JDEsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCQxLFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8sIGV4dGVudCk7XG4gIH0sXG4gIG9uRGVxZDogZnVuY3Rpb24gb25EZXFkKHNlbGYsIGRlcWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuICAgICAgZm4oZGVxZCk7XG4gICAgfVxuICB9LFxuICBzaG91bGRSZWRyYXc6IGZ1bmN0aW9uIHNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGVzID0gZGVxZFtpXS5lbGVzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBiYiA9IGVsZXNbal0uYm91bmRpbmdCb3goKTtcbiAgICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIsIGV4dGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVUeHJEZXE7XG4gIH1cbn0pO1xuXG52YXIgZGVmTnVtTGF5ZXJzID0gMTsgLy8gZGVmYXVsdCBudW1iZXIgb2YgbGF5ZXJzIHRvIHVzZVxudmFyIG1pbkx2bCA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcbnZhciBtYXhMdmwgPSAyOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG52YXIgbWF4Wm9vbSA9IDMuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG52YXIgZGVxUmVkcmF3VGhyZXNob2xkID0gNTA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG52YXIgcmVmaW5lRWxlRGVib3VuY2VUaW1lID0gNTA7IC8vIHRpbWUgdG8gZGVib3VuY2Ugc2hhcnBlciBlbGUgdGV4dHVyZSB1cGRhdGVzXG52YXIgZGVxQ29zdCA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxudmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG52YXIgZGVxTm9EcmF3Q29zdCA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcbnZhciBkZXFGYXN0Q29zdCA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcbnZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcbnZhciBpbnZhbGlkVGhyZXNob2xkID0gMjUwOyAvLyB0aW1lIHRocmVzaG9sZCBmb3IgZGlzYWJsaW5nIGIvYyBvZiBpbnZhbGlkYXRpb25zXG52YXIgbWF4TGF5ZXJBcmVhID0gNDAwMCAqIDQwMDA7IC8vIGxheWVycyBjYW4ndCBiZSBiaWdnZXIgdGhhbiB0aGlzXG52YXIgbWF4TGF5ZXJEaW0gPSAzMjc2NzsgLy8gbWF4aW11bSBzaXplIGZvciB0aGUgd2lkdGgvaGVpZ2h0IG9mIGxheWVyIGNhbnZhc2VzXG52YXIgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzID0gdHJ1ZTsgLy8gd2hldGhlciB0byB1c2UgaGlnaCBxdWFsaXR5IGVsZSB0eHIgcmVxdWVzdHMgKGdlbmVyYWxseSBmYXN0ZXIgYW5kIGNoZWFwZXIgaW4gdGhlIGxvbmd0ZXJtKVxuXG4vLyB2YXIgbG9nID0gZnVuY3Rpb24oKXsgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApOyB9O1xuXG52YXIgTGF5ZXJlZFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIExheWVyZWRUZXh0dXJlQ2FjaGUocmVuZGVyZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgc2VsZi5sYXllcnNCeUxldmVsID0ge307IC8vIGUuZy4gMiA9PiBbIGxheWVyMSwgbGF5ZXIyLCAuLi4sIGxheWVyTiBdXG5cbiAgc2VsZi5maXJzdEdldCA9IHRydWU7XG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gMiAqIGludmFsaWRUaHJlc2hvbGQ7XG4gIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgc2VsZi5lbGVUeHJEZXFzID0gY3kuY29sbGVjdGlvbigpO1xuICBzZWxmLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5yZWZpbmVFbGVtZW50VGV4dHVyZXMoc2VsZi5lbGVUeHJEZXFzKTtcbiAgICBzZWxmLmVsZVR4ckRlcXMudW5tZXJnZShzZWxmLmVsZVR4ckRlcXMpO1xuICB9LCByZWZpbmVFbGVEZWJvdW5jZVRpbWUpO1xuICByLmJlZm9yZVJlbmRlcihmdW5jdGlvbiAod2lsbERyYXcsIG5vdykge1xuICAgIGlmIChub3cgLSBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lIDw9IGludmFsaWRUaHJlc2hvbGQpIHtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG4gICAgfVxuICB9LCByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyU2tpcCk7XG4gIHZhciBxU29ydCA9IGZ1bmN0aW9uIHFTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9O1xuICBzZWxmLmxheWVyc1F1ZXVlID0gbmV3IEhlYXAocVNvcnQpO1xuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcbnZhciBMVENwID0gTGF5ZXJlZFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG52YXIgbGF5ZXJJZFBvb2wgPSAwO1xudmFyIE1BWF9JTlQgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuTFRDcC5tYWtlTGF5ZXIgPSBmdW5jdGlvbiAoYmIsIGx2bCkge1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgdyA9IE1hdGguY2VpbChiYi53ICogc2NhbGUpO1xuICB2YXIgaCA9IE1hdGguY2VpbChiYi5oICogc2NhbGUpO1xuICB2YXIgY2FudmFzID0gdGhpcy5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHcsIGgpO1xuICB2YXIgbGF5ZXIgPSB7XG4gICAgaWQ6IGxheWVySWRQb29sID0gKytsYXllcklkUG9vbCAlIE1BWF9JTlQsXG4gICAgYmI6IGJiLFxuICAgIGxldmVsOiBsdmwsXG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoLFxuICAgIGNhbnZhczogY2FudmFzLFxuICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgIGVsZXM6IFtdLFxuICAgIGVsZXNRdWV1ZTogW10sXG4gICAgcmVxczogMFxuICB9O1xuXG4gIC8vIGxvZygnbWFrZSBsYXllciAlcyB3aXRoIHcgJXMgYW5kIGggJXMgYW5kIGx2bCAlcycsIGxheWVyLmlkLCBsYXllci53aWR0aCwgbGF5ZXIuaGVpZ2h0LCBsYXllci5sZXZlbCk7XG5cbiAgdmFyIGN4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBkeCA9IC1sYXllci5iYi54MTtcbiAgdmFyIGR5ID0gLWxheWVyLmJiLnkxO1xuXG4gIC8vIGRvIHRoZSB0cmFuc2Zvcm0gb24gY3JlYXRpb24gdG8gc2F2ZSBjeWNsZXMgKGl0J3MgdGhlIHNhbWUgZm9yIGFsbCBlbGVzKVxuICBjeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgY3h0LnRyYW5zbGF0ZShkeCwgZHkpO1xuICByZXR1cm4gbGF5ZXI7XG59O1xuTFRDcC5nZXRMYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgcHhSYXRpbywgbHZsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSBzZWxmLnJlbmRlcmVyO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIGZpcnN0R2V0ID0gc2VsZi5maXJzdEdldDtcbiAgc2VsZi5maXJzdEdldCA9IGZhbHNlO1xuXG4gIC8vIGxvZygnLS1cXG5nZXQgbGF5ZXJzIHdpdGggJXMgZWxlcycsIGVsZXMubGVuZ3RoKTtcbiAgLy9sb2cgZWxlcy5tYXAoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5pZCgpIH0pICk7XG5cbiAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcbiAgICBpZiAobHZsIDwgbWluTHZsKSB7XG4gICAgICBsdmwgPSBtaW5Mdmw7XG4gICAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20gfHwgbHZsID4gbWF4THZsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsdmwsIGVsZXMpO1xuICB2YXIgbGF5ZXJzQnlMdmwgPSBzZWxmLmxheWVyc0J5TGV2ZWw7XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciBsYXllcnMgPSBsYXllcnNCeUx2bFtsdmxdID0gbGF5ZXJzQnlMdmxbbHZsXSB8fCBbXTtcbiAgdmFyIGJiO1xuICB2YXIgbHZsQ29tcGxldGUgPSBzZWxmLmxldmVsSXNDb21wbGV0ZShsdmwsIGVsZXMpO1xuICB2YXIgdG1wTGF5ZXJzO1xuICB2YXIgY2hlY2tUZW1wTGV2ZWxzID0gZnVuY3Rpb24gY2hlY2tUZW1wTGV2ZWxzKCkge1xuICAgIHZhciBjYW5Vc2VBc1RtcEx2bCA9IGZ1bmN0aW9uIGNhblVzZUFzVG1wTHZsKGwpIHtcbiAgICAgIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcobCwgZWxlcyk7XG4gICAgICBpZiAoc2VsZi5sZXZlbElzQ29tcGxldGUobCwgZWxlcykpIHtcbiAgICAgICAgdG1wTGF5ZXJzID0gbGF5ZXJzQnlMdmxbbF07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNoZWNrTHZscyA9IGZ1bmN0aW9uIGNoZWNrTHZscyhkaXIpIHtcbiAgICAgIGlmICh0bXBMYXllcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbCA9IGx2bCArIGRpcjsgbWluTHZsIDw9IGwgJiYgbCA8PSBtYXhMdmw7IGwgKz0gZGlyKSB7XG4gICAgICAgIGlmIChjYW5Vc2VBc1RtcEx2bChsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjaGVja0x2bHMoMSk7XG4gICAgY2hlY2tMdmxzKC0xKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgaW52YWxpZCBsYXllcnM7IHRoZXkgd2lsbCBiZSByZXBsYWNlZCBhcyBuZWVkZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvblxuICAgIGZvciAodmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmICghbHZsQ29tcGxldGUpIHtcbiAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBpbmNvbXBsZXRlLCB0aGVuIHVzZSB0aGUgY2xvc2VzdCwgYmVzdCBxdWFsaXR5IGxheWVyc2V0IHRlbXBvcmFyaWx5XG4gICAgLy8gYW5kIGxhdGVyIHF1ZXVlIHRoZSBjdXJyZW50IGxheWVyc2V0IHNvIHdlIGNhbiBnZXQgdGhlIHByb3BlciBxdWFsaXR5IGxldmVsIHNvb25cblxuICAgIGNoZWNrVGVtcExldmVscygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxvZygnbGV2ZWwgY29tcGxldGUsIHVzaW5nIGV4aXN0aW5nIGxheWVyc1xcbi0tJyk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuICB2YXIgZ2V0QmIgPSBmdW5jdGlvbiBnZXRCYigpIHtcbiAgICBpZiAoIWJiKSB7XG4gICAgICBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kaW5nQm94KGJiLCBlbGVzW2ldLmJvdW5kaW5nQm94KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmI7XG4gIH07XG4gIHZhciBtYWtlTGF5ZXIgPSBmdW5jdGlvbiBtYWtlTGF5ZXIob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBhZnRlciA9IG9wdHMuYWZ0ZXI7XG4gICAgZ2V0QmIoKTtcbiAgICB2YXIgdyA9IE1hdGguY2VpbChiYi53ICogc2NhbGUpO1xuICAgIHZhciBoID0gTWF0aC5jZWlsKGJiLmggKiBzY2FsZSk7XG4gICAgaWYgKHcgPiBtYXhMYXllckRpbSB8fCBoID4gbWF4TGF5ZXJEaW0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYXJlYSA9IHcgKiBoO1xuICAgIGlmIChhcmVhID4gbWF4TGF5ZXJBcmVhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoYmIsIGx2bCk7XG4gICAgaWYgKGFmdGVyICE9IG51bGwpIHtcbiAgICAgIHZhciBpbmRleCA9IGxheWVycy5pbmRleE9mKGFmdGVyKSArIDE7XG4gICAgICBsYXllcnMuc3BsaWNlKGluZGV4LCAwLCBsYXllcik7XG4gICAgfSBlbHNlIGlmIChvcHRzLmluc2VydCA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuaW5zZXJ0KSB7XG4gICAgICAvLyBubyBhZnRlciBzcGVjaWZpZWQgPT4gZmlyc3QgbGF5ZXIgbWFkZSBzbyBwdXQgYXQgc3RhcnRcbiAgICAgIGxheWVycy51bnNoaWZ0KGxheWVyKTtcbiAgICB9XG5cbiAgICAvLyBpZiggdG1wTGF5ZXJzICl7XG4gICAgLy9zZWxmLnF1ZXVlTGF5ZXIoIGxheWVyICk7XG4gICAgLy8gfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9O1xuICBpZiAoc2VsZi5za2lwcGluZyAmJiAhZmlyc3RHZXQpIHtcbiAgICAvLyBsb2coJ3NraXAgbGF5ZXJzJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsb2coJ2RvIGxheWVycycpO1xuXG4gIHZhciBsYXllciA9IG51bGw7XG4gIHZhciBtYXhFbGVzUGVyTGF5ZXIgPSBlbGVzLmxlbmd0aCAvIGRlZk51bUxheWVycztcbiAgdmFyIGFsbG93TGF6eVF1ZXVlaW5nID0gIWZpcnN0R2V0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICAvLyBsb2coJ2xvb2sgYXQgZWxlJywgZWxlLmlkKCkpO1xuXG4gICAgdmFyIGV4aXN0aW5nTGF5ZXIgPSBjYWNoZXNbbHZsXTtcbiAgICBpZiAoZXhpc3RpbmdMYXllcikge1xuICAgICAgLy8gcmV1c2UgbGF5ZXIgZm9yIGxhdGVyIGVsZXNcbiAgICAgIC8vIGxvZygncmV1c2UgbGF5ZXIgZm9yJywgZWxlLmlkKCkpO1xuICAgICAgbGF5ZXIgPSBleGlzdGluZ0xheWVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghbGF5ZXIgfHwgbGF5ZXIuZWxlcy5sZW5ndGggPj0gbWF4RWxlc1BlckxheWVyIHx8ICFib3VuZGluZ0JveEluQm91bmRpbmdCb3gobGF5ZXIuYmIsIGVsZS5ib3VuZGluZ0JveCgpKSkge1xuICAgICAgLy8gbG9nKCdtYWtlIG5ldyBsYXllciBmb3IgZWxlICVzJywgZWxlLmlkKCkpO1xuXG4gICAgICBsYXllciA9IG1ha2VMYXllcih7XG4gICAgICAgIGluc2VydDogdHJ1ZSxcbiAgICAgICAgYWZ0ZXI6IGxheWVyXG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgbm93IGxheWVyIGNhbiBiZSBidWlsdCB0aGVuIHdlIGNhbid0IHVzZSBsYXllcnMgYXQgdGhpcyBsZXZlbFxuICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gbG9nKCduZXcgbGF5ZXIgd2l0aCBpZCAlcycsIGxheWVyLmlkKTtcbiAgICB9XG4gICAgaWYgKHRtcExheWVycyB8fCBhbGxvd0xhenlRdWV1ZWluZykge1xuICAgICAgLy8gbG9nKCdxdWV1ZSBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5xdWV1ZUxheWVyKGxheWVyLCBlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2coJ2RyYXcgZWxlICVzIGluIGxheWVyICVzJywgZWxlLmlkKCksIGxheWVyLmlkKTtcbiAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKTtcbiAgICB9XG4gICAgbGF5ZXIuZWxlcy5wdXNoKGVsZSk7XG4gICAgY2FjaGVzW2x2bF0gPSBsYXllcjtcbiAgfVxuXG4gIC8vIGxvZygnLS0nKTtcblxuICBpZiAodG1wTGF5ZXJzKSB7XG4gICAgLy8gdGhlbiB3ZSBvbmx5IHF1ZXVlZCB0aGUgY3VycmVudCBsYXllcnNldCBhbmQgY2FuJ3QgZHJhdyBpdCB5ZXRcbiAgICByZXR1cm4gdG1wTGF5ZXJzO1xuICB9XG4gIGlmIChhbGxvd0xhenlRdWV1ZWluZykge1xuICAgIC8vIGxvZygnbGF6eSBxdWV1ZSBsZXZlbCcsIGx2bCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGxheWVycztcbn07XG5cbi8vIGEgbGF5ZXIgbWF5IHdhbnQgdG8gdXNlIGFuIGVsZSBjYWNoZSBvZiBhIGhpZ2hlciBsZXZlbCB0byBhdm9pZCBibHVycmluZXNzXG4vLyBzbyB0aGUgbGF5ZXIgbGV2ZWwgbWlnaHQgbm90IGVxdWFsIHRoZSBlbGUgbGV2ZWxcbkxUQ3AuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsID0gZnVuY3Rpb24gKGx2bCwgcHhSYXRpbykge1xuICByZXR1cm4gbHZsO1xufTtcbkxUQ3AuZHJhd0VsZUluTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgY29udGV4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8ICFlbGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGx2bCA9IHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKGx2bCwgcHhSYXRpbyk7XG4gIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gIH1cbiAge1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBudWxsLCBudWxsLCBsdmwsIHVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyk7XG4gIH1cbiAge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICB9XG59O1xuTFRDcC5sZXZlbElzQ29tcGxldGUgPSBmdW5jdGlvbiAobHZsLCBlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsdmxdO1xuICBpZiAoIWxheWVycyB8fCBsYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBudW1FbGVzSW5MYXllcnMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBhbnkgZWxlcyBuZWVkZWQgdG8gYmUgZHJhd24geWV0LCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG4gICAgaWYgKGxheWVyLnJlcXMgPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGxheWVyIGlzIGludmFsaWQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcbiAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBudW1FbGVzSW5MYXllcnMgKz0gbGF5ZXIuZWxlcy5sZW5ndGg7XG4gIH1cblxuICAvLyB3ZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBudW1iZXIgb2YgZWxlcyBwYXNzZWQgaW4gdG8gYmUgY29tcGxldGVcbiAgaWYgKG51bUVsZXNJbkxheWVycyAhPT0gZWxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuTFRDcC52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFtsdmxdO1xuICBpZiAoIWxheWVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGluIGEgbGF5ZXIgdGhlIGVsZXMgYXJlIG5vdCBpbiB0aGUgc2FtZSBvcmRlciwgdGhlbiB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuICAvLyAoaS5lLiB0aGVyZSBpcyBhbiBlbGUgaW4gYmV0d2VlbiB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgdmFyIG9mZnNldCA9IC0xO1xuXG4gICAgLy8gZmluZCB0aGUgb2Zmc2V0XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobGF5ZXIuZWxlc1swXSA9PT0gZWxlc1tqXSkge1xuICAgICAgICBvZmZzZXQgPSBqO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIHRoZW4gdGhlIGxheWVyIGhhcyBub25leGlzdGVudCBlbGVtZW50cyBhbmQgaXMgaW52YWxpZFxuICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGhlIGVsZXMgaW4gdGhlIGxheWVyIG11c3QgYmUgaW4gdGhlIHNhbWUgY29udGludW91cyBvcmRlciwgZWxzZSB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuXG4gICAgdmFyIG8gPSBvZmZzZXQ7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYXllci5lbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobGF5ZXIuZWxlc1tqXSAhPT0gZWxlc1tvICsgal0pIHtcbiAgICAgICAgLy8gbG9nKCdpbnZhbGlkYXRlIGJhc2VkIG9uIG9yZGVyaW5nJywgbGF5ZXIuaWQpO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuTFRDcC51cGRhdGVFbGVtZW50c0luTGF5ZXJzID0gZnVuY3Rpb24gKGVsZXMsIHVwZGF0ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBpc0VsZXMgPSBlbGVtZW50KGVsZXNbMF0pO1xuXG4gIC8vIGNvbGxlY3QgdWRwYXRlZCBlbGVtZW50cyAoY2FzY2FkZWQgZnJvbSB0aGUgbGF5ZXJzKSBhbmQgdXBkYXRlIGVhY2hcbiAgLy8gbGF5ZXIgaXRzZWxmIGFsb25nIHRoZSB3YXlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlcSA9IGlzRWxlcyA/IG51bGwgOiBlbGVzW2ldO1xuICAgIHZhciBlbGUgPSBpc0VsZXMgPyBlbGVzW2ldIDogZWxlc1tpXS5lbGU7XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuICAgIGZvciAodmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICAgIHZhciBsYXllciA9IGNhY2hlc1tsXTtcbiAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHVwZGF0ZSBpcyBhIHJlcXVlc3QgZnJvbSB0aGUgZWxlIGNhY2hlLCB0aGVuIGl0IGFmZmVjdHMgb25seVxuICAgICAgLy8gdGhlIG1hdGNoaW5nIGxldmVsXG4gICAgICBpZiAocmVxICYmIHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKGxheWVyLmxldmVsKSAhPT0gcmVxLmxldmVsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdXBkYXRlKGxheWVyLCBlbGUsIHJlcSk7XG4gICAgfVxuICB9XG59O1xuTFRDcC5oYXZlTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBoYXZlTGF5ZXJzID0gZmFsc2U7XG4gIGZvciAodmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2xdO1xuICAgIGlmIChsYXllcnMgJiYgbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGhhdmVMYXllcnMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXZlTGF5ZXJzO1xufTtcbkxUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoZWxlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgLy8gbG9nKCd1cGRhdGUgaW52YWxpZGF0ZSBsYXllciB0aW1lIGZyb20gZWxlcycpO1xuXG4gIGlmIChlbGVzLmxlbmd0aCA9PT0gMCB8fCAhc2VsZi5oYXZlTGF5ZXJzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIGludmFsQXNzb2NMYXllcnMobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgc2VsZi5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICB9KTtcbn07XG5MVENwLmludmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUnKTtcblxuICB0aGlzLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gc2F2ZSBjeWNsZXNcblxuICB2YXIgbHZsID0gbGF5ZXIubGV2ZWw7XG4gIHZhciBlbGVzID0gbGF5ZXIuZWxlcztcbiAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gIC8vIGxvZygnaW52YWxpZGF0ZSBsYXllcicsIGxheWVyLmlkICk7XG5cbiAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpO1xuICAvLyBsYXllci5lbGVzID0gW107XG5cbiAgbGF5ZXIuZWxlc1F1ZXVlID0gW107XG4gIGxheWVyLmludmFsaWQgPSB0cnVlO1xuICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICBsYXllci5yZXBsYWNlbWVudC5pbnZhbGlkID0gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2FjaGVzID0gZWxlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbWdMYXllckNhY2hlcztcbiAgICBpZiAoY2FjaGVzKSB7XG4gICAgICBjYWNoZXNbbHZsXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuTFRDcC5yZWZpbmVFbGVtZW50VGV4dHVyZXMgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gbG9nKCdyZWZpbmUnLCBlbGVzLmxlbmd0aCk7XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgdmFyIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudDtcbiAgICBpZiAoIXJMeXIpIHtcbiAgICAgIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudCA9IHNlbGYubWFrZUxheWVyKGxheWVyLmJiLCBsYXllci5sZXZlbCk7XG4gICAgICByTHlyLnJlcGxhY2VzID0gbGF5ZXI7XG4gICAgICByTHlyLmVsZXMgPSBsYXllci5lbGVzO1xuXG4gICAgICAvLyBsb2coJ21ha2UgcmVwbGFjZW1lbnQgbGF5ZXIgJXMgZm9yICVzIHdpdGggbGV2ZWwgJXMnLCByTHlyLmlkLCBsYXllci5pZCwgckx5ci5sZXZlbCk7XG4gICAgfVxuICAgIGlmICghckx5ci5yZXFzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJMeXIuZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnF1ZXVlTGF5ZXIockx5ciwgckx5ci5lbGVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgLy8gbG9nKCdxdWV1ZSByZXBsYWNlbWVudCBsYXllciByZWZpbmVtZW50Jywgckx5ci5pZCk7XG4gICAgfVxuICB9KTtcbn07XG5MVENwLmVucXVldWVFbGVtZW50UmVmaW5lbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdGhpcy5lbGVUeHJEZXFzLm1lcmdlKGVsZSk7XG4gIHRoaXMuc2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCgpO1xufTtcbkxUQ3AucXVldWVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZWxlc1EgPSBsYXllci5lbGVzUXVldWU7XG4gIHZhciBoYXNJZCA9IGVsZXNRLmhhc0lkID0gZWxlc1EuaGFzSWQgfHwge307XG5cbiAgLy8gaWYgYSBsYXllciBpcyBnb2luZyB0byBiZSByZXBsYWNlZCwgcXVldWluZyBpcyBhIHdhc3RlIG9mIHRpbWVcbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGUpIHtcbiAgICBpZiAoaGFzSWRbZWxlLmlkKCldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZXNRLnB1c2goZWxlKTtcbiAgICBoYXNJZFtlbGUuaWQoKV0gPSB0cnVlO1xuICB9XG4gIGlmIChsYXllci5yZXFzKSB7XG4gICAgbGF5ZXIucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShsYXllcik7XG4gIH0gZWxzZSB7XG4gICAgbGF5ZXIucmVxcyA9IDE7XG4gICAgcS5wdXNoKGxheWVyKTtcbiAgfVxufTtcbkxUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZGVxZCA9IFtdO1xuICB2YXIgZWxlRGVxcyA9IDA7XG4gIHdoaWxlIChlbGVEZXFzIDwgbWF4RGVxU2l6ZSkge1xuICAgIGlmIChxLnNpemUoKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBsYXllciA9IHEucGVlaygpO1xuXG4gICAgLy8gaWYgYSBsYXllciBoYXMgYmVlbiBvciB3aWxsIGJlIHJlcGxhY2VkLCB0aGVuIGRvbid0IHdhc3RlIHRpbWUgd2l0aCBpdFxuICAgIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciAlcyBpbiBxdWV1ZSBza2lwcGVkIGIvYyBpdCBhbHJlYWR5IGhhcyBhIHJlcGxhY2VtZW50JywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaXMgYSByZXBsYWNlbWVudCBsYXllciB0aGF0IGhhcyBiZWVuIHN1cGVyY2VkZWQsIHRoZW4gZm9yZ2V0IGl0XG4gICAgaWYgKGxheWVyLnJlcGxhY2VzICYmIGxheWVyICE9PSBsYXllci5yZXBsYWNlcy5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciBpcyBubyBsb25nZXIgdGhlIG1vc3QgdXB0b2RhdGUgcmVwbGFjZW1lbnQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpXG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyICVzIGlzIGludmFsaWQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgZWxlID0gbGF5ZXIuZWxlc1F1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKGVsZSkge1xuICAgICAgLy8gbG9nKCdkZXF1ZXVlIGxheWVyICVzJywgbGF5ZXIuaWQpO1xuXG4gICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKGxheWVyLCBlbGUsIGxheWVyLmxldmVsLCBweFJhdGlvKTtcbiAgICAgIGVsZURlcXMrKztcbiAgICB9XG4gICAgaWYgKGRlcWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyB3ZSBuZWVkIG9ubHkgb25lIGVudHJ5IGluIGRlcWQgdG8gcXVldWUgcmVkcmF3aW5nIGV0Y1xuICAgICAgZGVxZC5wdXNoKHRydWUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsYXllciBoYXMgYWxsIGl0cyBlbGVzIGRvbmUsIHRoZW4gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlXG4gICAgaWYgKGxheWVyLmVsZXNRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHEucG9wKCk7XG4gICAgICBsYXllci5yZXFzID0gMDtcblxuICAgICAgLy8gbG9nKCdkZXF1ZXVlIG9mIGxheWVyICVzIGNvbXBsZXRlJywgbGF5ZXIuaWQpO1xuXG4gICAgICAvLyB3aGVuIGEgcmVwbGFjZW1lbnQgbGF5ZXIgaXMgZGVxdWV1ZWQsIGl0IHJlcGxhY2VzIHRoZSBvbGQgbGF5ZXIgaW4gdGhlIGxldmVsXG4gICAgICBpZiAobGF5ZXIucmVwbGFjZXMpIHtcbiAgICAgICAgc2VsZi5hcHBseUxheWVyUmVwbGFjZW1lbnQobGF5ZXIpO1xuICAgICAgfVxuICAgICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXFkO1xufTtcbkxUQ3AuYXBwbHlMYXllclJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVyc0luTGV2ZWwgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbGF5ZXIubGV2ZWxdO1xuICB2YXIgcmVwbGFjZWQgPSBsYXllci5yZXBsYWNlcztcbiAgdmFyIGluZGV4ID0gbGF5ZXJzSW5MZXZlbC5pbmRleE9mKHJlcGxhY2VkKTtcblxuICAvLyBpZiB0aGUgcmVwbGFjZWQgbGF5ZXIgaXMgbm90IGluIHRoZSBhY3RpdmUgbGlzdCBmb3IgdGhlIGxldmVsLCB0aGVuIHJlcGxhY2luZ1xuICAvLyByZWZzIHdvdWxkIGJlIGEgbWlzdGFrZSAoaS5lLiBvdmVyd3JpdGluZyB0aGUgdHJ1ZSBhY3RpdmUgbGF5ZXIpXG4gIGlmIChpbmRleCA8IDAgfHwgcmVwbGFjZWQuaW52YWxpZCkge1xuICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgd291bGQgaGF2ZSBubyBlZmZlY3QnLCBsYXllci5pZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxheWVyc0luTGV2ZWxbaW5kZXhdID0gbGF5ZXI7IC8vIHJlcGxhY2UgbGV2ZWwgcmVmXG5cbiAgLy8gcmVwbGFjZSByZWZzIGluIGVsZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5lbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gbGF5ZXIuZWxlc1tpXS5fcHJpdmF0ZTtcbiAgICB2YXIgY2FjaGUgPSBfcC5pbWdMYXllckNhY2hlcyA9IF9wLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgY2FjaGVbbGF5ZXIubGV2ZWxdID0gbGF5ZXI7XG4gICAgfVxuICB9XG5cbiAgLy8gbG9nKCdhcHBseSByZXBsYWNlbWVudCBsYXllciAlcyBvdmVyICVzJywgbGF5ZXIuaWQsIHJlcGxhY2VkLmlkKTtcblxuICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbn07XG5MVENwLnJlcXVlc3RSZWRyYXcgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICByLnJlZHJhdygpO1xufSwgMTAwKTtcbkxUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgZGVxQ29zdDogZGVxQ29zdCxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvKSB7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZShweFJhdGlvKTtcbiAgfSxcbiAgb25EZXFkOiBub29wJDEsXG4gIHNob3VsZFJlZHJhdzogdHJ1ZWlmeSxcbiAgcHJpb3JpdHk6IGZ1bmN0aW9uIHByaW9yaXR5KHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmx5clR4ckRlcTtcbiAgfVxufSk7XG5cbnZhciBDUnAkYiA9IHt9O1xudmFyIGltcGw7XG5mdW5jdGlvbiBwb2x5Z29uKGNvbnRleHQsIHBvaW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxufVxuZnVuY3Rpb24gdHJpYW5nbGVCYWNrY3VydmUoY29udGV4dCwgcG9pbnRzLCBjb250cm9sUG9pbnQpIHtcbiAgdmFyIGZpcnN0UHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBmaXJzdFB0ID0gcHQ7XG4gICAgfVxuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbn1cbmZ1bmN0aW9uIHRyaWFuZ2xlVGVlKGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCB0ZWVQb2ludHMpIHtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gdHJpUHRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG4gIHZhciB0ZWVQdHMgPSB0ZWVQb2ludHM7XG4gIHZhciBmaXJzdFRlZVB0ID0gdGVlUG9pbnRzWzBdO1xuICBjb250ZXh0Lm1vdmVUbyhmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGVlUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gdGVlUHRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG4gIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNpcmNsZVRyaWFuZ2xlKGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCByeCwgcnksIHIpIHtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgdmFyIGZpcnN0VHJQdCA9IHRyaVB0c1swXTtcbiAgY29udGV4dC5tb3ZlVG8oZmlyc3RUclB0LngsIGZpcnN0VHJQdC55KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2lyY2xlJDEoY29udGV4dCwgcngsIHJ5LCByKSB7XG4gIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbn1cbkNScCRiLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIChpbXBsIHx8IChpbXBsID0ge1xuICAgICdwb2x5Z29uJzogcG9seWdvbixcbiAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogdHJpYW5nbGVCYWNrY3VydmUsXG4gICAgJ3RyaWFuZ2xlLXRlZSc6IHRyaWFuZ2xlVGVlLFxuICAgICdjaXJjbGUtdHJpYW5nbGUnOiBjaXJjbGVUcmlhbmdsZSxcbiAgICAndHJpYW5nbGUtY3Jvc3MnOiB0cmlhbmdsZVRlZSxcbiAgICAnY2lyY2xlJzogY2lyY2xlJDFcbiAgfSkpW25hbWVdO1xufTtcblxudmFyIENScCRhID0ge307XG5DUnAkYS5kcmF3RWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KTtcbiAgfVxufTtcbkNScCRhLmRyYXdFbGVtZW50T3ZlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgci5kcmF3Tm9kZU92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfSBlbHNlIHtcbiAgICByLmRyYXdFZGdlT3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuQ1JwJGEuZHJhd0VsZW1lbnRVbmRlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgci5kcmF3Tm9kZVVuZGVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3RWRnZVVuZGVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5DUnAkYS5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24gPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFJvdGF0aW9uLCBnZXRPcGFjaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGJiID0gZWxlVHhyQ2FjaGUuZ2V0Qm91bmRpbmdCb3goZWxlKTtcbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBpZ25vcmUgemVybyBzaXplIGNhc2VcblxuICB2YXIgZWxlQ2FjaGUgPSBlbGVUeHJDYWNoZS5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKTtcbiAgaWYgKGVsZUNhY2hlICE9IG51bGwpIHtcbiAgICB2YXIgb3BhY2l0eSA9IGdldE9wYWNpdHkociwgZWxlKTtcbiAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGhldGEgPSBnZXRSb3RhdGlvbihyLCBlbGUpO1xuICAgIHZhciB4MSA9IGJiLngxLFxuICAgICAgeTEgPSBiYi55MSxcbiAgICAgIHcgPSBiYi53LFxuICAgICAgaCA9IGJiLmg7XG4gICAgdmFyIHgsIHksIHN4LCBzeSwgc21vb3RoO1xuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgdmFyIHJvdFB0ID0gZWxlVHhyQ2FjaGUuZ2V0Um90YXRpb25Qb2ludChlbGUpO1xuICAgICAgc3ggPSByb3RQdC54O1xuICAgICAgc3kgPSByb3RQdC55O1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoc3gsIHN5KTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcbiAgICAgIHNtb290aCA9IHIuZ2V0SW1nU21vb3RoaW5nKGNvbnRleHQpO1xuICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgb2ZmID0gZWxlVHhyQ2FjaGUuZ2V0Um90YXRpb25PZmZzZXQoZWxlKTtcbiAgICAgIHggPSBvZmYueDtcbiAgICAgIHkgPSBvZmYueTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgxO1xuICAgICAgeSA9IHkxO1xuICAgIH1cbiAgICB2YXIgb2xkR2xvYmFsQWxwaGE7XG4gICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgIG9sZEdsb2JhbEFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYSAqIG9wYWNpdHk7XG4gICAgfVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGVsZUNhY2hlLnRleHR1cmUuY2FudmFzLCBlbGVDYWNoZS54LCAwLCBlbGVDYWNoZS53aWR0aCwgZWxlQ2FjaGUuaGVpZ2h0LCB4LCB5LCB3LCBoKTtcbiAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9sZEdsb2JhbEFscGhhO1xuICAgIH1cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtc3gsIC1zeSk7XG4gICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVsZVR4ckNhY2hlLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7IC8vIGRpcmVjdCBkcmF3IGZhbGxiYWNrXG4gIH1cbn07XG52YXIgZ2V0WmVyb1JvdGF0aW9uID0gZnVuY3Rpb24gZ2V0WmVyb1JvdGF0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG52YXIgZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsIG51bGwpO1xufTtcbnZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3NvdXJjZScpO1xufTtcbnZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xufTtcbnZhciBnZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eShyLCBlbGUpIHtcbiAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG59O1xudmFyIGdldFRleHRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0VGV4dE9wYWNpdHkoZSwgZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS5wZlZhbHVlICogZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbn07XG5DUnAkYS5kcmF3Q2FjaGVkRWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCwgbHZsLCByZXF1ZXN0SGlnaFF1YWxpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgX3IkZGF0YSA9IHIuZGF0YSxcbiAgICBlbGVUeHJDYWNoZSA9IF9yJGRhdGEuZWxlVHhyQ2FjaGUsXG4gICAgbGJsVHhyQ2FjaGUgPSBfciRkYXRhLmxibFR4ckNhY2hlLFxuICAgIHNsYlR4ckNhY2hlID0gX3IkZGF0YS5zbGJUeHJDYWNoZSxcbiAgICB0bGJUeHJDYWNoZSA9IF9yJGRhdGEudGxiVHhyQ2FjaGU7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuICB2YXIgcmVhc29uID0gcmVxdWVzdEhpZ2hRdWFsaXR5ID09PSB0cnVlID8gZWxlVHhyQ2FjaGUucmVhc29ucy5oaWdoUXVhbGl0eSA6IG51bGw7XG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFleHRlbnQgfHwgYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG4gICAgci5kcmF3RWxlbWVudFVuZGVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFplcm9Sb3RhdGlvbiwgZ2V0T3BhY2l0eSk7XG4gICAgaWYgKCFpc0VkZ2UgfHwgIWJhZExpbmUpIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgbGJsVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgfVxuICAgIGlmIChpc0VkZ2UgJiYgIWJhZExpbmUpIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgc2xiVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHRsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgIH1cbiAgICByLmRyYXdFbGVtZW50T3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuQ1JwJGEuZHJhd0VsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5DUnAkYS5kcmF3Q2FjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5DUnAkYS5kcmF3Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcbkNScCRhLmRyYXdMYXllcmVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHIuZGF0YS5seXJUeHJDYWNoZS5nZXRMYXllcnMoZWxlcywgcHhSYXRpbyk7XG4gIGlmIChsYXllcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgdmFyIGJiID0gbGF5ZXIuYmI7XG4gICAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UobGF5ZXIuY2FudmFzLCBiYi54MSwgYmIueTEsIGJiLncsIGJiLmgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsIGJhY2sgb24gcGxhaW4gY2FjaGluZyBpZiBubyBsYXllcnNcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuXG52YXIgQ1JwJDkgPSB7fTtcbkNScCQ5LmRyYXdFZGdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFlZGdlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGJlemllciBjdHJsIHB0cyBjYW4gbm90IGJlIGNhbGN1bGF0ZWQsIHRoZW4gZGllXG4gIGlmIChycy5iYWRMaW5lIHx8IHJzLmFsbHB0cyA9PSBudWxsIHx8IGlzTmFOKHJzLmFsbHB0c1swXSkpIHtcbiAgICAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGJiO1xuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cbiAgdmFyIG9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgOiAxO1xuICB2YXIgbGluZU9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdsaW5lLW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gIHZhciBsaW5lU3R5bGUgPSBlZGdlLnBzdHlsZSgnbGluZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgdmFyIGxpbmVDYXAgPSBlZGdlLnBzdHlsZSgnbGluZS1jYXAnKS52YWx1ZTtcbiAgdmFyIGxpbmVPdXRsaW5lV2lkdGggPSBlZGdlLnBzdHlsZSgnbGluZS1vdXRsaW5lLXdpZHRoJykudmFsdWU7XG4gIHZhciBsaW5lT3V0bGluZUNvbG9yID0gZWRnZS5wc3R5bGUoJ2xpbmUtb3V0bGluZS1jb2xvcicpLnZhbHVlO1xuICB2YXIgZWZmZWN0aXZlTGluZU9wYWNpdHkgPSBvcGFjaXR5ICogbGluZU9wYWNpdHk7XG4gIC8vIHNlcGFyYXRlIGFycm93IG9wYWNpdHkgd291bGQgcmVxdWlyZSBhcnJvdy1vcGFjaXR5IHByb3BlcnR5XG4gIHZhciBlZmZlY3RpdmVBcnJvd09wYWNpdHkgPSBvcGFjaXR5ICogbGluZU9wYWNpdHk7XG4gIHZhciBkcmF3TGluZSA9IGZ1bmN0aW9uIGRyYXdMaW5lKCkge1xuICAgIHZhciBzdHJva2VPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVMaW5lT3BhY2l0eTtcbiAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0LXRyaWFuZ2xlJykge1xuICAgICAgci5lbGVTdHJva2VTdHlsZShjb250ZXh0LCBlZGdlLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgIHIuZHJhd0VkZ2VUcmlhbmdsZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgci5lbGVTdHJva2VTdHlsZShjb250ZXh0LCBlZGdlLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgfVxuICB9O1xuICB2YXIgZHJhd0xpbmVPdXRsaW5lID0gZnVuY3Rpb24gZHJhd0xpbmVPdXRsaW5lKCkge1xuICAgIHZhciBzdHJva2VPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVMaW5lT3BhY2l0eTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aCArIGxpbmVPdXRsaW5lV2lkdGg7XG4gICAgY29udGV4dC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICBpZiAobGluZU91dGxpbmVXaWR0aCA+IDApIHtcbiAgICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBsaW5lT3V0bGluZUNvbG9yWzBdLCBsaW5lT3V0bGluZUNvbG9yWzFdLCBsaW5lT3V0bGluZUNvbG9yWzJdLCBzdHJva2VPcGFjaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG8gbm90IGRyYXcgYW55IGxpbmVPdXRsaW5lXG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IC8vIHJlc2V0IGZvciBvdGhlciBkcmF3aW5nIGZ1bmN0aW9uc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0LXRyaWFuZ2xlJykge1xuICAgICAgci5kcmF3RWRnZVRyaWFuZ2xlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsIGxpbmVTdHlsZSk7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IC8vIHJlc2V0IGZvciBvdGhlciBkcmF3aW5nIGZ1bmN0aW9uc1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByLmRyYXdFZGdlT3ZlcmxheShjb250ZXh0LCBlZGdlKTtcbiAgfTtcbiAgdmFyIGRyYXdVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdVbmRlcmxheSgpIHtcbiAgICBpZiAoIXNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHIuZHJhd0VkZ2VVbmRlcmxheShjb250ZXh0LCBlZGdlKTtcbiAgfTtcbiAgdmFyIGRyYXdBcnJvd3MgPSBmdW5jdGlvbiBkcmF3QXJyb3dzKCkge1xuICAgIHZhciBhcnJvd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVmZmVjdGl2ZUFycm93T3BhY2l0eTtcbiAgICByLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGFycm93T3BhY2l0eSk7XG4gIH07XG4gIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVkZ2UsIG51bGwsIGRyYXdMYWJlbCk7XG4gIH07XG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuICB2YXIgZ2hvc3QgPSBlZGdlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmZWN0aXZlR2hvc3RPcGFjaXR5ID0gZWZmZWN0aXZlTGluZU9wYWNpdHkgKiBnaG9zdE9wYWNpdHk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBkcmF3TGluZShlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgIGRyYXdBcnJvd3MoZWZmZWN0aXZlR2hvc3RPcGFjaXR5KTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gIH0gZWxzZSB7XG4gICAgZHJhd0xpbmVPdXRsaW5lKCk7XG4gIH1cbiAgZHJhd1VuZGVybGF5KCk7XG4gIGRyYXdMaW5lKCk7XG4gIGRyYXdBcnJvd3MoKTtcbiAgZHJhd092ZXJsYXkoKTtcbiAgZHJhd1RleHQoKTtcbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICB9XG59O1xudmFyIGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5ID0gZnVuY3Rpb24gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkob3ZlcmxheU9yVW5kZXJsYXkpIHtcbiAgaWYgKCFbJ292ZXJsYXknLCAndW5kZXJsYXknXS5pbmNsdWRlcyhvdmVybGF5T3JVbmRlcmxheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UpIHtcbiAgICBpZiAoIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvcGFjaXR5ID0gZWRnZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLW9wYWNpdHlcIikpLnZhbHVlO1xuICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgcGFkZGluZyA9IGVkZ2UucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1wYWRkaW5nXCIpKS5wZlZhbHVlO1xuICAgIHZhciB3aWR0aCA9IDIgKiBwYWRkaW5nO1xuICAgIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1jb2xvclwiKSkudmFsdWU7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWxmJyAmJiAhdXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICB9XG4gICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgJ3NvbGlkJyk7XG4gIH07XG59O1xuQ1JwJDkuZHJhd0VkZ2VPdmVybGF5ID0gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkoJ292ZXJsYXknKTtcbkNScCQ5LmRyYXdFZGdlVW5kZXJsYXkgPSBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSgndW5kZXJsYXknKTtcbkNScCQ5LmRyYXdFZGdlUGF0aCA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBwdHMsIHR5cGUpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGxpbmVEYXNoUGF0dGVybiA9IGVkZ2UucHN0eWxlKCdsaW5lLWRhc2gtcGF0dGVybicpLnBmVmFsdWU7XG4gIHZhciBsaW5lRGFzaE9mZnNldCA9IGVkZ2UucHN0eWxlKCdsaW5lLWRhc2gtb2Zmc2V0JykucGZWYWx1ZTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHB0cy5qb2luKCckJyk7XG4gICAgdmFyIGtleU1hdGNoZXMgPSBycy5wYXRoQ2FjaGVLZXkgJiYgcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXk7XG4gICAgaWYgKGtleU1hdGNoZXMpIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICBpZiAoY2FudmFzQ3h0LnNldExpbmVEYXNoKSB7XG4gICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2gobGluZURhc2hQYXR0ZXJuKTtcbiAgICAgICAgY2FudmFzQ3h0LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFwYXRoQ2FjaGVIaXQgJiYgIXJzLmJhZExpbmUpIHtcbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuICAgIGNvbnRleHQubW92ZVRvKHB0c1swXSwgcHRzWzFdKTtcbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pICsgMSA8IHB0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbX2ldLCBwdHNbX2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICAgIGlmIChycy5pc1JvdW5kKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJzLnJvdW5kQ29ybmVycyksXG4gICAgICAgICAgICBfc3RlcDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGNvcm5lciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBkcmF3UHJlcGFyZWRSb3VuZENvcm5lcihjb250ZXh0LCBjb3JuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW3B0cy5sZW5ndGggLSAyXSwgcHRzW3B0cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMjsgX2kyICsgMSA8IHB0cy5sZW5ndGg7IF9pMiArPSAyKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbX2kyXSwgcHRzW19pMiArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnRleHQgPSBjYW52YXNDeHQ7XG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICAvLyByZXNldCBhbnkgbGluZSBkYXNoZXNcbiAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgfVxufTtcbkNScCQ5LmRyYXdFZGdlVHJpYW5nbGVQYXRoID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIHB0cykge1xuICAvLyB1c2UgbGluZSBzdHJva2Ugc3R5bGUgZm9yIHRyaWFuZ2xlIGZpbGwgc3R5bGVcbiAgY29udGV4dC5maWxsU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHZlY3RvciA9IFtwdHNbaSArIDJdIC0gcHRzW2ldLCBwdHNbaSArIDNdIC0gcHRzW2kgKyAxXV07XG4gICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydCh2ZWN0b3JbMF0gKiB2ZWN0b3JbMF0gKyB2ZWN0b3JbMV0gKiB2ZWN0b3JbMV0pO1xuICAgIHZhciBub3JtYWwgPSBbdmVjdG9yWzFdIC8gbGVuZ3RoLCAtdmVjdG9yWzBdIC8gbGVuZ3RoXTtcbiAgICB2YXIgdHJpYW5nbGVIZWFkID0gW25vcm1hbFswXSAqIGVkZ2VXaWR0aCAvIDIsIG5vcm1hbFsxXSAqIGVkZ2VXaWR0aCAvIDJdO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8ocHRzW2ldIC0gdHJpYW5nbGVIZWFkWzBdLCBwdHNbaSArIDFdIC0gdHJpYW5nbGVIZWFkWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdHNbaV0gKyB0cmlhbmdsZUhlYWRbMF0sIHB0c1tpICsgMV0gKyB0cmlhbmdsZUhlYWRbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHB0c1tpICsgMl0sIHB0c1tpICsgM10pO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbn07XG5DUnAkOS5kcmF3QXJyb3doZWFkcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBvcGFjaXR5KSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxuICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ21pZC10YXJnZXQnLCBycy5taWRYLCBycy5taWRZLCBycy5taWR0Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdtaWQtc291cmNlJywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkc3JjQXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAndGFyZ2V0JywgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHJzLnRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICB9XG59O1xuQ1JwJDkuZHJhd0Fycm93aGVhZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBwcmVmaXgsIHgsIHksIGFuZ2xlLCBvcGFjaXR5KSB7XG4gIGlmIChpc05hTih4KSB8fCB4ID09IG51bGwgfHwgaXNOYU4oeSkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFycm93U2hhcGUgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gIGlmIChhcnJvd1NoYXBlID09PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFycm93Q2xlYXJGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gIHZhciBhcnJvd0ZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBwQXJyb3dXaWR0aCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctd2lkdGgnKTtcbiAgdmFyIGFycm93V2lkdGggPSBwQXJyb3dXaWR0aC52YWx1ZSA9PT0gJ21hdGNoLWxpbmUnID8gZWRnZVdpZHRoIDogcEFycm93V2lkdGgucGZWYWx1ZTtcbiAgaWYgKHBBcnJvd1dpZHRoLnVuaXRzID09PSAnJScpIGFycm93V2lkdGggKj0gZWRnZVdpZHRoO1xuICB2YXIgZWRnZU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICBpZiAob3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3BhY2l0eSA9IGVkZ2VPcGFjaXR5O1xuICB9XG4gIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgaWYgKG9wYWNpdHkgIT09IDEgfHwgYXJyb3dGaWxsID09PSAnaG9sbG93Jykge1xuICAgIC8vIHRoZW4gZXh0cmEgY2xlYXIgaXMgbmVlZGVkXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICBzZWxmLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgIHNlbGYuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93Q2xlYXJGaWxsLCBlZGdlV2lkdGgsIGFycm93U2hhcGUsIGFycm93V2lkdGgsIHgsIHksIGFuZ2xlKTtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfSAvLyBvdGhlcndpc2UsIHRoZSBvcGFxdWUgYXJyb3cgY2xlYXJzIGl0IGZvciBmcmVlIDopXG5cbiAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1jb2xvcicpLnZhbHVlO1xuICBzZWxmLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICBzZWxmLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dGaWxsLCBlZGdlV2lkdGgsIGFycm93U2hhcGUsIGFycm93V2lkdGgsIHgsIHksIGFuZ2xlKTtcbn07XG5DUnAkOS5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCBzaGFwZVdpZHRoLCB4LCB5LCBhbmdsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKSAmJiBzaGFwZSAhPT0gJ3RyaWFuZ2xlLWNyb3NzJztcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgcGF0aDtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG4gIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlV2lkdGgsIHNjYWxlKTtcbiAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICB2YXIgY2FjaGUgPSByLmFycm93UGF0aENhY2hlID0gci5hcnJvd1BhdGhDYWNoZSB8fCBbXTtcbiAgICB2YXIga2V5ID0gaGFzaFN0cmluZyhzaGFwZSk7XG4gICAgdmFyIGNhY2hlZFBhdGggPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWRQYXRoICE9IG51bGwpIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gY2FjaGVkUGF0aDtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY2FjaGVba2V5XSA9IHBhdGg7XG4gICAgfVxuICB9XG4gIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIC8vIHN0b3JlIGluIHRoZSBwYXRoIGNhY2hlIHdpdGggdmFsdWVzIGVhc2lseSBtYW5pcHVsYXRlZCBsYXRlclxuICAgICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgMSwgMCwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICAvLyBzZXQgdHJhbnNmb3JtIHRvIGFycm93IHBvc2l0aW9uL29yaWVudGF0aW9uXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5yb3RhdGUoYW5nbGUpO1xuICAgIGNvbnRleHQuc2NhbGUoc2l6ZSwgc2l6ZSk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2hhcGVXaWR0aCAvICh1c2VQYXRocyA/IHNpemUgOiAxKTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuICBpZiAodXNlUGF0aHMpIHtcbiAgICAvLyByZXNldCB0cmFuc2Zvcm0gYnkgYXBwbHlpbmcgaW52ZXJzZVxuICAgIGNvbnRleHQuc2NhbGUoMSAvIHNpemUsIDEgLyBzaXplKTtcbiAgICBjb250ZXh0LnJvdGF0ZSgtYW5nbGUpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbn07XG5cbnZhciBDUnAkOCA9IHt9O1xuQ1JwJDguc2FmZURyYXdJbWFnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoKSB7XG4gIC8vIGRldGVjdCBwcm9ibGVtYXRpYyBjYXNlcyBmb3Igb2xkIGJyb3dzZXJzIHdpdGggYmFkIGltYWdlcyAoY2hlYXBlciB0aGFuIHRyeS1jYXRjaClcbiAgaWYgKGl3IDw9IDAgfHwgaWggPD0gMCB8fCB3IDw9IDAgfHwgaCA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3YXJuKGUpO1xuICB9XG59O1xuQ1JwJDguZHJhd0luc2NyaWJlZEltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgbm9kZSwgaW5kZXgsIG5vZGVPcGFjaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIG5vZGVYID0gcG9zLng7XG4gIHZhciBub2RlWSA9IHBvcy55O1xuICB2YXIgc3R5bGVPYmogPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgdmFyIGdldEluZGV4ZWRTdHlsZSA9IHN0eWxlT2JqLmdldEluZGV4ZWRTdHlsZS5iaW5kKHN0eWxlT2JqKTtcbiAgdmFyIGZpdCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1maXQnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciByZXBlYXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcmVwZWF0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBwYWRkaW5nWDIgPSBub2RlLnBhZGRpbmcoKSAqIDI7XG4gIHZhciBub2RlVFcgPSBub2RlVyArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgdmFyIG5vZGVUSCA9IG5vZGVIICsgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNsaXAgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtY2xpcCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gIHZhciBpbWdPcGFjaXR5ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCAndmFsdWUnLCBpbmRleCkgKiBub2RlT3BhY2l0eTtcbiAgdmFyIHNtb290aCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1zbW9vdGhpbmcnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlO1xuICBpZiAoY29ybmVyUmFkaXVzICE9PSAnYXV0bycpIGNvcm5lclJhZGl1cyA9IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgdmFyIGltZ1cgPSBpbWcud2lkdGggfHwgaW1nLmNhY2hlZFc7XG4gIHZhciBpbWdIID0gaW1nLmhlaWdodCB8fCBpbWcuY2FjaGVkSDtcblxuICAvLyB3b3JrYXJvdW5kIGZvciBicm9rZW4gYnJvd3NlcnMgbGlrZSBpZVxuICBpZiAobnVsbCA9PSBpbWdXIHx8IG51bGwgPT0gaW1nSCkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgaW1nVyA9IGltZy5jYWNoZWRXID0gaW1nLndpZHRoIHx8IGltZy5vZmZzZXRXaWR0aDtcbiAgICBpbWdIID0gaW1nLmNhY2hlZEggPSBpbWcuaGVpZ2h0IHx8IGltZy5vZmZzZXRIZWlnaHQ7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbWcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH1cbiAgdmFyIHcgPSBpbWdXO1xuICB2YXIgaCA9IGltZ0g7XG4gIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAndmFsdWUnLCBpbmRleCkgIT09ICdhdXRvJykge1xuICAgIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgdyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICdwZlZhbHVlJywgaW5kZXgpICogbm9kZVRXO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3ZhbHVlJywgaW5kZXgpICE9PSAnYXV0bycpIHtcbiAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpICogbm9kZVRIO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICAgIH1cbiAgfVxuICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cbiAgaWYgKGZpdCA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5taW4obm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9IGVsc2UgaWYgKGZpdCA9PT0gJ2NvdmVyJykge1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KG5vZGVUVyAvIHcsIG5vZGVUSCAvIGgpO1xuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcbiAgfVxuICB2YXIgeCA9IG5vZGVYIC0gbm9kZVRXIC8gMjsgLy8gbGVmdFxuICB2YXIgcG9zWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBwb3NYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICBpZiAocG9zWFVuaXRzID09PSAnJScpIHtcbiAgICB4ICs9IChub2RlVFcgLSB3KSAqIHBvc1hQZlZhbDtcbiAgfSBlbHNlIHtcbiAgICB4ICs9IHBvc1hQZlZhbDtcbiAgfVxuICB2YXIgb2ZmWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC14JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgb2ZmWFBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC14JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gIGlmIChvZmZYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogb2ZmWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gb2ZmWFBmVmFsO1xuICB9XG4gIHZhciB5ID0gbm9kZVkgLSBub2RlVEggLyAyOyAvLyB0b3BcbiAgdmFyIHBvc1lVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgcG9zWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgaWYgKHBvc1lVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBwb3NZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBwb3NZUGZWYWw7XG4gIH1cbiAgdmFyIG9mZllVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteScsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIG9mZllQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteScsICdwZlZhbHVlJywgaW5kZXgpO1xuICBpZiAob2ZmWVVuaXRzID09PSAnJScpIHtcbiAgICB5ICs9IChub2RlVEggLSBoKSAqIG9mZllQZlZhbDtcbiAgfSBlbHNlIHtcbiAgICB5ICs9IG9mZllQZlZhbDtcbiAgfVxuICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgeCAtPSBub2RlWDtcbiAgICB5IC09IG5vZGVZO1xuICAgIG5vZGVYID0gMDtcbiAgICBub2RlWSA9IDA7XG4gIH1cbiAgdmFyIGdBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBpbWdPcGFjaXR5O1xuICB2YXIgc21vb3RoaW5nRW5hYmxlZCA9IHIuZ2V0SW1nU21vb3RoaW5nKGNvbnRleHQpO1xuICB2YXIgaXNTbW9vdGhpbmdTd2l0Y2hlZCA9IGZhbHNlO1xuICBpZiAoc21vb3RoID09PSAnbm8nICYmIHNtb290aGluZ0VuYWJsZWQpIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgaXNTbW9vdGhpbmdTd2l0Y2hlZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc21vb3RoID09PSAneWVzJyAmJiAhc21vb3RoaW5nRW5hYmxlZCkge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgIGlzU21vb3RoaW5nU3dpdGNoZWQgPSB0cnVlO1xuICB9XG4gIGlmIChyZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgaWYgKHJzLnBhdGhDYWNoZSkge1xuICAgICAgICBjb250ZXh0LmNsaXAocnMucGF0aENhY2hlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRILCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHIuc2FmZURyYXdJbWFnZShjb250ZXh0LCBpbWcsIDAsIDAsIGltZ1csIGltZ0gsIHgsIHksIHcsIGgpO1xuICAgIGlmIChzaG91bGRDbGlwKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oaW1nLCByZXBlYXQpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgbm9kZVgsIG5vZGVZLCBub2RlVFcsIG5vZGVUSCwgY29ybmVyUmFkaXVzLCBycyk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZ0FscGhhO1xuICBpZiAoaXNTbW9vdGhpbmdTd2l0Y2hlZCkge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHNtb290aGluZ0VuYWJsZWQpO1xuICB9XG59O1xuXG52YXIgQ1JwJDcgPSB7fTtcbkNScCQ3LmVsZVRleHRCaWdnZXJUaGFuTWluID0gZnVuY3Rpb24gKGVsZSwgc2NhbGUpIHtcbiAgaWYgKCFzY2FsZSkge1xuICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuICAgIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgdmFyIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7IC8vIHRoZSBlZmZlY3RpdmUgdGV4dHVyZSBsZXZlbFxuXG4gICAgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB9XG4gIHZhciBjb21wdXRlZFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICogc2NhbGU7XG4gIHZhciBtaW5TaXplID0gZWxlLnBzdHlsZSgnbWluLXpvb21lZC1mb250LXNpemUnKS5wZlZhbHVlO1xuICBpZiAoY29tcHV0ZWRTaXplIDwgbWluU2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5DUnAkNy5kcmF3RWxlbWVudFRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBmb3JjZSwgcHJlZml4KSB7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICB2YXIgciA9IHRoaXM7XG4gIGlmIChmb3JjZSA9PSBudWxsKSB7XG4gICAgaWYgKHVzZUVsZU9wYWNpdHkgJiYgIXIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG4gICAgaWYgKCFsYWJlbCB8fCAhbGFiZWwudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGp1c3RpZmljYXRpb24gPSByLmdldExhYmVsSnVzdGlmaWNhdGlvbihlbGUpO1xuICAgIGNvbnRleHQudGV4dEFsaWduID0ganVzdGlmaWNhdGlvbjtcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICB9IGVsc2Uge1xuICAgIHZhciBiYWRMaW5lID0gZWxlLmVsZW1lbnQoKS5fcHJpdmF0ZS5yc2NyYXRjaC5iYWRMaW5lO1xuICAgIHZhciBfbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuICAgIHZhciBzcmNMYWJlbCA9IGVsZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpO1xuICAgIHZhciB0Z3RMYWJlbCA9IGVsZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpO1xuICAgIGlmIChiYWRMaW5lIHx8ICghX2xhYmVsIHx8ICFfbGFiZWwudmFsdWUpICYmICghc3JjTGFiZWwgfHwgIXNyY0xhYmVsLnZhbHVlKSAmJiAoIXRndExhYmVsIHx8ICF0Z3RMYWJlbC52YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICB9XG4gIHZhciBhcHBseVJvdGF0aW9uID0gIXNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gIHZhciBiYjtcbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICB9XG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCBudWxsLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3NvdXJjZScsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsICd0YXJnZXQnLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsIHByZWZpeCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gIH1cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICB9XG59O1xuQ1JwJDcuZ2V0Rm9udENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlO1xuICB0aGlzLmZvbnRDYWNoZXMgPSB0aGlzLmZvbnRDYWNoZXMgfHwgW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG4gICAgaWYgKGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH1cbiAgY2FjaGUgPSB7XG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xuICB0aGlzLmZvbnRDYWNoZXMucHVzaChjYWNoZSk7XG4gIHJldHVybiBjYWNoZTtcbn07XG5cbi8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbi8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcbkNScCQ3LnNldHVwVGV4dFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICB2YXIgdXNlRWxlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgLy8gRm9udCBzdHlsZVxuICB2YXIgbGFiZWxTdHlsZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc3R5bGUnKS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKyAncHgnO1xuICB2YXIgbGFiZWxGYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICB2YXIgbGFiZWxXZWlnaHQgPSBlbGUucHN0eWxlKCdmb250LXdlaWdodCcpLnN0clZhbHVlO1xuICB2YXIgb3BhY2l0eSA9IHVzZUVsZU9wYWNpdHkgPyBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpICogZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykudmFsdWUgOiAxO1xuICB2YXIgb3V0bGluZU9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtb3BhY2l0eScpLnZhbHVlICogb3BhY2l0eTtcbiAgdmFyIGNvbG9yID0gZWxlLnBzdHlsZSgnY29sb3InKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1jb2xvcicpLnZhbHVlO1xuICBjb250ZXh0LmZvbnQgPSBsYWJlbFN0eWxlICsgJyAnICsgbGFiZWxXZWlnaHQgKyAnICcgKyBsYWJlbFNpemUgKyAnICcgKyBsYWJlbEZhbWlseTtcbiAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7IC8vIHNvIHRleHQgb3V0bGluZXMgYXJlbid0IGphZ2dlZFxuXG4gIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gIHRoaXMuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eSk7XG59O1xuZnVuY3Rpb24gY2lyY2xlKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgZGlhbWV0ZXIgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHJhZGl1cyA9IGRpYW1ldGVyIC8gMjtcbiAgdmFyIGNlbnRlclggPSB4ICsgd2lkdGggLyAyO1xuICB2YXIgY2VudGVyWSA9IHkgKyBoZWlnaHQgLyAyO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogNTtcbiAgdmFyIHIgPSBNYXRoLm1pbihyYWRpdXMsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7IC8vIHByZXZlbnQgb3ZlcmZsb3dcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHggKyByLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByLCB5KTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByLCB5ICsgaGVpZ2h0KTtcbiAgY3R4LmxpbmVUbyh4ICsgciwgeSArIGhlaWdodCk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcik7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByLCB5KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuQ1JwJDcuZ2V0VGV4dEFuZ2xlID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciB0aGV0YTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICBpZiAocm90YXRpb24uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJykge1xuICAgIHZhciB0ZXh0QW5nbGUgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG4gICAgdGhldGEgPSBlbGUuaXNFZGdlKCkgPyB0ZXh0QW5nbGUgOiAwO1xuICB9IGVsc2UgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnbm9uZScpIHtcbiAgICB0aGV0YSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhldGEgPSByb3RhdGlvbi5wZlZhbHVlO1xuICB9XG4gIHJldHVybiB0aGV0YTtcbn07XG5DUnAkNy5kcmF3VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHByZWZpeCkge1xuICB2YXIgYXBwbHlSb3RhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuICBpZiAodXNlRWxlT3BhY2l0eSAmJiAocGFyZW50T3BhY2l0eSA9PT0gMCB8fCBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA9PT0gMCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1c2UgJ21haW4nIGFzIGFuIGFsaWFzIGZvciB0aGUgbWFpbiBsYWJlbCAoaS5lLiBudWxsIHByZWZpeClcbiAgaWYgKHByZWZpeCA9PT0gJ21haW4nKSB7XG4gICAgcHJlZml4ID0gbnVsbDtcbiAgfVxuICB2YXIgdGV4dFggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgdmFyIHRleHRZID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gIHZhciBvcmdUZXh0WCwgb3JnVGV4dFk7IC8vIHVzZWQgZm9yIHJvdGF0aW9uXG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoZWxlLCBwcmVmaXgpO1xuICBpZiAodGV4dCAhPSBudWxsICYmIHRleHQgIT09ICcnICYmICFpc05hTih0ZXh0WCkgJiYgIWlzTmFOKHRleHRZKSkge1xuICAgIHRoaXMuc2V0dXBUZXh0U3R5bGUoY29udGV4dCwgZWxlLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICB2YXIgdGV4dFcgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCk7XG4gICAgdmFyIHRleHRIID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG4gICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG4gICAgaWYgKGlzRWRnZSkge1xuICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG4gICAgdGV4dFggKz0gbWFyZ2luWDtcbiAgICB0ZXh0WSArPSBtYXJnaW5ZO1xuICAgIHZhciB0aGV0YTtcbiAgICBpZiAoIWFwcGx5Um90YXRpb24pIHtcbiAgICAgIHRoZXRhID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhldGEgPSB0aGlzLmdldFRleHRBbmdsZShlbGUsIHByZWZpeCk7XG4gICAgfVxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgb3JnVGV4dFggPSB0ZXh0WDtcbiAgICAgIG9yZ1RleHRZID0gdGV4dFk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmdUZXh0WCwgb3JnVGV4dFkpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgdGV4dFggPSAwO1xuICAgICAgdGV4dFkgPSAwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICB0ZXh0WSArPSB0ZXh0SCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBib3JkZXJPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGJhY2tncm91bmRQYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBzdHlsZVNoYXBlID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJykuc3RyVmFsdWU7XG4gICAgdmFyIHJvdW5kZWQgPSBzdHlsZVNoYXBlID09PSAncm91bmQtcmVjdGFuZ2xlJyB8fCBzdHlsZVNoYXBlID09PSAncm91bmRyZWN0YW5nbGUnO1xuICAgIHZhciBjaXJjbGVkID0gc3R5bGVTaGFwZSA9PT0gJ2NpcmNsZSc7XG4gICAgdmFyIHJvdW5kUmFkaXVzID0gMjtcbiAgICBpZiAoYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8IHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgIHZhciB0ZXh0RmlsbCA9IGNvbnRleHQuZmlsbFN0eWxlO1xuICAgICAgdmFyIHRleHRTdHJva2UgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgICAgdmFyIHRleHRMaW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgICB2YXIgdGV4dEJvcmRlckNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItY29sb3InKS52YWx1ZTtcbiAgICAgIHZhciB0ZXh0Qm9yZGVyU3R5bGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1zdHlsZScpLnZhbHVlO1xuICAgICAgdmFyIGRvRmlsbCA9IGJhY2tncm91bmRPcGFjaXR5ID4gMDtcbiAgICAgIHZhciBkb1N0cm9rZSA9IHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDA7XG4gICAgICB2YXIgYmdYID0gdGV4dFggLSBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGJnWCAtPSB0ZXh0VztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFcgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIGJnWSA9IHRleHRZIC0gdGV4dEggLSBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIHZhciBiZ1cgPSB0ZXh0VyArIDIgKiBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIHZhciBiZ0ggPSB0ZXh0SCArIDIgKiBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIGlmIChkb0ZpbGwpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoXCIuY29uY2F0KHRleHRCYWNrZ3JvdW5kQ29sb3JbMF0sIFwiLFwiKS5jb25jYXQodGV4dEJhY2tncm91bmRDb2xvclsxXSwgXCIsXCIpLmNvbmNhdCh0ZXh0QmFja2dyb3VuZENvbG9yWzJdLCBcIixcIikuY29uY2F0KGJhY2tncm91bmRPcGFjaXR5ICogcGFyZW50T3BhY2l0eSwgXCIpXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRvU3Ryb2tlKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoXCIuY29uY2F0KHRleHRCb3JkZXJDb2xvclswXSwgXCIsXCIpLmNvbmNhdCh0ZXh0Qm9yZGVyQ29sb3JbMV0sIFwiLFwiKS5jb25jYXQodGV4dEJvcmRlckNvbG9yWzJdLCBcIixcIikuY29uY2F0KGJvcmRlck9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5LCBcIilcIik7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgIHN3aXRjaCAodGV4dEJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbNCwgMl0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gNDtcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJvdW5kZWQpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCwgcm91bmRSYWRpdXMpO1xuICAgICAgfSBlbHNlIGlmIChjaXJjbGVkKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNpcmNsZShjb250ZXh0LCBiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5yZWN0KGJnWCwgYmdZLCBiZ1csIGJnSCk7XG4gICAgICB9XG4gICAgICBpZiAoZG9GaWxsKSBjb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChkb1N0cm9rZSkgY29udGV4dC5zdHJva2UoKTtcblxuICAgICAgLy8gRG91YmxlIGJvcmRlciBwYXNzIGZvciAnZG91YmxlJyBzdHlsZVxuICAgICAgaWYgKGRvU3Ryb2tlICYmIHRleHRCb3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgdmFyIHdoaXRlV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyAyO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgIHJvdW5kUmVjdChjb250ZXh0LCBiZ1ggKyB3aGl0ZVdpZHRoLCBiZ1kgKyB3aGl0ZVdpZHRoLCBiZ1cgLSAyICogd2hpdGVXaWR0aCwgYmdIIC0gMiAqIHdoaXRlV2lkdGgsIHJvdW5kUmFkaXVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnJlY3QoYmdYICsgd2hpdGVXaWR0aCwgYmdZICsgd2hpdGVXaWR0aCwgYmdXIC0gMiAqIHdoaXRlV2lkdGgsIGJnSCAtIDIgKiB3aGl0ZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgIH1cbiAgICB2YXIgbGluZVdpZHRoID0gMiAqIGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7IC8vICoyIGIvYyB0aGUgc3Ryb2tlIGlzIGRyYXduIGNlbnRyZWQgb24gdGhlIG1pZGRsZVxuXG4gICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIH1cbiAgICBpZiAoZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWUgPT09ICd3cmFwJykge1xuICAgICAgdmFyIGxpbmVzID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsTGluZUhlaWdodCcsIHByZWZpeCk7XG4gICAgICB2YXIgaGFsZlRleHRXID0gdGV4dFcgLyAyO1xuICAgICAgdmFyIGp1c3RpZmljYXRpb24gPSB0aGlzLmdldExhYmVsSnVzdGlmaWNhdGlvbihlbGUpO1xuICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdhdXRvJykgOyBlbHNlIGlmIChoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAvLyBhdXRvIGp1c3RpZmljYXRpb24gOiByaWdodFxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gLXRleHRXO1xuICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dFggKz0gLWhhbGZUZXh0VztcbiAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIC8vIGF1dG8ganVzdGZpY2F0aW9uIDogY2VudGVyXG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSAtaGFsZlRleHRXO1xuICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cbiAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIC8vIGF1dG8ganVzdGlmaWNhdGlvbiA6IGxlZnRcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dFggKz0gaGFsZlRleHRXO1xuICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSB0ZXh0VztcbiAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuICAgICAgfVxuICAgICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgIH1cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb3JnVGV4dFgsIC1vcmdUZXh0WSk7XG4gICAgfVxuICB9XG59O1xuXG4vKiBnbG9iYWwgUGF0aDJEICovXG5cbnZhciBDUnAkNiA9IHt9O1xuQ1JwJDYuZHJhd05vZGUgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgc2hpZnRUb09yaWdpbldpdGhCYikge1xuICB2YXIgZHJhd0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd092ZXJsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgaWYgKCFudW1iZXIkMShwb3MueCkgfHwgIW51bWJlciQxKHBvcy55KSkge1xuICAgIHJldHVybjsgLy8gY2FuJ3QgZHJhdyBub2RlIHdpdGggdW5kZWZpbmVkIHBvc2l0aW9uXG4gIH1cbiAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFub2RlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZWxlT3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBwYWRkaW5nO1xuICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nO1xuXG4gIC8vXG4gIC8vIHNldHVwIHNoaWZ0XG5cbiAgdmFyIGJiO1xuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cblxuICAvL1xuICAvLyBsb2FkIGJnIGltYWdlXG5cbiAgdmFyIGJnSW1nUHJvcCA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gIHZhciB1cmxzID0gYmdJbWdQcm9wLnZhbHVlO1xuICB2YXIgdXJsRGVmaW5lZCA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBpbWFnZSA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBudW1JbWFnZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXJsID0gdXJsc1tpXTtcbiAgICB2YXIgZGVmZCA9IHVybERlZmluZWRbaV0gPSB1cmwgIT0gbnVsbCAmJiB1cmwgIT09ICdub25lJztcbiAgICBpZiAoZGVmZCkge1xuICAgICAgdmFyIGJnSW1nQ3Jvc3NPcmlnaW4gPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLCAndmFsdWUnLCBpKTtcbiAgICAgIG51bUltYWdlcysrO1xuXG4gICAgICAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuICAgICAgaW1hZ2VbaV0gPSByLmdldENhY2hlZEltYWdlKHVybCwgYmdJbWdDcm9zc09yaWdpbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbm9kZS5lbWl0QW5kTm90aWZ5KCdiYWNrZ3JvdW5kJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBzZXR1cCBzdHlsZXNcblxuICB2YXIgZGFya25lc3MgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1ibGFja2VuJykudmFsdWU7XG4gIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgYmdPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1jb2xvcicpLnZhbHVlO1xuICB2YXIgYm9yZGVyU3R5bGUgPSBub2RlLnBzdHlsZSgnYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gIHZhciBib3JkZXJKb2luID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1qb2luJykudmFsdWU7XG4gIHZhciBib3JkZXJDYXAgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNhcCcpLnZhbHVlO1xuICB2YXIgYm9yZGVyUG9zaXRpb24gPSBub2RlLnBzdHlsZSgnYm9yZGVyLXBvc2l0aW9uJykudmFsdWU7XG4gIHZhciBib3JkZXJQYXR0ZXJuID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1kYXNoLXBhdHRlcm4nKS5wZlZhbHVlO1xuICB2YXIgYm9yZGVyT2Zmc2V0ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1kYXNoLW9mZnNldCcpLnBmVmFsdWU7XG4gIHZhciBib3JkZXJPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICB2YXIgb3V0bGluZVdpZHRoID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtY29sb3InKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVTdHlsZSA9IG5vZGUucHN0eWxlKCdvdXRsaW5lLXN0eWxlJykudmFsdWU7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IG5vZGUucHN0eWxlKCdvdXRsaW5lLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gIHZhciBvdXRsaW5lT2Zmc2V0ID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtb2Zmc2V0JykudmFsdWU7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlO1xuICBpZiAoY29ybmVyUmFkaXVzICE9PSAnYXV0bycpIGNvcm5lclJhZGl1cyA9IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgdmFyIHNldHVwU2hhcGVDb2xvciA9IGZ1bmN0aW9uIHNldHVwU2hhcGVDb2xvcigpIHtcbiAgICB2YXIgYmdPcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGJnT3BhY2l0eTtcbiAgICByLmVsZUZpbGxTdHlsZShjb250ZXh0LCBub2RlLCBiZ09weSk7XG4gIH07XG4gIHZhciBzZXR1cEJvcmRlckNvbG9yID0gZnVuY3Rpb24gc2V0dXBCb3JkZXJDb2xvcigpIHtcbiAgICB2YXIgYmRyT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBib3JkZXJPcGFjaXR5O1xuICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBiZHJPcHkpO1xuICB9O1xuICB2YXIgc2V0dXBPdXRsaW5lQ29sb3IgPSBmdW5jdGlvbiBzZXR1cE91dGxpbmVDb2xvcigpIHtcbiAgICB2YXIgb3Rsbk9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogb3V0bGluZU9wYWNpdHk7XG4gICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG90bG5PcHkpO1xuICB9O1xuXG4gIC8vXG4gIC8vIHNldHVwIHNoYXBlXG5cbiAgdmFyIGdldFBhdGggPSBmdW5jdGlvbiBnZXRQYXRoKHdpZHRoLCBoZWlnaHQsIHNoYXBlLCBwb2ludHMpIHtcbiAgICB2YXIgcGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5ncyhzaGFwZSA9PT0gJ3BvbHlnb24nID8gc2hhcGUgKyAnLCcgKyBwb2ludHMuam9pbignLCcpIDogc2hhcGUsICcnICsgaGVpZ2h0LCAnJyArIHdpZHRoLCAnJyArIGNvcm5lclJhZGl1cyk7XG4gICAgdmFyIGNhY2hlZFBhdGggPSBwYXRoQ2FjaGVba2V5XTtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgY2FjaGVIaXQgPSBmYWxzZTtcbiAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICBwYXRoID0gY2FjaGVkUGF0aDtcbiAgICAgIGNhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoQ2FjaGVba2V5XSA9IHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgY2FjaGVIaXQ6IGNhY2hlSGl0XG4gICAgfTtcbiAgfTtcbiAgdmFyIHN0eWxlU2hhcGUgPSBub2RlLnBzdHlsZSgnc2hhcGUnKS5zdHJWYWx1ZTtcbiAgdmFyIHNoYXBlUHRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykucGZWYWx1ZTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICB2YXIgc2hhcGVQYXRoID0gZ2V0UGF0aChub2RlV2lkdGgsIG5vZGVIZWlnaHQsIHN0eWxlU2hhcGUsIHNoYXBlUHRzKTtcbiAgICBwYXRoID0gc2hhcGVQYXRoLnBhdGg7XG4gICAgcGF0aENhY2hlSGl0ID0gc2hhcGVQYXRoLmNhY2hlSGl0O1xuICB9XG4gIHZhciBkcmF3U2hhcGUgPSBmdW5jdGlvbiBkcmF3U2hhcGUoKSB7XG4gICAgaWYgKCFwYXRoQ2FjaGVIaXQpIHtcbiAgICAgIHZhciBucG9zID0gcG9zO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcocGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICB9XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdJbWFnZXMgPSBmdW5jdGlvbiBkcmF3SW1hZ2VzKCkge1xuICAgIHZhciBub2RlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWxlT3BhY2l0eTtcbiAgICB2YXIgaW5zaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBwcmV2QmdpbmcgPSBfcC5iYWNrZ3JvdW5kaW5nO1xuICAgIHZhciB0b3RhbENvbXBsZXRlZCA9IDA7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGltYWdlLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGJnQ29udGFpbm1lbnQgPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnLCAndmFsdWUnLCBfaSk7XG4gICAgICBpZiAoaW5zaWRlICYmIGJnQ29udGFpbm1lbnQgPT09ICdvdmVyJyB8fCAhaW5zaWRlICYmIGJnQ29udGFpbm1lbnQgPT09ICdpbnNpZGUnKSB7XG4gICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVybERlZmluZWRbX2ldICYmIGltYWdlW19pXS5jb21wbGV0ZSAmJiAhaW1hZ2VbX2ldLmVycm9yKSB7XG4gICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgIHIuZHJhd0luc2NyaWJlZEltYWdlKGNvbnRleHQsIGltYWdlW19pXSwgbm9kZSwgX2ksIG5vZGVPcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3AuYmFja2dyb3VuZGluZyA9ICEodG90YWxDb21wbGV0ZWQgPT09IG51bUltYWdlcyk7XG4gICAgaWYgKHByZXZCZ2luZyAhPT0gX3AuYmFja2dyb3VuZGluZykge1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGIvYyA6YmFja2dyb3VuZGluZyBzdGF0ZSBjaGFuZ2VkXG4gICAgICBub2RlLnVwZGF0ZVN0eWxlKGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIHZhciBkcmF3UGllID0gZnVuY3Rpb24gZHJhd1BpZSgpIHtcbiAgICB2YXIgcmVkcmF3U2hhcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBwaWVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBlbGVPcGFjaXR5O1xuICAgIGlmIChyLmhhc1BpZShub2RlKSkge1xuICAgICAgci5kcmF3UGllKGNvbnRleHQsIG5vZGUsIHBpZU9wYWNpdHkpO1xuXG4gICAgICAvLyByZWRyYXcvcmVzdG9yZSBwYXRoIGlmIHN0ZXBzIGFmdGVyIHBpZSBuZWVkIGl0XG4gICAgICBpZiAocmVkcmF3U2hhcGUpIHtcbiAgICAgICAgaWYgKCF1c2VQYXRocykge1xuICAgICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgY29ybmVyUmFkaXVzLCBycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkcmF3U3RyaXBlID0gZnVuY3Rpb24gZHJhd1N0cmlwZSgpIHtcbiAgICB2YXIgcmVkcmF3U2hhcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBzdHJpcGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBlbGVPcGFjaXR5O1xuICAgIGlmIChyLmhhc1N0cmlwZShub2RlKSkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5jbGlwKHJzLnBhdGhDYWNoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIGNvcm5lclJhZGl1cywgcnMpO1xuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgIH1cbiAgICAgIHIuZHJhd1N0cmlwZShjb250ZXh0LCBub2RlLCBzdHJpcGVPcGFjaXR5KTtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAvLyByZWRyYXcvcmVzdG9yZSBwYXRoIGlmIHN0ZXBzIGFmdGVyIHN0cmlwZXMgbmVlZCBpdFxuICAgICAgaWYgKHJlZHJhd1NoYXBlKSB7XG4gICAgICAgIGlmICghdXNlUGF0aHMpIHtcbiAgICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIGNvcm5lclJhZGl1cywgcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZGFya2VuID0gZnVuY3Rpb24gZGFya2VuKCkge1xuICAgIHZhciBkYXJrZW5PcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbGVPcGFjaXR5O1xuICAgIHZhciBvcGFjaXR5ID0gKGRhcmtuZXNzID4gMCA/IGRhcmtuZXNzIDogLWRhcmtuZXNzKSAqIGRhcmtlbk9wYWNpdHk7XG4gICAgdmFyIGMgPSBkYXJrbmVzcyA+IDAgPyAwIDogMjU1O1xuICAgIGlmIChkYXJrbmVzcyAhPT0gMCkge1xuICAgICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjLCBjLCBjLCBvcGFjaXR5KTtcbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkcmF3Qm9yZGVyID0gZnVuY3Rpb24gZHJhd0JvcmRlcigpIHtcbiAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gYm9yZGVyQ2FwO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9IGJvcmRlckpvaW47XG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgc3dpdGNoIChib3JkZXJTdHlsZSkge1xuICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChib3JkZXJQYXR0ZXJuKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBib3JkZXJPZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib3JkZXJQb3NpdGlvbiAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoICo9IDI7XG4gICAgICAgIGlmIChib3JkZXJQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcbiAgICAgICAgICB1c2VQYXRocyA/IGNvbnRleHQuY2xpcChwYXRoKSA6IGNvbnRleHQuY2xpcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgcmVnaW9uLnJlY3QoLW5vZGVXaWR0aCAvIDIgLSBib3JkZXJXaWR0aCwgLW5vZGVIZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGgsIG5vZGVXaWR0aCArIDIgKiBib3JkZXJXaWR0aCwgbm9kZUhlaWdodCArIDIgKiBib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcmVnaW9uLmFkZFBhdGgocGF0aCk7XG4gICAgICAgICAgY29udGV4dC5jbGlwKHJlZ2lvbiwgJ2V2ZW5vZGQnKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VQYXRocyA/IGNvbnRleHQuc3Ryb2tlKHBhdGgpIDogY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1c2VQYXRocyA/IGNvbnRleHQuc3Ryb2tlKHBhdGgpIDogY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAvIDM7XG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkcmF3T3V0bGluZSA9IGZ1bmN0aW9uIGRyYXdPdXRsaW5lKCkge1xuICAgIGlmIChvdXRsaW5lV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IG91dGxpbmVXaWR0aDtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JztcbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBzd2l0Y2ggKG91dGxpbmVTdHlsZSkge1xuICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbNCwgMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbnBvcyA9IHBvcztcbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBucG9zID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHNoYXBlID0gci5nZXROb2RlU2hhcGUobm9kZSk7XG4gICAgICB2YXIgYldpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBpZiAoYm9yZGVyUG9zaXRpb24gPT09ICdpbnNpZGUnKSBiV2lkdGggPSAwO1xuICAgICAgaWYgKGJvcmRlclBvc2l0aW9uID09PSAnb3V0c2lkZScpIGJXaWR0aCAqPSAyO1xuICAgICAgdmFyIHNjYWxlWCA9IChub2RlV2lkdGggKyBiV2lkdGggKyAob3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkpIC8gbm9kZVdpZHRoO1xuICAgICAgdmFyIHNjYWxlWSA9IChub2RlSGVpZ2h0ICsgYldpZHRoICsgKG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpKSAvIG5vZGVIZWlnaHQ7XG4gICAgICB2YXIgc1dpZHRoID0gbm9kZVdpZHRoICogc2NhbGVYO1xuICAgICAgdmFyIHNIZWlnaHQgPSBub2RlSGVpZ2h0ICogc2NhbGVZO1xuICAgICAgdmFyIHBvaW50cyA9IHIubm9kZVNoYXBlc1tzaGFwZV0ucG9pbnRzO1xuICAgICAgdmFyIF9wYXRoO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIHZhciBvdXRsaW5lUGF0aCA9IGdldFBhdGgoc1dpZHRoLCBzSGVpZ2h0LCBzaGFwZSwgcG9pbnRzKTtcbiAgICAgICAgX3BhdGggPSBvdXRsaW5lUGF0aC5wYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IHRoZSBvdXRsaW5lIHBhdGgsIGVpdGhlciBieSB1c2luZyBleHBhbmRlZCBwb2ludHMgb3IgYnkgc2NhbGluZyBcbiAgICAgIC8vIHRoZSBkaW1lbnNpb25zLCBkZXBlbmRpbmcgb24gc2hhcGVcbiAgICAgIGlmIChzaGFwZSA9PT0gXCJlbGxpcHNlXCIpIHtcbiAgICAgICAgci5kcmF3RWxsaXBzZVBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIHNXaWR0aCwgc0hlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKFsncm91bmQtZGlhbW9uZCcsICdyb3VuZC1oZXB0YWdvbicsICdyb3VuZC1oZXhhZ29uJywgJ3JvdW5kLW9jdGFnb24nLCAncm91bmQtcGVudGFnb24nLCAncm91bmQtcG9seWdvbicsICdyb3VuZC10cmlhbmdsZScsICdyb3VuZC10YWcnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgdmFyIHNNdWx0ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldFggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IDA7XG4gICAgICAgIGlmIChzaGFwZSA9PT0gJ3JvdW5kLWRpYW1vbmQnKSB7XG4gICAgICAgICAgc011bHQgPSAoYldpZHRoICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgKiAxLjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyb3VuZC1oZXB0YWdvbicpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIDEuMDc1O1xuICAgICAgICAgIG9mZnNldFkgPSAtKGJXaWR0aCAvIDIgKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAvIDM1O1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAncm91bmQtaGV4YWdvbicpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIDEuMTI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyb3VuZC1wZW50YWdvbicpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIDEuMTM7XG4gICAgICAgICAgb2Zmc2V0WSA9IC0oYldpZHRoIC8gMiArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpIC8gMTU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyb3VuZC10YWcnKSB7XG4gICAgICAgICAgc011bHQgPSAoYldpZHRoICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgKiAxLjEyO1xuICAgICAgICAgIG9mZnNldFggPSAoYldpZHRoIC8gMiArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpICogLjA3O1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAncm91bmQtdHJpYW5nbGUnKSB7XG4gICAgICAgICAgc011bHQgPSAoYldpZHRoICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgKiAoTWF0aC5QSSAvIDIpO1xuICAgICAgICAgIG9mZnNldFkgPSAtKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgLyAyICsgb3V0bGluZVdpZHRoKSAvIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNNdWx0ICE9PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gKG5vZGVXaWR0aCArIHNNdWx0KSAvIG5vZGVXaWR0aDtcbiAgICAgICAgICBzV2lkdGggPSBub2RlV2lkdGggKiBzY2FsZVg7XG4gICAgICAgICAgaWYgKCFbJ3JvdW5kLWhleGFnb24nLCAncm91bmQtdGFnJ10uaW5jbHVkZXMoc2hhcGUpKSB7XG4gICAgICAgICAgICBzY2FsZVkgPSAobm9kZUhlaWdodCArIHNNdWx0KSAvIG5vZGVIZWlnaHQ7XG4gICAgICAgICAgICBzSGVpZ2h0ID0gbm9kZUhlaWdodCAqIHNjYWxlWTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFBvbHlnb25SYWRpdXMoc1dpZHRoLCBzSGVpZ2h0KSA6IGNvcm5lclJhZGl1cztcbiAgICAgICAgdmFyIGhhbGZXID0gc1dpZHRoIC8gMjtcbiAgICAgICAgdmFyIGhhbGZIID0gc0hlaWdodCAvIDI7XG4gICAgICAgIHZhciByYWRpdXMgPSBjb3JuZXJSYWRpdXMgKyAoYldpZHRoICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgLyAyO1xuICAgICAgICB2YXIgcCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoIC8gMik7XG4gICAgICAgIHZhciBjb3JuZXJzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcG9pbnRzLmxlbmd0aCAvIDI7IF9pMisrKSB7XG4gICAgICAgICAgcFtfaTJdID0ge1xuICAgICAgICAgICAgeDogbnBvcy54ICsgb2Zmc2V0WCArIGhhbGZXICogcG9pbnRzW19pMiAqIDJdLFxuICAgICAgICAgICAgeTogbnBvcy55ICsgb2Zmc2V0WSArIGhhbGZIICogcG9pbnRzW19pMiAqIDIgKyAxXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9pMyxcbiAgICAgICAgICBwMSxcbiAgICAgICAgICBwMixcbiAgICAgICAgICBwMyxcbiAgICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgICAgcDEgPSBwW2xlbiAtIDFdO1xuICAgICAgICAvLyBmb3IgZWFjaCBwb2ludFxuICAgICAgICBmb3IgKF9pMyA9IDA7IF9pMyA8IGxlbjsgX2kzKyspIHtcbiAgICAgICAgICBwMiA9IHBbX2kzICUgbGVuXTtcbiAgICAgICAgICBwMyA9IHBbKF9pMyArIDEpICUgbGVuXTtcbiAgICAgICAgICBjb3JuZXJzW19pM10gPSBnZXRSb3VuZENvcm5lcihwMSwgcDIsIHAzLCByYWRpdXMpO1xuICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgcDIgPSBwMztcbiAgICAgICAgfVxuICAgICAgICByLmRyYXdSb3VuZFBvbHlnb25QYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCArIG9mZnNldFgsIG5wb3MueSArIG9mZnNldFksIG5vZGVXaWR0aCAqIHNjYWxlWCwgbm9kZUhlaWdodCAqIHNjYWxlWSwgcG9pbnRzLCBjb3JuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAoWydyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyhzV2lkdGgsIHNIZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICByLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIHNXaWR0aCwgc0hlaWdodCwgY29ybmVyUmFkaXVzICsgKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKFsnY3V0cmVjdGFuZ2xlJywgJ2N1dC1yZWN0YW5nbGUnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSA6IGNvcm5lclJhZGl1cztcbiAgICAgICAgci5kcmF3Q3V0UmVjdGFuZ2xlUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgc1dpZHRoLCBzSGVpZ2h0LCBudWxsLCBjb3JuZXJSYWRpdXMgKyAoYldpZHRoICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgLyA0KTtcbiAgICAgIH0gZWxzZSBpZiAoWydib3R0b21yb3VuZHJlY3RhbmdsZScsICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJ10uaW5jbHVkZXMoc2hhcGUpKSB7XG4gICAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMoc1dpZHRoLCBzSGVpZ2h0KSA6IGNvcm5lclJhZGl1cztcbiAgICAgICAgci5kcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBzV2lkdGgsIHNIZWlnaHQsIGNvcm5lclJhZGl1cyArIChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gXCJiYXJyZWxcIikge1xuICAgICAgICByLmRyYXdCYXJyZWxQYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBzV2lkdGgsIHNIZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChzaGFwZS5zdGFydHNXaXRoKFwicG9seWdvblwiKSB8fCBbJ3Job21ib2lkJywgJ3JpZ2h0LXJob21ib2lkJywgJ3JvdW5kLXRhZycsICd0YWcnLCAndmVlJ10uaW5jbHVkZXMoc2hhcGUpKSB7XG4gICAgICAgIHZhciBwYWQgPSAoYldpZHRoICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgLyBub2RlV2lkdGg7XG4gICAgICAgIHBvaW50cyA9IGpvaW5MaW5lcyhleHBhbmRQb2x5Z29uKHBvaW50cywgcGFkKSk7XG4gICAgICAgIHIuZHJhd1BvbHlnb25QYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIHBvaW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3BhZCA9IChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIG5vZGVXaWR0aDtcbiAgICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZFBvbHlnb24ocG9pbnRzLCAtX3BhZCkpO1xuICAgICAgICByLmRyYXdQb2x5Z29uUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBwb2ludHMpO1xuICAgICAgfVxuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKF9wYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBpZiAob3V0bGluZVN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJXaWR0aCAvIDM7XG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoX3BhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd092ZXJsYXkgPSBmdW5jdGlvbiBkcmF3T3ZlcmxheSgpIHtcbiAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICB9XG4gIH07XG4gIHZhciBkcmF3VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3VW5kZXJsYXkoKSB7XG4gICAgaWYgKHNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICByLmRyYXdOb2RlVW5kZXJsYXkoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgbm9kZSwgbnVsbCwgZHJhd0xhYmVsKTtcbiAgfTtcbiAgdmFyIGdob3N0ID0gbm9kZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuICBpZiAoZ2hvc3QpIHtcbiAgICB2YXIgZ3ggPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgIHZhciBneSA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgdmFyIGdob3N0T3BhY2l0eSA9IG5vZGUucHN0eWxlKCdnaG9zdC1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIGVmZkdob3N0T3BhY2l0eSA9IGdob3N0T3BhY2l0eSAqIGVsZU9wYWNpdHk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBzZXR1cE91dGxpbmVDb2xvcigpO1xuICAgIGRyYXdPdXRsaW5lKCk7XG4gICAgc2V0dXBTaGFwZUNvbG9yKGdob3N0T3BhY2l0eSAqIGJnT3BhY2l0eSk7XG4gICAgZHJhd1NoYXBlKCk7XG4gICAgZHJhd0ltYWdlcyhlZmZHaG9zdE9wYWNpdHksIHRydWUpO1xuICAgIHNldHVwQm9yZGVyQ29sb3IoZ2hvc3RPcGFjaXR5ICogYm9yZGVyT3BhY2l0eSk7XG4gICAgZHJhd0JvcmRlcigpO1xuICAgIGRyYXdQaWUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICAgIGRyYXdTdHJpcGUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5LCBmYWxzZSk7XG4gICAgZGFya2VuKGVmZkdob3N0T3BhY2l0eSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICB9XG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgfVxuICBkcmF3VW5kZXJsYXkoKTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgfVxuICBzZXR1cE91dGxpbmVDb2xvcigpO1xuICBkcmF3T3V0bGluZSgpO1xuICBzZXR1cFNoYXBlQ29sb3IoKTtcbiAgZHJhd1NoYXBlKCk7XG4gIGRyYXdJbWFnZXMoZWxlT3BhY2l0eSwgdHJ1ZSk7XG4gIHNldHVwQm9yZGVyQ29sb3IoKTtcbiAgZHJhd0JvcmRlcigpO1xuICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgZHJhd1N0cmlwZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gIGRyYXdJbWFnZXMoZWxlT3BhY2l0eSwgZmFsc2UpO1xuICBkYXJrZW4oKTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXBvcy54LCAtcG9zLnkpO1xuICB9XG4gIGRyYXdUZXh0KCk7XG4gIGRyYXdPdmVybGF5KCk7XG5cbiAgLy9cbiAgLy8gY2xlYW4gdXAgc2hpZnRcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG52YXIgZHJhd05vZGVPdmVybGF5VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheShvdmVybGF5T3JVbmRlcmxheSkge1xuICBpZiAoIVsnb3ZlcmxheScsICd1bmRlcmxheSddLmluY2x1ZGVzKG92ZXJsYXlPclVuZGVybGF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgaWYgKCFub2RlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFkZGluZyA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1wYWRkaW5nXCIpKS5wZlZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLW9wYWNpdHlcIikpLnZhbHVlO1xuICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1jb2xvclwiKSkudmFsdWU7XG4gICAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLXNoYXBlXCIpKS52YWx1ZTtcbiAgICB2YXIgcmFkaXVzID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLWNvcm5lci1yYWRpdXNcIikpLnZhbHVlO1xuICAgIGlmIChvcGFjaXR5ID4gMCkge1xuICAgICAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcbiAgICAgIGlmIChub2RlV2lkdGggPT0gbnVsbCB8fCBub2RlSGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIF9wYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gICAgICAgIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBfcGFkZGluZztcbiAgICAgICAgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCkgKyAyICogX3BhZGRpbmc7XG4gICAgICB9XG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgICAgci5ub2RlU2hhcGVzW3NoYXBlXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoICsgcGFkZGluZyAqIDIsIG5vZGVIZWlnaHQgKyBwYWRkaW5nICogMiwgcmFkaXVzKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfTtcbn07XG5DUnAkNi5kcmF3Tm9kZU92ZXJsYXkgPSBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSgnb3ZlcmxheScpO1xuQ1JwJDYuZHJhd05vZGVVbmRlcmxheSA9IGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5KCd1bmRlcmxheScpO1xuXG4vLyBkb2VzIHRoZSBub2RlIGhhdmUgYXQgbGVhc3Qgb25lIHBpZSBwaWVjZT9cbkNScCQ2Lmhhc1BpZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gIHJldHVybiBub2RlLl9wcml2YXRlLmhhc1BpZTtcbn07XG5DUnAkNi5oYXNTdHJpcGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNTdHJpcGU7XG59O1xuQ1JwJDYuZHJhd1BpZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuICBwb3MgPSBwb3MgfHwgbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgcGllU2l6ZSA9IG5vZGUucHN0eWxlKCdwaWUtc2l6ZScpO1xuICB2YXIgaG9sZSA9IG5vZGUucHN0eWxlKCdwaWUtaG9sZScpO1xuICB2YXIgb3ZlcmFsbFN0YXJ0QW5nbGUgPSBub2RlLnBzdHlsZSgncGllLXN0YXJ0LWFuZ2xlJykucGZWYWx1ZTtcbiAgdmFyIHggPSBwb3MueDtcbiAgdmFyIHkgPSBwb3MueTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcmFkaXVzID0gTWF0aC5taW4obm9kZVcsIG5vZGVIKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgdmFyIGhvbGVSYWRpdXM7XG4gIHZhciBsYXN0UGVyY2VudCA9IDA7IC8vIHdoYXQgJSB0byBjb250aW51ZSBkcmF3aW5nIHBpZSBzbGljZXMgZnJvbSBvbiBbMCwgMV1cbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgfVxuICBpZiAocGllU2l6ZS51bml0cyA9PT0gJyUnKSB7XG4gICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS5wZlZhbHVlO1xuICB9IGVsc2UgaWYgKHBpZVNpemUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmFkaXVzID0gcGllU2l6ZS5wZlZhbHVlIC8gMjsgLy8gZGlhbWV0ZXIgaW4gcGl4ZWxzID0+IHJhZGl1c1xuICB9XG4gIGlmIChob2xlLnVuaXRzID09PSAnJScpIHtcbiAgICBob2xlUmFkaXVzID0gcmFkaXVzICogaG9sZS5wZlZhbHVlO1xuICB9IGVsc2UgaWYgKGhvbGUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaG9sZVJhZGl1cyA9IGhvbGUucGZWYWx1ZSAvIDI7IC8vIGRpYW1ldGVyIGluIHBpeGVscyA9PiByYWRpdXNcbiAgfVxuICBpZiAoaG9sZVJhZGl1cyA+PSByYWRpdXMpIHtcbiAgICByZXR1cm47IC8vIHRoZSBwaWUgd291bGQgYmUgaW52aXNpYmxlIGFueXdheVxuICB9XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGN5U3R5bGUucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgIC8vIDEuLk5cbiAgICB2YXIgc2l6ZSA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScpLnZhbHVlO1xuICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogbm9kZU9wYWNpdHk7XG4gICAgdmFyIHBlcmNlbnQgPSBzaXplIC8gMTAwOyAvLyBtYXAgaW50ZWdlciByYW5nZSBbMCwgMTAwXSB0byBbMCwgMV1cblxuICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuICAgIGlmIChwZXJjZW50ICsgbGFzdFBlcmNlbnQgPiAxKSB7XG4gICAgICBwZXJjZW50ID0gMSAtIGxhc3RQZXJjZW50O1xuICAgIH1cbiAgICB2YXIgYW5nbGVTdGFydCA9IDEuNSAqIE1hdGguUEkgKyAyICogTWF0aC5QSSAqIGxhc3RQZXJjZW50OyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrIGFuZCBnbyBjbG9ja3dpc2VcbiAgICBhbmdsZVN0YXJ0ICs9IG92ZXJhbGxTdGFydEFuZ2xlOyAvLyBzaGlmdCBieSB0aGUgb3ZlcmFsbCBwaWUgc3RhcnQgYW5nbGVcbiAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTtcblxuICAgIC8vIGlnbm9yZSBpZlxuICAgIC8vIC0gemVybyBzaXplXG4gICAgLy8gLSB3ZSdyZSBhbHJlYWR5IGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAvLyAtIGFkZGluZyB0aGUgY3VycmVudCBzbGljZSB3b3VsZCBnbyBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgaWYgKHNpemUgPT09IDAgfHwgbGFzdFBlcmNlbnQgPj0gMSB8fCBsYXN0UGVyY2VudCArIHBlcmNlbnQgPiAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGhvbGVSYWRpdXMgPT09IDApIHtcbiAgICAgIC8vIG1ha2UgYSBwaWUgc2xpY2VcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWFrZSBhIHBpZSBzbGljZSB0aGF0J3MgbGlrZSB0aGUgYWJvdmUgYnV0IHdpdGggYSBob2xlIGluIHRoZSBtaWRkbGVcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kKTtcbiAgICAgIGNvbnRleHQuYXJjKHgsIHksIGhvbGVSYWRpdXMsIGFuZ2xlRW5kLCBhbmdsZVN0YXJ0LCB0cnVlKTsgLy8gdHJ1ZSBmb3IgYW50aWNsb2Nrd2lzZVxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICB9XG59O1xuQ1JwJDYuZHJhd1N0cmlwZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuICBwb3MgPSBwb3MgfHwgbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgeCA9IHBvcy54O1xuICB2YXIgeSA9IHBvcy55O1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBsYXN0UGVyY2VudCA9IDA7IC8vIHdoYXQgJSB0byBjb250aW51ZSBkcmF3aW5nIHBpZSBzbGljZXMgZnJvbSBvbiBbMCwgMV1cbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICBjb250ZXh0LnNhdmUoKTtcbiAgdmFyIGRpcmVjdGlvbiA9IG5vZGUucHN0eWxlKCdzdHJpcGUtZGlyZWN0aW9uJykudmFsdWU7XG4gIHZhciBzdHJpcGVTaXplID0gbm9kZS5wc3R5bGUoJ3N0cmlwZS1zaXplJyk7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgYnJlYWs7XG4gICAgLy8gZGVmYXVsdFxuICAgIGNhc2UgJ3JpZ2h3YXJkJzpcbiAgICAgIGNvbnRleHQucm90YXRlKC1NYXRoLlBJIC8gMik7XG4gICAgICBicmVhaztcbiAgfVxuICB2YXIgc3RyaXBlVyA9IG5vZGVXO1xuICB2YXIgc3RyaXBlSCA9IG5vZGVIO1xuICBpZiAoc3RyaXBlU2l6ZS51bml0cyA9PT0gJyUnKSB7XG4gICAgc3RyaXBlVyA9IHN0cmlwZVcgKiBzdHJpcGVTaXplLnBmVmFsdWU7XG4gICAgc3RyaXBlSCA9IHN0cmlwZUggKiBzdHJpcGVTaXplLnBmVmFsdWU7XG4gIH0gZWxzZSBpZiAoc3RyaXBlU2l6ZS5wZlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpcGVXID0gc3RyaXBlU2l6ZS5wZlZhbHVlO1xuICAgIHN0cmlwZUggPSBzdHJpcGVTaXplLnBmVmFsdWU7XG4gIH1cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cblxuICAvLyBzaGlmdCB1cCBmcm9tIHRoZSBjZW50cmUgb2YgdGhlIG5vZGUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lclxuICB5IC09IHN0cmlwZVcgLyAyO1xuICB4IC09IHN0cmlwZUggLyAyO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBjeVN0eWxlLnN0cmlwZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAvLyAxLi5OXG4gICAgdmFyIHNpemUgPSBub2RlLnBzdHlsZSgnc3RyaXBlLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnKS52YWx1ZTtcbiAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZSgnc3RyaXBlLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZSgnc3RyaXBlLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZSAqIG5vZGVPcGFjaXR5O1xuICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG5cbiAgICAvLyBwZXJjZW50IGNhbid0IHB1c2ggYmV5b25kIDFcbiAgICBpZiAocGVyY2VudCArIGxhc3RQZXJjZW50ID4gMSkge1xuICAgICAgcGVyY2VudCA9IDEgLSBsYXN0UGVyY2VudDtcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgaWZcbiAgICAvLyAtIHplcm8gc2l6ZVxuICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2hhcnRcbiAgICAvLyAtIGFkZGluZyB0aGUgY3VycmVudCBzbGljZSB3b3VsZCBnbyBiZXlvbmQgdGhlIGZ1bGwgY2hhcnRcbiAgICBpZiAoc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRyYXcgcmVjdCBmb3IgdGhlIGN1cnJlbnQgc3RyaXBlXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LnJlY3QoeCwgeSArIHN0cmlwZUggKiBsYXN0UGVyY2VudCwgc3RyaXBlVywgc3RyaXBlSCAqIHBlcmNlbnQpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICB9XG4gIGNvbnRleHQucmVzdG9yZSgpO1xufTtcblxudmFyIENScCQ1ID0ge307XG52YXIgbW90aW9uQmx1ckRlbGF5ID0gMTAwO1xuXG4vLyB2YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblxuQ1JwJDUuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG4gIGlmICh0aGlzLmZvcmNlZFBpeGVsUmF0aW8gIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmZvcmNlZFBpeGVsUmF0aW87XG4gIH1cbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHRoaXMuY3kud2luZG93KCk7XG4gIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4gKGNvbnRhaW5lcldpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59O1xuQ1JwJDUucGFpbnRDYWNoZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBjYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzID0gdGhpcy5wYWludENhY2hlcyB8fCBbXTtcbiAgdmFyIG5lZWRUb0NyZWF0ZUNhY2hlID0gdHJ1ZTtcbiAgdmFyIGNhY2hlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlID0gY2FjaGVzW2ldO1xuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChuZWVkVG9DcmVhdGVDYWNoZSkge1xuICAgIGNhY2hlID0ge1xuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH07XG4gICAgY2FjaGVzLnB1c2goY2FjaGUpO1xuICB9XG4gIHJldHVybiBjYWNoZTtcbn07XG5DUnAkNS5jcmVhdGVHcmFkaWVudFN0eWxlRm9yID0gZnVuY3Rpb24gKGNvbnRleHQsIHNoYXBlU3R5bGVOYW1lLCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGU7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGNvbG9ycyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtY29sb3JzJykudmFsdWUsXG4gICAgcG9zaXRpb25zID0gZWxlLnBzdHlsZShzaGFwZVN0eWxlTmFtZSArICctZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnKS5wZlZhbHVlO1xuICBpZiAoZmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB2YXIgc3RhcnQgPSBlbGUuc291cmNlRW5kcG9pbnQoKSxcbiAgICAgICAgZW5kID0gZWxlLnRhcmdldEVuZHBvaW50KCksXG4gICAgICAgIG1pZCA9IGVsZS5taWRwb2ludCgpO1xuICAgICAgdmFyIGQxID0gZGlzdChzdGFydCwgbWlkKTtcbiAgICAgIHZhciBkMiA9IGRpc3QoZW5kLCBtaWQpO1xuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQobWlkLngsIG1pZC55LCAwLCBtaWQueCwgbWlkLnksIE1hdGgubWF4KGQxLCBkMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpO1xuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQocG9zLngsIHBvcy55LCAwLCBwb3MueCwgcG9zLnksIE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIF9zdGFydCA9IGVsZS5zb3VyY2VFbmRwb2ludCgpLFxuICAgICAgICBfZW5kID0gZWxlLnRhcmdldEVuZHBvaW50KCk7XG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfc3RhcnQueCwgX3N0YXJ0LnksIF9lbmQueCwgX2VuZC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9wb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICBfd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgX2hlaWdodCA9IGVsZS5wYWRkZWRIZWlnaHQoKSxcbiAgICAgICAgaGFsZldpZHRoID0gX3dpZHRoIC8gMixcbiAgICAgICAgaGFsZkhlaWdodCA9IF9oZWlnaHQgLyAyO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJykudmFsdWU7XG4gICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICBjYXNlICd0by1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54LCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tdG9wJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLXJpZ2h0JzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by1ib3R0b20tcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tdG9wLXJpZ2h0JzpcbiAgICAgICAgY2FzZSAndG8tcmlnaHQtdG9wJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLWJvdHRvbS1sZWZ0JzpcbiAgICAgICAgY2FzZSAndG8tbGVmdC1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tdG9wLWxlZnQnOlxuICAgICAgICBjYXNlICd0by1sZWZ0LXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBpbnZhbGlkIGdyYWRpZW50IHN0eWxlXG5cbiAgdmFyIGhhc1Bvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGggPT09IGNvbG9ycy5sZW5ndGg7XG4gIHZhciBsZW5ndGggPSBjb2xvcnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZ3JhZGllbnRTdHlsZS5hZGRDb2xvclN0b3AoaGFzUG9zaXRpb25zID8gcG9zaXRpb25zW2ldIDogaSAvIChsZW5ndGggLSAxKSwgJ3JnYmEoJyArIGNvbG9yc1tpXVswXSArICcsJyArIGNvbG9yc1tpXVsxXSArICcsJyArIGNvbG9yc1tpXVsyXSArICcsJyArIG9wYWNpdHkgKyAnKScpO1xuICB9XG4gIHJldHVybiBncmFkaWVudFN0eWxlO1xufTtcbkNScCQ1LmdyYWRpZW50RmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZmlsbCwgb3BhY2l0eSkge1xuICB2YXIgZ3JhZGllbnRTdHlsZSA9IHRoaXMuY3JlYXRlR3JhZGllbnRTdHlsZUZvcihjb250ZXh0LCAnYmFja2dyb3VuZCcsIGVsZSwgZmlsbCwgb3BhY2l0eSk7XG4gIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGVycm9yXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbn07XG5DUnAkNS5jb2xvckZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIGZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAvLyB9XG59O1xuQ1JwJDUuZWxlRmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgb3BhY2l0eSkge1xuICB2YXIgYmFja2dyb3VuZEZpbGwgPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWZpbGwnKS52YWx1ZTtcbiAgaWYgKGJhY2tncm91bmRGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBiYWNrZ3JvdW5kRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50RmlsbFN0eWxlKGNvbnRleHQsIGVsZSwgYmFja2dyb3VuZEZpbGwsIG9wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBiYWNrZ3JvdW5kQ29sb3JbMF0sIGJhY2tncm91bmRDb2xvclsxXSwgYmFja2dyb3VuZENvbG9yWzJdLCBvcGFjaXR5KTtcbiAgfVxufTtcbkNScCQ1LmdyYWRpZW50U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdsaW5lJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG59O1xuQ1JwJDUuY29sb3JTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuXG4gIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuc3Ryb2tlU3R5bGUgIT09IHN0cm9rZVN0eWxlICl7XG4gIC8vICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNhY2hlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gIC8vIH1cbn07XG5DUnAkNS5lbGVTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgdmFyIGxpbmVGaWxsID0gZWxlLnBzdHlsZSgnbGluZS1maWxsJykudmFsdWU7XG4gIGlmIChsaW5lRmlsbCA9PT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgbGluZUZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgdGhpcy5ncmFkaWVudFN0cm9rZVN0eWxlKGNvbnRleHQsIGVsZSwgbGluZUZpbGwsIG9wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsaW5lQ29sb3IgPSBlbGUucHN0eWxlKCdsaW5lLWNvbG9yJykudmFsdWU7XG4gICAgdGhpcy5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIG9wYWNpdHkpO1xuICB9XG59O1xuXG4vLyBSZXNpemUgY2FudmFzXG5DUnAkNS5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBiYiA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgd2lkdGggPSBiYlsyXTtcbiAgdmFyIGhlaWdodCA9IGJiWzNdO1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcbiAgaWYgKGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHwgY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkge1xuICAgIHBpeGVsUmF0aW8gPSBtYlB4UmF0aW87XG4gIH1cbiAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhcztcbiAgaWYgKGNhbnZhc1dpZHRoID09PSByLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gci5jYW52YXNIZWlnaHQpIHtcbiAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgfVxuICByLmZvbnRDYWNoZXMgPSBudWxsOyAvLyByZXNpemluZyByZXNldHMgdGhlIHN0eWxlXG5cbiAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IGRhdGEuY2FudmFzQ29udGFpbmVyO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG4gICAgY2FudmFzID0gZGF0YS5jYW52YXNlc1tpXTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW2ldO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG4gIHIudGV4dHVyZU11bHQgPSAxO1xuICBpZiAocGl4ZWxSYXRpbyA8PSAxKSB7XG4gICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICByLnRleHR1cmVNdWx0ID0gMjtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQ7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQ7XG4gIH1cbiAgci5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICByLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgci5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbn07XG5DUnAkNS5yZW5kZXJUbyA9IGZ1bmN0aW9uIChjeHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICB0aGlzLnJlbmRlcih7XG4gICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgZm9yY2VkUGFuOiBwYW4sXG4gICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICBmb3JjZWRQeFJhdGlvOiBweFJhdGlvXG4gIH0pO1xufTtcbkNScCQ1LmNsZWFyQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICBmdW5jdGlvbiBjbGVhcihjb250ZXh0KSB7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICB9XG4gIGNsZWFyKGRhdGEuY29udGV4dHNbci5OT0RFXSk7XG4gIGNsZWFyKGRhdGEuY29udGV4dHNbci5EUkFHXSk7XG59O1xuQ1JwJDUucmVuZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciBwaXhlbFJhdGlvID0gb3B0aW9ucy5mb3JjZWRQeFJhdGlvID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFBpeGVsUmF0aW8oKSA6IG9wdGlvbnMuZm9yY2VkUHhSYXRpbztcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBuZWVkRHJhdyA9IGRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG4gIHZhciB0ZXh0dXJlRHJhdyA9IHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgJiYgKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyk7XG4gIHZhciBtb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vdGlvbkJsdXIgOiByLm1vdGlvbkJsdXI7XG4gIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGluTm9kZURyYWdHZXN0dXJlID0gci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzO1xuICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nID8gdHJ1ZSA6IGZhbHNlO1xuICBtb3Rpb25CbHVyID0gbW90aW9uQmx1ciAmJiAhZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJFbmFibGVkICYmICFpbkJveFNlbGVjdGlvbjtcbiAgdmFyIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gbW90aW9uQmx1cjtcbiAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgaWYgKHIucHJldlB4UmF0aW8gIT09IHBpeGVsUmF0aW8pIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgIH1cbiAgICByLnByZXZQeFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgfVxuICBpZiAoIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyVGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dChyLm1vdGlvbkJsdXJUaW1lb3V0KTtcbiAgfVxuICBpZiAobW90aW9uQmx1cikge1xuICAgIGlmIChyLm1iRnJhbWVzID09IG51bGwpIHtcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgIH1cbiAgICByLm1iRnJhbWVzKys7XG4gICAgaWYgKHIubWJGcmFtZXMgPCAzKSB7XG4gICAgICAvLyBuZWVkIHNldmVyYWwgZnJhbWVzIGJlZm9yZSBldmVuIGhpZ2ggcXVhbGl0eSBtb3Rpb25ibHVyXG4gICAgICBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdvIHRvIGxvd2VyIHF1YWxpdHkgYmx1cnJ5IGZyYW1lcyB3aGVuIHNldmVyYWwgbS9iIGZyYW1lcyBoYXZlIGJlZW4gcmVuZGVyZWQgKGF2b2lkcyBmbGFzaGluZylcbiAgICBpZiAoci5tYkZyYW1lcyA+IHIubWluTWJMb3dRdWFsRnJhbWVzKSB7XG4gICAgICAvL3IuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IHIubWJQeFJCbHVycnk7XG4gICAgfVxuICB9XG4gIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG5cbiAgLy8gYi9jIGRyYXdUb0NvbnRleHQoKSBtYXkgYmUgYXN5bmMgdy5yLnQuIHJlZHJhdygpLCBrZWVwIHRyYWNrIG9mIGxhc3QgdGV4dHVyZSBmcmFtZVxuICAvLyBiZWNhdXNlIGEgcm9ndWUgYXN5bmMgdGV4dHVyZSBmcmFtZSB3b3VsZCBjbGVhciBuZWVkRHJhd1xuICBpZiAoci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcpIHtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIGVmZmVjdGl2ZVpvb20gPSBmb3JjZWRab29tICE9PSB1bmRlZmluZWQgPyBmb3JjZWRab29tIDogem9vbTtcbiAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICB2YXIgZWZmZWN0aXZlUGFuID0ge1xuICAgIHg6IHBhbi54LFxuICAgIHk6IHBhbi55XG4gIH07XG4gIHZhciB2cCA9IHtcbiAgICB6b29tOiB6b29tLFxuICAgIHBhbjoge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH1cbiAgfTtcbiAgdmFyIHByZXZWcCA9IHIucHJldlZpZXdwb3J0O1xuICB2YXIgdmlld3BvcnRJc0RpZmYgPSBwcmV2VnAgPT09IHVuZGVmaW5lZCB8fCB2cC56b29tICE9PSBwcmV2VnAuem9vbSB8fCB2cC5wYW4ueCAhPT0gcHJldlZwLnBhbi54IHx8IHZwLnBhbi55ICE9PSBwcmV2VnAucGFuLnk7XG5cbiAgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcbiAgaWYgKCF2aWV3cG9ydElzRGlmZiAmJiAhKGluTm9kZURyYWdHZXN0dXJlICYmICFoYXNDb21wb3VuZE5vZGVzKSkge1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG4gIGlmIChmb3JjZWRQYW4pIHtcbiAgICBlZmZlY3RpdmVQYW4gPSBmb3JjZWRQYW47XG4gIH1cblxuICAvLyBhcHBseSBwaXhlbCByYXRpb1xuXG4gIGVmZmVjdGl2ZVpvb20gKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnggKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnkgKj0gcGl4ZWxSYXRpbztcbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIGZ1bmN0aW9uIG1iY2xlYXIoY29udGV4dCwgeCwgeSwgdywgaCkge1xuICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9XG4gIGZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpIHtcbiAgICB2YXIgZVBhbiwgZVpvb20sIHcsIGg7XG4gICAgaWYgKCFyLmNsZWFyaW5nTW90aW9uQmx1ciAmJiAoY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkpIHtcbiAgICAgIGVQYW4gPSB7XG4gICAgICAgIHg6IHBhbi54ICogbWJQeFJhdGlvLFxuICAgICAgICB5OiBwYW4ueSAqIG1iUHhSYXRpb1xuICAgICAgfTtcbiAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoICogbWJQeFJhdGlvO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0ICogbWJQeFJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBlUGFuID0gZWZmZWN0aXZlUGFuO1xuICAgICAgZVpvb20gPSBlZmZlY3RpdmVab29tO1xuICAgICAgdyA9IHIuY2FudmFzV2lkdGg7XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGlmIChjbGVhciA9PT0gJ21vdGlvbkJsdXInKSB7XG4gICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHcsIGgpO1xuICAgIH0gZWxzZSBpZiAoIWZvcmNlZENvbnRleHQgJiYgKGNsZWFyID09PSB1bmRlZmluZWQgfHwgY2xlYXIpKSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICB9XG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShlUGFuLngsIGVQYW4ueSk7XG4gICAgICBjb250ZXh0LnNjYWxlKGVab29tLCBlWm9vbSk7XG4gICAgfVxuICAgIGlmIChmb3JjZWRQYW4pIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSk7XG4gICAgfVxuICAgIGlmIChmb3JjZWRab29tKSB7XG4gICAgICBjb250ZXh0LnNjYWxlKGZvcmNlZFpvb20sIGZvcmNlZFpvb20pO1xuICAgIH1cbiAgfVxuICBpZiAoIXRleHR1cmVEcmF3KSB7XG4gICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IGZhbHNlO1xuICB9XG4gIGlmICh0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuICAgIGlmICghci50ZXh0dXJlQ2FjaGUpIHtcbiAgICAgIHIudGV4dHVyZUNhY2hlID0ge307XG4gICAgICByLnRleHR1cmVDYWNoZS5iYiA9IGN5Lm11dGFibGVFbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG4gICAgICByLnRleHR1cmVDYWNoZS50ZXh0dXJlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgdmFyIGN4dCA9IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjeHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0LCByLmNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQpO1xuICAgICAgci5yZW5kZXIoe1xuICAgICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICAgIGRyYXdPbmx5Tm9kZUxheWVyOiB0cnVlLFxuICAgICAgICBmb3JjZWRQeFJhdGlvOiBwaXhlbFJhdGlvICogci50ZXh0dXJlTXVsdFxuICAgICAgfSk7XG4gICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydCA9IHtcbiAgICAgICAgem9vbTogY3kuem9vbSgpLFxuICAgICAgICBwYW46IGN5LnBhbigpLFxuICAgICAgICB3aWR0aDogci5jYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiByLmNhbnZhc0hlaWdodFxuICAgICAgfTtcbiAgICAgIHZwLm1wYW4gPSB7XG4gICAgICAgIHg6ICgwIC0gdnAucGFuLngpIC8gdnAuem9vbSxcbiAgICAgICAgeTogKDAgLSB2cC5wYW4ueSkgLyB2cC56b29tXG4gICAgICB9O1xuICAgIH1cbiAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgIHZhciB0ZXh0dXJlID0gci50ZXh0dXJlQ2FjaGUudGV4dHVyZTtcbiAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydDtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBpZiAobW90aW9uQmx1cikge1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgfVxuICAgIHZhciBvdXRzaWRlQmdDb2xvciA9IHN0eWxlLmNvcmUoJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBvdXRzaWRlQmdPcGFjaXR5ID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknKS52YWx1ZTtcbiAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIG91dHNpZGVCZ0NvbG9yWzBdLCBvdXRzaWRlQmdDb2xvclsxXSwgb3V0c2lkZUJnQ29sb3JbMl0sIG91dHNpZGVCZ09wYWNpdHkpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBmYWxzZSk7XG4gICAgY29udGV4dC5jbGVhclJlY3QodnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICB9IGVsc2UgaWYgKHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQpIHtcbiAgICAvLyBjbGVhciB0aGUgY2FjaGUgc2luY2Ugd2UgZG9uJ3QgbmVlZCBpdFxuICAgIHIudGV4dHVyZUNhY2hlID0gbnVsbDtcbiAgfVxuICB2YXIgZXh0ZW50ID0gY3kuZXh0ZW50KCk7XG4gIHZhciB2cE1hbmlwID0gci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmN5LmFuaW1hdGVkKCk7XG4gIHZhciBoaWRlRWRnZXMgPSByLmhpZGVFZGdlc09uVmlld3BvcnQgJiYgdnBNYW5pcDtcbiAgdmFyIG5lZWRNYkNsZWFyID0gW107XG4gIG5lZWRNYkNsZWFyW3IuTk9ERV0gPSAhbmVlZERyYXdbci5OT0RFXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gIGlmIChuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gdHJ1ZTtcbiAgfVxuICBuZWVkTWJDbGVhcltyLkRSQUddID0gIW5lZWREcmF3W3IuRFJBR10gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuICBpZiAobmVlZE1iQ2xlYXJbci5EUkFHXSkge1xuICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IHRydWU7XG4gIH1cbiAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gOiBkYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKTtcbiAgICBpZiAoaGlkZUVkZ2VzKSB7XG4gICAgICByLmRyYXdDYWNoZWROb2Rlcyhjb250ZXh0LCBlbGVzLm5vbmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0xheWVyZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLm5vbmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfVxuICAgIGlmIChyLmRlYnVnKSB7XG4gICAgICByLmRyYXdEZWJ1Z1BvaW50cyhjb250ZXh0LCBlbGVzLm5vbmRyYWcpO1xuICAgIH1cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbci5EUkFHXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IG5lZWRNYkNsZWFyW3IuRFJBR10pKSB7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuRFJBR10gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10gOiBkYXRhLmNvbnRleHRzW3IuRFJBR10pO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkKTtcbiAgICBpZiAoaGlkZUVkZ2VzKSB7XG4gICAgICByLmRyYXdDYWNoZWROb2Rlcyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9XG4gICAgaWYgKHIuZGVidWcpIHtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMuZHJhZyk7XG4gICAgfVxuICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICB0aGlzLmRyYXdTZWxlY3Rpb25SZWN0YW5nbGUob3B0aW9ucywgc2V0Q29udGV4dFRyYW5zZm9ybSk7XG5cbiAgLy8gbW90aW9uYmx1cjogYmxpdCByZW5kZXJlZCBibHVycnkgZnJhbWVzXG4gIGlmIChtb3Rpb25CbHVyICYmIG1iUHhSYXRpbyAhPT0gMSkge1xuICAgIHZhciBjeHROb2RlID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgIHZhciB0eHROb2RlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV07XG4gICAgdmFyIGN4dERyYWcgPSBkYXRhLmNvbnRleHRzW3IuRFJBR107XG4gICAgdmFyIHR4dERyYWcgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXTtcbiAgICB2YXIgZHJhd01vdGlvbkJsdXIgPSBmdW5jdGlvbiBkcmF3TW90aW9uQmx1cihjeHQsIHR4dCwgbmVlZENsZWFyKSB7XG4gICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgaWYgKG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QpIHtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYmNsZWFyKGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdmFyIHB4ciA9IG1iUHhSYXRpbztcbiAgICAgIGN4dC5kcmF3SW1hZ2UodHh0LFxuICAgICAgLy8gaW1nXG4gICAgICAwLCAwLFxuICAgICAgLy8gc3gsIHN5XG4gICAgICByLmNhbnZhc1dpZHRoICogcHhyLCByLmNhbnZhc0hlaWdodCAqIHB4cixcbiAgICAgIC8vIHN3LCBzaFxuICAgICAgMCwgMCxcbiAgICAgIC8vIHgsIHlcbiAgICAgIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0IC8vIHcsIGhcbiAgICAgICk7XG4gICAgfTtcbiAgICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltyLk5PREVdKTtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5lZWREcmF3W3IuRFJBR10gfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkge1xuICAgICAgZHJhd01vdGlvbkJsdXIoY3h0RHJhZywgdHh0RHJhZywgbmVlZE1iQ2xlYXJbci5EUkFHXSk7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHIucHJldlZpZXdwb3J0ID0gdnA7XG4gIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgfVxuICBpZiAobW90aW9uQmx1cikge1xuICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gZmFsc2U7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSAhdGV4dHVyZURyYXc7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IHRydWU7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH0sIG1vdGlvbkJsdXJEZWxheSk7XG4gIH1cbiAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgY3kuZW1pdCgncmVuZGVyJyk7XG4gIH1cbn07XG52YXIgZnBzSGVpZ2h0O1xuQ1JwJDUuZHJhd1NlbGVjdGlvblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBzZXRDb250ZXh0VHJhbnNmb3JtKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBkcmF3QWxsTGF5ZXJzID0gb3B0aW9ucy5kcmF3QWxsTGF5ZXJzO1xuICB2YXIgbmVlZERyYXcgPSBkYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgaWYgKHIuc2hvd0ZwcyB8fCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykge1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW3IuU0VMRUNUX0JPWF07XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0KTtcbiAgICBpZiAoci5zZWxlY3Rpb25bNF0gPT0gMSAmJiAoci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZykpIHtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcpLnZhbHVlIC8gem9vbTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWNvbG9yJykudmFsdWVbMF0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgIGNvbnRleHQuZmlsbFJlY3Qoci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzFdLCByLnNlbGVjdGlvblsyXSAtIHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblszXSAtIHIuc2VsZWN0aW9uWzFdKTtcbiAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBzdHlsZS5jb3JlKCdhY3RpdmUtYmctc2l6ZScpLnBmVmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgdmFyIHRpbWVUb1JlbmRlciA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgaWYgKHIuc2hvd0ZwcyAmJiB0aW1lVG9SZW5kZXIpIHtcbiAgICAgIHRpbWVUb1JlbmRlciA9IE1hdGgucm91bmQodGltZVRvUmVuZGVyKTtcbiAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKDEwMDAgLyB0aW1lVG9SZW5kZXIpO1xuICAgICAgdmFyIHRleHQgPSAnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJztcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIC8vIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgIGNvbnRleHQuZm9udCA9ICczMHB4IEFyaWFsJztcbiAgICAgIGlmICghZnBzSGVpZ2h0KSB7XG4gICAgICAgIHZhciBkaW1zID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgZnBzSGVpZ2h0ID0gZGltcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgMCwgZnBzSGVpZ2h0KTtcbiAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCBmcHNIZWlnaHQgKyAxMCwgMjUwLCAyMCk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIGZwc0hlaWdodCArIDEwLCAyNTAgKiBNYXRoLm1pbihmcHMgLyBtYXhGcHMsIDEpLCAyMCk7XG4gICAgfVxuICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBOb3RlczpcbiAqIC0gQWxsIGNvbG9ycyBoYXZlIHByZW11bHRpcGxpZWQgYWxwaGEuIFZlcnkgaW1wb3J0YW50IGZvciB0ZXh0dWVzIGFuZCBcbiAqICAgYmxlbmRpbmcgdG8gd29yayBjb3JyZWN0bHkuXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG4gIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgfVxuICAvLyBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICByZXR1cm4gc2hhZGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U291cmNlLCBmcmFnZW1lbnRTb3VyY2UpIHtcbiAgdmFyIHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNvdXJjZSk7XG4gIHZhciBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ2VtZW50U291cmNlKTtcbiAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGluaXRpYWxpemUgc2hhZGVycycpO1xuICB9XG4gIHJldHVybiBwcm9ncmFtO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2Zmc2NyZW4gY2FudmFzIHdpdGggYSAyRCBjb250ZXh0LCBmb3IgdGhlXG4gKiBjYW52YXMgcmVuZGVyZXIgdG8gdXNlIGZvciBkcmF3aW5nIHRleHR1cmVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlQ2FudmFzKHIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGVpZ2h0ID0gd2lkdGg7XG4gIH1cbiAgdmFyIGNhbnZhcyA9IHIubWFrZU9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIGN0eCA9IGNhbnZhcy5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGNhbnZhcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9O1xuICBjYW52YXMuY2xlYXIoKTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBhbiAmIHpvb20gdmFsdWVzLCBzY2FsZWQgYnkgdGhlIHBpeGVsIHJhdGlvLlxuICovXG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVQYW5ab29tKHIpIHtcbiAgdmFyIHBpeGVsUmF0aW8gPSByLnBpeGVsUmF0aW87XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBwYW4gPSByLmN5LnBhbigpO1xuICByZXR1cm4ge1xuICAgIHpvb206IHpvb20gKiBwaXhlbFJhdGlvLFxuICAgIHBhbjoge1xuICAgICAgeDogcGFuLnggKiBwaXhlbFJhdGlvLFxuICAgICAgeTogcGFuLnkgKiBwaXhlbFJhdGlvXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHpvb20gdmFsdWUsIHNjYWxlZCBieSB0aGUgcGl4ZWwgcmF0aW8uXG4gKi9cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZVpvb20ocikge1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIucGl4ZWxSYXRpbztcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgcmV0dXJuIHpvb20gKiBwaXhlbFJhdGlvO1xufVxuZnVuY3Rpb24gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ociwgcGFuLCB6b29tLCB4LCB5KSB7XG4gIHZhciByeCA9IHggKiB6b29tICsgcGFuLng7XG4gIHZhciByeSA9IHkgKiB6b29tICsgcGFuLnk7XG4gIHJ5ID0gTWF0aC5yb3VuZChyLmNhbnZhc0hlaWdodCAtIHJ5KTsgLy8gYWRqdXN0IGZvciB3ZWJnbFxuICByZXR1cm4gW3J4LCByeV07XG59XG5mdW5jdGlvbiBpc1NpbXBsZVNoYXBlKG5vZGUpIHtcbiAgLy8gdGhlIGFjdHVhbCBzaGFwZSBpcyBjaGVja2VkIGluIEVsZW1lbnREcmF3aW5nV2ViR0wuX2dldFZlcnRUeXBlRm9yU2hhcGUoKVxuICAvLyBubyBuZWVkIHRvIGNoZWNrIGl0IHR3aWNlLCB0aGlzIGp1c3QgY2hlY2tzIG90aGVyIHZpc3VhbCBwcm9wZXJ0aWVzXG4gIGlmIChub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1maWxsJykudmFsdWUgIT09ICdzb2xpZCcpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJykuc3RyVmFsdWUgIT09ICdub25lJykgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnZhbHVlID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG5vZGUucHN0eWxlKCdib3JkZXItb3BhY2l0eScpLnZhbHVlID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgLy8gd2UgaGF2ZSBhIGJvcmRlciBidXQgaXQgbXVzdCBiZSBzaW1wbGVcbiAgaWYgKG5vZGUucHN0eWxlKCdib3JkZXItc3R5bGUnKS52YWx1ZSAhPT0gJ3NvbGlkJykgcmV0dXJuIGZhbHNlO1xuICAvLyBUT0RPIGlnbm9yaW5nICdib3JkZXItY2FwJywgJ2JvcmRlci1qb2luJyBhbmQgJ2JvcmRlci1wb3NpdGlvbicgZm9yIG5vd1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFycmF5RXF1YWwoYTEsIGEyKSB7XG4gIGlmIChhMS5sZW5ndGggIT09IGEyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGExLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGExW2ldICE9PSBhMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUYWtlcyBjb2xvciAmIG9wYWNpdHkgc3R5bGUgdmFsdWVzIGFuZCBjb252ZXJ0cyB0aGVtIHRvIFdlYkdMIGZvcm1hdC4gXG4gKiBBbHBoYSBpcyBwcmVtdWx0aXBsaWVkLlxuICovXG5mdW5jdGlvbiB0b1dlYkdMQ29sb3IoY29sb3IsIG9wYWNpdHksIG91dEFycmF5KSB7XG4gIHZhciByID0gY29sb3JbMF0gLyAyNTU7XG4gIHZhciBnID0gY29sb3JbMV0gLyAyNTU7XG4gIHZhciBiID0gY29sb3JbMl0gLyAyNTU7XG4gIHZhciBhID0gb3BhY2l0eTtcbiAgdmFyIGFyciA9IG91dEFycmF5IHx8IG5ldyBBcnJheSg0KTtcbiAgYXJyWzBdID0gciAqIGE7XG4gIGFyclsxXSA9IGcgKiBhO1xuICBhcnJbMl0gPSBiICogYTtcbiAgYXJyWzNdID0gYTtcbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGluZGV4VG9WZWM0KGluZGV4LCBvdXRBcnJheSkge1xuICB2YXIgYXJyID0gb3V0QXJyYXkgfHwgbmV3IEFycmF5KDQpO1xuICBhcnJbMF0gPSAoaW5kZXggPj4gMCAmIDB4RkYpIC8gMHhGRjtcbiAgYXJyWzFdID0gKGluZGV4ID4+IDggJiAweEZGKSAvIDB4RkY7XG4gIGFyclsyXSA9IChpbmRleCA+PiAxNiAmIDB4RkYpIC8gMHhGRjtcbiAgYXJyWzNdID0gKGluZGV4ID4+IDI0ICYgMHhGRikgLyAweEZGO1xuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gdmVjNFRvSW5kZXgodmVjNCkge1xuICByZXR1cm4gdmVjNFswXSArICh2ZWM0WzFdIDw8IDgpICsgKHZlYzRbMl0gPDwgMTYpICsgKHZlYzRbM10gPDwgMjQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCwgZGVidWdJRCkge1xuICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgdGV4dHVyZS5idWZmZXIgPSBmdW5jdGlvbiAob2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCk7XG5cbiAgICAvLyB2ZXJ5IGltcG9ydGFudCwgdGhpcyB0ZWxscyB3ZWJnbCB0byBwcmVtdWx0aXBseSBjb2xvcnMgYnkgdGhlIGFscGhhIGNoYW5uZWxcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgb2Zmc2NyZWVuQ2FudmFzKTtcbiAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgfTtcbiAgdGV4dHVyZS5kZWxldGVUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gIH07XG4gIHJldHVybiB0ZXh0dXJlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUluZm8oZ2wsIGdsc2xUeXBlKSB7XG4gIHN3aXRjaCAoZ2xzbFR5cGUpIHtcbiAgICBjYXNlICdmbG9hdCc6XG4gICAgICByZXR1cm4gWzEsIGdsLkZMT0FULCA0XTtcbiAgICBjYXNlICd2ZWMyJzpcbiAgICAgIHJldHVybiBbMiwgZ2wuRkxPQVQsIDRdO1xuICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgcmV0dXJuIFszLCBnbC5GTE9BVCwgNF07XG4gICAgY2FzZSAndmVjNCc6XG4gICAgICByZXR1cm4gWzQsIGdsLkZMT0FULCA0XTtcbiAgICBjYXNlICdpbnQnOlxuICAgICAgcmV0dXJuIFsxLCBnbC5JTlQsIDRdO1xuICAgIGNhc2UgJ2l2ZWMyJzpcbiAgICAgIHJldHVybiBbMiwgZ2wuSU5ULCA0XTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVHlwZWRBcnJheShnbCwgZ2xUeXBlLCBkYXRhT3JTaXplKSB7XG4gIHN3aXRjaCAoZ2xUeXBlKSB7XG4gICAgY2FzZSBnbC5GTE9BVDpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGRhdGFPclNpemUpO1xuICAgIGNhc2UgZ2wuSU5UOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGRhdGFPclNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlZEFycmF5VmlldyhnbCwgZ2xUeXBlLCBhcnJheSwgc3RyaWRlLCBzaXplLCBpKSB7XG4gIHN3aXRjaCAoZ2xUeXBlKSB7XG4gICAgY2FzZSBnbC5GTE9BVDpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGFycmF5LmJ1ZmZlciwgaSAqIHN0cmlkZSwgc2l6ZSk7XG4gICAgY2FzZSBnbC5JTlQ6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYXJyYXkuYnVmZmVyLCBpICogc3RyaWRlLCBzaXplKTtcbiAgfVxufVxuXG4vKiogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsICovXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJTdGF0aWNEcmF3KGdsLCB0eXBlLCBhdHRyaWJ1dGVMb2MsIGRhdGFBcnJheSkge1xuICB2YXIgX2dldFR5cGVJbmZvID0gZ2V0VHlwZUluZm8oZ2wsIHR5cGUpLFxuICAgIF9nZXRUeXBlSW5mbzIgPSBfc2xpY2VkVG9BcnJheShfZ2V0VHlwZUluZm8sIDIpLFxuICAgIHNpemUgPSBfZ2V0VHlwZUluZm8yWzBdLFxuICAgIGdsVHlwZSA9IF9nZXRUeXBlSW5mbzJbMV07XG4gIHZhciBkYXRhID0gY3JlYXRlVHlwZWRBcnJheShnbCwgZ2xUeXBlLCBkYXRhQXJyYXkpO1xuICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuICBpZiAoZ2xUeXBlID09PSBnbC5GTE9BVCkge1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmlidXRlTG9jLCBzaXplLCBnbFR5cGUsIGZhbHNlLCAwLCAwKTtcbiAgfSBlbHNlIGlmIChnbFR5cGUgPT09IGdsLklOVCkge1xuICAgIGdsLnZlcnRleEF0dHJpYklQb2ludGVyKGF0dHJpYnV0ZUxvYywgc2l6ZSwgZ2xUeXBlLCAwLCAwKTtcbiAgfVxuICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2MpO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbi8qKiBcbiAqIENyZWF0ZXMgYSBmbG9hdCBidWZmZXIgd2l0aCBnbC5EWU5BTUlDX0RSQVcuXG4gKiBUaGUgcmV0dXJuZWQgYnVmZmVyIG9iamVjdCBjb250YWlucyBmdW5jdGlvbnMgdG8gZWFzaWx5IHNldCBpbnN0YW5jZSBkYXRhIGFuZCBidWZmZXIgdGhlIGRhdGEgYmVmb3JlIGEgZHJhdyBjYWxsLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFxuICovXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgaW5zdGFuY2VzLCB0eXBlLCBhdHRyaWJ1dGVMb2MpIHtcbiAgdmFyIF9nZXRUeXBlSW5mbzMgPSBnZXRUeXBlSW5mbyhnbCwgdHlwZSksXG4gICAgX2dldFR5cGVJbmZvNCA9IF9zbGljZWRUb0FycmF5KF9nZXRUeXBlSW5mbzMsIDMpLFxuICAgIHNpemUgPSBfZ2V0VHlwZUluZm80WzBdLFxuICAgIGdsVHlwZSA9IF9nZXRUeXBlSW5mbzRbMV0sXG4gICAgYnl0ZXMgPSBfZ2V0VHlwZUluZm80WzJdO1xuICB2YXIgZGF0YUFycmF5ID0gY3JlYXRlVHlwZWRBcnJheShnbCwgZ2xUeXBlLCBpbnN0YW5jZXMgKiBzaXplKTtcbiAgdmFyIHN0cmlkZSA9IHNpemUgKiBieXRlcztcbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGluc3RhbmNlcyAqIHN0cmlkZSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlTG9jKTtcbiAgaWYgKGdsVHlwZSA9PT0gZ2wuRkxPQVQpIHtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvYywgc2l6ZSwgZ2xUeXBlLCBmYWxzZSwgc3RyaWRlLCAwKTtcbiAgfSBlbHNlIGlmIChnbFR5cGUgPT09IGdsLklOVCkge1xuICAgIGdsLnZlcnRleEF0dHJpYklQb2ludGVyKGF0dHJpYnV0ZUxvYywgc2l6ZSwgZ2xUeXBlLCBzdHJpZGUsIDApO1xuICB9XG4gIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0cmlidXRlTG9jLCAxKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuXG4gIC8vIHVzZSBhcnJheSB2aWV3cyB0byBzZXQgdmFsdWVzIGRpcmVjdGx5IGludG8gdGhlIGJ1ZmZlciBhcnJheVxuICB2YXIgdmlld3MgPSBuZXcgQXJyYXkoaW5zdGFuY2VzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZXM7IGkrKykge1xuICAgIHZpZXdzW2ldID0gY3JlYXRlVHlwZWRBcnJheVZpZXcoZ2wsIGdsVHlwZSwgZGF0YUFycmF5LCBzdHJpZGUsIHNpemUsIGkpO1xuICB9XG4gIGJ1ZmZlci5kYXRhQXJyYXkgPSBkYXRhQXJyYXk7XG4gIGJ1ZmZlci5zdHJpZGUgPSBzdHJpZGU7XG4gIGJ1ZmZlci5zaXplID0gc2l6ZTtcbiAgYnVmZmVyLmdldFZpZXcgPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiB2aWV3c1tpXTtcbiAgfTtcbiAgYnVmZmVyLnNldFBvaW50ID0gZnVuY3Rpb24gKGksIHgsIHkpIHtcbiAgICB2YXIgdmlldyA9IHZpZXdzW2ldO1xuICAgIHZpZXdbMF0gPSB4O1xuICAgIHZpZXdbMV0gPSB5O1xuICB9O1xuICBidWZmZXIuYnVmZmVyU3ViRGF0YSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGlmIChjb3VudCkge1xuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIGRhdGFBcnJheSwgMCwgY291bnQgKiBzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIGRhdGFBcnJheSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKiogXG4gKiBDcmVhdGVzIGEgYnVmZmVyIG9mIDN4MyBtYXRyaXggZGF0YSBmb3IgdXNlIGFzIGF0dHJpYnV0ZSBkYXRhLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFxuICovXG5mdW5jdGlvbiBjcmVhdGUzeDNNYXRyaXhCdWZmZXJEeW5hbWljRHJhdyhnbCwgaW5zdGFuY2VzLCBhdHRyaWJ1dGVMb2MpIHtcbiAgdmFyIG1hdHJpeFNpemUgPSA5OyAvLyAzeDMgbWF0cml4XG4gIHZhciBtYXRyaXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheShpbnN0YW5jZXMgKiBtYXRyaXhTaXplKTtcblxuICAvLyB1c2UgbWF0cml4IHZpZXdzIHRvIHNldCB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgbWF0cml4RGF0YSBhcnJheVxuICB2YXIgbWF0cml4Vmlld3MgPSBuZXcgQXJyYXkoaW5zdGFuY2VzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZXM7IGkrKykge1xuICAgIHZhciBieXRlT2Zmc2V0ID0gaSAqIG1hdHJpeFNpemUgKiA0OyAvLyA0IGJ5dGVzIHBlciBmbG9hdFxuICAgIG1hdHJpeFZpZXdzW2ldID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXhEYXRhLmJ1ZmZlciwgYnl0ZU9mZnNldCwgbWF0cml4U2l6ZSk7IC8vIGFycmF5IHZpZXdcbiAgfVxuICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbWF0cml4RGF0YS5ieXRlTGVuZ3RoLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gIC8vIGVhY2ggcm93IG9mIHRoZSBtYXRyaXggbmVlZHMgdG8gYmUgYSBzZXBhcmF0ZSBhdHRyaWJ1dGVcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDM7IF9pKyspIHtcbiAgICB2YXIgbG9jID0gYXR0cmlidXRlTG9jICsgX2k7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvYywgMywgZ2wuRkxPQVQsIGZhbHNlLCAzICogMTIsIF9pICogMTIpO1xuICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jLCAxKTtcbiAgfVxuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIGJ1ZmZlci5nZXRNYXRyaXhWaWV3ID0gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gbWF0cml4Vmlld3NbaV07XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIGlzIHRvbyBzbG93LCB1c2UgZ2V0TWF0cml4VmlldyBhbmQgcGFzcyB0aGUgdmlldyBkaXJlY3RseSB0byB0aGUgZ2xtYXRyaXggbGlicmFyeVxuICBidWZmZXIuc2V0RGF0YSA9IGZ1bmN0aW9uIChtYXRyaXgsIGkpIHtcbiAgICBtYXRyaXhWaWV3c1tpXS5zZXQobWF0cml4LCAwKTtcbiAgfTtcbiAgYnVmZmVyLmJ1ZmZlclN1YkRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIG1hdHJpeERhdGEpO1xuICB9O1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKiogXG4gKiBDcmVhdGVzIGEgRnJhbWUgQnVmZmVyIHRvIHVzZSBmb3Igb2Zmc2NyZWVuIHJlbmRlcmluZy5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGlja2luZ0ZyYW1lQnVmZmVyKGdsKSB7XG4gIC8vIENyZWF0ZSBhbmQgYmluZCB0aGUgZnJhbWVidWZmZXJcbiAgdmFyIGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYik7XG5cbiAgLy8gQ3JlYXRlIGEgdGV4dHVyZSB0byByZW5kZXIgdG9cbiAgdmFyIHRhcmdldFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRhcmdldFRleHR1cmUpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXG4gIC8vIGF0dGFjaCB0aGUgdGV4dHVyZSBhcyB0aGUgZmlyc3QgY29sb3IgYXR0YWNobWVudFxuICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRhcmdldFRleHR1cmUsIDApO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICBmYi5zZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRTaXplcyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGFyZ2V0VGV4dHVyZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgfTtcbiAgcmV0dXJuIGZiO1xufVxuXG4vKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbnZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmlmICghTWF0aC5oeXBvdCkgTWF0aC5oeXBvdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHkgPSAwLFxuICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHkgKz0gYXJndW1lbnRzW2ldICogYXJndW1lbnRzW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydCh5KTtcbn07XG5cbi8qKlxuICogM3gzIE1hdHJpeFxuICogQG1vZHVsZSBtYXQzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBBUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChBUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMCA9IGJbMF0sXG4gICAgICBiMDEgPSBiWzFdLFxuICAgICAgYjAyID0gYlsyXTtcbiAgdmFyIGIxMCA9IGJbM10sXG4gICAgICBiMTEgPSBiWzRdLFxuICAgICAgYjEyID0gYls1XTtcbiAgdmFyIGIyMCA9IGJbNl0sXG4gICAgICBiMjEgPSBiWzddLFxuICAgICAgYjIyID0gYls4XTtcbiAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcbiAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcbiAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0gYTAwO1xuICBvdXRbMV0gPSBhMDE7XG4gIG91dFsyXSA9IGEwMjtcbiAgb3V0WzNdID0gYTEwO1xuICBvdXRbNF0gPSBhMTE7XG4gIG91dFs1XSA9IGExMjtcbiAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0geCAqIGFbMF07XG4gIG91dFsxXSA9IHggKiBhWzFdO1xuICBvdXRbMl0gPSB4ICogYVsyXTtcbiAgb3V0WzNdID0geSAqIGFbM107XG4gIG91dFs0XSA9IHkgKiBhWzRdO1xuICBvdXRbNV0gPSB5ICogYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZ2wgY29udGV4dFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IC0xO1xuICBvdXRbN10gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vLyBBIFwidGV4dHVyZSBhdGxhc1wiIGlzIGEgYmlnIGNhbnZhcywgYW5kIHNlY3Rpb25zIG9mIGl0IGFyZSB1c2VkIGFzIHRleHR1cmVzIGZvciBub2Rlcy9sYWJlbHMuXG5cbi8qKlxuICogQSBzaW5nbGUgc3F1YXJlIHRleHR1cmUgYXRsYXMgKGFsc28ga25vd24gYXMgYSBcInNwcml0ZSBzaGVldFwiKS5cbiAqL1xudmFyIEF0bGFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXRsYXMociwgdGV4U2l6ZSwgdGV4Um93cywgY3JlYXRlVGV4dHVyZUNhbnZhcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdGxhcyk7XG4gICAgdGhpcy5kZWJ1Z0lEID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy50ZXhTaXplID0gdGV4U2l6ZTtcbiAgICB0aGlzLnRleFJvd3MgPSB0ZXhSb3dzO1xuICAgIHRoaXMudGV4SGVpZ2h0ID0gTWF0aC5mbG9vcih0ZXhTaXplIC8gdGV4Um93cyk7XG4gICAgdGhpcy5lbmFibGVXcmFwcGluZyA9IHRydWU7IC8vIGhhcmRjb2RlZCBmb3Igbm93LCBjYW4gYmUgbWFkZSBhbiBvcHRpb25cblxuICAgIHRoaXMubG9ja2VkID0gZmFsc2U7IC8vIG9uY2UgYW4gYXRsYXMgaXMgbG9ja2VkIGl0IGNhbiBubyBsb25nZXIgYmUgZHJhd24gdG9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsOyAvLyBXZWJHTFRleHR1cmUgb2JqZWN0XG4gICAgdGhpcy5uZWVkc0J1ZmZlciA9IHRydWU7XG5cbiAgICAvLyBhIFwibG9jYXRpb25cIiBpcyBhbiBwb2ludGVyIGludG8gdGhlIGF0bGFzIHdpdGggYSAncm93JyBhbmQgJ3gnIGZpZWxkc1xuICAgIHRoaXMuZnJlZVBvaW50ZXIgPSB7XG4gICAgICB4OiAwLFxuICAgICAgcm93OiAwXG4gICAgfTtcblxuICAgIC8vIG1hcCBmcm9tIHRoZSBzdHlsZSBrZXkgdG8gdGhlIHJvdy94IHdoZXJlIHRoZSB0ZXh0dXJlIHN0YXJ0c1xuICAgIC8vIGlmIHRoZSB0ZXh0dXJlIHdyYXBzIHRoZW4gdGhlcmUncyBhIHNlY29uZCBsb2NhdGlvblxuICAgIHRoaXMua2V5VG9Mb2NhdGlvbiA9IG5ldyBNYXAoKTsgLy8gc3R5bGVLZXkgLT4gWyBsb2NhdGlvbiwgbG9jYXRpb24gXVxuXG4gICAgdGhpcy5jYW52YXMgPSBjcmVhdGVUZXh0dXJlQ2FudmFzKHIsIHRleFNpemUsIHRleFNpemUpO1xuICAgIHRoaXMuc2NyYXRjaCA9IGNyZWF0ZVRleHR1cmVDYW52YXMociwgdGV4U2l6ZSwgdGhpcy50ZXhIZWlnaHQsICdzY3JhdGNoJyk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdGxhcywgW3tcbiAgICBrZXk6IFwibG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NrKCkge1xuICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEtleXMoKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh0aGlzLmtleVRvTG9jYXRpb24ua2V5cygpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NhbGUoX3JlZikge1xuICAgICAgdmFyIHcgPSBfcmVmLncsXG4gICAgICAgIGggPSBfcmVmLmg7XG4gICAgICB2YXIgdGV4SGVpZ2h0ID0gdGhpcy50ZXhIZWlnaHQsXG4gICAgICAgIG1heFRleFdpZHRoID0gdGhpcy50ZXhTaXplO1xuICAgICAgLy8gdHJ5IHRvIGZpdCB0byB0aGUgaGVpZ2h0IG9mIGEgcm93XG4gICAgICB2YXIgc2NhbGUgPSB0ZXhIZWlnaHQgLyBoOyAvLyBUT0RPIHdoYXQgYWJvdXQgcGl4ZWxSYXRpbz9cbiAgICAgIHZhciB0ZXhXID0gdyAqIHNjYWxlO1xuICAgICAgdmFyIHRleEggPSBoICogc2NhbGU7XG4gICAgICAvLyBpZiB0aGUgc2NhbGVkIHdpZHRoIGlzIHRvbyB3aWRlIHRoZW4gc2NhbGUgdG8gZml0IG1heCB3aWR0aCBpbnN0ZWFkXG4gICAgICBpZiAodGV4VyA+IG1heFRleFdpZHRoKSB7XG4gICAgICAgIHNjYWxlID0gbWF4VGV4V2lkdGggLyB3O1xuICAgICAgICB0ZXhXID0gdyAqIHNjYWxlO1xuICAgICAgICB0ZXhIID0gaCAqIHNjYWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICB0ZXhXOiB0ZXhXLFxuICAgICAgICB0ZXhIOiB0ZXhIXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoa2V5LCBiYiwgZG9EcmF3aW5nKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMubG9ja2VkKSB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgZHJhdywgYXRsYXMgaXMgbG9ja2VkJyk7XG4gICAgICB2YXIgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZSxcbiAgICAgICAgdGV4Um93cyA9IHRoaXMudGV4Um93cyxcbiAgICAgICAgdGV4SGVpZ2h0ID0gdGhpcy50ZXhIZWlnaHQ7XG4gICAgICB2YXIgX3RoaXMkZ2V0U2NhbGUgPSB0aGlzLmdldFNjYWxlKGJiKSxcbiAgICAgICAgc2NhbGUgPSBfdGhpcyRnZXRTY2FsZS5zY2FsZSxcbiAgICAgICAgdGV4VyA9IF90aGlzJGdldFNjYWxlLnRleFcsXG4gICAgICAgIHRleEggPSBfdGhpcyRnZXRTY2FsZS50ZXhIO1xuICAgICAgdmFyIGRyYXdBdCA9IGZ1bmN0aW9uIGRyYXdBdChsb2NhdGlvbiwgY2FudmFzKSB7XG4gICAgICAgIGlmIChkb0RyYXdpbmcgJiYgY2FudmFzKSB7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuY29udGV4dDtcbiAgICAgICAgICB2YXIgeCA9IGxvY2F0aW9uLngsXG4gICAgICAgICAgICByb3cgPSBsb2NhdGlvbi5yb3c7XG4gICAgICAgICAgdmFyIHhPZmZzZXQgPSB4O1xuICAgICAgICAgIHZhciB5T2Zmc2V0ID0gdGV4SGVpZ2h0ICogcm93O1xuICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgICBkb0RyYXdpbmcoY29udGV4dCwgYmIpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGxvY2F0aW9ucyA9IFtudWxsLCBudWxsXTtcbiAgICAgIHZhciBkcmF3Tm9ybWFsID0gZnVuY3Rpb24gZHJhd05vcm1hbCgpIHtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB3cmFwLCBkcmF3IGRpcmVjdGx5IG9uIHRoZSBjYW52YXNcbiAgICAgICAgZHJhd0F0KF90aGlzLmZyZWVQb2ludGVyLCBfdGhpcy5jYW52YXMpO1xuICAgICAgICBsb2NhdGlvbnNbMF0gPSB7XG4gICAgICAgICAgeDogX3RoaXMuZnJlZVBvaW50ZXIueCxcbiAgICAgICAgICB5OiBfdGhpcy5mcmVlUG9pbnRlci5yb3cgKiB0ZXhIZWlnaHQsXG4gICAgICAgICAgdzogdGV4VyxcbiAgICAgICAgICBoOiB0ZXhIXG4gICAgICAgIH07XG4gICAgICAgIGxvY2F0aW9uc1sxXSA9IHtcbiAgICAgICAgICAvLyBjcmVhdGUgYSBzZWNvbmQgbG9jYXRpb24gd2l0aCBhIHdpZHRoIG9mIDAsIGZvciBjb252ZW5pZW5jZVxuICAgICAgICAgIHg6IF90aGlzLmZyZWVQb2ludGVyLnggKyB0ZXhXLFxuICAgICAgICAgIHk6IF90aGlzLmZyZWVQb2ludGVyLnJvdyAqIHRleEhlaWdodCxcbiAgICAgICAgICB3OiAwLFxuICAgICAgICAgIGg6IHRleEhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtb3ZlIHRoZSBwb2ludGVyIHRvIHRoZSBlbmQgb2YgdGhlIHRleHR1cmVcbiAgICAgICAgX3RoaXMuZnJlZVBvaW50ZXIueCArPSB0ZXhXO1xuICAgICAgICBpZiAoX3RoaXMuZnJlZVBvaW50ZXIueCA9PSB0ZXhTaXplKSB7XG4gICAgICAgICAgX3RoaXMuZnJlZVBvaW50ZXIueCA9IDA7XG4gICAgICAgICAgX3RoaXMuZnJlZVBvaW50ZXIucm93Kys7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZHJhd1dyYXBwZWQgPSBmdW5jdGlvbiBkcmF3V3JhcHBlZCgpIHtcbiAgICAgICAgdmFyIHNjcmF0Y2ggPSBfdGhpcy5zY3JhdGNoLFxuICAgICAgICAgIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcblxuICAgICAgICAvLyBEcmF3IHRvIHRoZSBzY3JhdGNoIGNhbnZhc1xuICAgICAgICBzY3JhdGNoLmNsZWFyKCk7XG4gICAgICAgIGRyYXdBdCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICByb3c6IDBcbiAgICAgICAgfSwgc2NyYXRjaCk7XG4gICAgICAgIHZhciBmaXJzdFRleFcgPSB0ZXhTaXplIC0gX3RoaXMuZnJlZVBvaW50ZXIueDtcbiAgICAgICAgdmFyIHNlY29uZFRleFcgPSB0ZXhXIC0gZmlyc3RUZXhXO1xuICAgICAgICB2YXIgaCA9IHRleEhlaWdodDtcbiAgICAgICAge1xuICAgICAgICAgIC8vIGNvcHkgZmlyc3QgcGFydCBvZiBzY3JhdGNoIHRvIHRoZSBmaXJzdCB0ZXh0dXJlXG4gICAgICAgICAgdmFyIGR4ID0gX3RoaXMuZnJlZVBvaW50ZXIueDtcbiAgICAgICAgICB2YXIgZHkgPSBfdGhpcy5mcmVlUG9pbnRlci5yb3cgKiB0ZXhIZWlnaHQ7XG4gICAgICAgICAgdmFyIHcgPSBmaXJzdFRleFc7XG4gICAgICAgICAgY2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKHNjcmF0Y2gsIDAsIDAsIHcsIGgsIGR4LCBkeSwgdywgaCk7XG4gICAgICAgICAgbG9jYXRpb25zWzBdID0ge1xuICAgICAgICAgICAgeDogZHgsXG4gICAgICAgICAgICB5OiBkeSxcbiAgICAgICAgICAgIHc6IHcsXG4gICAgICAgICAgICBoOiB0ZXhIXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgLy8gY29weSBzZWNvbmQgcGFydCBvZiBzY3JhdGNoIHRvIHRoZSBzZWNvbmQgdGV4dHVyZVxuICAgICAgICAgIHZhciBzeCA9IGZpcnN0VGV4VztcbiAgICAgICAgICB2YXIgX2R5ID0gKF90aGlzLmZyZWVQb2ludGVyLnJvdyArIDEpICogdGV4SGVpZ2h0O1xuICAgICAgICAgIHZhciBfdyA9IHNlY29uZFRleFc7XG4gICAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgY2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKHNjcmF0Y2gsIHN4LCAwLCBfdywgaCwgMCwgX2R5LCBfdywgaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2F0aW9uc1sxXSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiBfZHksXG4gICAgICAgICAgICB3OiBfdyxcbiAgICAgICAgICAgIGg6IHRleEhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmZyZWVQb2ludGVyLnggPSBzZWNvbmRUZXhXO1xuICAgICAgICBfdGhpcy5mcmVlUG9pbnRlci5yb3crKztcbiAgICAgIH07XG4gICAgICB2YXIgbW92ZVRvU3RhcnRPZk5leHRSb3cgPSBmdW5jdGlvbiBtb3ZlVG9TdGFydE9mTmV4dFJvdygpIHtcbiAgICAgICAgX3RoaXMuZnJlZVBvaW50ZXIueCA9IDA7XG4gICAgICAgIF90aGlzLmZyZWVQb2ludGVyLnJvdysrO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmZyZWVQb2ludGVyLnggKyB0ZXhXIDw9IHRleFNpemUpIHtcbiAgICAgICAgLy8gVGhlcmUncyBlbm91Z2ggc3BhY2UgaW4gdGhlIGN1cnJlbnQgcm93XG4gICAgICAgIGRyYXdOb3JtYWwoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmVlUG9pbnRlci5yb3cgPj0gdGV4Um93cyAtIDEpIHtcbiAgICAgICAgLy8gTmVlZCB0byBtb3ZlIHRvIHRoZSBuZXh0IHJvdywgYnV0IHRoZXJlIGFyZSBubyBtb3JlIHJvd3MsIGF0bGFzIGlzIGZ1bGwuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmVlUG9pbnRlci54ID09PSB0ZXhTaXplKSB7XG4gICAgICAgIC8vIGhhcHBlbiB0byBiZSByaWdodCBhdCBlbmQgb2YgY3VycmVudCByb3dcbiAgICAgICAgbW92ZVRvU3RhcnRPZk5leHRSb3coKTtcbiAgICAgICAgZHJhd05vcm1hbCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVuYWJsZVdyYXBwaW5nKSB7XG4gICAgICAgIC8vIGRyYXcgcGFydCBvZiB0aGUgdGV4dHVyZSB0byB0aGUgZW5kIG9mIHRoZSBjdXJlbnQgcm93LCB0aGVuIHdyYXAgdG8gdGhlIG5leHQgcm93XG4gICAgICAgIGRyYXdXcmFwcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCByb3csIHRoZW4gZHJhdyBub3JtYWxseVxuICAgICAgICBtb3ZlVG9TdGFydE9mTmV4dFJvdygpO1xuICAgICAgICBkcmF3Tm9ybWFsKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmtleVRvTG9jYXRpb24uc2V0KGtleSwgbG9jYXRpb25zKTtcbiAgICAgIHRoaXMubmVlZHNCdWZmZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxvY2F0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T2Zmc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPZmZzZXRzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5VG9Mb2NhdGlvbi5nZXQoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNFbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJlZVBvaW50ZXIueCA9PT0gMCAmJiB0aGlzLmZyZWVQb2ludGVyLnJvdyA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuRml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkZpdChiYikge1xuICAgICAgaWYgKHRoaXMubG9ja2VkKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZSxcbiAgICAgICAgdGV4Um93cyA9IHRoaXMudGV4Um93cztcbiAgICAgIHZhciBfdGhpcyRnZXRTY2FsZTIgPSB0aGlzLmdldFNjYWxlKGJiKSxcbiAgICAgICAgdGV4VyA9IF90aGlzJGdldFNjYWxlMi50ZXhXO1xuICAgICAgaWYgKHRoaXMuZnJlZVBvaW50ZXIueCArIHRleFcgPiB0ZXhTaXplKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gd3JhcFxuICAgICAgICByZXR1cm4gdGhpcy5mcmVlUG9pbnRlci5yb3cgPCB0ZXhSb3dzIC0gMTsgLy8gcmV0dXJuIHRydWUgaWYgdGhlcmUncyBhIHJvdyB0byB3cmFwIHRvXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgb24gZXZlcnkgZnJhbWVcbiAgfSwge1xuICAgIGtleTogXCJidWZmZXJJZk5lZWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWZmZXJJZk5lZWRlZChnbCkge1xuICAgICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gY3JlYXRlVGV4dHVyZShnbCwgdGhpcy5kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZWRzQnVmZmVyKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZS5idWZmZXIodGhpcy5jYW52YXMpO1xuICAgICAgICB0aGlzLm5lZWRzQnVmZmVyID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnNjcmF0Y2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlbGV0ZVRleHR1cmUoKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuc2NyYXRjaCA9IG51bGw7XG4gICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHRleHR1cmUgYXRsYXNlcywgYWxsIG9mIHRoZSBzYW1lIFwicmVuZGVyIHR5cGVcIi4gXG4gKiAoJ25vZGUtYm9keScgaXMgYW4gZXhhbXBsZSBvZiBhIHJlbmRlciB0eXBlLilcbiAqIEFuIEF0bGFzQ29sbGVjdGlvbiBjYW4gYWxzbyBiZSBub3RpZmllZCB3aGVuIGEgdGV4dHVyZSBpcyBubyBsb25nZXIgbmVlZGVkLCBcbiAqIGFuZCBpdCBjYW4gZ2FyYmFnZSBjb2xsZWN0IHRoZSB1bnVzZWQgdGV4dHVyZXMuXG4gKi9cbnZhciBBdGxhc0NvbGxlY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdGxhc0NvbGxlY3Rpb24ociwgdGV4U2l6ZSwgdGV4Um93cywgY3JlYXRlVGV4dHVyZUNhbnZhcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdGxhc0NvbGxlY3Rpb24pO1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy50ZXhTaXplID0gdGV4U2l6ZTtcbiAgICB0aGlzLnRleFJvd3MgPSB0ZXhSb3dzO1xuICAgIHRoaXMuY3JlYXRlVGV4dHVyZUNhbnZhcyA9IGNyZWF0ZVRleHR1cmVDYW52YXM7XG4gICAgdGhpcy5hdGxhc2VzID0gW107XG4gICAgdGhpcy5zdHlsZUtleVRvQXRsYXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tYXJrZWRLZXlzID0gbmV3IFNldCgpOyAvLyBtYXJrZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXRsYXNDb2xsZWN0aW9uLCBbe1xuICAgIGtleTogXCJnZXRLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEtleXMoKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh0aGlzLnN0eWxlS2V5VG9BdGxhcy5rZXlzKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQXRsYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUF0bGFzKCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnIsXG4gICAgICAgIHRleFNpemUgPSB0aGlzLnRleFNpemUsXG4gICAgICAgIHRleFJvd3MgPSB0aGlzLnRleFJvd3MsXG4gICAgICAgIGNyZWF0ZVRleHR1cmVDYW52YXMgPSB0aGlzLmNyZWF0ZVRleHR1cmVDYW52YXM7XG4gICAgICByZXR1cm4gbmV3IEF0bGFzKHIsIHRleFNpemUsIHRleFJvd3MsIGNyZWF0ZVRleHR1cmVDYW52YXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U2NyYXRjaENhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2NyYXRjaENhbnZhcygpIHtcbiAgICAgIGlmICghdGhpcy5zY3JhdGNoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5yLFxuICAgICAgICAgIHRleFNpemUgPSB0aGlzLnRleFNpemUsXG4gICAgICAgICAgdGV4Um93cyA9IHRoaXMudGV4Um93cyxcbiAgICAgICAgICBjcmVhdGVUZXh0dXJlQ2FudmFzID0gdGhpcy5jcmVhdGVUZXh0dXJlQ2FudmFzO1xuICAgICAgICB2YXIgdGV4SGVpZ2h0ID0gTWF0aC5mbG9vcih0ZXhTaXplIC8gdGV4Um93cyk7XG4gICAgICAgIHRoaXMuc2NyYXRjaCA9IGNyZWF0ZVRleHR1cmVDYW52YXMociwgdGV4U2l6ZSwgdGV4SGVpZ2h0LCAnc2NyYXRjaCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2NyYXRjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGtleSwgYmIsIGRvRHJhd2luZykge1xuICAgICAgdmFyIGF0bGFzID0gdGhpcy5zdHlsZUtleVRvQXRsYXMuZ2V0KGtleSk7XG4gICAgICBpZiAoIWF0bGFzKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBsYXN0IGF0bGFzXG4gICAgICAgIGF0bGFzID0gdGhpcy5hdGxhc2VzW3RoaXMuYXRsYXNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFhdGxhcyB8fCAhYXRsYXMuY2FuRml0KGJiKSkge1xuICAgICAgICAgIGlmIChhdGxhcykgYXRsYXMubG9jaygpO1xuICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhdGxhc1xuICAgICAgICAgIGF0bGFzID0gdGhpcy5fY3JlYXRlQXRsYXMoKTtcbiAgICAgICAgICB0aGlzLmF0bGFzZXMucHVzaChhdGxhcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXRsYXMuZHJhdyhrZXksIGJiLCBkb0RyYXdpbmcpO1xuICAgICAgICB0aGlzLnN0eWxlS2V5VG9BdGxhcy5zZXQoa2V5LCBhdGxhcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXRsYXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0bGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVLZXlUb0F0bGFzLmdldChrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNBdGxhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNBdGxhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlS2V5VG9BdGxhcy5oYXMoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya0tleUZvckdDXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtLZXlGb3JHQyhrZXkpIHtcbiAgICAgIHRoaXMubWFya2VkS2V5cy5hZGQoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2MoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBtYXJrZWRLZXlzID0gdGhpcy5tYXJrZWRLZXlzO1xuICAgICAgaWYgKG1hcmtlZEtleXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnbm90aGluZyB0byBnYXJiYWdlIGNvbGxlY3QnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0F0bGFzZXMgPSBbXTtcbiAgICAgIHZhciBuZXdTdHlsZUtleVRvQXRsYXMgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgbmV3QXRsYXMgPSBudWxsO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuYXRsYXNlcyksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgdmFyIGF0bGFzID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGtleXMgPSBhdGxhcy5nZXRLZXlzKCk7XG4gICAgICAgICAgdmFyIGtleXNUb0NvbGxlY3QgPSBpbnRlcnNlY3Rpb24obWFya2VkS2V5cywga2V5cyk7XG4gICAgICAgICAgaWYgKGtleXNUb0NvbGxlY3Quc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gdGhpcyBhdGxhcyBjYW4gc3RpbGwgYmUgdXNlZFxuICAgICAgICAgICAgbmV3QXRsYXNlcy5wdXNoKGF0bGFzKTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3U3R5bGVLZXlUb0F0bGFzLnNldChrLCBhdGxhcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAxOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5ld0F0bGFzKSB7XG4gICAgICAgICAgICBuZXdBdGxhcyA9IF90aGlzMi5fY3JlYXRlQXRsYXMoKTtcbiAgICAgICAgICAgIG5ld0F0bGFzZXMucHVzaChuZXdBdGxhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoa2V5cyksXG4gICAgICAgICAgICBfc3RlcDI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgIGlmICgha2V5c1RvQ29sbGVjdC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBfYXRsYXMkZ2V0T2Zmc2V0cyA9IGF0bGFzLmdldE9mZnNldHMoa2V5KSxcbiAgICAgICAgICAgICAgICAgIF9hdGxhcyRnZXRPZmZzZXRzMiA9IF9zbGljZWRUb0FycmF5KF9hdGxhcyRnZXRPZmZzZXRzLCAyKSxcbiAgICAgICAgICAgICAgICAgIHMxID0gX2F0bGFzJGdldE9mZnNldHMyWzBdLFxuICAgICAgICAgICAgICAgICAgczIgPSBfYXRsYXMkZ2V0T2Zmc2V0czJbMV07XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdBdGxhcy5jYW5GaXQoe1xuICAgICAgICAgICAgICAgICAgdzogczEudyArIHMyLncsXG4gICAgICAgICAgICAgICAgICBoOiBzMS5oXG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0F0bGFzLmxvY2soKTtcbiAgICAgICAgICAgICAgICAgIG5ld0F0bGFzID0gX3RoaXMyLl9jcmVhdGVBdGxhcygpO1xuICAgICAgICAgICAgICAgICAgbmV3QXRsYXNlcy5wdXNoKG5ld0F0bGFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF0bGFzLmNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRleHR1cmUgY2FuJ3QgYmUgY29waWVkIHRoZW4gaXQgd2lsbCBoYXZlIHRvIGJlIHJlZHJhd24gb24gdGhlIG5leHQgZnJhbWVcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fY29weVRleHR1cmVUb05ld0F0bGFzKGtleSwgYXRsYXMsIG5ld0F0bGFzKTtcbiAgICAgICAgICAgICAgICAgIG5ld1N0eWxlS2V5VG9BdGxhcy5zZXQoa2V5LCBuZXdBdGxhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0bGFzLmRpc3Bvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICBpZiAoX2xvb3AoKSkgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXRsYXNlcyA9IG5ld0F0bGFzZXM7XG4gICAgICB0aGlzLnN0eWxlS2V5VG9BdGxhcyA9IG5ld1N0eWxlS2V5VG9BdGxhcztcbiAgICAgIHRoaXMubWFya2VkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvcHlUZXh0dXJlVG9OZXdBdGxhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weVRleHR1cmVUb05ld0F0bGFzKGtleSwgb2xkQXRsYXMsIG5ld0F0bGFzKSB7XG4gICAgICB2YXIgX29sZEF0bGFzJGdldE9mZnNldHMgPSBvbGRBdGxhcy5nZXRPZmZzZXRzKGtleSksXG4gICAgICAgIF9vbGRBdGxhcyRnZXRPZmZzZXRzMiA9IF9zbGljZWRUb0FycmF5KF9vbGRBdGxhcyRnZXRPZmZzZXRzLCAyKSxcbiAgICAgICAgczEgPSBfb2xkQXRsYXMkZ2V0T2Zmc2V0czJbMF0sXG4gICAgICAgIHMyID0gX29sZEF0bGFzJGdldE9mZnNldHMyWzFdO1xuICAgICAgaWYgKHMyLncgPT09IDApIHtcbiAgICAgICAgLy8gdGhlIHRleHR1cmUgZG9lcyBub3Qgd3JhcCwgZHJhdyBkaXJlY3RseSB0byBuZXcgYXRsYXNcbiAgICAgICAgbmV3QXRsYXMuZHJhdyhrZXksIHMxLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG9sZEF0bGFzLmNhbnZhcywgczEueCwgczEueSwgczEudywgczEuaCwgMCwgMCwgczEudywgczEuaCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIHRleHR1cmUgd3JhcHMsIGZpcnN0IGRyYXcgYm90aCBwYXJ0cyB0byBhIHNjcmF0Y2ggY2FudmFzXG4gICAgICAgIHZhciBzY3JhdGNoID0gdGhpcy5fZ2V0U2NyYXRjaENhbnZhcygpO1xuICAgICAgICBzY3JhdGNoLmNsZWFyKCk7XG4gICAgICAgIHNjcmF0Y2guY29udGV4dC5kcmF3SW1hZ2Uob2xkQXRsYXMuY2FudmFzLCBzMS54LCBzMS55LCBzMS53LCBzMS5oLCAwLCAwLCBzMS53LCBzMS5oKTtcbiAgICAgICAgc2NyYXRjaC5jb250ZXh0LmRyYXdJbWFnZShvbGRBdGxhcy5jYW52YXMsIHMyLngsIHMyLnksIHMyLncsIHMyLmgsIHMxLncsIDAsIHMyLncsIHMyLmgpO1xuXG4gICAgICAgIC8vIG5vdyBkcmF3IHRoZSBzY3JhdGNoIHRvIHRoZSBuZXcgYXRsYXNcbiAgICAgICAgdmFyIHcgPSBzMS53ICsgczIudztcbiAgICAgICAgdmFyIGggPSBzMS5oO1xuICAgICAgICBuZXdBdGxhcy5kcmF3KGtleSwge1xuICAgICAgICAgIHc6IHcsXG4gICAgICAgICAgaDogaFxuICAgICAgICB9LCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHNjcmF0Y2gsIDAsIDAsIHcsIGgsIDAsIDAsIHcsIGggLy8gdGhlIGRlc3RpbmF0aW9uIGNvbnRleHQgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2xhdGVkIHRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvdW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3VudHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXlDb3VudDogdGhpcy5zdHlsZUtleVRvQXRsYXMuc2l6ZSxcbiAgICAgICAgYXRsYXNDb3VudDogbmV3IFNldCh0aGlzLnN0eWxlS2V5VG9BdGxhcy52YWx1ZXMoKSkuc2l6ZVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbmZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXQxLCBzZXQyKSB7XG4gIC8vIFRPRE8gd2h5IG5vIFNldC5pbnRlcnNlY3Rpb24gaW4gbm9kZSAxNj8/P1xuICBpZiAoc2V0MS5pbnRlcnNlY3Rpb24pIHJldHVybiBzZXQxLmludGVyc2VjdGlvbihzZXQyKTtlbHNlIHJldHVybiBuZXcgU2V0KF90b0NvbnN1bWFibGVBcnJheShzZXQxKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gc2V0Mi5oYXMoeCk7XG4gIH0pKTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIG1hbmFnZSBiYXRjaGVzIG9mIEF0bGFzZXMgZm9yIGRyYXdpbmcgbm9kZXMgYW5kIGxhYmVscy5cbiAqIFN1cHBvcnRzIGRpZmZlcmVudCB0eXBlcyBvZiBBdGxhc0NvbGxlY3Rpb25zIGZvciBkaWZmZXJlbnQgcmVuZGVyIHR5cGVzLFxuICogZm9yIGV4YW1wbGUgJ25vZGUtYm9keScgYW5kICdub2RlLWxhYmVsJyB3b3VsZCBiZSBkaWZmZXJlbnQgcmVuZGVyIHR5cGVzLlxuICogUmVuZGVyIHR5cGVzIGFyZSBrZXB0IHNlcGFyYXRlIGJlY2F1c2UgdGhleSB3aWxsIGxpa2VseSBuZWVkIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gKiBzZXBhcmF0ZWx5IGFuZCBpdHMgbm90IGVudGllcmx5IGd1YXJhbnRlZWQgdGhhdCB0aGVpciBzdHlsZSBrZXlzIHdvbid0IGNvbGxpZGUuXG4gKi9cbnZhciBBdGxhc01hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdGxhc01hbmFnZXIociwgZ2xvYmFsT3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdGxhc01hbmFnZXIpO1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmF0bGFzU2l6ZSA9IGdsb2JhbE9wdGlvbnMud2ViZ2xUZXhTaXplO1xuICAgIHRoaXMubWF4QXRsYXNlc1BlckJhdGNoID0gZ2xvYmFsT3B0aW9ucy53ZWJnbFRleFBlckJhdGNoO1xuICAgIHRoaXMucmVuZGVyVHlwZXMgPSBuZXcgTWFwKCk7IC8vIHJlbmRlclR5cGU6c3RyaW5nIC0+IHJlbmRlclR5cGVPcHRpb25zXG4gICAgdGhpcy5jb2xsZWN0aW9ucyA9IG5ldyBNYXAoKTsgLy8gY29sbGVjdGlvbk5hbWU6c3RyaW5nIC0+IEF0bGFzQ29sbGVjdGlvblxuXG4gICAgdGhpcy50eXBlQW5kSWRUb0tleSA9IG5ldyBNYXAoKTsgLy8gW3JlbmRlclR5cGUsaWRdID0+IEFycmF5PHN0eWxlIGtleT5cbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF0bGFzTWFuYWdlciwgW3tcbiAgICBrZXk6IFwiZ2V0QXRsYXNTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0bGFzU2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQXRsYXNDb2xsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEF0bGFzQ29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSwgYXRsYXNDb2xsZWN0aW9uT3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzJGdsb2JhbE9wdGlvbnMgPSB0aGlzLmdsb2JhbE9wdGlvbnMsXG4gICAgICAgIHdlYmdsVGV4U2l6ZSA9IF90aGlzJGdsb2JhbE9wdGlvbnMud2ViZ2xUZXhTaXplLFxuICAgICAgICBjcmVhdGVUZXh0dXJlQ2FudmFzID0gX3RoaXMkZ2xvYmFsT3B0aW9ucy5jcmVhdGVUZXh0dXJlQ2FudmFzO1xuICAgICAgdmFyIHRleFJvd3MgPSBhdGxhc0NvbGxlY3Rpb25PcHRpb25zLnRleFJvd3M7XG4gICAgICB2YXIgY2FjaGVkQ3JlYXRlVGV4dHVyZUNhbnZhcyA9IHRoaXMuX2NhY2hlU2NyYXRjaENhbnZhcyhjcmVhdGVUZXh0dXJlQ2FudmFzKTtcbiAgICAgIHZhciBhdGxhc0NvbGxlY3Rpb24gPSBuZXcgQXRsYXNDb2xsZWN0aW9uKHRoaXMuciwgd2ViZ2xUZXhTaXplLCB0ZXhSb3dzLCBjYWNoZWRDcmVhdGVUZXh0dXJlQ2FudmFzKTtcbiAgICAgIHRoaXMuY29sbGVjdGlvbnMuc2V0KGNvbGxlY3Rpb25OYW1lLCBhdGxhc0NvbGxlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRSZW5kZXJUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJlbmRlclR5cGUodHlwZSwgcmVuZGVyVHlwZU9wdGlvbnMpIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gcmVuZGVyVHlwZU9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICAgIGlmICghdGhpcy5jb2xsZWN0aW9ucy5oYXMoY29sbGVjdGlvbikpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXRsYXMgY29sbGVjdGlvbiBuYW1lICdcIi5jb25jYXQoY29sbGVjdGlvbiwgXCInXCIpKTtcbiAgICAgIHZhciBhdGxhc0NvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb25zLmdldChjb2xsZWN0aW9uKTtcbiAgICAgIHZhciBvcHRzID0gZXh0ZW5kKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgYXRsYXNDb2xsZWN0aW9uOiBhdGxhc0NvbGxlY3Rpb25cbiAgICAgIH0sIHJlbmRlclR5cGVPcHRpb25zKTtcbiAgICAgIHRoaXMucmVuZGVyVHlwZXMuc2V0KHR5cGUsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZW5kZXJUeXBlT3B0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW5kZXJUeXBlT3B0cyh0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUeXBlcy5nZXQodHlwZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0bGFzQ29sbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhc0NvbGxlY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnMuZ2V0KG5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FjaGVTY3JhdGNoQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWNoZVNjcmF0Y2hDYW52YXMoY3JlYXRlVGV4dHVyZUNhbnZhcykge1xuICAgICAgLy8gYWxsIHNjcmF0Y2ggY2FudmFzZXMgZm9yIHRoZSBzYW1lIHJlbmRlciB0eXBlIHdpbGwgaGF2ZSB0aGUgc2FtZSB3aWR0aCBhbmQgaGVpZ2h0IChpZSB3ZWJnbFRleFJvd3Mgb3B0aW9uKVxuICAgICAgLy8gYnV0IHdlJ2xsIGtlZXAgdHJhY2sgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQganVzdCB0byBiZSBzYWZlXG4gICAgICB2YXIgcHJldlcgPSAtMTtcbiAgICAgIHZhciBwcmV2SCA9IC0xO1xuICAgICAgdmFyIHNjcmF0Y2hDYW52YXMgPSBudWxsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyLCB3LCBoLCBzY3JhdGNoKSB7XG4gICAgICAgIGlmIChzY3JhdGNoKSB7XG4gICAgICAgICAgaWYgKCFzY3JhdGNoQ2FudmFzIHx8IHcgIT0gcHJldlcgfHwgaCAhPSBwcmV2SCkge1xuICAgICAgICAgICAgcHJldlcgPSB3O1xuICAgICAgICAgICAgcHJldkggPSBoO1xuICAgICAgICAgICAgc2NyYXRjaENhbnZhcyA9IGNyZWF0ZVRleHR1cmVDYW52YXMociwgdywgaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY3JhdGNoQ2FudmFzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlQ2FudmFzKHIsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfa2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9rZXkocmVuZGVyVHlwZSwgaWQpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZW5kZXJUeXBlLCBcIi1cIikuY29uY2F0KGlkKTsgLy8gVE9ETyBub3QgdmVyeSBlZmZpY2llbnRcbiAgICB9XG5cbiAgICAvKiogTWFya3MgdGV4dHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi4gKi9cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBfcmVmMiRmb3JjZVJlZHJhdyA9IF9yZWYyLmZvcmNlUmVkcmF3LFxuICAgICAgICBmb3JjZVJlZHJhdyA9IF9yZWYyJGZvcmNlUmVkcmF3ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYyJGZvcmNlUmVkcmF3LFxuICAgICAgICBfcmVmMiRmaWx0ZXJFbGUgPSBfcmVmMi5maWx0ZXJFbGUsXG4gICAgICAgIGZpbHRlckVsZSA9IF9yZWYyJGZpbHRlckVsZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IDogX3JlZjIkZmlsdGVyRWxlLFxuICAgICAgICBfcmVmMiRmaWx0ZXJUeXBlID0gX3JlZjIuZmlsdGVyVHlwZSxcbiAgICAgICAgZmlsdGVyVHlwZSA9IF9yZWYyJGZpbHRlclR5cGUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSA6IF9yZWYyJGZpbHRlclR5cGU7XG4gICAgICB2YXIgbmVlZEdDID0gZmFsc2U7XG4gICAgICB2YXIgcnVuR0NOb3cgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZWxlcyksXG4gICAgICAgIF9zdGVwMztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGVsZSA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICBpZiAoZmlsdGVyRWxlKGVsZSkpIHtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5yZW5kZXJUeXBlcy52YWx1ZXMoKSksXG4gICAgICAgICAgICAgIF9zdGVwNDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclR5cGUgPSBvcHRzLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlclR5cGUocmVuZGVyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdGxhc0NvbGxlY3Rpb24gPSBfdGhpczMuY29sbGVjdGlvbnMuZ2V0KG9wdHMuY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5ID0gb3B0cy5nZXRLZXkoZWxlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXlBcnJheSA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IFtrZXldO1xuXG4gICAgICAgICAgICAgICAgICAvLyB3aGVuIGEgbm9kZSdzIGJhY2tncm91bmQgaW1hZ2UgZmluaXNoZXMgbG9hZGluZywgdGhlIHN0eWxlIGtleSBkb2Vzbid0IGNoYW5nZSBidXQgc3RpbGwgbmVlZHMgdG8gYmUgcmVkcmF3blxuICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlUmVkcmF3KSB7XG4gICAgICAgICAgICAgICAgICAgIGtleUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdGxhc0NvbGxlY3Rpb24ubWFya0tleUZvckdDKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBydW5HQ05vdyA9IHRydWU7IC8vIHJ1biBHQyB0byByZW1vdmUgdGhlIG9sZCB0ZXh0dXJlIHJpZ2h0IG5vdywgdGhhdCB3YXkgd2UgZG9uJ3QgbmVlZCB0byByZW1lbWJlciBmb3IgdGhlIG5leHQgZ2MgXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBvcHRzLmdldElEID8gb3B0cy5nZXRJRChlbGUpIDogZWxlLmlkKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXBLZXkgPSBfdGhpczMuX2tleShyZW5kZXJUeXBlLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRLZXlBcnJheSA9IF90aGlzMy50eXBlQW5kSWRUb0tleS5nZXQobWFwS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEtleUFycmF5ICE9PSB1bmRlZmluZWQgJiYgIWFycmF5RXF1YWwoa2V5QXJyYXksIG9sZEtleUFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNlcnZhdGl2ZSBhcHByb2FjaCwgaWYgYW55IG9mIHRoZSBrZXlzIGRvbid0IG1hdGNoIHRoZW4gdGhyb3cgdGhlbSBhbGwgYXdheVxuICAgICAgICAgICAgICAgICAgICAgIG5lZWRHQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLnR5cGVBbmRJZFRvS2V5W1wiZGVsZXRlXCJdKG1hcEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgb2xkS2V5QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAob2xkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXRsYXNDb2xsZWN0aW9uLm1hcmtLZXlGb3JHQyhvbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgIF9sb29wMigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgICAgaWYgKHJ1bkdDTm93KSB7XG4gICAgICAgIHRoaXMuZ2MoKTtcbiAgICAgICAgbmVlZEdDID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmVlZEdDO1xuICAgIH1cblxuICAgIC8qKiBHYXJiYWdlIGNvbGxlY3QgKi9cbiAgfSwge1xuICAgIGtleTogXCJnY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnYygpIHtcbiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb2xsZWN0aW9ucy52YWx1ZXMoKSksXG4gICAgICAgIF9zdGVwNTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBfc3RlcDUudmFsdWU7XG4gICAgICAgICAgY29sbGVjdGlvbi5nYygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3JDcmVhdGVBdGxhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPckNyZWF0ZUF0bGFzKGVsZSwgdHlwZSwgYmIsIHN0eWxlS2V5KSB7XG4gICAgICAvLyBzdHlsZUtleSBpcyBub3QgYW4gYXJyYXkgaGVyZVxuICAgICAgdmFyIG9wdHMgPSB0aGlzLnJlbmRlclR5cGVzLmdldCh0eXBlKTtcbiAgICAgIHZhciBhdGxhc0NvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb25zLmdldChvcHRzLmNvbGxlY3Rpb24pO1xuXG4gICAgICAvLyBkcmF3cyB0aGUgdGV4dHVyZSBvbmx5IGlmIG5lZWRlZFxuICAgICAgdmFyIGRyYXduID0gZmFsc2U7XG4gICAgICB2YXIgYXRsYXMgPSBhdGxhc0NvbGxlY3Rpb24uZHJhdyhzdHlsZUtleSwgYmIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChvcHRzLmRyYXdDbGlwcGVkKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgYmIudywgYmIuaCk7XG4gICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgICAgb3B0cy5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRzLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXduID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGRyYXduKSB7XG4gICAgICAgIHZhciBpZCA9IG9wdHMuZ2V0SUQgPyBvcHRzLmdldElEKGVsZSkgOiBlbGUuaWQoKTsgLy8gZm9yIHRlc3RpbmdcbiAgICAgICAgdmFyIG1hcEtleSA9IHRoaXMuX2tleSh0eXBlLCBpZCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGVBbmRJZFRvS2V5LmhhcyhtYXBLZXkpKSB7XG4gICAgICAgICAgdGhpcy50eXBlQW5kSWRUb0tleS5nZXQobWFwS2V5KS5wdXNoKHN0eWxlS2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnR5cGVBbmRJZFRvS2V5LnNldChtYXBLZXksIFtzdHlsZUtleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXRsYXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0bGFzSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhc0luZm8oZWxlLCB0eXBlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBvcHRzID0gdGhpcy5yZW5kZXJUeXBlcy5nZXQodHlwZSk7XG4gICAgICB2YXIga2V5ID0gb3B0cy5nZXRLZXkoZWxlKTtcbiAgICAgIHZhciBrZXlBcnJheSA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IFtrZXldO1xuICAgICAgcmV0dXJuIGtleUFycmF5Lm1hcChmdW5jdGlvbiAoc3R5bGVLZXkpIHtcbiAgICAgICAgdmFyIGJiID0gb3B0cy5nZXRCb3VuZGluZ0JveChlbGUsIHN0eWxlS2V5KTsgLy8gcGFzcyB0aGUga2V5IGJhY2sgdG8gdGhlIGdldEJvdW5kaW5nQm94IG1ldGhvZFxuICAgICAgICB2YXIgYXRsYXMgPSBfdGhpczQuZ2V0T3JDcmVhdGVBdGxhcyhlbGUsIHR5cGUsIGJiLCBzdHlsZUtleSk7XG4gICAgICAgIHZhciBfYXRsYXMkZ2V0T2Zmc2V0czMgPSBhdGxhcy5nZXRPZmZzZXRzKHN0eWxlS2V5KSxcbiAgICAgICAgICBfYXRsYXMkZ2V0T2Zmc2V0czQgPSBfc2xpY2VkVG9BcnJheShfYXRsYXMkZ2V0T2Zmc2V0czMsIDIpLFxuICAgICAgICAgIHRleDEgPSBfYXRsYXMkZ2V0T2Zmc2V0czRbMF0sXG4gICAgICAgICAgdGV4MiA9IF9hdGxhcyRnZXRPZmZzZXRzNFsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhdGxhczogYXRsYXMsXG4gICAgICAgICAgdGV4OiB0ZXgxLFxuICAgICAgICAgIHRleDE6IHRleDEsXG4gICAgICAgICAgdGV4MjogdGV4MixcbiAgICAgICAgICBiYjogYmJcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZWJ1Z0luZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVidWdJbmZvKCkge1xuICAgICAgdmFyIGRlYnVnSW5mbyA9IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbGxlY3Rpb25zKSxcbiAgICAgICAgX3N0ZXA2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA2JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA2LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5hbWUgPSBfc3RlcDYkdmFsdWVbMF0sXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gX3N0ZXA2JHZhbHVlWzFdO1xuICAgICAgICAgIHZhciBfY29sbGVjdGlvbiRnZXRDb3VudHMgPSBjb2xsZWN0aW9uLmdldENvdW50cygpLFxuICAgICAgICAgICAga2V5Q291bnQgPSBfY29sbGVjdGlvbiRnZXRDb3VudHMua2V5Q291bnQsXG4gICAgICAgICAgICBhdGxhc0NvdW50ID0gX2NvbGxlY3Rpb24kZ2V0Q291bnRzLmF0bGFzQ291bnQ7XG4gICAgICAgICAgZGVidWdJbmZvLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgICAgIGtleUNvdW50OiBrZXlDb3VudCxcbiAgICAgICAgICAgIGF0bGFzQ291bnQ6IGF0bGFzQ291bnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVidWdJbmZvO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIEF0bGFzQmF0Y2hNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXRsYXNCYXRjaE1hbmFnZXIoZ2xvYmFsT3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdGxhc0JhdGNoTWFuYWdlcik7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmF0bGFzU2l6ZSA9IGdsb2JhbE9wdGlvbnMud2ViZ2xUZXhTaXplO1xuICAgIHRoaXMubWF4QXRsYXNlc1BlckJhdGNoID0gZ2xvYmFsT3B0aW9ucy53ZWJnbFRleFBlckJhdGNoO1xuICAgIHRoaXMuYmF0Y2hBdGxhc2VzID0gW107XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdGxhc0JhdGNoTWFuYWdlciwgW3tcbiAgICBrZXk6IFwiZ2V0TWF4QXRsYXNlc1BlckJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heEF0bGFzZXNQZXJCYXRjaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1heEF0bGFzZXNQZXJCYXRjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0bGFzU2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5kZXhBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmRleEFycmF5KCkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IHRoaXMubWF4QXRsYXNlc1BlckJhdGNoXG4gICAgICB9LCBmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gICAgICB0aGlzLmJhdGNoQXRsYXNlcyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdGxhc0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYXRjaEF0bGFzZXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdGxhc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYXRjaEF0bGFzZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbkFkZFRvQ3VycmVudEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkFkZFRvQ3VycmVudEJhdGNoKGF0bGFzKSB7XG4gICAgICBpZiAodGhpcy5iYXRjaEF0bGFzZXMubGVuZ3RoID09PSB0aGlzLm1heEF0bGFzZXNQZXJCYXRjaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaEF0bGFzZXMuaW5jbHVkZXMoYXRsYXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7IC8vIG5vdCBmdWxsXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0bGFzSW5kZXhGb3JCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhc0luZGV4Rm9yQmF0Y2goYXRsYXMpIHtcbiAgICAgIHZhciBhdGxhc0lEID0gdGhpcy5iYXRjaEF0bGFzZXMuaW5kZXhPZihhdGxhcyk7XG4gICAgICBpZiAoYXRsYXNJRCA8IDApIHtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hBdGxhc2VzLmxlbmd0aCA9PT0gdGhpcy5tYXhBdGxhc2VzUGVyQmF0Y2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBhZGQgbW9yZSBhdGxhc2VzIHRvIGJhdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXRjaEF0bGFzZXMucHVzaChhdGxhcyk7XG4gICAgICAgIGF0bGFzSUQgPSB0aGlzLmJhdGNoQXRsYXNlcy5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0bGFzSUQ7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8vIEZyYWdtZW50IHNoYWRlciBmdW5jdGlvbnMgdG8gY2FsY3VsYXRlIHNpZ25lZCBkaXN0YW5jZVxuLy8gaHR0cHM6Ly9pcXVpbGV6bGVzLm9yZy9hcnRpY2xlcy9kaXN0ZnVuY3Rpb25zMmQvXG4vLyBlbGxpcHNlOiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNGxzWEROIFxuXG4vKipcbiAqIHBhcmFtIHAgLSBwb2ludFxuICogZmxvYXQgciAtIGNpcmNsZSByYWRpdXMsIGVnIDAuNSBmb3IgdW5pdCBjaXJjbGVcbiAqL1xudmFyIGNpcmNsZVNEID0gXCJcXG4gIGZsb2F0IGNpcmNsZVNEKHZlYzIgcCwgZmxvYXQgcikge1xcbiAgICByZXR1cm4gZGlzdGFuY2UodmVjMigwKSwgcCkgLSByOyAvLyBzaWduZWQgZGlzdGFuY2VcXG4gIH1cXG5cIjtcblxuLyoqXG4gKiBwYXJhbSBwIC0gcG9pbnRcbiAqIHBhcmFtIGIgLSBiLnggPSBoYWxmIHdpZHRoLCBiLnkgPSBoYWxmIGhlaWdodFxuICovXG52YXIgcmVjdGFuZ2xlU0QgPSBcIlxcbiAgZmxvYXQgcmVjdGFuZ2xlU0QodmVjMiBwLCB2ZWMyIGIpIHtcXG4gICAgdmVjMiBkID0gYWJzKHApLWI7XFxuICAgIHJldHVybiBkaXN0YW5jZSh2ZWMyKDApLG1heChkLDAuMCkpICsgbWluKG1heChkLngsZC55KSwwLjApO1xcbiAgfVxcblwiO1xuXG4vKipcbiAqIHBhcmFtIHAgLSBwb2ludFxuICogcGFyYW0gYiAtIGIueCA9IGhhbGYgd2lkdGgsIGIueSA9IGhhbGYgaGVpZ2h0XG4gKiBwYXJhbSBjciAtIHZlY3RvciBvZiBjb3JuZXIgcmFkaXVzZXNcbiAqL1xudmFyIHJvdW5kUmVjdGFuZ2xlU0QgPSBcIlxcbiAgZmxvYXQgcm91bmRSZWN0YW5nbGVTRCh2ZWMyIHAsIHZlYzIgYiwgdmVjNCBjcikge1xcbiAgICBjci54eSA9IChwLnggPiAwLjApID8gY3IueHkgOiBjci56dztcXG4gICAgY3IueCAgPSAocC55ID4gMC4wKSA/IGNyLnggIDogY3IueTtcXG4gICAgdmVjMiBxID0gYWJzKHApIC0gYiArIGNyLng7XFxuICAgIHJldHVybiBtaW4obWF4KHEueCwgcS55KSwgMC4wKSArIGRpc3RhbmNlKHZlYzIoMCksIG1heChxLCAwLjApKSAtIGNyLng7XFxuICB9XFxuXCI7XG5cbi8qKlxuICogcGFyYW0gcCAtIHBvaW50XG4gKiBwYXJhbSBhYiAtIGEueCA9IGhvcml6b250YWwgcmFkaXVzLCBhLnkgPSB2ZXJ0aWNhbCByYWRpdXNcbiAqL1xudmFyIGVsbGlwc2VTRCA9IFwiXFxuICBmbG9hdCBlbGxpcHNlU0QodmVjMiBwLCB2ZWMyIGFiKSB7XFxuICAgIHAgPSBhYnMoIHAgKTsgLy8gc3ltbWV0cnlcXG5cXG4gICAgLy8gZmluZCByb290IHdpdGggTmV3dG9uIHNvbHZlclxcbiAgICB2ZWMyIHEgPSBhYioocC1hYik7XFxuICAgIGZsb2F0IHcgPSAocS54PHEueSk/IDEuNTcwNzk2MzI3IDogMC4wO1xcbiAgICBmb3IoIGludCBpPTA7IGk8NTsgaSsrICkge1xcbiAgICAgIHZlYzIgY3MgPSB2ZWMyKGNvcyh3KSxzaW4odykpO1xcbiAgICAgIHZlYzIgdSA9IGFiKnZlYzIoIGNzLngsY3MueSk7XFxuICAgICAgdmVjMiB2ID0gYWIqdmVjMigtY3MueSxjcy54KTtcXG4gICAgICB3ID0gdyArIGRvdChwLXUsdikvKGRvdChwLXUsdSkrZG90KHYsdikpO1xcbiAgICB9XFxuICAgIFxcbiAgICAvLyBjb21wdXRlIGZpbmFsIHBvaW50IGFuZCBkaXN0YW5jZVxcbiAgICBmbG9hdCBkID0gbGVuZ3RoKHAtYWIqdmVjMihjb3Modyksc2luKHcpKSk7XFxuICAgIFxcbiAgICAvLyByZXR1cm4gc2lnbmVkIGRpc3RhbmNlXFxuICAgIHJldHVybiAoZG90KHAvYWIscC9hYik+MS4wKSA/IGQgOiAtZDtcXG4gIH1cXG5cIjtcblxuLyoqXG4gKiBUd28gcmVuZGVyIG1vZGVzLiBFYWNoIG1vZGUgaGFzIGl0cyBvd24gc2hhZGVyIHByb2dyYW0uIFRoZXkgYXJlIGFsbW9zdCBpZGVudGljYWwsIHRoZSBtYWluIGRpZmZlcmVuY2UgaXMgdGhlIG91dHB1dC5cbiAqIFNDUkVFTjogIG91dHB1dCBwaXhlbCBjb2xvcnMgdG8gdGhlIHNjcmVlblxuICogUElDS0lORzogb3V0cHV0IHotb3JkZXIgaW5kZXggdG8gYW4gb2Zmc2NyZWVuIGZyYW1lYnVmZmVyLCB1c2VkIHRvIGRldGVjdCB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIGN1cnNvclxuICovXG52YXIgUkVOREVSX1RBUkdFVCA9IHtcbiAgU0NSRUVOOiB7XG4gICAgbmFtZTogJ3NjcmVlbicsXG4gICAgc2NyZWVuOiB0cnVlXG4gIH0sXG4gIFBJQ0tJTkc6IHtcbiAgICBuYW1lOiAncGlja2luZycsXG4gICAgcGlja2luZzogdHJ1ZVxuICB9XG59O1xuXG4vKipcbiAqIFNwZWNpYWwgaGFuZGluZyBmb3IgbGFiZWwgdGV4dHVyZXMgaW4gUElDS0lORyBtb2RlLiBTZWUgaXNzdWUgIzMzMzcuXG4gKi9cbnZhciBURVhfUElDS0lOR19NT0RFID0ge1xuICAvLyByZW5kZXIgdGhlIHRleHR1cmUganVzdCBsaWtlIGluIFJFTkRFUl9UQVJHRVQuU0NSRUVOIG1vZGVcbiAgSUdOT1JFOiAxLFxuICAvLyBkb24ndCByZW5kZXIgdGhlIHRleHR1cmUgYXQgYWxsXG4gIFVTRV9CQjogMiAvLyByZW5kZXIgdGhlIGJvdW5kaW5nIGJveCBhcyBhbiBvcGFxdWUgcmVjdGFuZ2xlXG59O1xuXG4vLyBWZXJ0ZXggdHlwZXMuXG4vLyBVc2VkIGRpcmVjdGx5IGluIHRoZSBzaGFkZXJzIHNvIG11c3QgYmUgbnVtZXJpYy5cbi8vIFRoZXJlIGlzIG9ubHkgb25lIHNoYWRlciBwcm9ncmFtIHVzZWQgZm9yIGFuIGVudGlyZSBmcmFtZSB0aGF0IHJlbmRlcnMgYWxsIHR5cGVzIG9mIGVsZW1lbnRzLlxuLy8gVGhlcmUgYXJlIGlmLWVsc2UgYmxvY2tzIGluIHRoZSBzaGFkZXJzIHRoYXQgZG8gZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIHZlcnRleCB0eXBlLlxuLy8gVGhpcyBhbGxvd3MgYWxsIGVsZW1lbnRzIHRvIGJlIHJlbmRlcmVyZCBpbiBsYXJnZSBiYXRjaGVzIHdpdGhvdXQgc3dpdGNoaW5nIHNoYWRlciBwcm9ncmFtcy5cbnZhciBURVhUVVJFID0gMDtcbnZhciBFREdFX1NUUkFJR0hUID0gMTtcbnZhciBFREdFX0NVUlZFX1NFR01FTlQgPSAyO1xudmFyIEVER0VfQVJST1cgPSAzO1xudmFyIFJFQ1RBTkdMRSA9IDQ7XG52YXIgUk9VTkRfUkVDVEFOR0xFID0gNTtcbnZhciBCT1RUT01fUk9VTkRfUkVDVEFOR0xFID0gNjtcbnZhciBFTExJUFNFID0gNztcbnZhciBFbGVtZW50RHJhd2luZ1dlYkdMID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKi9cbiAgZnVuY3Rpb24gRWxlbWVudERyYXdpbmdXZWJHTChyLCBnbCwgb3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50RHJhd2luZ1dlYkdMKTtcbiAgICB0aGlzLnIgPSByOyAvLyByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyByZW5kZXJlclxuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLm1heEluc3RhbmNlcyA9IG9wdHMud2ViZ2xCYXRjaFNpemU7XG4gICAgdGhpcy5hdGxhc1NpemUgPSBvcHRzLndlYmdsVGV4U2l6ZTtcbiAgICB0aGlzLmJnQ29sb3IgPSBvcHRzLmJnQ29sb3I7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdHMud2ViZ2xEZWJ1ZztcbiAgICB0aGlzLmJhdGNoRGVidWdJbmZvID0gW107XG4gICAgb3B0cy5lbmFibGVXcmFwcGluZyA9IHRydWU7XG4gICAgb3B0cy5jcmVhdGVUZXh0dXJlQ2FudmFzID0gY3JlYXRlVGV4dHVyZUNhbnZhczsgLy8gVW5pdCB0ZXN0cyBtb2NrIHRoaXNcblxuICAgIHRoaXMuYXRsYXNNYW5hZ2VyID0gbmV3IEF0bGFzTWFuYWdlcihyLCBvcHRzKTtcbiAgICB0aGlzLmJhdGNoTWFuYWdlciA9IG5ldyBBdGxhc0JhdGNoTWFuYWdlcihvcHRzKTtcbiAgICB0aGlzLnNpbXBsZVNoYXBlT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnByb2dyYW0gPSB0aGlzLl9jcmVhdGVTaGFkZXJQcm9ncmFtKFJFTkRFUl9UQVJHRVQuU0NSRUVOKTtcbiAgICB0aGlzLnBpY2tpbmdQcm9ncmFtID0gdGhpcy5fY3JlYXRlU2hhZGVyUHJvZ3JhbShSRU5ERVJfVEFSR0VULlBJQ0tJTkcpO1xuICAgIHRoaXMudmFvID0gdGhpcy5fY3JlYXRlVkFPKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gY29sbGVjdGlvbk5hbWVcbiAgICogQHBhcmFtIHt7IHRleFJvd3M6IG51bWJlciB9fSBvcHRzXG4gICAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVsZW1lbnREcmF3aW5nV2ViR0wsIFt7XG4gICAga2V5OiBcImFkZEF0bGFzQ29sbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBdGxhc0NvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUsIG9wdHMpIHtcbiAgICAgIHRoaXMuYXRsYXNNYW5hZ2VyLmFkZEF0bGFzQ29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSwgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgeyBPYmplY3QgfSBUZXh0dXJlUmVuZGVyVHlwZU9wdHNcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBjb2xsZWN0aW9uIC0gbmFtZSBvZiBhdGxhcyBjb2xsZWN0aW9uIHRvIHJlbmRlciB0ZXh0dXJlcyB0b1xuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZ2V0S2V5IC0gcmV0dXJucyB0aGUgXCJzdHlsZSBrZXlcIiBmb3IgYW4gZWxlbWVudCwgbWF5IGJlIGEgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IGZvciBtdWx0aS1saW5lIGxhYmxlc1xuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZHJhd0VsZW1lbnQgLSB1c2VzIGEgY2FudmFzIHJlbmRlcmVyIHRvIGRyYXcgdGhlIGVsZW1lbnQgdG8gdGhlIHRleHR1cmUgYXRsYXNcbiAgICAgKiBAcHJvcGVydHkgeyBib29sZWFuICB9IGRyYXdDbGlwcGVkIC0gaWYgdHJ1ZSB0aGUgY29udGV4dCB3aWxsIGJlIGNsaXBwZWQgdG8gdGhlIGJvdW5kaW5nIGJveCBiZWZvcmUgZHJhd0VsZW1lbnQoKSBpcyBjYWxsZWQsIG1heSBhZmZlY3QgcGVyZm9ybWFuY2VcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGdldEJvdW5kaW5nQm94IC0gcmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciBhbiBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBnZXRSb3RhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZ2V0Um90YXRpb25Qb2ludFxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZ2V0Um90YXRpb25PZmZzZXRcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGlzVmlzaWJsZSAtIGFuIGV4dHJhIGNoZWNrIGZvciB2aXNpYmlsaXR5IGluIGFkZGl0aW9uIHRvIGVsZS52aXNpYmxlKClcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGdldFRleFBpY2tpbmdNb2RlIC0gcmV0dXJucyBhIHZhbHVlIGZyb20gdGhlIFRFWF9QSUNLSU5HX01PREUgZW51bVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHR5cGVOYW1lXG4gICAgICogQHBhcmFtIHsgVGV4dHVyZVJlbmRlclR5cGVPcHRzIH0gb3B0c1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFRleHR1cmVBdGxhc1JlbmRlclR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGV4dHVyZUF0bGFzUmVuZGVyVHlwZSh0eXBlTmFtZSwgb3B0cykge1xuICAgICAgdGhpcy5hdGxhc01hbmFnZXIuYWRkUmVuZGVyVHlwZSh0eXBlTmFtZSwgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgeyBPYmplY3QgfSBTaW1wbGVTaGFwZVJlbmRlclR5cGVPcHRzXG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBnZXRCb3VuZGluZ0JveCAtIHJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgYW4gZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gaXNWaXNpYmxlIC0gdGhpcyBpcyBhbiBleHRyYSBjaGVjayBmb3IgdmlzaWJpbGl0eSBpbiBhZGRpdGlvbiB0byBlbGUudmlzaWJsZSgpXG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBpc1NpbXBsZSAtIGNoZWNrIGlmIGVsZW1lbnQgaXMgYSBzaW1wbGUgc2hhcGUsIG9yIGlmIGl0IG5lZWRzIHRvIGZhbGwgYmFjayB0byB0ZXh0dXJlIHJlbmRlcmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7IFNoYXBlVmlzdWFsUHJvcGVydGllcyB9IHNoYXBlUHJvcHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7IE9iamVjdCB9IFNoYXBlVmlzdWFsUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHNoYXBlXG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gY29sb3JcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBvcGFjaXR5XG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gcGFkZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHJhZGl1c1xuICAgICAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBib3JkZXJcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHR5cGVOYW1lXG4gICAgICogQHBhcmFtIHsgU2ltcGxlU2hhcGVSZW5kZXJUeXBlT3B0cyB9IG9wdHNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRTaW1wbGVTaGFwZVJlbmRlclR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2ltcGxlU2hhcGVSZW5kZXJUeXBlKHR5cGVOYW1lLCBvcHRzKSB7XG4gICAgICB0aGlzLnNpbXBsZVNoYXBlT3B0aW9ucy5zZXQodHlwZU5hbWUsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZm9ybSB0aGUgYXRsYXNNYW5hZ2VyIHdoZW4gZWxlbWVudCBzdHlsZSBrZXlzIG1heSBoYXZlIGNoYW5nZWQuXG4gICAgICogVGhlIGF0bGFzTWFuYWdlciBjYW4gdGhlbiBtYXJrIHVudXNlZCB0ZXh0dXJlcyBmb3IgXCJnYXJiYWdlIGNvbGxlY3Rpb25cIi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlcykge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuICAgICAgdmFyIGF0bGFzTWFuYWdlciA9IHRoaXMuYXRsYXNNYW5hZ2VyO1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGF0bGFzTWFuYWdlci5pbnZhbGlkYXRlKGVsZXMsIHtcbiAgICAgICAgICBmaWx0ZXJUeXBlOiBmdW5jdGlvbiBmaWx0ZXJUeXBlKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ID09PSB0eXBlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9yY2VSZWRyYXc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXRsYXNNYW5hZ2VyLmludmFsaWRhdGUoZWxlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVuIHRleHR1cmUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdjKCkge1xuICAgICAgdGhpcy5hdGxhc01hbmFnZXIuZ2MoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVNoYWRlclByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVNoYWRlclByb2dyYW0ocmVuZGVyVGFyZ2V0KSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgdmFyIHZlcnRleFNoYWRlclNvdXJjZSA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbiAgICAgIHVuaWZvcm0gbWF0MyB1UGFuWm9vbU1hdHJpeDtcXG4gICAgICB1bmlmb3JtIGludCAgdUF0bGFzU2l6ZTtcXG4gICAgICBcXG4gICAgICAvLyBpbnN0YW5jZWRcXG4gICAgICBpbiB2ZWMyIGFQb3NpdGlvbjsgLy8gYSB2ZXJ0ZXggZnJvbSB0aGUgdW5pdCBzcXVhcmVcXG4gICAgICBcXG4gICAgICBpbiBtYXQzIGFUcmFuc2Zvcm07IC8vIHVzZWQgdG8gdHJhbnNmb3JtIHZlcnRpY2llcywgZWcgaW50byBhIGJvdW5kaW5nIGJveFxcbiAgICAgIGluIGludCBhVmVydFR5cGU7IC8vIHRoZSB0eXBlIG9mIHRoaW5nIHdlIGFyZSByZW5kZXJpbmdcXG5cXG4gICAgICAvLyB0aGUgei1pbmRleCB0aGF0IGlzIG91dHB1dCB3aGVuIHVzaW5nIHBpY2tpbmcgbW9kZVxcbiAgICAgIGluIHZlYzQgYUluZGV4O1xcbiAgICAgIFxcbiAgICAgIC8vIEZvciB0ZXh0dXJlc1xcbiAgICAgIGluIGludCBhQXRsYXNJZDsgLy8gd2hpY2ggc2hhZGVyIHVuaXQvYXRsYXMgdG8gdXNlXFxuICAgICAgaW4gdmVjNCBhVGV4OyAvLyB4L3kvdy9oIG9mIHRleHR1cmUgaW4gYXRsYXNcXG5cXG4gICAgICAvLyBmb3IgZWRnZXNcXG4gICAgICBpbiB2ZWM0IGFQb2ludEFQb2ludEI7XFxuICAgICAgaW4gdmVjNCBhUG9pbnRDUG9pbnREO1xcbiAgICAgIGluIHZlYzIgYUxpbmVXaWR0aDsgLy8gYWxzbyB1c2VkIGZvciBub2RlIGJvcmRlciB3aWR0aFxcblxcbiAgICAgIC8vIHNpbXBsZSBzaGFwZXNcXG4gICAgICBpbiB2ZWM0IGFDb3JuZXJSYWRpdXM7IC8vIGZvciByb3VuZC1yZWN0YW5nbGUgW3RvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCB0b3AtbGVmdCwgYm90dG9tLWxlZnRdXFxuICAgICAgaW4gdmVjNCBhQ29sb3I7IC8vIGFsc28gdXNlZCBmb3IgZWRnZXNcXG4gICAgICBpbiB2ZWM0IGFCb3JkZXJDb2xvcjsgLy8gYUxpbmVXaWR0aCBpcyB1c2VkIGZvciBib3JkZXIgd2lkdGhcXG5cXG4gICAgICAvLyBvdXRwdXQgdmFsdWVzIHBhc3NlZCB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXFxuICAgICAgb3V0IHZlYzIgdlRleENvb3JkO1xcbiAgICAgIG91dCB2ZWM0IHZDb2xvcjtcXG4gICAgICBvdXQgdmVjMiB2UG9zaXRpb247XFxuICAgICAgLy8gZmxhdCB2YWx1ZXMgYXJlIG5vdCBpbnRlcnBvbGF0ZWRcXG4gICAgICBmbGF0IG91dCBpbnQgdkF0bGFzSWQ7IFxcbiAgICAgIGZsYXQgb3V0IGludCB2VmVydFR5cGU7XFxuICAgICAgZmxhdCBvdXQgdmVjMiB2VG9wUmlnaHQ7XFxuICAgICAgZmxhdCBvdXQgdmVjMiB2Qm90TGVmdDtcXG4gICAgICBmbGF0IG91dCB2ZWM0IHZDb3JuZXJSYWRpdXM7XFxuICAgICAgZmxhdCBvdXQgdmVjNCB2Qm9yZGVyQ29sb3I7XFxuICAgICAgZmxhdCBvdXQgdmVjMiB2Qm9yZGVyV2lkdGg7XFxuICAgICAgZmxhdCBvdXQgdmVjNCB2SW5kZXg7XFxuICAgICAgXFxuICAgICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGludCB2aWQgPSBnbF9WZXJ0ZXhJRDtcXG4gICAgICAgIHZlYzIgcG9zaXRpb24gPSBhUG9zaXRpb247IC8vIFRPRE8gbWFrZSB0aGlzIGEgdmVjMywgc2ltcGxpZmllcyBzb21lIGNvZGUgYmVsb3dcXG5cXG4gICAgICAgIGlmKGFWZXJ0VHlwZSA9PSBcIi5jb25jYXQoVEVYVFVSRSwgXCIpIHtcXG4gICAgICAgICAgZmxvYXQgdGV4WCA9IGFUZXgueDsgLy8gdGV4dHVyZSBjb29yZGluYXRlc1xcbiAgICAgICAgICBmbG9hdCB0ZXhZID0gYVRleC55O1xcbiAgICAgICAgICBmbG9hdCB0ZXhXID0gYVRleC56O1xcbiAgICAgICAgICBmbG9hdCB0ZXhIID0gYVRleC53O1xcblxcbiAgICAgICAgICBpZih2aWQgPT0gMSB8fCB2aWQgPT0gMiB8fCB2aWQgPT0gNCkge1xcbiAgICAgICAgICAgIHRleFggKz0gdGV4VztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZih2aWQgPT0gMiB8fCB2aWQgPT0gNCB8fCB2aWQgPT0gNSkge1xcbiAgICAgICAgICAgIHRleFkgKz0gdGV4SDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCBkID0gZmxvYXQodUF0bGFzU2l6ZSk7XFxuICAgICAgICAgIHZUZXhDb29yZCA9IHZlYzIodGV4WCAvIGQsIHRleFkgLyBkKTsgLy8gdGV4IGNvb3JkcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMVxcblxcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodVBhblpvb21NYXRyaXggKiBhVHJhbnNmb3JtICogdmVjMyhwb3NpdGlvbiwgMS4wKSwgMS4wKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYoYVZlcnRUeXBlID09IFwiKS5jb25jYXQoUkVDVEFOR0xFLCBcIiB8fCBhVmVydFR5cGUgPT0gXCIpLmNvbmNhdChFTExJUFNFLCBcIiBcXG4gICAgICAgICAgICAgfHwgYVZlcnRUeXBlID09IFwiKS5jb25jYXQoUk9VTkRfUkVDVEFOR0xFLCBcIiB8fCBhVmVydFR5cGUgPT0gXCIpLmNvbmNhdChCT1RUT01fUk9VTkRfUkVDVEFOR0xFLCBcIikgeyAvLyBzaW1wbGUgc2hhcGVzXFxuXFxuICAgICAgICAgIC8vIHRoZSBib3VuZGluZyBib3ggaXMgbmVlZGVkIGJ5IHRoZSBmcmFnbWVudCBzaGFkZXJcXG4gICAgICAgICAgdkJvdExlZnQgID0gKGFUcmFuc2Zvcm0gKiB2ZWMzKDAsIDAsIDEpKS54eTsgLy8gZmxhdFxcbiAgICAgICAgICB2VG9wUmlnaHQgPSAoYVRyYW5zZm9ybSAqIHZlYzMoMSwgMSwgMSkpLnh5OyAvLyBmbGF0XFxuICAgICAgICAgIHZQb3NpdGlvbiA9IChhVHJhbnNmb3JtICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5OyAvLyB3aWxsIGJlIGludGVycG9sYXRlZFxcblxcbiAgICAgICAgICAvLyBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgaW4gdGhlIGZyYWdtZW50IHNoYWRlciwganVzdCBwYXNzIHRoZXNlIGFsb25nXFxuICAgICAgICAgIHZDb2xvciA9IGFDb2xvcjtcXG4gICAgICAgICAgdkNvcm5lclJhZGl1cyA9IGFDb3JuZXJSYWRpdXM7XFxuICAgICAgICAgIHZCb3JkZXJDb2xvciA9IGFCb3JkZXJDb2xvcjtcXG4gICAgICAgICAgdkJvcmRlcldpZHRoID0gYUxpbmVXaWR0aDtcXG5cXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHVQYW5ab29tTWF0cml4ICogYVRyYW5zZm9ybSAqIHZlYzMocG9zaXRpb24sIDEuMCksIDEuMCk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmKGFWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVER0VfU1RSQUlHSFQsIFwiKSB7XFxuICAgICAgICAgIHZlYzIgc291cmNlID0gYVBvaW50QVBvaW50Qi54eTtcXG4gICAgICAgICAgdmVjMiB0YXJnZXQgPSBhUG9pbnRBUG9pbnRCLnp3O1xcblxcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGdlb21ldHJ5IHNvIHRoYXQgdGhlIGxpbmUgaXMgY2VudGVyZWQgb24gdGhlIGVkZ2VcXG4gICAgICAgICAgcG9zaXRpb24ueSA9IHBvc2l0aW9uLnkgLSAwLjU7XFxuXFxuICAgICAgICAgIC8vIHN0cmV0Y2ggdGhlIHVuaXQgc3F1YXJlIGludG8gYSBsb25nIHNraW5ueSByZWN0YW5nbGVcXG4gICAgICAgICAgdmVjMiB4QmFzaXMgPSB0YXJnZXQgLSBzb3VyY2U7XFxuICAgICAgICAgIHZlYzIgeUJhc2lzID0gbm9ybWFsaXplKHZlYzIoLXhCYXNpcy55LCB4QmFzaXMueCkpO1xcbiAgICAgICAgICB2ZWMyIHBvaW50ID0gc291cmNlICsgeEJhc2lzICogcG9zaXRpb24ueCArIHlCYXNpcyAqIGFMaW5lV2lkdGhbMF0gKiBwb3NpdGlvbi55O1xcblxcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodVBhblpvb21NYXRyaXggKiB2ZWMzKHBvaW50LCAxLjApLCAxLjApO1xcbiAgICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XFxuICAgICAgICB9IFxcbiAgICAgICAgZWxzZSBpZihhVmVydFR5cGUgPT0gXCIpLmNvbmNhdChFREdFX0NVUlZFX1NFR01FTlQsIFwiKSB7XFxuICAgICAgICAgIHZlYzIgcG9pbnRBID0gYVBvaW50QVBvaW50Qi54eTtcXG4gICAgICAgICAgdmVjMiBwb2ludEIgPSBhUG9pbnRBUG9pbnRCLnp3O1xcbiAgICAgICAgICB2ZWMyIHBvaW50QyA9IGFQb2ludENQb2ludEQueHk7XFxuICAgICAgICAgIHZlYzIgcG9pbnREID0gYVBvaW50Q1BvaW50RC56dztcXG5cXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBnZW9tZXRyeSBzbyB0aGF0IHRoZSBsaW5lIGlzIGNlbnRlcmVkIG9uIHRoZSBlZGdlXFxuICAgICAgICAgIHBvc2l0aW9uLnkgPSBwb3NpdGlvbi55IC0gMC41O1xcblxcbiAgICAgICAgICB2ZWMyIHAwLCBwMSwgcDIsIHBvcztcXG4gICAgICAgICAgaWYocG9zaXRpb24ueCA9PSAwLjApIHsgLy8gVGhlIGxlZnQgc2lkZSBvZiB0aGUgdW5pdCBzcXVhcmVcXG4gICAgICAgICAgICBwMCA9IHBvaW50QTtcXG4gICAgICAgICAgICBwMSA9IHBvaW50QjtcXG4gICAgICAgICAgICBwMiA9IHBvaW50QztcXG4gICAgICAgICAgICBwb3MgPSBwb3NpdGlvbjtcXG4gICAgICAgICAgfSBlbHNlIHsgLy8gVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHVuaXQgc3F1YXJlLCB1c2Ugc2FtZSBhcHByb2FjaCBidXQgZmxpcCB0aGUgZ2VvbWV0cnkgdXBzaWRlIGRvd25cXG4gICAgICAgICAgICBwMCA9IHBvaW50RDtcXG4gICAgICAgICAgICBwMSA9IHBvaW50QztcXG4gICAgICAgICAgICBwMiA9IHBvaW50QjtcXG4gICAgICAgICAgICBwb3MgPSB2ZWMyKDAuMCwgLXBvc2l0aW9uLnkpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZlYzIgcDAxID0gcDEgLSBwMDtcXG4gICAgICAgICAgdmVjMiBwMTIgPSBwMiAtIHAxO1xcbiAgICAgICAgICB2ZWMyIHAyMSA9IHAxIC0gcDI7XFxuXFxuICAgICAgICAgIC8vIEZpbmQgdGhlIG5vcm1hbCB2ZWN0b3IuXFxuICAgICAgICAgIHZlYzIgdGFuZ2VudCA9IG5vcm1hbGl6ZShub3JtYWxpemUocDEyKSArIG5vcm1hbGl6ZShwMDEpKTtcXG4gICAgICAgICAgdmVjMiBub3JtYWwgPSB2ZWMyKC10YW5nZW50LnksIHRhbmdlbnQueCk7XFxuXFxuICAgICAgICAgIC8vIEZpbmQgdGhlIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHAwIC0+IHAxLlxcbiAgICAgICAgICB2ZWMyIHAwMU5vcm0gPSBub3JtYWxpemUodmVjMigtcDAxLnksIHAwMS54KSk7XFxuXFxuICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYmVuZCBkaXJlY3Rpb24uXFxuICAgICAgICAgIGZsb2F0IHNpZ21hID0gc2lnbihkb3QocDAxICsgcDIxLCBub3JtYWwpKTtcXG4gICAgICAgICAgZmxvYXQgd2lkdGggPSBhTGluZVdpZHRoWzBdO1xcblxcbiAgICAgICAgICBpZihzaWduKHBvcy55KSA9PSAtc2lnbWEpIHtcXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVyc2VjdGluZyB2ZXJ0ZXguIEFkanVzdCB0aGUgcG9zaXRpb24gc28gdGhhdCB0aGVyZSdzIG5vIG92ZXJsYXAuXFxuICAgICAgICAgICAgdmVjMiBwb2ludCA9IDAuNSAqIHdpZHRoICogbm9ybWFsICogLXNpZ21hIC8gZG90KG5vcm1hbCwgcDAxTm9ybSk7XFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHVQYW5ab29tTWF0cml4ICogdmVjMyhwMSArIHBvaW50LCAxLjApLCAxLjApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBub24taW50ZXJzZWN0aW5nIHZlcnRleC4gVHJlYXQgaXQgbGlrZSBhIG1pdHJlIGpvaW4uXFxuICAgICAgICAgICAgdmVjMiBwb2ludCA9IDAuNSAqIHdpZHRoICogbm9ybWFsICogc2lnbWEgKiBkb3Qobm9ybWFsLCBwMDFOb3JtKTtcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodVBhblpvb21NYXRyaXggKiB2ZWMzKHAxICsgcG9pbnQsIDEuMCksIDEuMCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xcbiAgICAgICAgfSBcXG4gICAgICAgIGVsc2UgaWYoYVZlcnRUeXBlID09IFwiKS5jb25jYXQoRURHRV9BUlJPVywgXCIgJiYgdmlkIDwgMykge1xcbiAgICAgICAgICAvLyBtYXNzYWdlIHRoZSBmaXJzdCB0cmlhbmdsZSBpbnRvIGFuIGVkZ2UgYXJyb3dcXG4gICAgICAgICAgaWYodmlkID09IDApXFxuICAgICAgICAgICAgcG9zaXRpb24gPSB2ZWMyKC0wLjE1LCAtMC4zKTtcXG4gICAgICAgICAgaWYodmlkID09IDEpXFxuICAgICAgICAgICAgcG9zaXRpb24gPSB2ZWMyKCAgMC4wLCAgMC4wKTtcXG4gICAgICAgICAgaWYodmlkID09IDIpXFxuICAgICAgICAgICAgcG9zaXRpb24gPSB2ZWMyKCAwLjE1LCAtMC4zKTtcXG5cXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHVQYW5ab29tTWF0cml4ICogYVRyYW5zZm9ybSAqIHZlYzMocG9zaXRpb24sIDEuMCksIDEuMCk7XFxuICAgICAgICAgIHZDb2xvciA9IGFDb2xvcjtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMi4wLCAwLjAsIDAuMCwgMS4wKTsgLy8gZGlzY2FyZCB2ZXJ0ZXggYnkgcHV0dGluZyBpdCBvdXRzaWRlIHdlYmdsIGNsaXAgc3BhY2VcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZBdGxhc0lkID0gYUF0bGFzSWQ7XFxuICAgICAgICB2VmVydFR5cGUgPSBhVmVydFR5cGU7XFxuICAgICAgICB2SW5kZXggPSBhSW5kZXg7XFxuICAgICAgfVxcbiAgICBcIik7XG4gICAgICB2YXIgaWR4cyA9IHRoaXMuYmF0Y2hNYW5hZ2VyLmdldEluZGV4QXJyYXkoKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlclNvdXJjZSA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbiAgICAgIC8vIGRlY2xhcmUgdGV4dHVyZSB1bml0IGZvciBlYWNoIHRleHR1cmUgYXRsYXMgaW4gdGhlIGJhdGNoXFxuICAgICAgXCIuY29uY2F0KGlkeHMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcInVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlXCIuY29uY2F0KGksIFwiO1wiKTtcbiAgICAgIH0pLmpvaW4oJ1xcblxcdCcpLCBcIlxcblxcbiAgICAgIHVuaWZvcm0gdmVjNCB1QkdDb2xvcjtcXG4gICAgICB1bmlmb3JtIGZsb2F0IHVab29tO1xcblxcbiAgICAgIGluIHZlYzIgdlRleENvb3JkO1xcbiAgICAgIGluIHZlYzQgdkNvbG9yO1xcbiAgICAgIGluIHZlYzIgdlBvc2l0aW9uOyAvLyBtb2RlbCBjb29yZGluYXRlc1xcblxcbiAgICAgIGZsYXQgaW4gaW50IHZBdGxhc0lkO1xcbiAgICAgIGZsYXQgaW4gdmVjNCB2SW5kZXg7XFxuICAgICAgZmxhdCBpbiBpbnQgdlZlcnRUeXBlO1xcbiAgICAgIGZsYXQgaW4gdmVjMiB2VG9wUmlnaHQ7XFxuICAgICAgZmxhdCBpbiB2ZWMyIHZCb3RMZWZ0O1xcbiAgICAgIGZsYXQgaW4gdmVjNCB2Q29ybmVyUmFkaXVzO1xcbiAgICAgIGZsYXQgaW4gdmVjNCB2Qm9yZGVyQ29sb3I7XFxuICAgICAgZmxhdCBpbiB2ZWMyIHZCb3JkZXJXaWR0aDtcXG5cXG4gICAgICBvdXQgdmVjNCBvdXRDb2xvcjtcXG5cXG4gICAgICBcIikuY29uY2F0KGNpcmNsZVNELCBcIlxcbiAgICAgIFwiKS5jb25jYXQocmVjdGFuZ2xlU0QsIFwiXFxuICAgICAgXCIpLmNvbmNhdChyb3VuZFJlY3RhbmdsZVNELCBcIlxcbiAgICAgIFwiKS5jb25jYXQoZWxsaXBzZVNELCBcIlxcblxcbiAgICAgIHZlYzQgYmxlbmQodmVjNCB0b3AsIHZlYzQgYm90KSB7IC8vIGJsZW5kIGNvbG9ycyB3aXRoIHByZW11bHRpcGxpZWQgYWxwaGFcXG4gICAgICAgIHJldHVybiB2ZWM0KCBcXG4gICAgICAgICAgdG9wLnJnYiArIChib3QucmdiICogKDEuMCAtIHRvcC5hKSksXFxuICAgICAgICAgIHRvcC5hICAgKyAoYm90LmEgICAqICgxLjAgLSB0b3AuYSkpIFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmVjNCBkaXN0SW50ZXJwKHZlYzQgY0EsIHZlYzQgY0IsIGZsb2F0IGQpIHsgLy8gaW50ZXJwb2xhdGUgY29sb3IgdXNpbmcgU2lnbmVkIERpc3RhbmNlXFxuICAgICAgICAvLyBzY2FsZSB0byB0aGUgem9vbSBsZXZlbCBzbyB0aGF0IGJvcmRlcnMgZG9uJ3QgbG9vayBibHVycnkgd2hlbiB6b29tZWQgaW5cXG4gICAgICAgIC8vIG5vdGUgMS41IGlzIGFuIGFyaWJpdHJhcnkgdmFsdWUgY2hvc2VuIGJlY2F1c2UgaXQgbG9va3MgZ29vZFxcbiAgICAgICAgcmV0dXJuIG1peChjQSwgY0IsIDEuMCAtIHNtb290aHN0ZXAoMC4wLCAxLjUgLyB1Wm9vbSwgYWJzKGQpKSk7IFxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaWYodlZlcnRUeXBlID09IFwiKS5jb25jYXQoVEVYVFVSRSwgXCIpIHtcXG4gICAgICAgICAgLy8gbG9vayB1cCB0aGUgdGV4ZWwgZnJvbSB0aGUgdGV4dHVyZSB1bml0XFxuICAgICAgICAgIFwiKS5jb25jYXQoaWR4cy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIFwiaWYodkF0bGFzSWQgPT0gXCIuY29uY2F0KGksIFwiKSBvdXRDb2xvciA9IHRleHR1cmUodVRleHR1cmVcIikuY29uY2F0KGksIFwiLCB2VGV4Q29vcmQpO1wiKTtcbiAgICAgIH0pLmpvaW4oJ1xcblxcdGVsc2UgJyksIFwiXFxuICAgICAgICB9IFxcbiAgICAgICAgZWxzZSBpZih2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChFREdFX0FSUk9XLCBcIikge1xcbiAgICAgICAgICAvLyBtaW1pY3MgaG93IGNhbnZhcyByZW5kZXJlciB1c2VzIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XFxuICAgICAgICAgIG91dENvbG9yID0gYmxlbmQodkNvbG9yLCB1QkdDb2xvcik7XFxuICAgICAgICAgIG91dENvbG9yLmEgPSAxLjA7IC8vIG1ha2Ugb3BhcXVlLCBtYXNrcyBvdXQgbGluZSB1bmRlciBhcnJvd1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZih2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChSRUNUQU5HTEUsIFwiICYmIHZCb3JkZXJXaWR0aCA9PSB2ZWMyKDAuMCkpIHsgLy8gc2ltcGxlIHJlY3RhbmdsZSB3aXRoIG5vIGJvcmRlclxcbiAgICAgICAgICBvdXRDb2xvciA9IHZDb2xvcjsgLy8gdW5pdCBzcXVhcmUgaXMgYWxyZWFkeSB0cmFuc2Zvcm1lZCB0byB0aGUgcmVjdGFuZ2xlLCBub3RoaW5nIGVsc2UgbmVlZHMgdG8gYmUgZG9uZVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZih2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChSRUNUQU5HTEUsIFwiIHx8IHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVMTElQU0UsIFwiIFxcbiAgICAgICAgICB8fCB2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChST1VORF9SRUNUQU5HTEUsIFwiIHx8IHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEJPVFRPTV9ST1VORF9SRUNUQU5HTEUsIFwiKSB7IC8vIHVzZSBTREZcXG5cXG4gICAgICAgICAgZmxvYXQgb3V0ZXJCb3JkZXIgPSB2Qm9yZGVyV2lkdGhbMF07XFxuICAgICAgICAgIGZsb2F0IGlubmVyQm9yZGVyID0gdkJvcmRlcldpZHRoWzFdO1xcbiAgICAgICAgICBmbG9hdCBib3JkZXJQYWRkaW5nID0gb3V0ZXJCb3JkZXIgKiAyLjA7XFxuICAgICAgICAgIGZsb2F0IHcgPSB2VG9wUmlnaHQueCAtIHZCb3RMZWZ0LnggLSBib3JkZXJQYWRkaW5nO1xcbiAgICAgICAgICBmbG9hdCBoID0gdlRvcFJpZ2h0LnkgLSB2Qm90TGVmdC55IC0gYm9yZGVyUGFkZGluZztcXG4gICAgICAgICAgdmVjMiBiID0gdmVjMih3LzIuMCwgaC8yLjApOyAvLyBoYWxmIHdpZHRoLCBoYWxmIGhlaWdodFxcbiAgICAgICAgICB2ZWMyIHAgPSB2UG9zaXRpb24gLSB2ZWMyKHZUb3BSaWdodC54IC0gYlswXSAtIG91dGVyQm9yZGVyLCB2VG9wUmlnaHQueSAtIGJbMV0gLSBvdXRlckJvcmRlcik7IC8vIHRyYW5zbGF0ZSB0byBjZW50ZXJcXG5cXG4gICAgICAgICAgZmxvYXQgZDsgLy8gc2lnbmVkIGRpc3RhbmNlXFxuICAgICAgICAgIGlmKHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KFJFQ1RBTkdMRSwgXCIpIHtcXG4gICAgICAgICAgICBkID0gcmVjdGFuZ2xlU0QocCwgYik7XFxuICAgICAgICAgIH0gZWxzZSBpZih2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChFTExJUFNFLCBcIiAmJiB3ID09IGgpIHtcXG4gICAgICAgICAgICBkID0gY2lyY2xlU0QocCwgYi54KTsgLy8gZmFzdGVyIHRoYW4gZWxsaXBzZVxcbiAgICAgICAgICB9IGVsc2UgaWYodlZlcnRUeXBlID09IFwiKS5jb25jYXQoRUxMSVBTRSwgXCIpIHtcXG4gICAgICAgICAgICBkID0gZWxsaXBzZVNEKHAsIGIpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGQgPSByb3VuZFJlY3RhbmdsZVNEKHAsIGIsIHZDb3JuZXJSYWRpdXMud3p5eCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLy8gdXNlIHRoZSBkaXN0YW5jZSB0byBpbnRlcnBvbGF0ZSBhIGNvbG9yIHRvIHNtb290aCB0aGUgZWRnZXMgb2YgdGhlIHNoYXBlLCBkb2Vzbid0IG5lZWQgbXVsdGlzYW1wbGluZ1xcbiAgICAgICAgICAvLyB3ZSBtdXN0IHNtb290aCBjb2xvcnMgaW53YXJkcywgYmVjYXVzZSB3ZSBjYW4ndCBjaGFuZ2UgcGl4ZWxzIG91dHNpZGUgdGhlIHNoYXBlJ3MgYm91bmRpbmcgYm94XFxuICAgICAgICAgIGlmKGQgPiAwLjApIHtcXG4gICAgICAgICAgICBpZihkID4gb3V0ZXJCb3JkZXIpIHtcXG4gICAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIG91dENvbG9yID0gZGlzdEludGVycCh2Qm9yZGVyQ29sb3IsIHZlYzQoMCksIGQgLSBvdXRlckJvcmRlcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmKGQgPiBpbm5lckJvcmRlcikge1xcbiAgICAgICAgICAgICAgdmVjNCBvdXRlckNvbG9yID0gb3V0ZXJCb3JkZXIgPT0gMC4wID8gdmVjNCgwKSA6IHZCb3JkZXJDb2xvcjtcXG4gICAgICAgICAgICAgIHZlYzQgaW5uZXJCb3JkZXJDb2xvciA9IGJsZW5kKHZCb3JkZXJDb2xvciwgdkNvbG9yKTtcXG4gICAgICAgICAgICAgIG91dENvbG9yID0gZGlzdEludGVycChpbm5lckJvcmRlckNvbG9yLCBvdXRlckNvbG9yLCBkKTtcXG4gICAgICAgICAgICB9IFxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgdmVjNCBvdXRlckNvbG9yO1xcbiAgICAgICAgICAgICAgaWYoaW5uZXJCb3JkZXIgPT0gMC4wICYmIG91dGVyQm9yZGVyID09IDAuMCkge1xcbiAgICAgICAgICAgICAgICBvdXRlckNvbG9yID0gdmVjNCgwKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihpbm5lckJvcmRlciA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgb3V0ZXJDb2xvciA9IHZCb3JkZXJDb2xvcjtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIG91dGVyQ29sb3IgPSBibGVuZCh2Qm9yZGVyQ29sb3IsIHZDb2xvcik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBvdXRDb2xvciA9IGRpc3RJbnRlcnAodkNvbG9yLCBvdXRlckNvbG9yLCBkIC0gaW5uZXJCb3JkZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIG91dENvbG9yID0gdkNvbG9yO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIpLmNvbmNhdChyZW5kZXJUYXJnZXQucGlja2luZyA/IFwiaWYob3V0Q29sb3IuYSA9PSAwLjApIGRpc2NhcmQ7XFxuICAgICAgICAgICAgIGVsc2Ugb3V0Q29sb3IgPSB2SW5kZXg7XCIgOiAnJywgXCJcXG4gICAgICB9XFxuICAgIFwiKTtcbiAgICAgIHZhciBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG5cbiAgICAgIC8vIGluc3RhbmNlIGdlb21ldHJ5XG4gICAgICBwcm9ncmFtLmFQb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUG9zaXRpb24nKTtcblxuICAgICAgLy8gYXR0cmlidXRlc1xuICAgICAgcHJvZ3JhbS5hSW5kZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUluZGV4Jyk7XG4gICAgICBwcm9ncmFtLmFWZXJ0VHlwZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVmVydFR5cGUnKTtcbiAgICAgIHByb2dyYW0uYVRyYW5zZm9ybSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVHJhbnNmb3JtJyk7XG4gICAgICBwcm9ncmFtLmFBdGxhc0lkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FBdGxhc0lkJyk7XG4gICAgICBwcm9ncmFtLmFUZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVRleCcpO1xuICAgICAgcHJvZ3JhbS5hUG9pbnRBUG9pbnRCID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb2ludEFQb2ludEInKTtcbiAgICAgIHByb2dyYW0uYVBvaW50Q1BvaW50RCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUG9pbnRDUG9pbnREJyk7XG4gICAgICBwcm9ncmFtLmFMaW5lV2lkdGggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUxpbmVXaWR0aCcpO1xuICAgICAgcHJvZ3JhbS5hQ29sb3IgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUNvbG9yJyk7XG4gICAgICBwcm9ncmFtLmFDb3JuZXJSYWRpdXMgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUNvcm5lclJhZGl1cycpO1xuICAgICAgcHJvZ3JhbS5hQm9yZGVyQ29sb3IgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUJvcmRlckNvbG9yJyk7XG5cbiAgICAgIC8vIHVuaWZvcm1zXG4gICAgICBwcm9ncmFtLnVQYW5ab29tTWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1UGFuWm9vbU1hdHJpeCcpO1xuICAgICAgcHJvZ3JhbS51QXRsYXNTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QXRsYXNTaXplJyk7XG4gICAgICBwcm9ncmFtLnVCR0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QkdDb2xvcicpO1xuICAgICAgcHJvZ3JhbS51Wm9vbSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVpvb20nKTtcbiAgICAgIHByb2dyYW0udVRleHR1cmVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmF0Y2hNYW5hZ2VyLmdldE1heEF0bGFzZXNQZXJCYXRjaCgpOyBpKyspIHtcbiAgICAgICAgcHJvZ3JhbS51VGV4dHVyZXMucHVzaChnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1VGV4dHVyZVwiLmNvbmNhdChpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVWQU9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVZBTygpIHtcbiAgICAgIHZhciB1bml0U3F1YXJlID0gWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDFdO1xuICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHVuaXRTcXVhcmUubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBuID0gdGhpcy5tYXhJbnN0YW5jZXM7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsLFxuICAgICAgICBwcm9ncmFtID0gdGhpcy5wcm9ncmFtO1xuICAgICAgdmFyIHZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgICAgIGNyZWF0ZUJ1ZmZlclN0YXRpY0RyYXcoZ2wsICd2ZWMyJywgcHJvZ3JhbS5hUG9zaXRpb24sIHVuaXRTcXVhcmUpO1xuXG4gICAgICAvLyBDcmVhdGUgYnVmZmVycyBmb3IgYWxsIHRoZSBhdHRyaWJ1dGVzXG4gICAgICB0aGlzLnRyYW5zZm9ybUJ1ZmZlciA9IGNyZWF0ZTN4M01hdHJpeEJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCBwcm9ncmFtLmFUcmFuc2Zvcm0pO1xuICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjNCcsIHByb2dyYW0uYUluZGV4KTtcbiAgICAgIHRoaXMudmVydFR5cGVCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ2ludCcsIHByb2dyYW0uYVZlcnRUeXBlKTtcbiAgICAgIHRoaXMuYXRsYXNJZEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAnaW50JywgcHJvZ3JhbS5hQXRsYXNJZCk7XG4gICAgICB0aGlzLnRleEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjNCcsIHByb2dyYW0uYVRleCk7XG4gICAgICB0aGlzLnBvaW50QVBvaW50QkJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjNCcsIHByb2dyYW0uYVBvaW50QVBvaW50Qik7XG4gICAgICB0aGlzLnBvaW50Q1BvaW50REJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjNCcsIHByb2dyYW0uYVBvaW50Q1BvaW50RCk7XG4gICAgICB0aGlzLmxpbmVXaWR0aEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjMicsIHByb2dyYW0uYUxpbmVXaWR0aCk7XG4gICAgICB0aGlzLmNvbG9yQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWM0JywgcHJvZ3JhbS5hQ29sb3IpO1xuICAgICAgdGhpcy5jb3JuZXJSYWRpdXNCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzQnLCBwcm9ncmFtLmFDb3JuZXJSYWRpdXMpO1xuICAgICAgdGhpcy5ib3JkZXJDb2xvckJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjNCcsIHByb2dyYW0uYUJvcmRlckNvbG9yKTtcbiAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICAgIHJldHVybiB2YW87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1ZmZlcnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuX2J1ZmZlcnMpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IE9iamVjdC5rZXlzKHRoaXMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBlbmRzV2l0aChrLCAnQnVmZmVyJyk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBfdGhpc1trXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYnVmZmVycztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRGcmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydEZyYW1lKHBhblpvb21NYXRyaXgpIHtcbiAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFJFTkRFUl9UQVJHRVQuU0NSRUVOO1xuICAgICAgdGhpcy5wYW5ab29tTWF0cml4ID0gcGFuWm9vbU1hdHJpeDtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgdGhpcy5iYXRjaERlYnVnSW5mbyA9IFtdO1xuICAgICAgdGhpcy53cmFwcGVkQ291bnQgPSAwO1xuICAgICAgdGhpcy5zaW1wbGVDb3VudCA9IDA7XG4gICAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gMDtcbiAgICAgIHRoaXMuYmF0Y2hNYW5hZ2VyLnN0YXJ0QmF0Y2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kRnJhbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kRnJhbWUoKSB7XG4gICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1Zpc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVmlzaWJsZShlbGUsIG9wdHMpIHtcbiAgICAgIGlmIChlbGUudmlzaWJsZSgpKSB7XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdHMuaXNWaXNpYmxlKGVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSB0ZXh0dXJlIHVzaW5nIHRoZSB0ZXh0dXJlIGF0bGFzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdUZXh0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUZXh0dXJlKGVsZSwgZWxlSW5kZXgsIHR5cGUpIHtcbiAgICAgIHZhciBhdGxhc01hbmFnZXIgPSB0aGlzLmF0bGFzTWFuYWdlcixcbiAgICAgICAgYmF0Y2hNYW5hZ2VyID0gdGhpcy5iYXRjaE1hbmFnZXI7XG4gICAgICB2YXIgb3B0cyA9IGF0bGFzTWFuYWdlci5nZXRSZW5kZXJUeXBlT3B0cyh0eXBlKTtcbiAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKGVsZSwgb3B0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBFZGdlcyB3aXRoIGludmFsaWQgcG9pbnRzIGNvdWxkIGJlIHBhc3NlZCBoZXJlIChsYWJlbHMpLCBjYXVzaW5nIGVycm9yc1xuICAgICAgLy8gUmVmOiBSYW5kb20gXCJTY3JpcHQgRXJyb3JcIiB0aHJvd24gd2hlbiBnZW5lcmF0aW5nIG5vZGVzIGFuZCBlZGdlcyBpbiBuZXdlc3Qgd2ViZ2wgdmVyc2lvbiAjMzM2NVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2N5dG9zY2FwZS9jeXRvc2NhcGUuanMvaXNzdWVzLzMzNjVcbiAgICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgIXRoaXMuX2lzVmFsaWRFZGdlKGVsZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVuZGVyVGFyZ2V0LnBpY2tpbmcgJiYgb3B0cy5nZXRUZXhQaWNraW5nTW9kZSkge1xuICAgICAgICB2YXIgbW9kZSA9IG9wdHMuZ2V0VGV4UGlja2luZ01vZGUoZWxlKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFRFWF9QSUNLSU5HX01PREUuSUdOT1JFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gVEVYX1BJQ0tJTkdfTU9ERS5VU0VfQkIpIHtcbiAgICAgICAgICB0aGlzLmRyYXdQaWNraW5nUmVjdGFuZ2xlKGVsZSwgZWxlSW5kZXgsIHR5cGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIGF0bGFzIGFuZCB0aGUgdGV4dHVyZSBjb29yZGluYXRlcywgd2lsbCBkcmF3IHRoZSB0ZXh0dXJlIGlmIGl0IGhhc24ndCBiZWVuIGRyYXduIHlldFxuICAgICAgLy8gTWF5IGJlIG1vcmUgdGhhbiBvbmUgdGV4dHVyZSBpZiBmb3IgZXhhbXBsZSB0aGUgbGFiZWwgaGFzIG11bHRpcGxlIGxpbmVzXG4gICAgICB2YXIgYXRsYXNJbmZvQXJyYXkgPSBhdGxhc01hbmFnZXIuZ2V0QXRsYXNJbmZvKGVsZSwgdHlwZSk7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXRsYXNJbmZvQXJyYXkpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGF0bGFzSW5mbyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBhdGxhcyA9IGF0bGFzSW5mby5hdGxhcyxcbiAgICAgICAgICAgIHRleDEgPSBhdGxhc0luZm8udGV4MSxcbiAgICAgICAgICAgIHRleDIgPSBhdGxhc0luZm8udGV4MjsgLy8gdGV4MiBpcyB1c2VkIGlmIHRoZSBsYWJlbCB3cmFwcyBhbmQgdGhlcmUgYXJlIHR3byB0ZXh0dXJlc1xuXG4gICAgICAgICAgaWYgKCFiYXRjaE1hbmFnZXIuY2FuQWRkVG9DdXJyZW50QmF0Y2goYXRsYXMpKSB7XG4gICAgICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdGxhc0luZGV4ID0gYmF0Y2hNYW5hZ2VyLmdldEF0bGFzSW5kZXhGb3JCYXRjaChhdGxhcyk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYXJyID0gW1t0ZXgxLCB0cnVlXSwgW3RleDIsIGZhbHNlXV07IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfYXJyJF9pID0gX3NsaWNlZFRvQXJyYXkoX2FycltfaV0sIDIpLFxuICAgICAgICAgICAgICB0ZXggPSBfYXJyJF9pWzBdLFxuICAgICAgICAgICAgICBmaXJzdCA9IF9hcnIkX2lbMV07XG4gICAgICAgICAgICBpZiAodGV4LncgIT0gMCkge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG4gICAgICAgICAgICAgIHRoaXMudmVydFR5cGVCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSlbMF0gPSBURVhUVVJFO1xuICAgICAgICAgICAgICB2YXIgaW5kZXhWaWV3ID0gdGhpcy5pbmRleEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgaW5kZXhUb1ZlYzQoZWxlSW5kZXgsIGluZGV4Vmlldyk7XG5cbiAgICAgICAgICAgICAgLy8gU2V0IHZhbHVlcyBpbiB0aGUgYnVmZmVycyB1c2luZyBUeXBlZCBBcnJheSBWaWV3cyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgIHZhciBhdGxhc0lkVmlldyA9IHRoaXMuYXRsYXNJZEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgYXRsYXNJZFZpZXdbMF0gPSBhdGxhc0luZGV4O1xuXG4gICAgICAgICAgICAgIC8vIHdlIGhhdmUgdHdvIHNldHMgb2YgdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgdHJhbnNmb3JtcyBiZWNhdXNlIHRleHR1cmVzIGNhbiB3cmFwIGluIHRoZSBhdGxhc1xuICAgICAgICAgICAgICB2YXIgdGV4VmlldyA9IHRoaXMudGV4QnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICB0ZXhWaWV3WzBdID0gdGV4Lng7XG4gICAgICAgICAgICAgIHRleFZpZXdbMV0gPSB0ZXgueTtcbiAgICAgICAgICAgICAgdGV4Vmlld1syXSA9IHRleC53O1xuICAgICAgICAgICAgICB0ZXhWaWV3WzNdID0gdGV4Lmg7XG4gICAgICAgICAgICAgIHZhciBtYXRyaXhWaWV3ID0gdGhpcy50cmFuc2Zvcm1CdWZmZXIuZ2V0TWF0cml4VmlldyhpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtTWF0cml4KGVsZSwgbWF0cml4Vmlldywgb3B0cywgYXRsYXNJbmZvLCBmaXJzdCk7XG4gICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB0aGlzLndyYXBwZWRDb3VudCsrO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUNvdW50ID49IHRoaXMubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWF0cml4IGlzIGV4cGVjdGVkIHRvIGJlIGEgOSBlbGVtZW50IGFycmF5XG4gICAgICogdGhpcyBmdW5jdGlvbiBmb2xsb3dzIHNhbWUgcGF0dGVybiBhcyBDUnAuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKC4uLilcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmFuc2Zvcm1NYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNmb3JtTWF0cml4KGVsZSwgbWF0cml4LCBvcHRzLCBhdGxhc0luZm8pIHtcbiAgICAgIHZhciBmaXJzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgICAgIHZhciBwYWRkaW5nID0gMDtcbiAgICAgIGlmIChvcHRzLnNoYXBlUHJvcHMgJiYgb3B0cy5zaGFwZVByb3BzLnBhZGRpbmcpIHtcbiAgICAgICAgcGFkZGluZyA9IGVsZS5wc3R5bGUob3B0cy5zaGFwZVByb3BzLnBhZGRpbmcpLnBmVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoYXRsYXNJbmZvKSB7XG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgY29tcHV0ZWQgdGhlIGJiIGFuZCB0ZXggYm91bmRzIGZvciBhIHRleHR1cmVcbiAgICAgICAgdmFyIGJiID0gYXRsYXNJbmZvLmJiLFxuICAgICAgICAgIHRleDEgPSBhdGxhc0luZm8udGV4MSxcbiAgICAgICAgICB0ZXgyID0gYXRsYXNJbmZvLnRleDI7XG4gICAgICAgIC8vIHdyYXBwZWQgdGV4dHVyZXMgbmVlZCBzZXBhcmF0ZSBtYXRyaXggZm9yIGVhY2ggcGFydFxuICAgICAgICB2YXIgcmF0aW8gPSB0ZXgxLncgLyAodGV4MS53ICsgdGV4Mi53KTtcbiAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgIC8vIGZpcnN0ID0gdHJ1ZSBtZWFucyBpdHMgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHdyYXBwZWQgdGV4dHVyZVxuICAgICAgICAgIHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZGpCQiA9IHRoaXMuX2dldEFkanVzdGVkQkIoYmIsIHBhZGRpbmcsIGZpcnN0LCByYXRpbyk7XG4gICAgICAgIHRoaXMuX2FwcGx5VHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgYWRqQkIsIG9wdHMsIGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGEgdGV4dHVyZSwgb3Igd2Ugd2FudCB0byBhdm9pZCBjcmVhdGluZyBhIHRleHR1cmUgZm9yIHNpbXBsZSBzaGFwZXNcbiAgICAgICAgdmFyIF9iYiA9IG9wdHMuZ2V0Qm91bmRpbmdCb3goZWxlKTtcbiAgICAgICAgdmFyIF9hZGpCQiA9IHRoaXMuX2dldEFkanVzdGVkQkIoX2JiLCBwYWRkaW5nLCB0cnVlLCAxKTtcbiAgICAgICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBfYWRqQkIsIG9wdHMsIGVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseVRyYW5zZm9ybU1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHlUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBhZGpCQiwgb3B0cywgZWxlKSB7XG4gICAgICB2YXIgeCwgeTtcbiAgICAgIGlkZW50aXR5KG1hdHJpeCk7XG4gICAgICB2YXIgdGhldGEgPSBvcHRzLmdldFJvdGF0aW9uID8gb3B0cy5nZXRSb3RhdGlvbihlbGUpIDogMDtcbiAgICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgICB2YXIgX29wdHMkZ2V0Um90YXRpb25Qb2luID0gb3B0cy5nZXRSb3RhdGlvblBvaW50KGVsZSksXG4gICAgICAgICAgc3ggPSBfb3B0cyRnZXRSb3RhdGlvblBvaW4ueCxcbiAgICAgICAgICBzeSA9IF9vcHRzJGdldFJvdGF0aW9uUG9pbi55O1xuICAgICAgICB0cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFtzeCwgc3ldKTtcbiAgICAgICAgcm90YXRlKG1hdHJpeCwgbWF0cml4LCB0aGV0YSk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBvcHRzLmdldFJvdGF0aW9uT2Zmc2V0KGVsZSk7XG4gICAgICAgIHggPSBvZmZzZXQueCArIChhZGpCQi54T2Zmc2V0IHx8IDApO1xuICAgICAgICB5ID0gb2Zmc2V0LnkgKyAoYWRqQkIueU9mZnNldCB8fCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBhZGpCQi54MTtcbiAgICAgICAgeSA9IGFkakJCLnkxO1xuICAgICAgfVxuICAgICAgdHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbeCwgeV0pO1xuICAgICAgc2NhbGUobWF0cml4LCBtYXRyaXgsIFthZGpCQi53LCBhZGpCQi5oXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIG5vZGUgb3IgbGFiZWwgQkIgdG8gYWNjb21vZGF0ZSBwYWRkaW5nIGFuZCBzcGxpdCBmb3Igd3JhcHBlZCB0ZXh0dXJlcy5cbiAgICAgKiBAcGFyYW0gYmIgLSB0aGUgb3JpZ2luYWwgYm91bmRpbmcgYm94XG4gICAgICogQHBhcmFtIHBhZGRpbmcgLSB0aGUgcGFkZGluZyB0byBhZGQgdG8gdGhlIGJvdW5kaW5nIGJveFxuICAgICAqIEBwYXJhbSBmaXJzdCAtIHdoZXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgcGFydCBvZiBhIHdyYXBwZWQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSByYXRpbyAtIHRoZSByYXRpbyBvZiB0aGUgdGV4dHVyZSB3aWR0aCBvZiBwYXJ0IG9mIHRoZSB0ZXh0IHRvIHRoZSBlbnRpcmUgdGV4dHVyZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBZGp1c3RlZEJCXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBZGp1c3RlZEJCKGJiLCBwYWRkaW5nLCBmaXJzdCwgcmF0aW8pIHtcbiAgICAgIHZhciB4MSA9IGJiLngxLFxuICAgICAgICB5MSA9IGJiLnkxLFxuICAgICAgICB3ID0gYmIudyxcbiAgICAgICAgaCA9IGJiLmgsXG4gICAgICAgIHlPZmZzZXQgPSBiYi55T2Zmc2V0O1xuICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgeDEgLT0gcGFkZGluZztcbiAgICAgICAgeTEgLT0gcGFkZGluZztcbiAgICAgICAgdyArPSAyICogcGFkZGluZztcbiAgICAgICAgaCArPSAyICogcGFkZGluZztcbiAgICAgIH1cbiAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBhZGpXID0gdyAqIHJhdGlvO1xuICAgICAgaWYgKGZpcnN0ICYmIHJhdGlvIDwgMSkge1xuICAgICAgICB3ID0gYWRqVztcbiAgICAgIH0gZWxzZSBpZiAoIWZpcnN0ICYmIHJhdGlvIDwgMSkge1xuICAgICAgICB4T2Zmc2V0ID0gdyAtIGFkalc7XG4gICAgICAgIHgxICs9IHhPZmZzZXQ7XG4gICAgICAgIHcgPSBhZGpXO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHc6IHcsXG4gICAgICAgIGg6IGgsXG4gICAgICAgIHhPZmZzZXQ6IHhPZmZzZXQsXG4gICAgICAgIHlPZmZzZXQ6IHlPZmZzZXRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNvbGlkIG9wYXF1ZSByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGVsZW1lbnQncyBCb3VuZGluZyBCb3guXG4gICAgICogVXNlZCBieSB0aGUgUElDS0lORyBtb2RlIHRvIG1ha2UgdGhlIGVudGlyZSBCQiBvZiBhIGxhYmVsIGNsaWNrYWJsZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UGlja2luZ1JlY3RhbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGlja2luZ1JlY3RhbmdsZShlbGUsIGVsZUluZGV4LCB0eXBlKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMuYXRsYXNNYW5hZ2VyLmdldFJlbmRlclR5cGVPcHRzKHR5cGUpO1xuICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuICAgICAgdGhpcy52ZXJ0VHlwZUJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKVswXSA9IFJFQ1RBTkdMRTtcbiAgICAgIHZhciBpbmRleFZpZXcgPSB0aGlzLmluZGV4QnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgaW5kZXhUb1ZlYzQoZWxlSW5kZXgsIGluZGV4Vmlldyk7XG4gICAgICB2YXIgY29sb3JWaWV3ID0gdGhpcy5jb2xvckJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgIHRvV2ViR0xDb2xvcihbMCwgMCwgMF0sIDEsIGNvbG9yVmlldyk7IC8vIG9wYXF1ZSwgc28gZW50aXJlIGxhYmVsIEJCIGlzIGNsaWNrYWJsZVxuXG4gICAgICB2YXIgbWF0cml4VmlldyA9IHRoaXMudHJhbnNmb3JtQnVmZmVyLmdldE1hdHJpeFZpZXcoaW5zdGFuY2UpO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1NYXRyaXgoZWxlLCBtYXRyaXhWaWV3LCBvcHRzKTtcbiAgICAgIHRoaXMuc2ltcGxlQ291bnQrKztcbiAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2VDb3VudCA+PSB0aGlzLm1heEluc3RhbmNlcykge1xuICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIG5vZGUgdXNpbmcgZWl0aGVyIGEgdGV4dHVyZSBvciBhIFwic2ltcGxlIHNoYXBlXCIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd05vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd05vZGUobm9kZSwgZWxlSW5kZXgsIHR5cGUpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5zaW1wbGVTaGFwZU9wdGlvbnMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKCF0aGlzLl9pc1Zpc2libGUobm9kZSwgb3B0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gb3B0cy5zaGFwZVByb3BzO1xuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIHVzZSBhIHRleHR1cmVcbiAgICAgIHZhciB2ZXJ0VHlwZSA9IHRoaXMuX2dldFZlcnRUeXBlRm9yU2hhcGUobm9kZSwgcHJvcHMuc2hhcGUpO1xuICAgICAgaWYgKHZlcnRUeXBlID09PSB1bmRlZmluZWQgfHwgb3B0cy5pc1NpbXBsZSAmJiAhb3B0cy5pc1NpbXBsZShub2RlKSkge1xuICAgICAgICB0aGlzLmRyYXdUZXh0dXJlKG5vZGUsIGVsZUluZGV4LCB0eXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXIgYSBcInNpbXBsZSBzaGFwZVwiIHVzaW5nIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkcylcbiAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgIHRoaXMudmVydFR5cGVCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSlbMF0gPSB2ZXJ0VHlwZTtcbiAgICAgIGlmICh2ZXJ0VHlwZSA9PT0gUk9VTkRfUkVDVEFOR0xFIHx8IHZlcnRUeXBlID09PSBCT1RUT01fUk9VTkRfUkVDVEFOR0xFKSB7XG4gICAgICAgIC8vIGdldCBjb3JuZXIgcmFkaXVzXG4gICAgICAgIHZhciBiYiA9IG9wdHMuZ2V0Qm91bmRpbmdCb3gobm9kZSk7XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLl9nZXRDb3JuZXJSYWRpdXMobm9kZSwgcHJvcHMucmFkaXVzLCBiYik7XG4gICAgICAgIHZhciByYWRpdXNWaWV3ID0gdGhpcy5jb3JuZXJSYWRpdXNCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgIHJhZGl1c1ZpZXdbMF0gPSByYWRpdXM7IC8vIHRvcC1yaWdodFxuICAgICAgICByYWRpdXNWaWV3WzFdID0gcmFkaXVzOyAvLyBib3R0b20tcmlnaHRcbiAgICAgICAgcmFkaXVzVmlld1syXSA9IHJhZGl1czsgLy8gdG9wLWxlZnRcbiAgICAgICAgcmFkaXVzVmlld1szXSA9IHJhZGl1czsgLy8gYm90dG9tLWxlZnRcbiAgICAgICAgaWYgKHZlcnRUeXBlID09PSBCT1RUT01fUk9VTkRfUkVDVEFOR0xFKSB7XG4gICAgICAgICAgcmFkaXVzVmlld1swXSA9IDA7XG4gICAgICAgICAgcmFkaXVzVmlld1syXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpbmRleFZpZXcgPSB0aGlzLmluZGV4QnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgaW5kZXhUb1ZlYzQoZWxlSW5kZXgsIGluZGV4Vmlldyk7XG4gICAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZShwcm9wcy5jb2xvcikudmFsdWU7XG4gICAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKHByb3BzLm9wYWNpdHkpLnZhbHVlO1xuICAgICAgdmFyIGNvbG9yVmlldyA9IHRoaXMuY29sb3JCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICB0b1dlYkdMQ29sb3IoY29sb3IsIG9wYWNpdHksIGNvbG9yVmlldyk7XG4gICAgICB2YXIgbGluZVdpZHRoVmlldyA9IHRoaXMubGluZVdpZHRoQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpOyAvLyByZXVzZSBlZGdlIGxpbmUgd2lkdGggYXR0cmlidXRlIGZvciBub2RlIGJvcmRlclxuICAgICAgbGluZVdpZHRoVmlld1swXSA9IDA7XG4gICAgICBsaW5lV2lkdGhWaWV3WzFdID0gMDtcbiAgICAgIGlmIChwcm9wcy5ib3JkZXIpIHtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gbm9kZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnZhbHVlO1xuICAgICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1jb2xvcicpLnZhbHVlO1xuICAgICAgICAgIHZhciBib3JkZXJPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWU7XG4gICAgICAgICAgdmFyIGJvcmRlckNvbG9yVmlldyA9IHRoaXMuYm9yZGVyQ29sb3JCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgICAgdG9XZWJHTENvbG9yKGJvcmRlckNvbG9yLCBib3JkZXJPcGFjaXR5LCBib3JkZXJDb2xvclZpZXcpO1xuXG4gICAgICAgICAgLy8gU0RGIGRpc3RhbmNlIGlzIG5lZ2F0aXZlIGluc2lkZSB0aGUgc2hhcGUgYW5kIHBvc2l0aXZlIG91dHNpZGVcbiAgICAgICAgICB2YXIgYm9yZGVyUG9zID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1wb3NpdGlvbicpLnZhbHVlO1xuICAgICAgICAgIGlmIChib3JkZXJQb3MgPT09ICdpbnNpZGUnKSB7XG4gICAgICAgICAgICBsaW5lV2lkdGhWaWV3WzBdID0gMDtcbiAgICAgICAgICAgIGxpbmVXaWR0aFZpZXdbMV0gPSAtYm9yZGVyV2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChib3JkZXJQb3MgPT09ICdvdXRzaWRlJykge1xuICAgICAgICAgICAgbGluZVdpZHRoVmlld1swXSA9IGJvcmRlcldpZHRoO1xuICAgICAgICAgICAgbGluZVdpZHRoVmlld1sxXSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICdjZW50ZXInXG4gICAgICAgICAgICB2YXIgaGFsZldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgICAgICAgICAgbGluZVdpZHRoVmlld1swXSA9IGhhbGZXaWR0aDtcbiAgICAgICAgICAgIGxpbmVXaWR0aFZpZXdbMV0gPSAtaGFsZldpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1hdHJpeFZpZXcgPSB0aGlzLnRyYW5zZm9ybUJ1ZmZlci5nZXRNYXRyaXhWaWV3KGluc3RhbmNlKTtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtTWF0cml4KG5vZGUsIG1hdHJpeFZpZXcsIG9wdHMpO1xuICAgICAgdGhpcy5zaW1wbGVDb3VudCsrO1xuICAgICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZUNvdW50ID49IHRoaXMubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZlcnRUeXBlRm9yU2hhcGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZlcnRUeXBlRm9yU2hhcGUobm9kZSwgc2hhcGVQcm9wKSB7XG4gICAgICB2YXIgc2hhcGUgPSBub2RlLnBzdHlsZShzaGFwZVByb3ApLnZhbHVlO1xuICAgICAgc3dpdGNoIChzaGFwZSkge1xuICAgICAgICBjYXNlICdyZWN0YW5nbGUnOlxuICAgICAgICAgIHJldHVybiBSRUNUQU5HTEU7XG4gICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgICAgIHJldHVybiBFTExJUFNFO1xuICAgICAgICBjYXNlICdyb3VuZHJlY3RhbmdsZSc6XG4gICAgICAgIGNhc2UgJ3JvdW5kLXJlY3RhbmdsZSc6XG4gICAgICAgICAgcmV0dXJuIFJPVU5EX1JFQ1RBTkdMRTtcbiAgICAgICAgY2FzZSAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZSc6XG4gICAgICAgICAgcmV0dXJuIEJPVFRPTV9ST1VORF9SRUNUQU5HTEU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvcm5lclJhZGl1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29ybmVyUmFkaXVzKG5vZGUsIHJhZGl1c1Byb3AsIF9yZWYyKSB7XG4gICAgICB2YXIgdyA9IF9yZWYyLncsXG4gICAgICAgIGggPSBfcmVmMi5oO1xuICAgICAgLy8gc2VlIENScC5kcmF3Um91bmRSZWN0YW5nbGVQYXRoXG4gICAgICBpZiAobm9kZS5wc3R5bGUocmFkaXVzUHJvcCkudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgICByZXR1cm4gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXModywgaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFkaXVzID0gbm9kZS5wc3R5bGUocmFkaXVzUHJvcCkucGZWYWx1ZTtcbiAgICAgICAgdmFyIGhhbGZXaWR0aCA9IHcgLyAyO1xuICAgICAgICB2YXIgaGFsZkhlaWdodCA9IGggLyAyO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ocmFkaXVzLCBoYWxmSGVpZ2h0LCBoYWxmV2lkdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ubHkgc3VwcG9ydHMgZHJhd2luZyB0cmlhbmdsZXMgYXQgdGhlIG1vbWVudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3RWRnZUFycm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdFZGdlQXJyb3coZWRnZSwgZWxlSW5kZXgsIHByZWZpeCkge1xuICAgICAgaWYgKCFlZGdlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBFZGdlIHBvaW50cyBhbmQgYXJyb3cgYW5nbGVzIGV0YyBhcmUgY2FsY3VsYXRlZCBieSB0aGUgYmFzZSByZW5kZXJlciBhbmQgY2FjaGVkIGluIHRoZSByc2NyYXRjaCBvYmplY3QuXG4gICAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIHgsIHksIGFuZ2xlO1xuICAgICAgaWYgKHByZWZpeCA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgeCA9IHJzLmFycm93U3RhcnRYO1xuICAgICAgICB5ID0gcnMuYXJyb3dTdGFydFk7XG4gICAgICAgIGFuZ2xlID0gcnMuc3JjQXJyb3dBbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBycy5hcnJvd0VuZFg7XG4gICAgICAgIHkgPSBycy5hcnJvd0VuZFk7XG4gICAgICAgIGFuZ2xlID0gcnMudGd0QXJyb3dBbmdsZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGFrZW4gZnJvbSBDUnAuZHJhd0Fycm93aGVhZFxuICAgICAgaWYgKGlzTmFOKHgpIHx8IHggPT0gbnVsbCB8fCBpc05hTih5KSB8fCB5ID09IG51bGwgfHwgaXNOYU4oYW5nbGUpIHx8IGFuZ2xlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBzaGFwZSBhZnRlciB0aGUgeC95IGNoZWNrIGJlY2F1c2UgcHN0eWxlKCkgaXMgYSBiaXQgc2xvd1xuICAgICAgdmFyIGFycm93U2hhcGUgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gICAgICBpZiAoYXJyb3dTaGFwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgICAgIHZhciBiYXNlT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgbGluZU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnbGluZS1vcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgb3BhY2l0eSA9IGJhc2VPcGFjaXR5ICogbGluZU9wYWNpdHk7XG4gICAgICB2YXIgbGluZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBzY2FsZSQxID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuci5nZXRBcnJvd1dpZHRoKGxpbmVXaWR0aCwgc2NhbGUkMSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1CdWZmZXIuZ2V0TWF0cml4VmlldyhpbnN0YW5jZSk7XG4gICAgICBpZGVudGl0eSh0cmFuc2Zvcm0pO1xuICAgICAgdHJhbnNsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBbeCwgeV0pO1xuICAgICAgc2NhbGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIFtzaXplLCBzaXplXSk7XG4gICAgICByb3RhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGFuZ2xlKTtcbiAgICAgIHRoaXMudmVydFR5cGVCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSlbMF0gPSBFREdFX0FSUk9XO1xuICAgICAgdmFyIGluZGV4VmlldyA9IHRoaXMuaW5kZXhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICBpbmRleFRvVmVjNChlbGVJbmRleCwgaW5kZXhWaWV3KTtcbiAgICAgIHZhciBjb2xvclZpZXcgPSB0aGlzLmNvbG9yQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgdG9XZWJHTENvbG9yKGNvbG9yLCBvcGFjaXR5LCBjb2xvclZpZXcpO1xuICAgICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZUNvdW50ID49IHRoaXMubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHN0cmFpZ2h0LWxpbmUgb3IgYmV6aWVyIGN1cnZlIGVkZ2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdFZGdlTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3RWRnZUxpbmUoZWRnZSwgZWxlSW5kZXgpIHtcbiAgICAgIGlmICghZWRnZS52aXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX2dldEVkZ2VQb2ludHMoZWRnZSk7XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGxpbmUgc3R5bGVcbiAgICAgIHZhciBiYXNlT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgbGluZU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnbGluZS1vcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgd2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUoJ2xpbmUtY29sb3InKS52YWx1ZTtcbiAgICAgIHZhciBvcGFjaXR5ID0gYmFzZU9wYWNpdHkgKiBsaW5lT3BhY2l0eTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIC8gMiArIHRoaXMuaW5zdGFuY2VDb3VudCA+IHRoaXMubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgIH1cbiAgICAgIGlmIChwb2ludHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgLy8gc3RyYWlnaHQgbGluZVxuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG4gICAgICAgIHRoaXMudmVydFR5cGVCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSlbMF0gPSBFREdFX1NUUkFJR0hUO1xuICAgICAgICB2YXIgaW5kZXhWaWV3ID0gdGhpcy5pbmRleEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgaW5kZXhUb1ZlYzQoZWxlSW5kZXgsIGluZGV4Vmlldyk7XG4gICAgICAgIHZhciBjb2xvclZpZXcgPSB0aGlzLmNvbG9yQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICB0b1dlYkdMQ29sb3IoY29sb3IsIG9wYWNpdHksIGNvbG9yVmlldyk7XG4gICAgICAgIHZhciBsaW5lV2lkdGhCdWZmZXIgPSB0aGlzLmxpbmVXaWR0aEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgbGluZVdpZHRoQnVmZmVyWzBdID0gd2lkdGg7XG4gICAgICAgIHZhciBzb3VyY2VUYXJnZXRWaWV3ID0gdGhpcy5wb2ludEFQb2ludEJCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgIHNvdXJjZVRhcmdldFZpZXdbMF0gPSBwb2ludHNbMF07IC8vIHNvdXJjZSB4XG4gICAgICAgIHNvdXJjZVRhcmdldFZpZXdbMV0gPSBwb2ludHNbMV07IC8vIHNvdXJjZSB5XG4gICAgICAgIHNvdXJjZVRhcmdldFZpZXdbMl0gPSBwb2ludHNbMl07IC8vIHRhcmdldCB4XG4gICAgICAgIHNvdXJjZVRhcmdldFZpZXdbM10gPSBwb2ludHNbM107IC8vIHRhcmdldCB5XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPj0gdGhpcy5tYXhJbnN0YW5jZXMpIHtcbiAgICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGN1cnZlZCBsaW5lXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDI7IGkgKz0gMikge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG4gICAgICAgICAgdGhpcy52ZXJ0VHlwZUJ1ZmZlci5nZXRWaWV3KF9pbnN0YW5jZSlbMF0gPSBFREdFX0NVUlZFX1NFR01FTlQ7XG4gICAgICAgICAgdmFyIF9pbmRleFZpZXcgPSB0aGlzLmluZGV4QnVmZmVyLmdldFZpZXcoX2luc3RhbmNlKTtcbiAgICAgICAgICBpbmRleFRvVmVjNChlbGVJbmRleCwgX2luZGV4Vmlldyk7XG4gICAgICAgICAgdmFyIF9jb2xvclZpZXcgPSB0aGlzLmNvbG9yQnVmZmVyLmdldFZpZXcoX2luc3RhbmNlKTtcbiAgICAgICAgICB0b1dlYkdMQ29sb3IoY29sb3IsIG9wYWNpdHksIF9jb2xvclZpZXcpO1xuICAgICAgICAgIHZhciBfbGluZVdpZHRoQnVmZmVyID0gdGhpcy5saW5lV2lkdGhCdWZmZXIuZ2V0VmlldyhfaW5zdGFuY2UpO1xuICAgICAgICAgIF9saW5lV2lkdGhCdWZmZXJbMF0gPSB3aWR0aDtcbiAgICAgICAgICB2YXIgcEF4ID0gcG9pbnRzW2kgLSAyXSxcbiAgICAgICAgICAgIHBBeSA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgICAgdmFyIHBCeCA9IHBvaW50c1tpXSxcbiAgICAgICAgICAgIHBCeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgdmFyIHBDeCA9IHBvaW50c1tpICsgMl0sXG4gICAgICAgICAgICBwQ3kgPSBwb2ludHNbaSArIDNdO1xuICAgICAgICAgIHZhciBwRHggPSBwb2ludHNbaSArIDRdLFxuICAgICAgICAgICAgcER5ID0gcG9pbnRzW2kgKyA1XTtcblxuICAgICAgICAgIC8vIG1ha2UgcGhhbnRvbSBwb2ludHMgZm9yIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAgICAgICAgIC8vIFRPRE8gYWRkaW5nIDAuMDAxIHRvIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gaW4gdGhlIHNoYWRlciAoSSB0aGluayksIG5lZWQgYSBiZXR0ZXIgc29sdXRpb25cbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICBwQXggPSAyICogcEJ4IC0gcEN4ICsgMC4wMDE7XG4gICAgICAgICAgICBwQXkgPSAyICogcEJ5IC0gcEN5ICsgMC4wMDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09IHBvaW50cy5sZW5ndGggLSA0KSB7XG4gICAgICAgICAgICBwRHggPSAyICogcEN4IC0gcEJ4ICsgMC4wMDE7XG4gICAgICAgICAgICBwRHkgPSAyICogcEN5IC0gcEJ5ICsgMC4wMDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwb2ludEFCVmlldyA9IHRoaXMucG9pbnRBUG9pbnRCQnVmZmVyLmdldFZpZXcoX2luc3RhbmNlKTtcbiAgICAgICAgICBwb2ludEFCVmlld1swXSA9IHBBeDtcbiAgICAgICAgICBwb2ludEFCVmlld1sxXSA9IHBBeTtcbiAgICAgICAgICBwb2ludEFCVmlld1syXSA9IHBCeDtcbiAgICAgICAgICBwb2ludEFCVmlld1szXSA9IHBCeTtcbiAgICAgICAgICB2YXIgcG9pbnRDRFZpZXcgPSB0aGlzLnBvaW50Q1BvaW50REJ1ZmZlci5nZXRWaWV3KF9pbnN0YW5jZSk7XG4gICAgICAgICAgcG9pbnRDRFZpZXdbMF0gPSBwQ3g7XG4gICAgICAgICAgcG9pbnRDRFZpZXdbMV0gPSBwQ3k7XG4gICAgICAgICAgcG9pbnRDRFZpZXdbMl0gPSBwRHg7XG4gICAgICAgICAgcG9pbnRDRFZpZXdbM10gPSBwRHk7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VDb3VudCA+PSB0aGlzLm1heEluc3RhbmNlcykge1xuICAgICAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNWYWxpZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVmFsaWRFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICBpZiAocnMuYmFkTGluZSB8fCBycy5hbGxwdHMgPT0gbnVsbCB8fCBpc05hTihycy5hbGxwdHNbMF0pKSB7XG4gICAgICAgIC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVkZ2VQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEVkZ2VQb2ludHMoZWRnZSkge1xuICAgICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgICAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgICAgIGlmICghdGhpcy5faXNWYWxpZEVkZ2UoZWRnZSkpIHtcbiAgICAgICAgLy8gaXNOYU4gaW4gY2FzZSBlZGdlIGlzIGltcG9zc2libGUgYW5kIGJyb3dzZXIgYnVncyAoZS5nLiBzYWZhcmkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjb250cm9sUG9pbnRzID0gcnMuYWxscHRzO1xuICAgICAgaWYgKGNvbnRyb2xQb2ludHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xQb2ludHM7XG4gICAgICB9XG4gICAgICB2YXIgbnVtU2VnbWVudHMgPSB0aGlzLl9nZXROdW1TZWdtZW50cyhlZGdlKTtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDdXJ2ZVNlZ21lbnRQb2ludHMoY29udHJvbFBvaW50cywgbnVtU2VnbWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TnVtU2VnbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE51bVNlZ21lbnRzKGVkZ2UpIHtcbiAgICAgIC8vIFRPRE8gTmVlZCBhIGhldXJpc3RpYyB0aGF0IGRlY2lkZXMgaG93IG1hbnkgc2VnbWVudHMgdG8gdXNlLiBGYWN0b3JzIHRvIGNvbnNpZGVyOlxuICAgICAgLy8gLSBlZGdlIHdpZHRoL2xlbmd0aFxuICAgICAgLy8gLSBlZGdlIGN1cnZhdHVyZSAodGhlIG1vcmUgdGhlIGN1cnZhdHVyZSwgdGhlIG1vcmUgc2VnbWVudHMpXG4gICAgICAvLyAtIHpvb20gbGV2ZWwgKG1vcmUgc2VnbWVudHMgd2hlbiB6b29tZWQgaW4pXG4gICAgICAvLyAtIG51bWJlciBvZiB2aXNpYmxlIGVkZ2VzIChtb3JlIHNlZ21lbnRzIHdoZW4gdGhlcmUgYXJlIGZld2VyIGVkZ2VzKVxuICAgICAgLy8gLSBwZXJmb3JtYW5jZSAoZmV3ZXIgc2VnbWVudHMgd2hlbiBwZXJmb3JtYW5jZSBpcyBhIGNvbmNlcm4pXG4gICAgICAvLyAtIHVzZXIgY29uZmlndXJhYmxlIG9wdGlvbihzKVxuICAgICAgLy8gbm90ZTogbnVtYmVyIG9mIHNlZ21lbnRzIG11c3QgYmUgbGVzcyB0aGFuIHRoZSBtYXggbnVtYmVyIG9mIGluc3RhbmNlc1xuICAgICAgLy8gbm90ZTogc2VnbWVudHMgZG9uJ3QgbmVlZCB0byBiZSBldmVubHkgc3BhY2VkIG91dCwgaXQgbWlnaHQgbWFrZSBzZW5zZSB0byBoYXZlIHNob3J0ZXIgc2VnbWVudHMgbmVhcmVyIHRvIHRoZSBjb250cm9sIHBvaW50c1xuICAgICAgdmFyIG51bVNlZ21lbnRzID0gMTU7XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtU2VnbWVudHMsIDUpLCB0aGlzLm1heEluc3RhbmNlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDdXJ2ZVNlZ21lbnRQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEN1cnZlU2VnbWVudFBvaW50cyhjb250cm9sUG9pbnRzLCBzZWdtZW50cykge1xuICAgICAgaWYgKGNvbnRyb2xQb2ludHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xQb2ludHM7IC8vIHN0cmFpZ2h0IGxpbmVcbiAgICAgIH1cbiAgICAgIHZhciBjdXJ2ZVBvaW50cyA9IEFycmF5KChzZWdtZW50cyArIDEpICogMik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBhbmQgbGFzdCBjb250cm9sIHBvaW50c1xuICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgY3VydmVQb2ludHNbMF0gPSBjb250cm9sUG9pbnRzWzBdO1xuICAgICAgICAgIGN1cnZlUG9pbnRzWzFdID0gY29udHJvbFBvaW50c1sxXTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09IHNlZ21lbnRzKSB7XG4gICAgICAgICAgY3VydmVQb2ludHNbaSAqIDJdID0gY29udHJvbFBvaW50c1tjb250cm9sUG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIGN1cnZlUG9pbnRzW2kgKiAyICsgMV0gPSBjb250cm9sUG9pbnRzW2NvbnRyb2xQb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHQgPSBpIC8gc2VnbWVudHM7IC8vIHNlZ21lbnRzIGhhdmUgZXF1YWwgbGVuZ3RoLCBpdHMgbm90IHN0cmljdGx5IG5lY2Vzc2FyeSB0byBkbyBpdCB0aGlzIHdheVxuICAgICAgICAgIC8vIHBhc3MgaW4gY3VydmVQb2ludHMgdG8gc2V0IHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IGRpcmVjdGx5XG4gICAgICAgICAgdGhpcy5fc2V0Q3VydmVQb2ludChjb250cm9sUG9pbnRzLCB0LCBjdXJ2ZVBvaW50cywgaSAqIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VydmVQb2ludHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRDdXJ2ZVBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDdXJ2ZVBvaW50KHBvaW50cywgdCwgY3VydmVQb2ludHMsIGNwaSkge1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICBjdXJ2ZVBvaW50c1tjcGldID0gcG9pbnRzWzBdO1xuICAgICAgICBjdXJ2ZVBvaW50c1tjcGkgKyAxXSA9IHBvaW50c1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdwb2ludHMgPSBBcnJheShwb2ludHMubGVuZ3RoIC0gMik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3cG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIHggPSAoMSAtIHQpICogcG9pbnRzW2ldICsgdCAqIHBvaW50c1tpICsgMl07XG4gICAgICAgICAgdmFyIHkgPSAoMSAtIHQpICogcG9pbnRzW2kgKyAxXSArIHQgKiBwb2ludHNbaSArIDNdO1xuICAgICAgICAgIG5ld3BvaW50c1tpXSA9IHg7XG4gICAgICAgICAgbmV3cG9pbnRzW2kgKyAxXSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldEN1cnZlUG9pbnQobmV3cG9pbnRzLCB0LCBjdXJ2ZVBvaW50cywgY3BpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kQmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsLFxuICAgICAgICB2YW8gPSB0aGlzLnZhbyxcbiAgICAgICAgdmVydGV4Q291bnQgPSB0aGlzLnZlcnRleENvdW50LFxuICAgICAgICBjb3VudCA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLnJlbmRlclRhcmdldC5waWNraW5nID8gdGhpcy5waWNraW5nUHJvZ3JhbSA6IHRoaXMucHJvZ3JhbTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcblxuICAgICAgLy8gYnVmZmVyIHRoZSBhdHRyaWJ1dGUgZGF0YVxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmJ1ZmZlcnMpLFxuICAgICAgICBfc3RlcDI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBidWZmZXIgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgYnVmZmVyLmJ1ZmZlclN1YkRhdGEoY291bnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICAgIHZhciBhdGxhc2VzID0gdGhpcy5iYXRjaE1hbmFnZXIuZ2V0QXRsYXNlcygpO1xuICAgICAgLy8gbXVzdCBidWZmZXIgYmVmb3JlIGFjdGl2YXRpbmcgdGV4dHVyZSB1bml0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdGxhc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF0bGFzZXNbaV0uYnVmZmVySWZOZWVkZWQoZ2wpO1xuICAgICAgfVxuICAgICAgLy8gQWN0aXZhdGUgYWxsIHRoZSB0ZXh0dXJlIHVuaXRzIHRoYXQgd2UgbmVlZFxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYXRsYXNlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBfaTIpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhdGxhc2VzW19pMl0udGV4dHVyZSk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVUZXh0dXJlc1tfaTJdLCBfaTIpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHVuaWZvcm1zXG4gICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51Wm9vbSwgZ2V0RWZmZWN0aXZlWm9vbSh0aGlzLnIpKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYocHJvZ3JhbS51UGFuWm9vbU1hdHJpeCwgZmFsc2UsIHRoaXMucGFuWm9vbU1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtMWkocHJvZ3JhbS51QXRsYXNTaXplLCB0aGlzLmJhdGNoTWFuYWdlci5nZXRBdGxhc1NpemUoKSk7XG4gICAgICAvLyBzZXQgYmFja2dyb3VuZCBjb2xvciwgbmVlZGVkIGZvciBlZGdlIGFycm93IGNvbG9yIGJsZW5kaW5nXG4gICAgICB2YXIgd2ViZ2xCZ0NvbG9yID0gdG9XZWJHTENvbG9yKHRoaXMuYmdDb2xvciwgMSk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHByb2dyYW0udUJHQ29sb3IsIHdlYmdsQmdDb2xvcik7XG5cbiAgICAgIC8vIGRyYXchXG4gICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKGdsLlRSSUFOR0xFUywgMCwgdmVydGV4Q291bnQsIGNvdW50KTtcbiAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyAvLyBUT0RPIGlzIHRoaXMgcmlnaHQgd2hlbiBoYXZpbmcgbXVsdGlwbGUgdGV4dHVyZSB1bml0cz9cblxuICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgdGhpcy5iYXRjaERlYnVnSW5mby5wdXNoKHtcbiAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgLy8gaW5zdGFuY2UgY291bnRcbiAgICAgICAgICBhdGxhc0NvdW50OiBhdGxhc2VzLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhcnQgdGhlIG5leHQgYmF0Y2gsIGV2ZW4gaWYgbm90IG5lZWRlZFxuICAgICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlYnVnSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWJ1Z0luZm8oKSB7XG4gICAgICB2YXIgYXRsYXNJbmZvID0gdGhpcy5hdGxhc01hbmFnZXIuZ2V0RGVidWdJbmZvKCk7XG4gICAgICB2YXIgdG90YWxBdGxhc2VzID0gYXRsYXNJbmZvLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIGluZm8pIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ICsgaW5mby5hdGxhc0NvdW50O1xuICAgICAgfSwgMCk7XG4gICAgICB2YXIgYmF0Y2hJbmZvID0gdGhpcy5iYXRjaERlYnVnSW5mbztcbiAgICAgIHZhciB0b3RhbEluc3RhbmNlcyA9IGJhdGNoSW5mby5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBpbmZvKSB7XG4gICAgICAgIHJldHVybiBjb3VudCArIGluZm8uY291bnQ7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF0bGFzSW5mbzogYXRsYXNJbmZvLFxuICAgICAgICB0b3RhbEF0bGFzZXM6IHRvdGFsQXRsYXNlcyxcbiAgICAgICAgd3JhcHBlZENvdW50OiB0aGlzLndyYXBwZWRDb3VudCxcbiAgICAgICAgc2ltcGxlQ291bnQ6IHRoaXMuc2ltcGxlQ291bnQsXG4gICAgICAgIGJhdGNoQ291bnQ6IGJhdGNoSW5mby5sZW5ndGgsXG4gICAgICAgIGJhdGNoSW5mbzogYmF0Y2hJbmZvLFxuICAgICAgICB0b3RhbEluc3RhbmNlczogdG90YWxJbnN0YW5jZXNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBDUnAkNCA9IHt9O1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFdlYkdMIHJlbmRlcmluZyBtb2RlIGFmdGVyIHRoZSBDYW52YXMgcmVuZGVyZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKi9cbkNScCQ0LmluaXRXZWJnbCA9IGZ1bmN0aW9uIChvcHRzLCBmbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZ2wgPSByLmRhdGEuY29udGV4dHNbci5XRUJHTF07XG5cbiAgLy8gU2V0IGRlZmF1bHRzIGFuZCBsaW1pdHMgZm9yIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgb3B0cy5iZ0NvbG9yID0gZ2V0QkdDb2xvcihyKTtcbiAgb3B0cy53ZWJnbFRleFNpemUgPSBNYXRoLm1pbihvcHRzLndlYmdsVGV4U2l6ZSwgZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpKTtcbiAgb3B0cy53ZWJnbFRleFJvd3MgPSBNYXRoLm1pbihvcHRzLndlYmdsVGV4Um93cywgNTQpO1xuICBvcHRzLndlYmdsVGV4Um93c05vZGVzID0gTWF0aC5taW4ob3B0cy53ZWJnbFRleFJvd3NOb2RlcywgNTQpO1xuICBvcHRzLndlYmdsQmF0Y2hTaXplID0gTWF0aC5taW4ob3B0cy53ZWJnbEJhdGNoU2l6ZSwgMTYzODQpO1xuICBvcHRzLndlYmdsVGV4UGVyQmF0Y2ggPSBNYXRoLm1pbihvcHRzLndlYmdsVGV4UGVyQmF0Y2gsIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUykpO1xuXG4gIC8vIFR1cm4gZGVidWcgbW9kZSBvbiBvciBvZmYuXG4gIHIud2ViZ2xEZWJ1ZyA9IG9wdHMud2ViZ2xEZWJ1ZztcbiAgci53ZWJnbERlYnVnU2hvd0F0bGFzZXMgPSBvcHRzLndlYmdsRGVidWdTaG93QXRsYXNlcztcblxuICAvLyBDcmVhdGUgb2Zmc2NyZWVuIGZyYW1lYnVmZmVyIHRoYXQgc3RvcmVzIHRoZSByZXN1bHRzIHdoZW4gUkVOREVSX1RBUkdFVC5QSUNLSU5HIGlzIGVuYWJsZWQuXG4gIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgdG9wbW9zdCBlbGVtZW50IHotaW5kZXggZm9yIGVhY2ggcGl4ZWwsIHdoaWNoIGlzIHVzZWQgdG8gdGVsbCB3aGF0cyB1bmRlciB0aGUgbW91c2UgY3Vyc29yIHBvaW50LlxuICByLnBpY2tpbmdGcmFtZUJ1ZmZlciA9IGNyZWF0ZVBpY2tpbmdGcmFtZUJ1ZmZlcihnbCk7XG4gIHIucGlja2luZ0ZyYW1lQnVmZmVyLm5lZWRzRHJhdyA9IHRydWU7XG5cbiAgLy8gQ3JlYXRlIGFuIEVsZW1lbnREcmF3aW5nV2ViR0wgaW5zdGFuY2Ugd2ljaCBpcyB1c2VkIHRvIGRvIHRoZSBhY3R1YWwgV2ViR0wgcmVuZGVyaW5nLlxuICAvLyBUaGlzIGluc3RhbmNlIG5lZWRzIHRvIGJlIGNvbmZpZ3VyZWQgdG8gZHJhdyB2YXJpb3VzIHR5cGVzIG9mIGVsZW1lbnRzLlxuICByLmRyYXdpbmcgPSBuZXcgRWxlbWVudERyYXdpbmdXZWJHTChyLCBnbCwgb3B0cyk7XG5cbiAgLy8gU29tZSBmdW5jdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBjb25maWd1cmUgRWxlbWVudERyYXdpbmdXZWJHTFxuICB2YXIgZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb24ocHJvcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCBwcm9wKTtcbiAgICB9O1xuICB9O1xuICB2YXIgaXNMYWJlbFZpc2libGUgPSBmdW5jdGlvbiBpc0xhYmVsVmlzaWJsZShwcm9wKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUocHJvcCk7XG4gICAgICByZXR1cm4gbGFiZWwgJiYgbGFiZWwudmFsdWU7XG4gICAgfTtcbiAgfTtcbiAgdmFyIGlzTGF5ZXJWaXNpYmxlID0gZnVuY3Rpb24gaXNMYXllclZpc2libGUocHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAvLyBwcmVmaXggaXMgJ292ZXJsYXknIG9yICd1bmRlcmxheSdcbiAgICAgIHJldHVybiBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChwcmVmaXgsIFwiLW9wYWNpdHlcIikpLnZhbHVlID4gMDtcbiAgICB9O1xuICB9O1xuICB2YXIgZ2V0VGV4UGlja2luZ01vZGUgPSBmdW5jdGlvbiBnZXRUZXhQaWNraW5nTW9kZShlbGUpIHtcbiAgICAvLyB0ZWxscyB3aGVuIGEgbGFiZWwgc2hvdWxkIGJlIGNsaWNrYWJsZVxuICAgIHZhciBlbmFibGVkID0gZWxlLnBzdHlsZSgndGV4dC1ldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG4gICAgcmV0dXJuIGVuYWJsZWQgPyBURVhfUElDS0lOR19NT0RFLlVTRV9CQiA6IFRFWF9QSUNLSU5HX01PREUuSUdOT1JFO1xuICB9O1xuICB2YXIgZ2V0QkJGb3JTaW1wbGVTaGFwZSA9IGZ1bmN0aW9uIGdldEJCRm9yU2ltcGxlU2hhcGUobm9kZSkge1xuICAgIC8vIFwic2ltcGxlXCIgc2hhcGVzIG5lZWQgdGhlaXIgQkIgdG8gaW5jbHVkZSBib3JkZXIgYW5kIHBhZGRpbmdcbiAgICB2YXIgX25vZGUkcG9zaXRpb24gPSBub2RlLnBvc2l0aW9uKCksXG4gICAgICB4ID0gX25vZGUkcG9zaXRpb24ueCxcbiAgICAgIHkgPSBfbm9kZSRwb3NpdGlvbi55O1xuICAgIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7IC8vIGluY2x1ZGVzIGJvcmRlciBhbmQgcGFkZGluZ1xuICAgIHZhciBoID0gbm9kZS5vdXRlckhlaWdodCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3OiB3LFxuICAgICAgaDogaCxcbiAgICAgIHgxOiB4IC0gdyAvIDIsXG4gICAgICB5MTogeSAtIGggLyAyXG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBBdGxhc0NvbGxlY3Rpb24gaXMgYSBjb2xsZWN0aW9uIG9mIEF0bGFzZXMgdGhhdCBoYXZlIHRoZSBzYW1lIGNvbmZpZ3VyYWl0b24gb3B0aW9ucy5cbiAgLy8gQ3JlYXRlIG9uZSBmb3Igbm9kZSBib2RpZXMgYW5kIG9uZSBmb3IgYWxsIHR5cGVzIG9mIGxhYmVscy5cbiAgci5kcmF3aW5nLmFkZEF0bGFzQ29sbGVjdGlvbignbm9kZScsIHtcbiAgICB0ZXhSb3dzOiBvcHRzLndlYmdsVGV4Um93c05vZGVzXG4gIH0pO1xuICByLmRyYXdpbmcuYWRkQXRsYXNDb2xsZWN0aW9uKCdsYWJlbCcsIHtcbiAgICB0ZXhSb3dzOiBvcHRzLndlYmdsVGV4Um93c1xuICB9KTtcblxuICAvLyBDb25maWd1cmUgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBlbGVtZW50cyB0aGF0IGNhbiBiZSByZW5kZXJlZC5cblxuICAvLyBOb2RlIGJvZGllcyBjYW4gYmUgcmVuZGVyZWQgYXMgdGV4dHVyZXMgb3IgYXMgXCJzaW1wbGUgc2hhcGVzXCIuIFxuICAvLyBTaW1wbGUgc2hhcGVzIGFyZSBwcmVmZXJyZWQgYmVjYXVzZSB0aGV5IGRvIG5vdCB1c2UgdGV4dHVyZSBtZW1vcnkuXG4gIC8vIFRleHR1cmVzIGFyZSByZXF1aXJlZCBpZiB0aGUgbm9kZSBib2R5IHVzZXMgY29tcGxleCBzdHlsZXMuIFxuICByLmRyYXdpbmcuYWRkVGV4dHVyZUF0bGFzUmVuZGVyVHlwZSgnbm9kZS1ib2R5Jywge1xuICAgIGNvbGxlY3Rpb246ICdub2RlJyxcbiAgICBnZXRLZXk6IGZucy5nZXRTdHlsZUtleSxcbiAgICBnZXRCb3VuZGluZ0JveDogZm5zLmdldEVsZW1lbnRCb3gsXG4gICAgZHJhd0VsZW1lbnQ6IGZucy5kcmF3RWxlbWVudFxuICB9KTtcbiAgci5kcmF3aW5nLmFkZFNpbXBsZVNoYXBlUmVuZGVyVHlwZSgnbm9kZS1ib2R5Jywge1xuICAgIGdldEJvdW5kaW5nQm94OiBnZXRCQkZvclNpbXBsZVNoYXBlLFxuICAgIGlzU2ltcGxlOiBpc1NpbXBsZVNoYXBlLFxuICAgIHNoYXBlUHJvcHM6IHtcbiAgICAgIHNoYXBlOiAnc2hhcGUnLFxuICAgICAgY29sb3I6ICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgIG9wYWNpdHk6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgcmFkaXVzOiAnY29ybmVyLXJhZGl1cycsXG4gICAgICBib3JkZXI6IHRydWVcbiAgICB9XG4gIH0pO1xuICByLmRyYXdpbmcuYWRkU2ltcGxlU2hhcGVSZW5kZXJUeXBlKCdub2RlLW92ZXJsYXknLCB7XG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEJCRm9yU2ltcGxlU2hhcGUsXG4gICAgaXNWaXNpYmxlOiBpc0xheWVyVmlzaWJsZSgnb3ZlcmxheScpLFxuICAgIHNoYXBlUHJvcHM6IHtcbiAgICAgIHNoYXBlOiAnb3ZlcmxheS1zaGFwZScsXG4gICAgICBjb2xvcjogJ292ZXJsYXktY29sb3InLFxuICAgICAgb3BhY2l0eTogJ292ZXJsYXktb3BhY2l0eScsXG4gICAgICBwYWRkaW5nOiAnb3ZlcmxheS1wYWRkaW5nJyxcbiAgICAgIHJhZGl1czogJ292ZXJsYXktY29ybmVyLXJhZGl1cydcbiAgICB9XG4gIH0pO1xuICByLmRyYXdpbmcuYWRkU2ltcGxlU2hhcGVSZW5kZXJUeXBlKCdub2RlLXVuZGVybGF5Jywge1xuICAgIGdldEJvdW5kaW5nQm94OiBnZXRCQkZvclNpbXBsZVNoYXBlLFxuICAgIGlzVmlzaWJsZTogaXNMYXllclZpc2libGUoJ3VuZGVybGF5JyksXG4gICAgc2hhcGVQcm9wczoge1xuICAgICAgc2hhcGU6ICd1bmRlcmxheS1zaGFwZScsXG4gICAgICBjb2xvcjogJ3VuZGVybGF5LWNvbG9yJyxcbiAgICAgIG9wYWNpdHk6ICd1bmRlcmxheS1vcGFjaXR5JyxcbiAgICAgIHBhZGRpbmc6ICd1bmRlcmxheS1wYWRkaW5nJyxcbiAgICAgIHJhZGl1czogJ3VuZGVybGF5LWNvcm5lci1yYWRpdXMnXG4gICAgfVxuICB9KTtcbiAgci5kcmF3aW5nLmFkZFRleHR1cmVBdGxhc1JlbmRlclR5cGUoJ2xhYmVsJywge1xuICAgIC8vIG5vZGUgbGFiZWwgb3IgZWRnZSBtaWQgbGFiZWxcbiAgICBjb2xsZWN0aW9uOiAnbGFiZWwnLFxuICAgIGdldFRleFBpY2tpbmdNb2RlOiBnZXRUZXhQaWNraW5nTW9kZSxcbiAgICBnZXRLZXk6IGdldFN0eWxlS2V5c0ZvckxhYmVsKGZucy5nZXRMYWJlbEtleSwgbnVsbCksXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEJvdW5kaW5nQm94Rm9yTGFiZWwoZm5zLmdldExhYmVsQm94LCBudWxsKSxcbiAgICBkcmF3Q2xpcHBlZDogdHJ1ZSxcbiAgICBkcmF3RWxlbWVudDogZm5zLmRyYXdMYWJlbCxcbiAgICBnZXRSb3RhdGlvbjogZ2V0TGFiZWxSb3RhdGlvbihudWxsKSxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBmbnMuZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBmbnMuZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlKCdsYWJlbCcpXG4gIH0pO1xuICByLmRyYXdpbmcuYWRkVGV4dHVyZUF0bGFzUmVuZGVyVHlwZSgnZWRnZS1zb3VyY2UtbGFiZWwnLCB7XG4gICAgY29sbGVjdGlvbjogJ2xhYmVsJyxcbiAgICBnZXRUZXhQaWNraW5nTW9kZTogZ2V0VGV4UGlja2luZ01vZGUsXG4gICAgZ2V0S2V5OiBnZXRTdHlsZUtleXNGb3JMYWJlbChmbnMuZ2V0U291cmNlTGFiZWxLZXksICdzb3VyY2UnKSxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0Qm91bmRpbmdCb3hGb3JMYWJlbChmbnMuZ2V0U291cmNlTGFiZWxCb3gsICdzb3VyY2UnKSxcbiAgICBkcmF3Q2xpcHBlZDogdHJ1ZSxcbiAgICBkcmF3RWxlbWVudDogZm5zLmRyYXdTb3VyY2VMYWJlbCxcbiAgICBnZXRSb3RhdGlvbjogZ2V0TGFiZWxSb3RhdGlvbignc291cmNlJyksXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZm5zLmdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZm5zLmdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZSgnc291cmNlLWxhYmVsJylcbiAgfSk7XG4gIHIuZHJhd2luZy5hZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlKCdlZGdlLXRhcmdldC1sYWJlbCcsIHtcbiAgICBjb2xsZWN0aW9uOiAnbGFiZWwnLFxuICAgIGdldFRleFBpY2tpbmdNb2RlOiBnZXRUZXhQaWNraW5nTW9kZSxcbiAgICBnZXRLZXk6IGdldFN0eWxlS2V5c0ZvckxhYmVsKGZucy5nZXRUYXJnZXRMYWJlbEtleSwgJ3RhcmdldCcpLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRCb3VuZGluZ0JveEZvckxhYmVsKGZucy5nZXRUYXJnZXRMYWJlbEJveCwgJ3RhcmdldCcpLFxuICAgIGRyYXdDbGlwcGVkOiB0cnVlLFxuICAgIGRyYXdFbGVtZW50OiBmbnMuZHJhd1RhcmdldExhYmVsLFxuICAgIGdldFJvdGF0aW9uOiBnZXRMYWJlbFJvdGF0aW9uKCd0YXJnZXQnKSxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBmbnMuZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBmbnMuZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlKCd0YXJnZXQtbGFiZWwnKVxuICB9KTtcblxuICAvLyBWZXJ5IHNpbXBsaXN0aWMgd2F5IG9mIHRyaWdnZXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uLCBqdXN0IHVzZSBhIHRpbWVyLlxuICB2YXIgc2V0R0NGbGFnID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdnYXJiYWdlIGNvbGxlY3QgZmxhZyBzZXQnKTtcbiAgICByLmRhdGEuZ2MgPSB0cnVlO1xuICB9LCAxMDAwMCk7XG5cbiAgLy8gRXZlbnQgbGlzdGVuZXIgY2hlY2tzIGlmIHN0eWxlIGtleXMgYXJlIG5vIGxvbmdlciBpbiB1c2UuXG4gIHIub25VcGRhdGVFbGVDYWxjcyhmdW5jdGlvbiAod2lsbERyYXcsIGVsZXMpIHtcbiAgICB2YXIgZ2NOZWVkZWQgPSBmYWxzZTtcbiAgICBpZiAoZWxlcyAmJiBlbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGdjTmVlZGVkIHw9IHIuZHJhd2luZy5pbnZhbGlkYXRlKGVsZXMpO1xuICAgIH1cbiAgICBpZiAoZ2NOZWVkZWQpIHtcbiAgICAgIHNldEdDRmxhZygpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gXCJPdmVycmlkZVwiIGNlcnRhaW4gZnVuY3Rpb25zIGluIGNhbnZhcyBhbmQgYmFzZSByZW5kZXJlclxuICBvdmVycmlkZUNhbnZhc1JlbmRlcmVyRnVuY3Rpb25zKHIpO1xufTtcbmZ1bmN0aW9uIGdldEJHQ29sb3Iocikge1xuICB2YXIgY29udGFpbmVyID0gci5jeS5jb250YWluZXIoKTtcbiAgdmFyIGNzc0NvbG9yID0gY29udGFpbmVyICYmIGNvbnRhaW5lci5zdHlsZSAmJiBjb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yIHx8ICd3aGl0ZSc7XG4gIHJldHVybiBjb2xvcjJ0dXBsZShjc3NDb2xvcik7XG59XG5mdW5jdGlvbiBnZXRMYWJlbExpbmVzKGVsZSwgcHJlZml4KSB7XG4gIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkocnMsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCkgfHwgW107XG59XG5cbi8qKiBcbiAqIEhhbmRsZSBtdWx0aS1saW5lIGxhYmVscyBieSByZW5kZXJpbmcgZWFjaCBsaW5lIGFzIGEgc2VwZXJhdGUgdGV4dHVyZS5cbiAqIFRoYXQgbWVhbnMgZWFjaCBsaW5lIG5lZWRzIGl0cyBvd24gc3R5bGUga2V5LlxuICovXG52YXIgZ2V0U3R5bGVLZXlzRm9yTGFiZWwgPSBmdW5jdGlvbiBnZXRTdHlsZUtleXNGb3JMYWJlbChnZXRLZXksIHByZWZpeCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBrZXkgPSBnZXRLZXkoZWxlKTtcbiAgICB2YXIgbGluZXMgPSBnZXRMYWJlbExpbmVzKGVsZSwgcHJlZml4KTtcbiAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCJfXCIpLmNvbmNhdChpbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfTtcbn07XG5cbi8qKlxuICogTmVlZCB0byBjcmVhdGUgYSBzZXBhcmF0ZSBib3VuZGluZyBib3ggZm9yIGVhY2ggbGluZSBvZiBhIG11bHRpLWxpbmUgbGFiZWwuXG4gKiBOb3RlIHRoYXQgJ2RyYXdDbGlwcGVkOiB0cnVlJyBzaG91bGQgYmUgdXNlZCB3aXRoIHRoaXMuXG4gKi9cbnZhciBnZXRCb3VuZGluZ0JveEZvckxhYmVsID0gZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hGb3JMYWJlbChnZXRCb3VuZGluZ0JveCwgcHJlZml4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZWxlLCBzdHlsZUtleSkge1xuICAgIHZhciBiYiA9IGdldEJvdW5kaW5nQm94KGVsZSk7XG4gICAgaWYgKHR5cGVvZiBzdHlsZUtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB1aSA9IHN0eWxlS2V5LmluZGV4T2YoJ18nKTtcbiAgICAgIGlmICh1aSA+IDApIHtcbiAgICAgICAgdmFyIGxpbmVJbmRleCA9IE51bWJlcihzdHlsZUtleS5zdWJzdHJpbmcodWkgKyAxKSk7XG4gICAgICAgIHZhciBsaW5lcyA9IGdldExhYmVsTGluZXMoZWxlLCBwcmVmaXgpO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGhlaWdodCBhbmQgWSBjb29yZGluYXRlIGZvciBvbmUgbGluZSBvZiB0aGUgbGFiZWwuXG4gICAgICAgIHZhciBoID0gYmIuaCAvIGxpbmVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSBoICogbGluZUluZGV4O1xuICAgICAgICB2YXIgeTEgPSBiYi55MSArIHlPZmZzZXQ7XG4gICAgICAgIC8vIHRoZSB5T2Zmc2V0IGlzIG5lZWRlZCB3aGVuIHJvdGF0aW5nIHRoZSBsYWJlbFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICB3OiBiYi53LFxuICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICBoOiBoLFxuICAgICAgICAgIHlPZmZzZXQ6IHlPZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJiO1xuICB9O1xufTtcblxuLyoqXG4gKiBQbHVnIGludG8gdGhlIGNhbnZhcyByZW5kZXJlciBieSBkeW5hbWljYWxseSBvdmVycmlkaW5nIHNvbWUgb2YgaXRzIGZ1bmN0aW9ucy5cbiAqIFRoaXMgcmVxdWlyZXMgbWluaW1hbCBjaGFuZ2VzIHRvIHRoZSBjYW52YXMgcmVuZHJlcmVyLlxuICovXG5mdW5jdGlvbiBvdmVycmlkZUNhbnZhc1JlbmRlcmVyRnVuY3Rpb25zKHIpIHtcbiAge1xuICAgIC8vIE92ZXJyaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gdG8gY2FsbCB0aGUgd2ViZ2wgcmVuZGVyIGZ1bmN0aW9uIGlmIHRoZSB6b29tIGxldmVsIGlzIGFwcHJvcHJpYXRlXG4gICAgdmFyIHJlbmRlckNhbnZhcyA9IHIucmVuZGVyO1xuICAgIHIucmVuZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIGlmIChyLndlYmdsKSB7XG4gICAgICAgIC8vIElmIHRoZSB6b29tIGxldmVsIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4IHpvb20gbGV2ZWwsIHRoZW4gZGlzYWJsZSB3ZWJnbCBhbmQgc3dpdGNoIGJhY2sgdG8gXG4gICAgICAgIC8vIHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAgICAgIGlmIChjeS56b29tKCkgPiBtYXhab29tJDEpIHtcbiAgICAgICAgICBjbGVhcldlYmdsKHIpO1xuICAgICAgICAgIHJlbmRlckNhbnZhcy5jYWxsKHIsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFyQ2FudmFzKHIpO1xuICAgICAgICAgIHJlbmRlcldlYmdsKHIsIG9wdGlvbnMsIFJFTkRFUl9UQVJHRVQuU0NSRUVOKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAge1xuICAgIC8vIE92ZXJyaWRlIHRoZSBtYXRjaENhbnZhc1NpemUgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSBwaWNraW5nIGZyYW1lIGJ1ZmZlciBzaXplXG4gICAgdmFyIGJhc2VGdW5jID0gci5tYXRjaENhbnZhc1NpemU7XG4gICAgci5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICBiYXNlRnVuYy5jYWxsKHIsIGNvbnRhaW5lcik7XG4gICAgICByLnBpY2tpbmdGcmFtZUJ1ZmZlci5zZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRTaXplcyhyLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICByLnBpY2tpbmdGcmFtZUJ1ZmZlci5uZWVkc0RyYXcgPSB0cnVlO1xuICAgIH07XG4gIH1cbiAge1xuICAgIC8vIE92ZXJyaWRlIGZ1bmN0aW9uIHRvIGNhbGwgdGhlIHdlYmdsIHZlcnNpb24gZm9yIHBpY2tpbmcuXG4gICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgci5nZXRBbGxJbkJveCgpIHNlbGN0aW9uIGJveCBwaWNraW5nLCBpdHMgbm90IGFjY3VyYXRlIGVub3VnaCB3aXRoIHdlYmdsXG4gICAgci5maW5kTmVhcmVzdEVsZW1lbnRzID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gICAgICAvLyB0aGUgY2FudmFzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNsb3cgb24gbGFyZ2UgZ3JhcGhzXG4gICAgICByZXR1cm4gZmluZE5lYXJlc3RFbGVtZW50c1dlYmdsKHIsIHgsIHkpO1xuICAgIH07XG4gIH1cbiAge1xuICAgIC8vIG5lZWQgdG8ga25vdyB3aGVuIHRoZSBjYWNoZWQgZWxlbWVudHMgaGF2ZSBjaGFuZ2VkIHNvIHdlIGNhbiBpbnZhbGlkYXRlIG91ciBjYWNoZXNcbiAgICB2YXIgX2Jhc2VGdW5jID0gci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXM7XG4gICAgci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfYmFzZUZ1bmMuY2FsbChyKTtcbiAgICAgIHIucGlja2luZ0ZyYW1lQnVmZmVyLm5lZWRzRHJhdyA9IHRydWU7XG4gICAgfTtcbiAgfVxuICB7XG4gICAgLy8gbmVlZCB0byBrbm93IHdoZW4gdGhlIGNhY2hlZCBlbGVtZW50cyBoYXZlIGNoYW5nZWQgc28gd2UgY2FuIGludmFsaWRhdGUgb3VyIGNhY2hlc1xuICAgIHZhciBfYmFzZUZ1bmMyID0gci5ub3RpZnk7XG4gICAgci5ub3RpZnkgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbGVzKSB7XG4gICAgICBfYmFzZUZ1bmMyLmNhbGwociwgZXZlbnROYW1lLCBlbGVzKTtcbiAgICAgIGlmIChldmVudE5hbWUgPT09ICd2aWV3cG9ydCcgfHwgZXZlbnROYW1lID09PSAnYm91bmRzJykge1xuICAgICAgICByLnBpY2tpbmdGcmFtZUJ1ZmZlci5uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAvLyBiYWNrZ3JvdW5kIGltYWdlIGZpbmlzaGVkIGxvYWRpbmcsIG5lZWQgdG8gcmVkcmF3XG4gICAgICAgIHIuZHJhd2luZy5pbnZhbGlkYXRlKGVsZXMsIHtcbiAgICAgICAgICB0eXBlOiAnbm9kZS1ib2R5J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjbGVhcldlYmdsKHIpIHtcbiAgdmFyIGdsID0gci5kYXRhLmNvbnRleHRzW3IuV0VCR0xdO1xuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhyKSB7XG4gIC8vIHRoZSBDUnAuY2xlYXJDYW52YXMoKSBmdW5jdGlvbiBkb2Vzbid0IHRha2UgdGhlIHRyYW5zZm9ybSBpbnRvIGFjY291bnRcbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24gY2xlYXIoY29udGV4dCkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfTtcbiAgY2xlYXIoci5kYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICBjbGVhcihyLmRhdGEuY29udGV4dHNbci5EUkFHXSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tTWF0cml4KHIpIHtcbiAgdmFyIHdpZHRoID0gci5jYW52YXNXaWR0aDtcbiAgdmFyIGhlaWdodCA9IHIuY2FudmFzSGVpZ2h0O1xuICB2YXIgX3V0aWwkZ2V0RWZmZWN0aXZlUGFuID0gZ2V0RWZmZWN0aXZlUGFuWm9vbShyKSxcbiAgICBwYW4gPSBfdXRpbCRnZXRFZmZlY3RpdmVQYW4ucGFuLFxuICAgIHpvb20gPSBfdXRpbCRnZXRFZmZlY3RpdmVQYW4uem9vbTtcbiAgdmFyIHRyYW5zZm9ybSA9IGNyZWF0ZSgpO1xuICB0cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIFtwYW4ueCwgcGFuLnldKTtcbiAgc2NhbGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIFt6b29tLCB6b29tXSk7XG4gIHZhciBwcm9qZWN0aW9uJDEgPSBjcmVhdGUoKTtcbiAgcHJvamVjdGlvbihwcm9qZWN0aW9uJDEsIHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgcHJvZHVjdCA9IGNyZWF0ZSgpO1xuICBtdWx0aXBseShwcm9kdWN0LCBwcm9qZWN0aW9uJDEsIHRyYW5zZm9ybSk7XG4gIHJldHVybiBwcm9kdWN0O1xufVxuZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShyLCBjb250ZXh0KSB7XG4gIHZhciB3aWR0aCA9IHIuY2FudmFzV2lkdGg7XG4gIHZhciBoZWlnaHQgPSByLmNhbnZhc0hlaWdodDtcbiAgdmFyIF91dGlsJGdldEVmZmVjdGl2ZVBhbjIgPSBnZXRFZmZlY3RpdmVQYW5ab29tKHIpLFxuICAgIHBhbiA9IF91dGlsJGdldEVmZmVjdGl2ZVBhbjIucGFuLFxuICAgIHpvb20gPSBfdXRpbCRnZXRFZmZlY3RpdmVQYW4yLnpvb207XG4gIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY29udGV4dC50cmFuc2xhdGUocGFuLngsIHBhbi55KTtcbiAgY29udGV4dC5zY2FsZSh6b29tLCB6b29tKTtcbn1cbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SZWN0YW5nbGUociwgb3B0aW9ucykge1xuICByLmRyYXdTZWxlY3Rpb25SZWN0YW5nbGUob3B0aW9ucywgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0Q29udGV4dFRyYW5zZm9ybShyLCBjb250ZXh0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkcmF3QXhlcyhyKSB7XG4gIC8vIGZvciBkZWJnZ2luZ1xuICB2YXIgY29udGV4dCA9IHIuZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICBjb250ZXh0LnNhdmUoKTtcbiAgc2V0Q29udGV4dFRyYW5zZm9ybShyLCBjb250ZXh0KTtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuMyknO1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjb250ZXh0Lm1vdmVUbygtMWUzLCAwKTtcbiAgY29udGV4dC5saW5lVG8oMTAwMCwgMCk7XG4gIGNvbnRleHQuc3Ryb2tlKCk7XG4gIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNvbnRleHQubW92ZVRvKDAsIC0xZTMpO1xuICBjb250ZXh0LmxpbmVUbygwLCAxMDAwKTtcbiAgY29udGV4dC5zdHJva2UoKTtcbiAgY29udGV4dC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkcmF3QXRsYXNlcyhyKSB7XG4gIC8vIEZvciBkZWJ1Z2dpbmcgdGhlIGF0bGFzZXMsIHRoaXMgZG9lc24ndCB3b3JrIGZvciBBdGxhc2VzIHRoYXQgYXJlIGxvY2tlZFxuICB2YXIgZHJhdyA9IGZ1bmN0aW9uIGRyYXcoZHJhd2luZywgbmFtZSwgcm93KSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBkcmF3aW5nLmF0bGFzTWFuYWdlci5nZXRBdGxhc0NvbGxlY3Rpb24obmFtZSk7XG4gICAgdmFyIGNvbnRleHQgPSByLmRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgYXRsYXNlcyA9IGNvbGxlY3Rpb24uYXRsYXNlcztcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXRsYXNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBhdGxhcyA9IGF0bGFzZXNbX2ldO1xuICAgICAgdmFyIGNhbnZhcyA9IGF0bGFzLmNhbnZhcztcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgdmFyIHcgPSBjYW52YXMud2lkdGg7XG4gICAgICAgIHZhciBoID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgdmFyIHggPSB3ICogX2k7XG4gICAgICAgIHZhciB5ID0gY2FudmFzLmhlaWdodCAqIHJvdztcbiAgICAgICAgdmFyIHNjYWxlID0gMC40O1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIHgsIHkpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgY29udGV4dC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBpID0gMDtcbiAgZHJhdyhyLmRyYXdpbmcsICdub2RlJywgaSsrKTtcbiAgZHJhdyhyLmRyYXdpbmcsICdsYWJlbCcsIGkrKyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgei1vcmRlciBpbmRleCBvZiBlbG1lbnRzIHVuZGVyIG9yIHZlcnkgY2xvc2UgdG8gdGhlIG1vdXNlIGN1cnNvciBwb2ludC5cbiAqIEFyZ3VtZW50cyBhcmUgaW4gbW9kZWwgY29vcmRpbmF0ZXMuXG4gKiAoeDEsIHkxKSBpcyB0b3AgbGVmdCBjb3JuZXJcbiAqICh4MiwgeTIpIGlzIGJvdHRvbSByaWdodCBjb3JuZXIgKG9wdGlvbmFsKVxuICogUmV0dXJucyBhIFNldCBvZiBpbmRleGVzLlxuICovXG5mdW5jdGlvbiBnZXRQaWNraW5nSW5kZXhlcyhyLCBtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgdmFyIHgsIHksIHcsIGg7XG4gIHZhciBfdXRpbCRnZXRFZmZlY3RpdmVQYW4zID0gZ2V0RWZmZWN0aXZlUGFuWm9vbShyKSxcbiAgICBwYW4gPSBfdXRpbCRnZXRFZmZlY3RpdmVQYW4zLnBhbixcbiAgICB6b29tID0gX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMy56b29tO1xuICB7XG4gICAgdmFyIF91dGlsJG1vZGVsVG9SZW5kZXJlZCA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHIsIHBhbiwgem9vbSwgbVgxLCBtWTEpLFxuICAgICAgX3V0aWwkbW9kZWxUb1JlbmRlcmVkMiA9IF9zbGljZWRUb0FycmF5KF91dGlsJG1vZGVsVG9SZW5kZXJlZCwgMiksXG4gICAgICBjWDEgPSBfdXRpbCRtb2RlbFRvUmVuZGVyZWQyWzBdLFxuICAgICAgY1kxID0gX3V0aWwkbW9kZWxUb1JlbmRlcmVkMlsxXTtcbiAgICB2YXIgdCA9IDY7IC8vIHNob3VsZCBiZSBldmVuXG4gICAgeCA9IGNYMSAtIHQgLyAyO1xuICAgIHkgPSBjWTEgLSB0IC8gMjtcbiAgICB3ID0gdDtcbiAgICBoID0gdDtcbiAgfVxuICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBnbCA9IHIuZGF0YS5jb250ZXh0c1tyLldFQkdMXTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCByLnBpY2tpbmdGcmFtZUJ1ZmZlcik7XG4gIGlmIChyLnBpY2tpbmdGcmFtZUJ1ZmZlci5uZWVkc0RyYXcpIHtcbiAgICAvLyBEcmF3IGVsZW1lbnQgei1pbmRleGVzIHRvIHRoZSBwaWNraW5nIGZyYW1lYnVmZmVyXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbiAgICByZW5kZXJXZWJnbChyLCBudWxsLCBSRU5ERVJfVEFSR0VULlBJQ0tJTkcpO1xuICAgIHIucGlja2luZ0ZyYW1lQnVmZmVyLm5lZWRzRHJhdyA9IGZhbHNlO1xuICB9XG4gIHZhciBuID0gdyAqIGg7IC8vIG51bWJlciBvZiBwaXhlbHMgdG8gcmVhZFxuICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KG4gKiA0KTsgLy8gNCBieXRlcyBwZXIgcGl4ZWxcbiAgZ2wucmVhZFBpeGVscyh4LCB5LCB3LCBoLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgdmFyIGluZGV4ZXMgPSBuZXcgU2V0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHBpeGVsID0gZGF0YS5zbGljZShpICogNCwgaSAqIDQgKyA0KTtcbiAgICB2YXIgaW5kZXggPSB2ZWM0VG9JbmRleChwaXhlbCkgLSAxOyAvLyBUaGUgZnJhbWVidWZmZXIgaXMgY2xlYXJlZCB3aXRoIDBzLCBzbyB6LWluZGV4ZXMgYXJlIG9mZnNldCBieSAxXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGluZGV4ZXMuYWRkKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4ZXM7XG59XG5cbi8qKlxuICogQ3kuanM6IG1vZGVsIGNvb3JkaW5hdGUgeSBheGlzIGdvZXMgZG93blxuICovXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEVsZW1lbnRzV2ViZ2wociwgeCwgeSkge1xuICAvLyBtb2RlbCBjb29yZGluYXRlc1xuICB2YXIgaW5kZXhlcyA9IGdldFBpY2tpbmdJbmRleGVzKHIsIHgsIHkpO1xuICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgdmFyIG5vZGUsIGVkZ2U7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbmRleGVzKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGluZGV4ID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpbmRleF07XG4gICAgICBpZiAoIW5vZGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIG5vZGUgPSBlbGU7XG4gICAgICB9XG4gICAgICBpZiAoIWVkZ2UgJiYgZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIGVkZ2UgPSBlbGU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAmJiBlZGdlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiBbbm9kZSwgZWRnZV0uZmlsdGVyKEJvb2xlYW4pO1xufVxuXG4vKipcbiAqIERyYXcgb25lIG5vZGUgb3IgZWRnZS4gXG4gKi9cbmZ1bmN0aW9uIGRyYXdFbGUociwgaW5kZXgsIGVsZSkge1xuICB2YXIgZHJhd2luZyA9IHIuZHJhd2luZztcbiAgaW5kZXggKz0gMTsgLy8gMCBpcyB1c2VkIHRvIGNsZWFyIHRoZSBiYWNrZ3JvdW5kLCBuZWVkIHRvIG9mZnNldCBhbGwgei1pbmRleGVzIGJ5IG9uZVxuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgZHJhd2luZy5kcmF3Tm9kZShlbGUsIGluZGV4LCAnbm9kZS11bmRlcmxheScpO1xuICAgIGRyYXdpbmcuZHJhd05vZGUoZWxlLCBpbmRleCwgJ25vZGUtYm9keScpO1xuICAgIGRyYXdpbmcuZHJhd1RleHR1cmUoZWxlLCBpbmRleCwgJ2xhYmVsJyk7XG4gICAgZHJhd2luZy5kcmF3Tm9kZShlbGUsIGluZGV4LCAnbm9kZS1vdmVybGF5Jyk7XG4gIH0gZWxzZSB7XG4gICAgZHJhd2luZy5kcmF3RWRnZUxpbmUoZWxlLCBpbmRleCk7XG4gICAgZHJhd2luZy5kcmF3RWRnZUFycm93KGVsZSwgaW5kZXgsICdzb3VyY2UnKTtcbiAgICBkcmF3aW5nLmRyYXdFZGdlQXJyb3coZWxlLCBpbmRleCwgJ3RhcmdldCcpO1xuICAgIGRyYXdpbmcuZHJhd1RleHR1cmUoZWxlLCBpbmRleCwgJ2xhYmVsJyk7XG4gICAgZHJhd2luZy5kcmF3VGV4dHVyZShlbGUsIGluZGV4LCAnZWRnZS1zb3VyY2UtbGFiZWwnKTtcbiAgICBkcmF3aW5nLmRyYXdUZXh0dXJlKGVsZSwgaW5kZXgsICdlZGdlLXRhcmdldC1sYWJlbCcpO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVyIG9uZSBmcmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyV2ViZ2wociwgb3B0aW9ucywgcmVuZGVyVGFyZ2V0KSB7XG4gIHZhciBzdGFydDtcbiAgaWYgKHIud2ViZ2xEZWJ1Zykge1xuICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfVxuICB2YXIgZHJhd2luZyA9IHIuZHJhd2luZztcbiAgdmFyIGVsZUNvdW50ID0gMDtcbiAgaWYgKHJlbmRlclRhcmdldC5zY3JlZW4pIHtcbiAgICBpZiAoci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuU0VMRUNUX0JPWF0pIHtcbiAgICAgIGRyYXdTZWxlY3Rpb25SZWN0YW5nbGUociwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VlIGRyYXdpbmctZWxlbWVudHMuanMgZHJhd0NhY2hlZEVsZW1lbnQoKVxuICBpZiAoci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuTk9ERV0gfHwgcmVuZGVyVGFyZ2V0LnBpY2tpbmcpIHtcbiAgICB2YXIgZ2wgPSByLmRhdGEuY29udGV4dHNbci5XRUJHTF07XG4gICAgaWYgKHJlbmRlclRhcmdldC5zY3JlZW4pIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7IC8vIGJhY2tncm91bmQgY29sb3JcbiAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7IC8vIGVuYWJsZSBhbHBoYSBibGVuZGluZyBvZiBjb2xvcnNcbiAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpOyAvLyB3ZWJnbCBjb2xvcnMgdXNlIHByZW11bHRpcGxpZWQgYWxwaGFcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7IC8vIGRvbid0IGJsZW5kIHotb3JkZXIgaW5kZXggdmFsdWVzISB0aGV5IGFyZSBub3QgY29sb3JzXG4gICAgfVxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuICAgIHZhciBwYW5ab29tTWF0cml4ID0gY3JlYXRlUGFuWm9vbU1hdHJpeChyKTtcbiAgICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICBlbGVDb3VudCA9IGVsZXMubGVuZ3RoO1xuICAgIGRyYXdpbmcuc3RhcnRGcmFtZShwYW5ab29tTWF0cml4LCByZW5kZXJUYXJnZXQpO1xuICAgIGlmIChyZW5kZXJUYXJnZXQuc2NyZWVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubm9uZHJhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkcmF3RWxlKHIsIGksIGVsZXMubm9uZHJhZ1tpXSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlbGVzLmRyYWcubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBkcmF3RWxlKHIsIF9pMiwgZWxlcy5kcmFnW19pMl0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0LnBpY2tpbmcpIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVsZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICBkcmF3RWxlKHIsIF9pMywgZWxlc1tfaTNdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZHJhd2luZy5lbmRGcmFtZSgpO1xuICAgIGlmIChyZW5kZXJUYXJnZXQuc2NyZWVuICYmIHIud2ViZ2xEZWJ1Z1Nob3dBdGxhc2VzKSB7XG4gICAgICBkcmF3QXhlcyhyKTtcbiAgICAgIGRyYXdBdGxhc2VzKHIpO1xuICAgIH1cbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tyLkRSQUddID0gZmFsc2U7XG4gIH1cbiAgaWYgKHIud2ViZ2xEZWJ1Zykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgY29tcGFjdCA9IGZhbHNlO1xuICAgIHZhciB0aW1lID0gTWF0aC5jZWlsKGVuZCAtIHN0YXJ0KTtcbiAgICB2YXIgZGVidWdJbmZvID0gZHJhd2luZy5nZXREZWJ1Z0luZm8oKTtcbiAgICB2YXIgcmVwb3J0ID0gW1wiXCIuY29uY2F0KGVsZUNvdW50LCBcIiBlbGVtZW50c1wiKSwgXCJcIi5jb25jYXQoZGVidWdJbmZvLnRvdGFsSW5zdGFuY2VzLCBcIiBpbnN0YW5jZXNcIiksIFwiXCIuY29uY2F0KGRlYnVnSW5mby5iYXRjaENvdW50LCBcIiBiYXRjaGVzXCIpLCBcIlwiLmNvbmNhdChkZWJ1Z0luZm8udG90YWxBdGxhc2VzLCBcIiBhdGxhc2VzXCIpLCBcIlwiLmNvbmNhdChkZWJ1Z0luZm8ud3JhcHBlZENvdW50LCBcIiB3cmFwcGVkIHRleHR1cmVzXCIpLCBcIlwiLmNvbmNhdChkZWJ1Z0luZm8uc2ltcGxlQ291bnQsIFwiIHNpbXBsZSBzaGFwZXNcIildLmpvaW4oJywgJyk7XG4gICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2ViR0wgKFwiLmNvbmNhdChyZW5kZXJUYXJnZXQubmFtZSwgXCIpIC0gdGltZSBcIikuY29uY2F0KHRpbWUsIFwibXMsIFwiKS5jb25jYXQocmVwb3J0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2ViR0wgKFwiLmNvbmNhdChyZW5kZXJUYXJnZXQubmFtZSwgXCIpIC0gZnJhbWUgdGltZSBcIikuY29uY2F0KHRpbWUsIFwibXNcIikpO1xuICAgICAgY29uc29sZS5sb2coJ1RvdGFsczonKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiICBcIi5jb25jYXQocmVwb3J0KSk7XG4gICAgICBjb25zb2xlLmxvZygnVGV4dHVyZSBBdGxhc2VzIFVzZWQ6Jyk7XG4gICAgICB2YXIgYXRsYXNJbmZvID0gZGVidWdJbmZvLmF0bGFzSW5mbztcbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXRsYXNJbmZvKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaW5mbyA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgXCIuY29uY2F0KGluZm8udHlwZSwgXCI6IFwiKS5jb25jYXQoaW5mby5rZXlDb3VudCwgXCIga2V5cywgXCIpLmNvbmNhdChpbmZvLmF0bGFzQ291bnQsIFwiIGF0bGFzZXNcIikpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCcnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHIuZGF0YS5nYykge1xuICAgIGNvbnNvbGUubG9nKCdHYXJiYWdlIENvbGxlY3QhJyk7XG4gICAgci5kYXRhLmdjID0gZmFsc2U7XG4gICAgZHJhd2luZy5nYygpO1xuICB9XG59XG5cbnZhciBDUnAkMyA9IHt9O1xuXG4vLyBATyBQb2x5Z29uIGRyYXdpbmdcbkNScCQzLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGNvbnRleHQubW92ZVRvKHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV0pO1xuICB9XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuQ1JwJDMuZHJhd1JvdW5kUG9seWdvblBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzLCBjb3JuZXJzKSB7XG4gIGNvcm5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY29ybmVyKSB7XG4gICAgcmV0dXJuIGRyYXdQcmVwYXJlZFJvdW5kQ29ybmVyKGNvbnRleHQsIGNvcm5lcik7XG4gIH0pO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcbkNScCQzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IHJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiBNYXRoLm1pbihyYWRpdXMsIGhhbGZIZWlnaHQsIGhhbGZXaWR0aCk7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG4gIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAvLyBBcmMgZnJvbSBib3R0b20gdG8gbGVmdCBzaWRlXG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIC8vIEpvaW4gbGluZVxuICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuQ1JwJDMuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gcmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IHJhZGl1cztcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkpO1xuICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuQ1JwJDMuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzLCBjb3JuZXJzKSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lckxlbmd0aCA9IGNvcm5lcnMgPT09ICdhdXRvJyA/IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIDogY29ybmVycztcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICBjb250ZXh0Lm1vdmVUbyh4IC0gaGFsZldpZHRoICsgY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSArIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5DUnAkMy5kcmF3QmFycmVsUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHhCZWdpbiA9IHggLSBoYWxmV2lkdGg7XG4gIHZhciB4RW5kID0geCArIGhhbGZXaWR0aDtcbiAgdmFyIHlCZWdpbiA9IHkgLSBoYWxmSGVpZ2h0O1xuICB2YXIgeUVuZCA9IHkgKyBoYWxmSGVpZ2h0O1xuICB2YXIgYmFycmVsQ3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHdPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgdmFyIGhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gIHZhciBjdHJsUHRYT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd09mZnNldDtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICBjb250ZXh0Lm1vdmVUbyh4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICBjb250ZXh0LmxpbmVUbyh4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0KTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiArIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LmxpbmVUbyh4RW5kIC0gd09mZnNldCwgeUVuZCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCwgeUVuZCAtIGhPZmZzZXQpO1xuICBjb250ZXh0LmxpbmVUbyh4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSB3T2Zmc2V0LCB5QmVnaW4pO1xuICBjb250ZXh0LmxpbmVUbyh4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW4pO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcbnZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG52YXIgY29zMCA9IE1hdGguY29zKDApO1xudmFyIHNpbiA9IHt9O1xudmFyIGNvcyA9IHt9O1xudmFyIGVsbGlwc2VTdGVwU2l6ZSA9IE1hdGguUEkgLyA0MDtcbmZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSkge1xuICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgY29zW2ldID0gTWF0aC5jb3MoaSk7XG59XG5DUnAkMy5kcmF3RWxsaXBzZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGlmIChjb250ZXh0LmVsbGlwc2UpIHtcbiAgICBjb250ZXh0LmVsbGlwc2UoY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHhQb3MsIHlQb3M7XG4gICAgdmFyIHJ3ID0gd2lkdGggLyAyO1xuICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG4gICAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gICAgICB4UG9zID0gY2VudGVyWCAtIHJ3ICogc2luW2ldICogc2luMCArIHJ3ICogY29zW2ldICogY29zMDtcbiAgICAgIHlQb3MgPSBjZW50ZXJZICsgcmggKiBjb3NbaV0gKiBzaW4wICsgcmggKiBzaW5baV0gKiBjb3MwO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8qIGdsb2JhbCBhdG9iLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgQmxvYiAqL1xuXG52YXIgQ1JwJDIgPSB7fTtcbkNScCQyLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uICh3LCBoKSB7XG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICBidWZmZXIud2lkdGggPSB3O1xuICBidWZmZXIuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIFtidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpXTtcbn07XG5DUnAkMi5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gIHZhciBiYiA9IGVsZXMuYm91bmRpbmdCb3goKTtcbiAgdmFyIGN0clJlY3QgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLncpIDogY3RyUmVjdFsyXTtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi5oKSA6IGN0clJlY3RbM107XG4gIHZhciBzcGVjZE1heERpbXMgPSBudW1iZXIkMShvcHRpb25zLm1heFdpZHRoKSB8fCBudW1iZXIkMShvcHRpb25zLm1heEhlaWdodCk7XG4gIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBzY2FsZSA9IDE7XG4gIGlmIChvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICB3aWR0aCAqPSBvcHRpb25zLnNjYWxlO1xuICAgIGhlaWdodCAqPSBvcHRpb25zLnNjYWxlO1xuICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgfSBlbHNlIGlmIChzcGVjZE1heERpbXMpIHtcbiAgICB2YXIgbWF4U2NhbGVXID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFNjYWxlSCA9IEluZmluaXR5O1xuICAgIGlmIChudW1iZXIkMShvcHRpb25zLm1heFdpZHRoKSkge1xuICAgICAgbWF4U2NhbGVXID0gc2NhbGUgKiBvcHRpb25zLm1heFdpZHRoIC8gd2lkdGg7XG4gICAgfVxuICAgIGlmIChudW1iZXIkMShvcHRpb25zLm1heEhlaWdodCkpIHtcbiAgICAgIG1heFNjYWxlSCA9IHNjYWxlICogb3B0aW9ucy5tYXhIZWlnaHQgLyBoZWlnaHQ7XG4gICAgfVxuICAgIHNjYWxlID0gTWF0aC5taW4obWF4U2NhbGVXLCBtYXhTY2FsZUgpO1xuICAgIHdpZHRoICo9IHNjYWxlO1xuICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgfVxuICBpZiAoIXNwZWNkTWF4RGltcykge1xuICAgIHdpZHRoICo9IHB4UmF0aW87XG4gICAgaGVpZ2h0ICo9IHB4UmF0aW87XG4gICAgc2NhbGUgKj0gcHhSYXRpbztcbiAgfVxuICB2YXIgYnVmZkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgYnVmZkNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBidWZmQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgYnVmZkNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgYnVmZkNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB2YXIgYnVmZkN4dCA9IGJ1ZmZDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcbiAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG4gICAgYnVmZkN4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgIHZhciB6c29ydGVkRWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICBpZiAob3B0aW9ucy5mdWxsKSB7XG4gICAgICAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKC1iYi54MSAqIHNjYWxlLCAtYmIueTEgKiBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyhidWZmQ3h0LCB6c29ydGVkRWxlcyk7XG4gICAgICBidWZmQ3h0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKGJiLngxICogc2NhbGUsIGJiLnkxICogc2NhbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogcGFuLnggKiBzY2FsZSxcbiAgICAgICAgeTogcGFuLnkgKiBzY2FsZVxuICAgICAgfTtcbiAgICAgIHNjYWxlICo9IGN5Lnpvb20oKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnkpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtdHJhbnNsYXRpb24ueCwgLXRyYW5zbGF0aW9uLnkpO1xuICAgIH1cblxuICAgIC8vIG5lZWQgdG8gZmlsbCBiZyBhdCBlbmQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIGZpbGwgY2xlYXJlZCB0cmFuc3BhcmVudCBwaXhlbHMgaW4ganBnc1xuICAgIGlmIChvcHRpb25zLmJnKSB7XG4gICAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcbiAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgIGJ1ZmZDeHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmZkNhbnZhcztcbn07XG5mdW5jdGlvbiBiNjRUb0Jsb2IoYjY0LCBtaW1lVHlwZSkge1xuICB2YXIgYnl0ZXMgPSBhdG9iKGI2NCk7XG4gIHZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzLmxlbmd0aCk7XG4gIHZhciBidWZmVWludDggPSBuZXcgVWludDhBcnJheShidWZmKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZVaW50OFtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtidWZmXSwge1xuICAgIHR5cGU6IG1pbWVUeXBlXG4gIH0pO1xufVxuZnVuY3Rpb24gYjY0VXJpVG9CNjQoYjY0dXJpKSB7XG4gIHZhciBpID0gYjY0dXJpLmluZGV4T2YoJywnKTtcbiAgcmV0dXJuIGI2NHVyaS5zdWJzdHIoaSArIDEpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG9wdGlvbnMsIGNhbnZhcywgbWltZVR5cGUpIHtcbiAgdmFyIGdldEI2NFVyaSA9IGZ1bmN0aW9uIGdldEI2NFVyaSgpIHtcbiAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KTtcbiAgfTtcbiAgc3dpdGNoIChvcHRpb25zLm91dHB1dCkge1xuICAgIGNhc2UgJ2Jsb2ItcHJvbWlzZSc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgICAgaWYgKGJsb2IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXNvbHZlKGJsb2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYGNhbnZhcy50b0Jsb2IoKWAgc2VudCBhIG51bGwgdmFsdWUgaW4gaXRzIGNhbGxiYWNrJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgY2FzZSAnYmxvYic6XG4gICAgICByZXR1cm4gYjY0VG9CbG9iKGI2NFVyaVRvQjY0KGdldEI2NFVyaSgpKSwgbWltZVR5cGUpO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpO1xuICAgIGNhc2UgJ2Jhc2U2NHVyaSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZXRCNjRVcmkoKTtcbiAgfVxufVxuQ1JwJDIucG5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvcG5nJyk7XG59O1xuQ1JwJDIuanBnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvanBlZycpO1xufTtcblxudmFyIENScCQxID0ge307XG5DUnAkMS5ub2RlU2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cywgY29ybmVycykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdFbGxpcHNlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjYXNlICdwb2x5Z29uJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpO1xuICAgIGNhc2UgJ3JvdW5kLXBvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzLCBjb3JuZXJzKTtcbiAgICBjYXNlICdyb3VuZHJlY3RhbmdsZSc6XG4gICAgY2FzZSAncm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVycyk7XG4gICAgY2FzZSAnY3V0cmVjdGFuZ2xlJzpcbiAgICBjYXNlICdjdXQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdDdXRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cywgY29ybmVycyk7XG4gICAgY2FzZSAnYm90dG9tcm91bmRyZWN0YW5nbGUnOlxuICAgIGNhc2UgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJzKTtcbiAgICBjYXNlICdiYXJyZWwnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0JhcnJlbFBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbn07XG5cbnZhciBDUiA9IENhbnZhc1JlbmRlcmVyO1xudmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbkNScC5DQU5WQVNfTEFZRVJTID0gMztcbi8vXG5DUnAuU0VMRUNUX0JPWCA9IDA7XG5DUnAuRFJBRyA9IDE7XG5DUnAuTk9ERSA9IDI7XG5DUnAuV0VCR0wgPSAzO1xuQ1JwLkNBTlZBU19UWVBFUyA9IFsnMmQnLCAnMmQnLCAnMmQnLCAnd2ViZ2wyJ107XG5DUnAuQlVGRkVSX0NPVU5UID0gMztcbi8vXG5DUnAuVEVYVFVSRV9CVUZGRVIgPSAwO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIob3B0aW9ucykge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSByLmN5LndpbmRvdygpO1xuICB2YXIgZG9jdW1lbnQgPSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgQ1JwLkNBTlZBU19MQVlFUlMgPSByLkNBTlZBU19MQVlFUlMgPSA0O1xuICAgIGNvbnNvbGUubG9nKCd3ZWJnbCByZW5kZXJpbmcgZW5hYmxlZCcpO1xuICB9XG4gIHIuZGF0YSA9IHtcbiAgICBjYW52YXNlczogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKSxcbiAgICBjb250ZXh0czogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKSxcbiAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKSxcbiAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KENScC5CVUZGRVJfQ09VTlQpLFxuICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpXG4gIH07XG4gIHZhciB0YXBIbE9mZkF0dHIgPSAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJztcbiAgdmFyIHRhcEhsT2ZmU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gIHIuZGF0YS5jYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB2YXIgY29udGFpbmVyU3R5bGUgPSByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlW3RhcEhsT2ZmQXR0cl0gPSB0YXBIbE9mZlN0eWxlO1xuICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgY29udGFpbmVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuY2FudmFzQ29udGFpbmVyKTtcbiAgY29udGFpbmVyLnN0eWxlW3RhcEhsT2ZmQXR0cl0gPSB0YXBIbE9mZlN0eWxlO1xuICB2YXIgc3R5bGVNYXAgPSB7XG4gICAgJy13ZWJraXQtdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgJy1tb3otdXNlci1zZWxlY3QnOiAnLW1vei1ub25lJyxcbiAgICAndXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAnb3V0bGluZS1zdHlsZSc6ICdub25lJ1xuICB9O1xuICBpZiAobXMoKSkge1xuICAgIHN0eWxlTWFwWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgc3R5bGVNYXBbJ3RvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIHZhciBjYW52YXMgPSByLmRhdGEuY2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciB0eXBlID0gQ1JwLkNBTlZBU19UWVBFU1tpXTtcbiAgICByLmRhdGEuY29udGV4dHNbaV0gPSBjYW52YXMuZ2V0Q29udGV4dCh0eXBlKTtcbiAgICBpZiAoIXIuZGF0YS5jb250ZXh0c1tpXSkge1xuICAgICAgZXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgY2FudmFzIG9mIHR5cGUgJyArIHR5cGUpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzdHlsZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgY2FudmFzLnN0eWxlW2tdID0gc3R5bGVNYXBba107XG4gICAgfSk7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ1JwLkNBTlZBU19MQVlFUlMgLSBpKTtcbiAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W2ldID0gZmFsc2U7XG4gIH1cbiAgci5kYXRhLnRvcENhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1swXTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLk5PREUgKyAnLW5vZGUnKTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwLkRSQUddLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuRFJBRyArICctZHJhZycpO1xuICBpZiAoci5kYXRhLmNhbnZhc2VzW0NScC5XRUJHTF0pIHtcbiAgICByLmRhdGEuY2FudmFzZXNbQ1JwLldFQkdMXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLldFQkdMICsgJy13ZWJnbCcpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICByLmRhdGEuYnVmZmVyQ29udGV4dHNbaV0gPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoLWkgLSAxKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIC8vci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICB9XG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcbiAgdmFyIGVtcHR5QmIgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgdmFyIGdldEJveENlbnRlciA9IGZ1bmN0aW9uIGdldEJveENlbnRlcihiYikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoYmIueDEgKyBiYi54MikgLyAyLFxuICAgICAgeTogKGJiLnkxICsgYmIueTIpIC8gMlxuICAgIH07XG4gIH07XG4gIHZhciBnZXRDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBnZXRDZW50ZXJPZmZzZXQoYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLWJiLncgLyAyLFxuICAgICAgeTogLWJiLmggLyAyXG4gICAgfTtcbiAgfTtcbiAgdmFyIGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkID0gZnVuY3Rpb24gYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQoZWxlKSB7XG4gICAgdmFyIF9wID0gZWxlWzBdLl9wcml2YXRlO1xuICAgIHZhciBzYW1lID0gX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9PT0gX3AuYmFja2dyb3VuZFRpbWVzdGFtcDtcbiAgICByZXR1cm4gIXNhbWU7XG4gIH07XG4gIHZhciBnZXRTdHlsZUtleSA9IGZ1bmN0aW9uIGdldFN0eWxlS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubm9kZUtleTtcbiAgfTtcbiAgdmFyIGdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbFN0eWxlS2V5O1xuICB9O1xuICB2YXIgZ2V0U291cmNlTGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnNvdXJjZUxhYmVsU3R5bGVLZXk7XG4gIH07XG4gIHZhciBnZXRUYXJnZXRMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUudGFyZ2V0TGFiZWxTdHlsZUtleTtcbiAgfTtcbiAgdmFyIGRyYXdFbGVtZW50ID0gZnVuY3Rpb24gZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIGZhbHNlLCBmYWxzZSwgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG4gIHZhciBkcmF3TGFiZWwgPSBmdW5jdGlvbiBkcmF3TGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAnbWFpbicsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuICB2YXIgZHJhd1NvdXJjZUxhYmVsID0gZnVuY3Rpb24gZHJhd1NvdXJjZUxhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3NvdXJjZScsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuICB2YXIgZHJhd1RhcmdldExhYmVsID0gZnVuY3Rpb24gZHJhd1RhcmdldExhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3RhcmdldCcsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuICB2YXIgZ2V0RWxlbWVudEJveCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5ib2R5Qm91bmRzO1xuICB9O1xuICB2YXIgZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLm1haW4gfHwgZW1wdHlCYjtcbiAgfTtcbiAgdmFyIGdldFNvdXJjZUxhYmVsQm94ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5zb3VyY2UgfHwgZW1wdHlCYjtcbiAgfTtcbiAgdmFyIGdldFRhcmdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy50YXJnZXQgfHwgZW1wdHlCYjtcbiAgfTtcbiAgdmFyIGlzTGFiZWxWaXNpYmxlQXRTY2FsZSA9IGZ1bmN0aW9uIGlzTGFiZWxWaXNpYmxlQXRTY2FsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pIHtcbiAgICByZXR1cm4gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGdldEJveENlbnRlcihnZXRFbGVtZW50Qm94KGVsZSkpO1xuICB9O1xuICB2YXIgYWRkVGV4dE1hcmdpbiA9IGZ1bmN0aW9uIGFkZFRleHRNYXJnaW4ocHJlZml4LCBwdCwgZWxlKSB7XG4gICAgdmFyIHByZSA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwdC54ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWUsXG4gICAgICB5OiBwdC55ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWVcbiAgICB9O1xuICB9O1xuICB2YXIgZ2V0UnNQdCA9IGZ1bmN0aW9uIGdldFJzUHQoZWxlLCB4LCB5KSB7XG4gICAgdmFyIHJzID0gZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHJldHVybiB7XG4gICAgICB4OiByc1t4XSxcbiAgICAgIHk6IHJzW3ldXG4gICAgfTtcbiAgfTtcbiAgdmFyIGdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignJywgZ2V0UnNQdChlbGUsICdsYWJlbFgnLCAnbGFiZWxZJyksIGVsZSk7XG4gIH07XG4gIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJ3NvdXJjZScsIGdldFJzUHQoZWxlLCAnc291cmNlTGFiZWxYJywgJ3NvdXJjZUxhYmVsWScpLCBlbGUpO1xuICB9O1xuICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCd0YXJnZXQnLCBnZXRSc1B0KGVsZSwgJ3RhcmdldExhYmVsWCcsICd0YXJnZXRMYWJlbFknKSwgZWxlKTtcbiAgfTtcbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldEVsZW1lbnRCb3goZWxlKSk7XG4gIH07XG4gIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldFNvdXJjZUxhYmVsQm94KGVsZSkpO1xuICB9O1xuICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRUYXJnZXRMYWJlbEJveChlbGUpKTtcbiAgfTtcbiAgdmFyIGdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHZhciBiYiA9IGdldExhYmVsQm94KGVsZSk7XG4gICAgdmFyIHAgPSBnZXRDZW50ZXJPZmZzZXQoZ2V0TGFiZWxCb3goZWxlKSk7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHAueCA9IC1iYi53IC0gKGJiLmxlZnRQYWQgfHwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBwLnggPSAtKGJiLnJpZ2h0UGFkIHx8IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgcC55ID0gLWJiLmggLSAoYmIudG9wUGFkIHx8IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHAueSA9IC0oYmIuYm90UGFkIHx8IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfTtcbiAgdmFyIGVsZVR4ckNhY2hlID0gci5kYXRhLmVsZVR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0U3R5bGVLZXksXG4gICAgZG9lc0VsZUludmFsaWRhdGVLZXk6IGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkLFxuICAgIGRyYXdFbGVtZW50OiBkcmF3RWxlbWVudCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0RWxlbWVudEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRFbGVtZW50Um90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0LFxuICAgIGFsbG93RWRnZVR4ckNhY2hpbmc6IGZhbHNlLFxuICAgIGFsbG93UGFyZW50VHhyQ2FjaGluZzogZmFsc2VcbiAgfSk7XG4gIHZhciBsYmxUeHJDYWNoZSA9IHIuZGF0YS5sYmxUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldExhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3TGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldExhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIHNsYlR4ckNhY2hlID0gci5kYXRhLnNsYlR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0U291cmNlTGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdTb3VyY2VMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0U291cmNlTGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgdGxiVHhyQ2FjaGUgPSByLmRhdGEudGxiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRUYXJnZXRMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd1RhcmdldExhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRUYXJnZXRMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciBseXJUeHJDYWNoZSA9IHIuZGF0YS5seXJUeHJDYWNoZSA9IG5ldyBMYXllcmVkVGV4dHVyZUNhY2hlKHIpO1xuICByLm9uVXBkYXRlRWxlQ2FsY3MoZnVuY3Rpb24gaW52YWxpZGF0ZVRleHR1cmVDYWNoZXMod2lsbERyYXcsIGVsZXMpIHtcbiAgICAvLyBlYWNoIGNhY2hlIHNob3VsZCBjaGVjayBmb3Igc3ViLWtleSBkaWZmIHRvIHNlZSB0aGF0IHRoZSB1cGRhdGUgYWZmZWN0cyB0aGF0IGNhY2hlIHBhcnRpY3VsYXJseVxuICAgIGVsZVR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICBsYmxUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgc2xiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIHRsYlR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcblxuICAgIC8vIGFueSBjaGFuZ2UgaW52YWxpZGF0ZXMgdGhlIGxheWVyc1xuICAgIGx5clR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgb2xkIGJnIHRpbWVzdGFtcCBzbyBkaWZmcyBjYW4gYmUgZG9uZSBpbiB0aGUgZWxlIHR4ciBjYWNoZXNcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfcCA9IGVsZXNbX2ldLl9wcml2YXRlO1xuICAgICAgX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9IF9wLmJhY2tncm91bmRUaW1lc3RhbXA7XG4gICAgfVxuICB9KTtcbiAgdmFyIHJlZmluZUluTGF5ZXJzID0gZnVuY3Rpb24gcmVmaW5lSW5MYXllcnMocmVxcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxcy5sZW5ndGg7IGkrKykge1xuICAgICAgbHlyVHhyQ2FjaGUuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50KHJlcXNbaV0uZWxlKTtcbiAgICB9XG4gIH07XG4gIGVsZVR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIGxibFR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIHNsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIHRsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgci5pbml0V2ViZ2wob3B0aW9ucywge1xuICAgICAgZ2V0U3R5bGVLZXk6IGdldFN0eWxlS2V5LFxuICAgICAgZ2V0TGFiZWxLZXk6IGdldExhYmVsS2V5LFxuICAgICAgZ2V0U291cmNlTGFiZWxLZXk6IGdldFNvdXJjZUxhYmVsS2V5LFxuICAgICAgZ2V0VGFyZ2V0TGFiZWxLZXk6IGdldFRhcmdldExhYmVsS2V5LFxuICAgICAgZHJhd0VsZW1lbnQ6IGRyYXdFbGVtZW50LFxuICAgICAgZHJhd0xhYmVsOiBkcmF3TGFiZWwsXG4gICAgICBkcmF3U291cmNlTGFiZWw6IGRyYXdTb3VyY2VMYWJlbCxcbiAgICAgIGRyYXdUYXJnZXRMYWJlbDogZHJhd1RhcmdldExhYmVsLFxuICAgICAgZ2V0RWxlbWVudEJveDogZ2V0RWxlbWVudEJveCxcbiAgICAgIGdldExhYmVsQm94OiBnZXRMYWJlbEJveCxcbiAgICAgIGdldFNvdXJjZUxhYmVsQm94OiBnZXRTb3VyY2VMYWJlbEJveCxcbiAgICAgIGdldFRhcmdldExhYmVsQm94OiBnZXRUYXJnZXRMYWJlbEJveCxcbiAgICAgIGdldEVsZW1lbnRSb3RhdGlvblBvaW50OiBnZXRFbGVtZW50Um90YXRpb25Qb2ludCxcbiAgICAgIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldDogZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0LFxuICAgICAgZ2V0TGFiZWxSb3RhdGlvblBvaW50OiBnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCxcbiAgICAgIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0TGFiZWxSb3RhdGlvbk9mZnNldDogZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICAgIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgICBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0XG4gICAgfSk7XG4gIH1cbn1cbkNScC5yZWRyYXdIaW50ID0gZnVuY3Rpb24gKGdyb3VwLCBib29sKSB7XG4gIHZhciByID0gdGhpcztcbiAgc3dpdGNoIChncm91cCkge1xuICAgIGNhc2UgJ2VsZXMnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5OT0RFXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkcmFnJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuRFJBR10gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuU0VMRUNUX0JPWF0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZ2MnOlxuICAgICAgci5kYXRhLmdjID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xudmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcbkNScC5wYXRoMmRFbmFibGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aHNFbmFibGVkO1xuICB9XG4gIHRoaXMucGF0aHNFbmFibGVkID0gb24gPyB0cnVlIDogZmFsc2U7XG59O1xuQ1JwLnVzZVBhdGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGF0aHNJbXBsZCAmJiB0aGlzLnBhdGhzRW5hYmxlZDtcbn07XG5DUnAuc2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQsIGJvb2wpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfVxufTtcbkNScC5nZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgfVxufTtcbkNScC5tYWtlT2Zmc2NyZWVuQ2FudmFzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGNhbnZhcztcbiAgaWYgKCh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoT2Zmc2NyZWVuQ2FudmFzKSkgIT09IChcInVuZGVmaW5lZFwiICkpIHtcbiAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXJXaW5kb3cgPSB0aGlzLmN5LndpbmRvdygpO1xuICAgIHZhciBkb2N1bWVudCA9IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudDtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn07XG5bQ1JwJGIsIENScCRhLCBDUnAkOSwgQ1JwJDgsIENScCQ3LCBDUnAkNiwgQ1JwJDUsIENScCQ0LCBDUnAkMywgQ1JwJDIsIENScCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoQ1JwLCBwcm9wcyk7XG59KTtcblxudmFyIHJlbmRlcmVyID0gW3tcbiAgbmFtZTogJ251bGwnLFxuICBpbXBsOiBOdWxsUmVuZGVyZXJcbn0sIHtcbiAgbmFtZTogJ2Jhc2UnLFxuICBpbXBsOiBCUlxufSwge1xuICBuYW1lOiAnY2FudmFzJyxcbiAgaW1wbDogQ1Jcbn1dO1xuXG52YXIgaW5jRXh0cyA9IFt7XG4gIHR5cGU6ICdsYXlvdXQnLFxuICBleHRlbnNpb25zOiBsYXlvdXRcbn0sIHtcbiAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgZXh0ZW5zaW9uczogcmVuZGVyZXJcbn1dO1xuXG4vLyByZWdpc3RlcmVkIGV4dGVuc2lvbnMgdG8gY3l0b3NjYXBlLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBleHRlbnNpb25zID0ge307XG5cbi8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG52YXIgbW9kdWxlcyA9IHt9O1xuZnVuY3Rpb24gc2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQpIHtcbiAgdmFyIGV4dCA9IHJlZ2lzdHJhbnQ7XG4gIHZhciBvdmVycmlkZUVyciA9IGZ1bmN0aW9uIG92ZXJyaWRlRXJyKGZpZWxkKSB7XG4gICAgd2FybignQ2FuIG5vdCByZWdpc3RlciBgJyArIG5hbWUgKyAnYCBmb3IgYCcgKyB0eXBlICsgJ2Agc2luY2UgYCcgKyBmaWVsZCArICdgIGFscmVhZHkgZXhpc3RzIGluIHRoZSBwcm90b3R5cGUgYW5kIGNhbiBub3QgYmUgb3ZlcnJpZGRlbicpO1xuICB9O1xuICBpZiAodHlwZSA9PT0gJ2NvcmUnKSB7XG4gICAgaWYgKENvcmUucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvcmUucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbGxlY3Rpb24nKSB7XG4gICAgaWYgKENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xheW91dCcpIHtcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG5cbiAgICB2YXIgTGF5b3V0ID0gZnVuY3Rpb24gTGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICByZWdpc3RyYW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBsYXlvdXQgaGFzIF9wcml2YXRlIGZvciB1c2Ugdy8gc3RkIGFwaXMgbGlrZSAub24oKVxuICAgICAgaWYgKCFwbGFpbk9iamVjdCh0aGlzLl9wcml2YXRlKSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlID0ge307XG4gICAgICB9XG4gICAgICB0aGlzLl9wcml2YXRlLmN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgICB9O1xuICAgIHZhciBsYXlvdXRQcm90byA9IExheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHJlZ2lzdHJhbnQucHJvdG90eXBlKTtcbiAgICB2YXIgb3B0TGF5b3V0Rm5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbk5hbWUgPSBvcHRMYXlvdXRGbnNbaV07XG4gICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBlaXRoZXIgLnN0YXJ0KCkgb3IgLnJ1bigpIGlzIGRlZmluZWQsIHNvIGF1dG9nZW4gdGhlIG90aGVyXG4gICAgaWYgKGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghbGF5b3V0UHJvdG8uc3RhcnQgJiYgbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgcmVnU3RvcCA9IHJlZ2lzdHJhbnQucHJvdG90eXBlLnN0b3A7XG4gICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hbmltYXRlKSB7XG4gICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuICAgICAgICBpZiAoYW5pcykge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhbmlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYW5pc1tfaV0uc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlZ1N0b3ApIHtcbiAgICAgICAgcmVnU3RvcC5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGlmICghbGF5b3V0UHJvdG8uZGVzdHJveSkge1xuICAgICAgbGF5b3V0UHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cbiAgICBsYXlvdXRQcm90by5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICAgIH07XG4gICAgdmFyIGdldEN5ID0gZnVuY3Rpb24gZ2V0Q3kobGF5b3V0KSB7XG4gICAgICByZXR1cm4gbGF5b3V0Ll9wcml2YXRlLmN5O1xuICAgIH07XG4gICAgdmFyIGVtaXR0ZXJPcHRzID0ge1xuICAgICAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGxheW91dCwgZXZ0KSB7XG4gICAgICAgIGV2dC5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIGV2dC5jeSA9IGdldEN5KGxheW91dCk7XG4gICAgICAgIGV2dC50YXJnZXQgPSBsYXlvdXQ7XG4gICAgICB9LFxuICAgICAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGxheW91dCkge1xuICAgICAgICByZXR1cm4gZ2V0Q3kobGF5b3V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4dGVuZChsYXlvdXRQcm90bywge1xuICAgICAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdHMsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICAgICAgfSxcbiAgICAgIG9uOiBmdW5jdGlvbiBvbihldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLm9uKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbmU6IGZ1bmN0aW9uIG9uZShldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLm9uZShldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgb25jZTogZnVuY3Rpb24gb25jZShldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLm9uZShldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZW1pdDogZnVuY3Rpb24gZW1pdChldnQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KGV2dCwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lLmV2ZW50QWxpYXNlc09uKGxheW91dFByb3RvKTtcbiAgICBleHQgPSBMYXlvdXQ7IC8vIHJlcGxhY2Ugd2l0aCBvdXIgd3JhcHBlZCBsYXlvdXRcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncmVuZGVyZXInICYmIG5hbWUgIT09ICdudWxsJyAmJiBuYW1lICE9PSAnYmFzZScpIHtcbiAgICAvLyB1c2VyIHJlZ2lzdGVyZWQgcmVuZGVyZXJzIGluaGVyaXQgZnJvbSBiYXNlXG5cbiAgICB2YXIgQmFzZVJlbmRlcmVyID0gZ2V0RXh0ZW5zaW9uKCdyZW5kZXJlcicsICdiYXNlJyk7XG4gICAgdmFyIGJQcm90byA9IEJhc2VSZW5kZXJlci5wcm90b3R5cGU7XG4gICAgdmFyIFJlZ2lzdHJhbnRSZW5kZXJlciA9IHJlZ2lzdHJhbnQ7XG4gICAgdmFyIHJQcm90byA9IHJlZ2lzdHJhbnQucHJvdG90eXBlO1xuICAgIHZhciBSZW5kZXJlciA9IGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgQmFzZVJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBSZWdpc3RyYW50UmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHZhciBwcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBwTmFtZSBpbiBiUHJvdG8pIHtcbiAgICAgIHZhciBwVmFsID0gYlByb3RvW3BOYW1lXTtcbiAgICAgIHZhciBleGlzdHNJblIgPSByUHJvdG9bcE5hbWVdICE9IG51bGw7XG4gICAgICBpZiAoZXhpc3RzSW5SKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZUVycihwTmFtZSk7XG4gICAgICB9XG4gICAgICBwcm90b1twTmFtZV0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgfVxuICAgIGZvciAodmFyIF9wTmFtZSBpbiByUHJvdG8pIHtcbiAgICAgIHByb3RvW19wTmFtZV0gPSByUHJvdG9bX3BOYW1lXTsgLy8gdGFrZSBpbXBsIGZyb20gcmVnaXN0cmFudFxuICAgIH1cbiAgICBiUHJvdG8uY2xpZW50RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHByb3RvW25hbWVdID0gcHJvdG9bbmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlcnJvcignUmVuZGVyZXIgZG9lcyBub3QgaW1wbGVtZW50IGByZW5kZXJlci4nICsgbmFtZSArICcoKWAgb24gaXRzIHByb3RvdHlwZScpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBleHQgPSBSZW5kZXJlcjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnX19wcm90b19fJyB8fCB0eXBlID09PSAnY29uc3RydWN0b3InIHx8IHR5cGUgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgLy8gdG8gYXZvaWQgcG90ZW50aWFsIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICByZXR1cm4gZXJyb3IodHlwZSArICcgaXMgYW4gaWxsZWdhbCB0eXBlIHRvIGJlIHJlZ2lzdGVyZWQsIHBvc3NpYmx5IGxlYWQgdG8gcHJvdG90eXBlIHBvbGx1dGlvbnMnKTtcbiAgfVxuICByZXR1cm4gc2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdLFxuICAgIHZhbHVlOiBleHRcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFeHRlbnNpb24odHlwZSwgbmFtZSkge1xuICByZXR1cm4gZ2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdXG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQpIHtcbiAgcmV0dXJuIHNldE1hcCh7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXSxcbiAgICB2YWx1ZTogcmVnaXN0cmFudFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV1cbiAgfSk7XG59XG52YXIgZXh0ZW5zaW9uID0gZnVuY3Rpb24gZXh0ZW5zaW9uKCkge1xuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnKVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIGdldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgZXh0ZW5zaW9uIGFjY2VzcyBzeW50YXgnKTtcbiAgfVxufTtcblxuLy8gYWxsb3dzIGEgY29yZSBpbnN0YW5jZSB0byBhY2Nlc3MgZXh0ZW5zaW9ucyBpbnRlcm5hbGx5XG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbi8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcbmluY0V4dHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgZ3JvdXAuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICBzZXRFeHRlbnNpb24oZ3JvdXAudHlwZSwgZXh0Lm5hbWUsIGV4dC5pbXBsKTtcbiAgfSk7XG59KTtcblxuLy8gYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCB0aGF0IGRvZXNuJ3QgbmVlZCBhIHJlZmVyZW5jZSB0byB0aGUgY29yZVxuLy8gKHVzZWZ1bCBmb3IgaW5pdClcbnZhciBfU3R5bGVzaGVldCA9IGZ1bmN0aW9uIFN0eWxlc2hlZXQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfU3R5bGVzaGVldCkpIHtcbiAgICByZXR1cm4gbmV3IF9TdHlsZXNoZWV0KCk7XG4gIH1cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcbnZhciBzaGVldGZuID0gX1N0eWxlc2hlZXQucHJvdG90eXBlO1xuc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZXNoZWV0Jztcbn07XG5cbi8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuc2hlZXRmbi5zZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7XG4gIHRoaXNbaV0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdXG4gIH07XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8ganVzdCBzdG9yZSB0aGUgcHJvcGVydHkgdG8gYmUgcGFyc2VkIGxhdGVyXG5zaGVldGZuLmNzcyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgIHZhciBtYXAgPSBuYW1lO1xuICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcE5hbWVzW2pdO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtrZXldO1xuICAgICAgaWYgKG1hcFZhbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3AgPSBfU3R5bGUucHJvcGVydGllc1trZXldIHx8IF9TdHlsZS5wcm9wZXJ0aWVzW2Rhc2gyY2FtZWwoa2V5KV07XG4gICAgICBpZiAocHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIF92YWx1ZSA9IG1hcFZhbDtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5zaGVldGZuLnN0eWxlID0gc2hlZXRmbi5jc3M7XG5cbi8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24gKGN5KSB7XG4gIHZhciBzdHlsZSA9IG5ldyBfU3R5bGUoY3kpO1xuICByZXR1cm4gdGhpcy5hcHBlbmRUb1N0eWxlKHN0eWxlKTtcbn07XG5cbi8vIGFwcGVuZCBhIGR1bW15IHN0eWxlc2hlZXQgb2JqZWN0IG9uIGEgcmVhbCBzdHlsZSBvYmplY3RcbnNoZWV0Zm4uYXBwZW5kVG9TdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIHN0eWxlLmNzcyhwcm9wLm5hbWUsIHByb3AudmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGU7XG59O1xuXG52YXIgdmVyc2lvbiA9IFwiMy4zMy4xXCI7XG5cbnZhciBjeXRvc2NhcGUgPSBmdW5jdGlvbiBjeXRvc2NhcGUob3B0aW9ucykge1xuICAvLyBpZiBubyBvcHRpb25zIHNwZWNpZmllZCwgdXNlIGRlZmF1bHRcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbnN0YW5jZVxuICBpZiAocGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gbmV3IENvcmUob3B0aW9ucyk7XG4gIH1cblxuICAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgZWxzZSBpZiAoc3RyaW5nKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5hcHBseShleHRlbnNpb24sIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbi8vIGUuZy4gY3l0b3NjYXBlLnVzZSggcmVxdWlyZSgnY3l0b3NjYXBlLWZvbycpLCBiYXIgKVxuY3l0b3NjYXBlLnVzZSA9IGZ1bmN0aW9uIChleHQpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmdzIHRvIHBhc3MgdG8gZXh0XG5cbiAgYXJncy51bnNoaWZ0KGN5dG9zY2FwZSk7IC8vIGN5dG9zY2FwZSBpcyBmaXJzdCBhcmcgdG8gZXh0XG5cbiAgZXh0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5jeXRvc2NhcGUud2FybmluZ3MgPSBmdW5jdGlvbiAoYm9vbCkge1xuICByZXR1cm4gd2FybmluZ3MoYm9vbCk7XG59O1xuXG4vLyByZXBsYWNlZCBieSBidWlsZCBzeXN0ZW1cbmN5dG9zY2FwZS52ZXJzaW9uID0gdmVyc2lvbjtcblxuLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5jeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gX1N0eWxlc2hlZXQ7XG5cbmV4cG9ydCB7IGN5dG9zY2FwZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiX2FycmF5TGlrZVRvQXJyYXkiLCJyIiwiYSIsImxlbmd0aCIsImUiLCJuIiwiQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJpc0FycmF5IiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0IiwibyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b3R5cGUiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiRiIsInMiLCJkb25lIiwidmFsdWUiLCJmIiwidSIsImNhbGwiLCJuZXh0IiwicmV0dXJuIiwiX2RlZmluZVByb3BlcnR5JDEiLCJfaXRlcmFibGVUb0FycmF5IiwiZnJvbSIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsImwiLCJpIiwicHVzaCIsIl9ub25JdGVyYWJsZVJlc3QiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfc2xpY2VkVG9BcnJheSIsIl90b0NvbnN1bWFibGVBcnJheSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwiU3RyaW5nIiwiX3R5cGVvZiIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwidGVzdCIsIl93aW5kb3ciLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJkb2N1bWVudCIsInR5cGVvZnN0ciIsInR5cGVvZm9iaiIsInR5cGVvZmZuIiwidHlwZW9maHRtbGVsZSIsIkhUTUxFbGVtZW50IiwiaW5zdGFuY2VTdHIiLCJvYmoiLCJpbnN0YW5jZVN0cmluZyIsImZuJDYiLCJzdHJpbmciLCJmbiIsImFycmF5IiwiZWxlbWVudE9yQ29sbGVjdGlvbiIsInBsYWluT2JqZWN0Iiwib2JqZWN0IiwibnVtYmVyJDEiLCJudW1iZXIiLCJpc05hTiIsImludGVnZXIiLCJNYXRoIiwiZmxvb3IiLCJodG1sRWxlbWVudCIsImVsZW1lbnQiLCJjb2xsZWN0aW9uIiwiX3ByaXZhdGUiLCJzaW5nbGUiLCJjb3JlIiwic3R5bGVzaGVldCIsImV2ZW50IiwiZW1wdHlTdHJpbmciLCJtYXRjaCIsImRvbUVsZW1lbnQiLCJib3VuZGluZ0JveCIsIngxIiwieDIiLCJ5MSIsInkyIiwicHJvbWlzZSIsInRoZW4iLCJtcyIsInVzZXJBZ2VudCIsIm1lbW9pemUiLCJrZXlGbiIsImFyZ3VtZW50cyIsImFyZ3MiLCJqb2luIiwiX21lbW9pemVkRm4iLCJtZW1vaXplZEZuIiwic2VsZiIsInJldCIsImsiLCJhcHBseSIsImNhY2hlIiwiY2FtZWwyZGFzaCIsInN0ciIsInJlcGxhY2UiLCJ2IiwidG9Mb3dlckNhc2UiLCJkYXNoMmNhbWVsIiwidG9VcHBlckNhc2UiLCJwcmVwZW5kQ2FtZWwiLCJwcmVmaXgiLCJzdWJzdHJpbmciLCJjYXBpdGFsaXplIiwiY2hhckF0IiwiZW5kc1dpdGgiLCJzdWZmaXgiLCJyZ2JhIiwicmdiYU5vQmFja1JlZnMiLCJoc2xhIiwiaHNsYU5vQmFja1JlZnMiLCJoZXgzIiwiaGV4NiIsImFzY2VuZGluZyIsImIiLCJkZXNjZW5kaW5nIiwiZXh0ZW5kIiwiYXNzaWduIiwiYmluZCIsInRndCIsImtleXMiLCJqIiwiaGV4MnR1cGxlIiwiaGV4Iiwic2hvcnRIZXgiLCJnIiwiYmFzZSIsInBhcnNlSW50IiwiaHNsMnR1cGxlIiwiaHNsIiwiaCIsImh1ZTJyZ2IiLCJwIiwicSIsIm0iLCJSZWdFeHAiLCJleGVjIiwicGFyc2VGbG9hdCIsInJvdW5kIiwicmdiMnR1cGxlIiwicmdiIiwiaXNQY3QiLCJjaGFubmVsIiwiYXRMZWFzdE9uZUlzUGN0IiwiYWxsQXJlUGN0IiwiYWxwaGEiLCJjb2xvcm5hbWUydHVwbGUiLCJjb2xvciIsImNvbG9ycyIsImNvbG9yMnR1cGxlIiwidHJhbnNwYXJlbnQiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZSIsImJsdWV2aW9sZXQiLCJicm93biIsImJ1cmx5d29vZCIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmV5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlZCIsInJvc3licm93biIsInJveWFsYmx1ZSIsInNhZGRsZWJyb3duIiwic2FsbW9uIiwic2FuZHlicm93biIsInNlYWdyZWVuIiwic2Vhc2hlbGwiLCJzaWVubmEiLCJzaWx2ZXIiLCJza3libHVlIiwic2xhdGVibHVlIiwic2xhdGVncmF5Iiwic2xhdGVncmV5Iiwic25vdyIsInNwcmluZ2dyZWVuIiwic3RlZWxibHVlIiwidGFuIiwidGVhbCIsInRoaXN0bGUiLCJ0b21hdG8iLCJ0dXJxdW9pc2UiLCJ2aW9sZXQiLCJ3aGVhdCIsIndoaXRlIiwid2hpdGVzbW9rZSIsInllbGxvdyIsInllbGxvd2dyZWVuIiwic2V0TWFwIiwib3B0aW9ucyIsIm1hcCIsIkVycm9yIiwiZ2V0TWFwIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwiZ2xvYmFsIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsImhhc093blByb3BlcnR5IiwiaXNPYmplY3RfMSIsImhhc1JlcXVpcmVkSXNPYmplY3QiLCJyZXF1aXJlSXNPYmplY3QiLCJpc09iamVjdCIsInR5cGUiLCJfZnJlZUdsb2JhbCIsImhhc1JlcXVpcmVkX2ZyZWVHbG9iYWwiLCJyZXF1aXJlX2ZyZWVHbG9iYWwiLCJmcmVlR2xvYmFsIiwiX3Jvb3QiLCJoYXNSZXF1aXJlZF9yb290IiwicmVxdWlyZV9yb290IiwiZnJlZVNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJub3dfMSIsImhhc1JlcXVpcmVkTm93IiwicmVxdWlyZU5vdyIsIm5vdyIsIkRhdGUiLCJfdHJpbW1lZEVuZEluZGV4IiwiaGFzUmVxdWlyZWRfdHJpbW1lZEVuZEluZGV4IiwicmVxdWlyZV90cmltbWVkRW5kSW5kZXgiLCJyZVdoaXRlc3BhY2UiLCJ0cmltbWVkRW5kSW5kZXgiLCJpbmRleCIsIl9iYXNlVHJpbSIsImhhc1JlcXVpcmVkX2Jhc2VUcmltIiwicmVxdWlyZV9iYXNlVHJpbSIsInJlVHJpbVN0YXJ0IiwiYmFzZVRyaW0iLCJfU3ltYm9sIiwiaGFzUmVxdWlyZWRfU3ltYm9sIiwicmVxdWlyZV9TeW1ib2wiLCJfZ2V0UmF3VGFnIiwiaGFzUmVxdWlyZWRfZ2V0UmF3VGFnIiwicmVxdWlyZV9nZXRSYXdUYWciLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldFJhd1RhZyIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJyZXN1bHQiLCJfb2JqZWN0VG9TdHJpbmciLCJoYXNSZXF1aXJlZF9vYmplY3RUb1N0cmluZyIsInJlcXVpcmVfb2JqZWN0VG9TdHJpbmciLCJvYmplY3RUb1N0cmluZyIsIl9iYXNlR2V0VGFnIiwiaGFzUmVxdWlyZWRfYmFzZUdldFRhZyIsInJlcXVpcmVfYmFzZUdldFRhZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlXzEiLCJoYXNSZXF1aXJlZElzT2JqZWN0TGlrZSIsInJlcXVpcmVJc09iamVjdExpa2UiLCJpc09iamVjdExpa2UiLCJpc1N5bWJvbF8xIiwiaGFzUmVxdWlyZWRJc1N5bWJvbCIsInJlcXVpcmVJc1N5bWJvbCIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwidG9OdW1iZXJfMSIsImhhc1JlcXVpcmVkVG9OdW1iZXIiLCJyZXF1aXJlVG9OdW1iZXIiLCJOQU4iLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsImZyZWVQYXJzZUludCIsInRvTnVtYmVyIiwib3RoZXIiLCJ2YWx1ZU9mIiwiaXNCaW5hcnkiLCJkZWJvdW5jZV8xIiwiaGFzUmVxdWlyZWREZWJvdW5jZSIsInJlcXVpcmVEZWJvdW5jZSIsIkZVTkNfRVJST1JfVEVYVCIsIm5hdGl2ZU1heCIsIm1heCIsIm5hdGl2ZU1pbiIsIm1pbiIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJ0cmFpbGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwidGhpc0FyZyIsImxlYWRpbmdFZGdlIiwic2V0VGltZW91dCIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImNsZWFyVGltZW91dCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImRlYm91bmNlRXhwb3J0cyIsInBlcmZvcm1hbmNlJDEiLCJwZXJmb3JtYW5jZSIsInBub3ciLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInBlcmZvcm1hbmNlTm93IiwiREVGQVVMVF9IQVNIX1NFRUQiLCJLIiwiREVGQVVMVF9IQVNIX1NFRURfQUxUIiwiaGFzaEl0ZXJhYmxlSW50cyIsInNlZWQiLCJoYXNoIiwiZW50cnkiLCJoYXNoSW50IiwibnVtIiwiaGFzaEludEFsdCIsImNvbWJpbmVIYXNoZXMiLCJoYXNoMSIsImhhc2gyIiwiY29tYmluZUhhc2hlc0FycmF5IiwiaGFzaGVzIiwiaGFzaEFycmF5cyIsImhhc2hlczEiLCJoYXNoZXMyIiwiaGFzaEludHNBcnJheSIsImludHMiLCJoYXNoU3RyaW5nIiwiY2hhckNvZGVBdCIsImhhc2hTdHJpbmdzIiwiaGFzaFN0cmluZ3NBcnJheSIsInN0cnMiLCJyb3RhdGVQb2ludCIsInkiLCJjZW50ZXJYIiwiY2VudGVyWSIsImFuZ2xlRGVncmVlcyIsImFuZ2xlUmFkaWFucyIsIlBJIiwicm90YXRlZFgiLCJjb3MiLCJzaW4iLCJyb3RhdGVkWSIsIm1vdmVQb2ludEJ5Qm94QXNwZWN0IiwiYm94WCIsImJveFkiLCJza2V3WCIsInNrZXdZIiwicm90YXRlUG9zQW5kU2tld0J5Qm94IiwicG9zIiwiYm94IiwidyIsInJvdGF0ZWQiLCJza2V3ZWQiLCJ3YXJuaW5nc0VuYWJsZWQiLCJ3YXJuU3VwcG9ydGVkIiwiY29uc29sZSIsIndhcm4iLCJ0cmFjZVN1cHBvcnRlZCIsInRyYWNlIiwiTUFYX0lOVCQxIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInRydWVpZnkiLCJmYWxzaWZ5IiwiemVyb2lmeSIsIm5vb3AkMSIsIm5vb3AiLCJlcnJvciIsIm1zZyIsIndhcm5pbmdzIiwiZW5hYmxlZCIsImxvZyIsImNsb25lIiwiY29weSIsImNvcHlBcnJheSIsImFyciIsInV1aWQiLCJyYW5kb20iLCJfc3RhdGljRW1wdHlPYmplY3QiLCJzdGF0aWNFbXB0eU9iamVjdCIsImRlZmF1bHRzJGciLCJkZWZhdWx0cyIsIl9kZWZhdWx0cyIsIm9wdHMiLCJmaWxsZWRPcHRzIiwib3B0VmFsIiwicmVtb3ZlRnJvbUFycmF5IiwiZWxlIiwib25lQ29weSIsInNwbGljZSIsImNsZWFyQXJyYXkiLCJvdGhlckFyciIsImVsIiwiZ2V0UHJlZml4ZWRQcm9wZXJ0eSIsInByb3BOYW1lIiwic2V0UHJlZml4ZWRQcm9wZXJ0eSIsIk9iamVjdE1hcCIsIl9vYmoiLCJzZXQiLCJ2YWwiLCJfZGVsZXRlIiwiY2xlYXIiLCJoYXMiLCJnZXQiLCJNYXAkMSIsIk1hcCIsInVuZGVmIiwiT2JqZWN0U2V0IiwiYXJyYXlPck9iamVjdFNldCIsImNyZWF0ZSIsInNpemUiLCJ0b0FycmF5IiwiYWRkIiwiX3RoaXMiLCJmaWx0ZXIiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJTZXQkMSIsIlNldCIsIkVsZW1lbnQiLCJjeSIsInBhcmFtcyIsInJlc3RvcmUiLCJncm91cCIsImRhdGEiLCJzb3VyY2UiLCJ0YXJnZXQiLCJfcCIsInBvc2l0aW9uIiwiYXV0b1dpZHRoIiwiYXV0b0hlaWdodCIsImF1dG9QYWRkaW5nIiwiY29tcG91bmRCb3VuZHNDbGVhbiIsImxpc3RlbmVycyIsInN0eWxlIiwicnN0eWxlIiwic3R5bGVDeHRzIiwic3R5bGVLZXlzIiwicmVtb3ZlZCIsInNlbGVjdGVkIiwic2VsZWN0YWJsZSIsImxvY2tlZCIsImdyYWJiZWQiLCJncmFiYmFibGUiLCJwYW5uYWJsZSIsImFjdGl2ZSIsImNsYXNzZXMiLCJhbmltYXRpb24iLCJjdXJyZW50IiwicXVldWUiLCJyc2NyYXRjaCIsInNjcmF0Y2giLCJlZGdlcyIsImNoaWxkcmVuIiwicGFyZW50IiwiaXNOb2RlIiwidHJhdmVyc2FsQ2FjaGUiLCJiYWNrZ3JvdW5kaW5nIiwiYmJDYWNoZSIsImJiQ2FjaGVTaGlmdCIsImJvZHlCb3VuZHMiLCJvdmVybGF5Qm91bmRzIiwibGFiZWxCb3VuZHMiLCJhbGwiLCJtYWluIiwiYXJyb3dCb3VuZHMiLCJyZW5kZXJlZFBvc2l0aW9uIiwicnBvcyIsInBhbiIsInpvb20iLCJzcGxpdCIsImNscyIsImNyZWF0ZUVtaXR0ZXIiLCJieXBhc3MiLCJjc3MiLCJkZWZpbmVTZWFyY2giLCJiZnMiLCJkZnMiLCJzZWFyY2hGbiIsInJvb3RzIiwiZGlyZWN0ZWQiLCJ2aXNpdCIsIlEiLCJjb25uZWN0ZWROb2RlcyIsImNvbm5lY3RlZEJ5IiwiaWQyZGVwdGgiLCJWIiwiZm91bmQiLCJfdGhpcyRieUdyb3VwIiwiYnlHcm91cCIsIm5vZGVzIiwidmkiLCJ2aUlkIiwiaWQiLCJ1bnNoaWZ0IiwiX2xvb3AiLCJzaGlmdCIsInBvcCIsInZJZCIsImRlcHRoIiwicHJldkVkZ2UiLCJzcmMiLCJwcmV2Tm9kZSIsInNhbWUiLCJ2d0VkZ2VzIiwiY29ubmVjdGVkRWRnZXMiLCJfaTIiLCJ3SWQiLCJfcmV0IiwiY29ubmVjdGVkRWxlcyIsIl9pIiwibm9kZSIsImVkZ2UiLCJwYXRoIiwiZWxlc2ZuJHYiLCJicmVhZHRoRmlyc3RTZWFyY2giLCJkZXB0aEZpcnN0U2VhcmNoIiwiaGVhcCQyIiwiZXhwb3J0cyIsImhlYXAkMSIsImhhc1JlcXVpcmVkSGVhcCQxIiwicmVxdWlyZUhlYXAkMSIsIm1vZHVsZSIsIkhlYXAiLCJkZWZhdWx0Q21wIiwiaGVhcGlmeSIsImhlYXBwb3AiLCJoZWFwcHVzaCIsImhlYXBwdXNocG9wIiwiaGVhcHJlcGxhY2UiLCJpbnNvcnQiLCJubGFyZ2VzdCIsIm5zbWFsbGVzdCIsInVwZGF0ZUl0ZW0iLCJfc2lmdGRvd24iLCJfc2lmdHVwIiwibG8iLCJoaSIsImNtcCIsIm1pZCIsImNvbmNhdCIsIml0ZW0iLCJsYXN0ZWx0IiwicmV0dXJuaXRlbSIsIl9yZWYiLCJfbGVuIiwiX3JlZjEiLCJfcmVzdWx0cyIsIl9yZXN1bHRzMSIsIl9qIiwicmV2ZXJzZSIsImluZGV4T2YiLCJlbGVtIiwic29ydCIsImxvcyIsInN0YXJ0cG9zIiwibmV3aXRlbSIsInBhcmVudHBvcyIsImNoaWxkcG9zIiwiZW5kcG9zIiwicmlnaHRwb3MiLCJwdXNocG9wIiwicGVlayIsImNvbnRhaW5zIiwiZW1wdHkiLCJoZWFwIiwiaW5zZXJ0IiwidG9wIiwiZnJvbnQiLCJmYWN0b3J5IiwiaGFzUmVxdWlyZWRIZWFwIiwicmVxdWlyZUhlYXAiLCJoZWFwRXhwb3J0cyIsImRpamtzdHJhRGVmYXVsdHMiLCJ3ZWlnaHQiLCJlbGVzZm4kdSIsImRpamtzdHJhIiwiX2RpamtzdHJhRGVmYXVsdHMiLCJlbGVzIiwid2VpZ2h0Rm4iLCJkaXN0IiwicHJldiIsImtub3duRGlzdCIsInVubWVyZ2VCeSIsImlzTG9vcCIsImdldERpc3QiLCJzZXREaXN0IiwiZCIsIkluZmluaXR5IiwiZGlzdEJldHdlZW4iLCJ1dnMiLCJlZGdlc1RvIiwiZWRnZXNXaXRoIiwiaW50ZXJzZWN0Iiwic21hbGxlc3REaXN0YW5jZSIsInNtYWxsZXN0RWRnZSIsIl93ZWlnaHQiLCJzbWFsbGV0c0Rpc3QiLCJ1aWQiLCJuZWlnaGJvcnMiLCJuZWlnaGJvcmhvb2QiLCJ2aWQiLCJ2RGlzdCIsImFsdCIsImRpc3RhbmNlVG8iLCJwYXRoVG8iLCJTIiwic3Bhd24iLCJlbGVzZm4kdCIsImtydXNrYWwiLCJudW1Ob2RlcyIsImZvcmVzdCIsIkEiLCJmaW5kU2V0SW5kZXgiLCJzZXRVSW5kZXgiLCJzZXRWSW5kZXgiLCJzZXRVIiwic2V0ViIsIm1lcmdlIiwiYVN0YXJEZWZhdWx0cyIsImdvYWwiLCJoZXVyaXN0aWMiLCJlbGVzZm4kcyIsImFTdGFyIiwiX2FTdGFyRGVmYXVsdHMiLCJzaWQiLCJ0aWQiLCJnU2NvcmUiLCJmU2NvcmUiLCJjbG9zZWRTZXRJZHMiLCJvcGVuU2V0Iiwib3BlblNldElkcyIsImNhbWVGcm9tIiwiY2FtZUZyb21FZGdlIiwiYWRkVG9PcGVuU2V0IiwiY01pbiIsImNNaW5JZCIsInBvcEZyb21PcGVuU2V0IiwiaXNJbk9wZW5TZXQiLCJzdGVwcyIsInBhdGhOb2RlIiwicGF0aE5vZGVJZCIsInBhdGhFZGdlIiwiZGlzdGFuY2UiLCJoYXNFbGVtZW50V2l0aElkIiwid1NyYyIsIndUZ3QiLCJ3aWQiLCJ0ZW1wU2NvcmUiLCJmbG95ZFdhcnNoYWxsRGVmYXVsdHMiLCJlbGVzZm4kciIsImZsb3lkV2Fyc2hhbGwiLCJfZmxveWRXYXJzaGFsbERlZmF1bHQiLCJOIiwiTnNxIiwiYXRJbmRleCIsImVkZ2VOZXh0Iiwic3QiLCJ0cyIsImlrIiwiaWoiLCJraiIsImdldEFyZ0VsZSIsImluZGV4T2ZBcmdFbGUiLCJyZXMiLCJ0byIsImZyb21Ob2RlIiwiYmVsbG1hbkZvcmREZWZhdWx0cyIsImVsZXNmbiRxIiwiYmVsbG1hbkZvcmQiLCJfYmVsbG1hbkZvcmREZWZhdWx0cyIsImluZm9NYXAiLCJoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlIiwibmVnYXRpdmVXZWlnaHRDeWNsZXMiLCJudW1FZGdlcyIsImdldEluZm8iLCJnZXROb2RlRnJvbVRvIiwiJCIsInRoaXNTdGFydCIsImVuZCIsIl9nZXRJbmZvIiwicHJlZCIsImluZm8iLCJyZXBsYWNlZEVkZ2UiLCJjaGVja0ZvckVkZ2VSZXBsYWNlbWVudCIsIm5vZGUxIiwibm9kZTIiLCJpbmZvMSIsImluZm8yIiwic3JjSW5mbyIsInRndEluZm8iLCJuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzIiwiX2UiLCJfZWRnZSIsIl9zcmMiLCJfdGd0IiwiX3dlaWdodDIiLCJzcmNEaXN0IiwidGd0RGlzdCIsImZpbmROZWdhdGl2ZVdlaWdodEN5Y2xlcyIsIm5lZ2F0aXZlTm9kZXMiLCJudW1OZWdhdGl2ZU5vZGVzIiwic3RhcnQiLCJjeWNsZSIsIl9ub2RlIiwic21hbGxlc3RJZCIsInNtYWxsZXN0SW5kZXgiLCJjIiwiY3ljbGVJZCIsInNxcnQyIiwic3FydCIsImNvbGxhcHNlIiwiZWRnZUluZGV4Iiwibm9kZU1hcCIsInJlbWFpbmluZ0VkZ2VzIiwiZWRnZUluZm8iLCJzb3VyY2VJbiIsInRhcmdldEluIiwicGFydGl0aW9uMSIsInBhcnRpdGlvbjIiLCJuZXdFZGdlcyIsImNvbnRyYWN0VW50aWwiLCJtZXRhTm9kZU1hcCIsInNpemVMaW1pdCIsImVsZXNmbiRwIiwia2FyZ2VyU3RlaW4iLCJudW1JdGVyIiwiY2VpbCIsInBvdyIsIkxOMiIsInN0b3BTaXplIiwiZWRnZUluZGV4ZXMiLCJtaW5DdXRTaXplIiwibWluQ3V0RWRnZUluZGV4ZXMiLCJtaW5DdXROb2RlTWFwIiwibWV0YU5vZGVNYXAyIiwiY29weU5vZGVzTWFwIiwiX2kzIiwiaXRlciIsIl9pNCIsImVkZ2VzU3RhdGUiLCJlZGdlc1N0YXRlMiIsInJlczEiLCJyZXMyIiwiY3V0Iiwid2l0bmVzc05vZGVQYXJ0aXRpb24iLCJfaTUiLCJwYXJ0aXRpb25JZCIsImNvbnN0cnVjdENvbXBvbmVudCIsInN1YnNldCIsImNvbXBvbmVudCIsImNvbXBvbmVudHMiLCJfTWF0aCRoeXBvdCIsImNvcHlQb3NpdGlvbiIsIm1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uJDEiLCJtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiIsInJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uIiwiYXJyYXkycG9pbnQiLCJiZWdpbiIsImlzRmluaXRlIiwibWVhbiIsInRvdGFsIiwibWVkaWFuIiwiaW5jbHVkZUhvbGVzIiwib2ZmIiwibGVuIiwiZGVnMnJhZCIsImRlZyIsImdldEFuZ2xlRnJvbURpc3AiLCJkaXNwWCIsImRpc3BZIiwiYXRhbjIiLCJsb2cyIiwic2lnbnVtIiwicDEiLCJwMiIsInNxZGlzdCIsImR4IiwiZHkiLCJpblBsYWNlU3VtTm9ybWFsaXplIiwicWJlemllckF0IiwicDAiLCJxYmV6aWVyUHRBdCIsImxpbmVBdCIsInZlYyIsInZlY0Rpc3QiLCJub3JtVmVjIiwiYm91bmQiLCJtYWtlQm91bmRpbmdCb3giLCJiYiIsImNvcHlCb3VuZGluZ0JveCIsImNsZWFyQm91bmRpbmdCb3giLCJ1cGRhdGVCb3VuZGluZ0JveCIsImJiMSIsImJiMiIsImV4cGFuZEJvdW5kaW5nQm94QnlQb2ludCIsImV4cGFuZEJvdW5kaW5nQm94IiwicGFkZGluZyIsImV4cGFuZEJvdW5kaW5nQm94U2lkZXMiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJfcGFkZGluZyIsImFzc2lnbkJvdW5kaW5nQm94IiwiYm91bmRpbmdCb3hlc0ludGVyc2VjdCIsImluQm91bmRpbmdCb3giLCJwb2ludEluQm91bmRpbmdCb3giLCJwdCIsImJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCIsImh5cG90IiwiaW5mbGF0ZVBvbHlnb24iLCJwb2x5Z29uIiwic3ViIiwic2NhbGUiLCJjcm9zcyIsIm5vcm1hbGl6ZSIsInNpZ25lZEFyZWEiLCJwdHMiLCJpbnRlcnNlY3RMaW5lcyIsInAzIiwicDQiLCJkZW5vbSIsImFicyIsIm5vcm1hbHMiLCJvdXQiLCJvZmZzZXRFZGdlcyIsIm5ybSIsImluZmxhdGVkIiwiY3VyckVkZ2UiLCJpcCIsIm1pdGVyQm94Iiwid2lkdGgiLCJoZWlnaHQiLCJzdHJva2VXaWR0aCIsInRwdHMiLCJ0cmFuc2Zvcm1Qb2ludHMiLCJvZmZzZXRQb2ludHMiLCJyb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUiLCJub2RlWCIsIm5vZGVZIiwicmFkaXVzIiwiY29ybmVyUmFkaXVzIiwiZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMiLCJoYWxmV2lkdGgiLCJoYWxmSGVpZ2h0IiwiZG9XaWR0aCIsImRvSGVpZ2h0Iiwic3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyIsInRvcFN0YXJ0WCIsInRvcFN0YXJ0WSIsInRvcEVuZFgiLCJ0b3BFbmRZIiwiZmluaXRlTGluZXNJbnRlcnNlY3QiLCJyaWdodFN0YXJ0WCIsInJpZ2h0U3RhcnRZIiwicmlnaHRFbmRYIiwicmlnaHRFbmRZIiwiYm90dG9tU3RhcnRYIiwiYm90dG9tU3RhcnRZIiwiYm90dG9tRW5kWCIsImJvdHRvbUVuZFkiLCJsZWZ0U3RhcnRYIiwibGVmdFN0YXJ0WSIsImxlZnRFbmRYIiwibGVmdEVuZFkiLCJhcmNJbnRlcnNlY3Rpb25zIiwidG9wTGVmdENlbnRlclgiLCJ0b3BMZWZ0Q2VudGVyWSIsImludGVyc2VjdExpbmVDaXJjbGUiLCJ0b3BSaWdodENlbnRlclgiLCJ0b3BSaWdodENlbnRlclkiLCJib3R0b21SaWdodENlbnRlclgiLCJib3R0b21SaWdodENlbnRlclkiLCJib3R0b21MZWZ0Q2VudGVyWCIsImJvdHRvbUxlZnRDZW50ZXJZIiwiaW5MaW5lVmljaW5pdHkiLCJseDEiLCJseTEiLCJseDIiLCJseTIiLCJ0b2xlcmFuY2UiLCJpbkJlemllclZpY2luaXR5IiwieDMiLCJ5MyIsInNvbHZlUXVhZHJhdGljIiwic3FydFIiLCJyb290MSIsInJvb3QyIiwic29sdmVDdWJpYyIsImVwc2lsb24iLCJkaXNjcmltaW5hbnQiLCJkdW0xIiwidGVybTEiLCJyMTMiLCJhY29zIiwic3FkaXN0VG9RdWFkcmF0aWNCZXppZXIiLCJ6ZXJvVGhyZXNob2xkIiwibWluRGlzdGFuY2VTcXVhcmVkIiwiY3VyWCIsImN1clkiLCJkaXN0U3F1YXJlZCIsInNxZGlzdFRvRmluaXRlTGluZSIsIm9mZnNldCIsImxpbmUiLCJsaW5lU3EiLCJoeXBTcSIsImRvdFByb2R1Y3QiLCJhZGpTcSIsInBvaW50SW5zaWRlUG9seWdvblBvaW50cyIsInBvaW50cyIsInVwIiwicG9pbnRJbnNpZGVQb2x5Z29uIiwiYmFzZVBvaW50cyIsImRpcmVjdGlvbiIsInRyYW5zZm9ybWVkUG9pbnRzIiwiYW5nbGUiLCJhdGFuIiwiZXhwYW5kZWRMaW5lU2V0IiwiZXhwYW5kUG9seWdvbiIsImpvaW5MaW5lcyIsInBvaW50SW5zaWRlUm91bmRQb2x5Z29uIiwiY29ybmVycyIsImN1dFBvbHlnb25Qb2ludHMiLCJjb3JuZXIiLCJzdGFydFgiLCJzdGFydFkiLCJzdG9wWCIsInN0b3BZIiwic3F1YXJlZERpc3RhbmNlIiwiY3giLCJsaW5lU2V0IiwidmVydGljZXMiLCJjdXJyZW50TGluZVN0YXJ0WCIsImN1cnJlbnRMaW5lU3RhcnRZIiwiY3VycmVudExpbmVFbmRYIiwiY3VycmVudExpbmVFbmRZIiwibmV4dExpbmVTdGFydFgiLCJuZXh0TGluZVN0YXJ0WSIsIm5leHRMaW5lRW5kWCIsIm5leHRMaW5lRW5kWSIsImludGVyc2VjdGlvbiIsInBhZCIsImN1cnJlbnRQb2ludFgiLCJjdXJyZW50UG9pbnRZIiwibmV4dFBvaW50WCIsIm5leHRQb2ludFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIm9mZnNldExlbmd0aCIsIm5vcm1hbGl6ZWRPZmZzZXRYIiwibm9ybWFsaXplZE9mZnNldFkiLCJpbnRlcnNlY3RMaW5lRWxsaXBzZSIsImVsbGlwc2VXcmFkaXVzIiwiZWxsaXBzZUhyYWRpdXMiLCJuZXdMZW5ndGgiLCJsZW5Qcm9wb3J0aW9uIiwiY2hlY2tJbkVsbGlwc2UiLCJ0MSIsInQyIiwidE1pbiIsInRNYXgiLCJpblJhbmdlUGFyYW1zIiwibmVhckludGVyc2VjdGlvblgiLCJuZWFySW50ZXJzZWN0aW9uWSIsImZhckludGVyc2VjdGlvblgiLCJmYXJJbnRlcnNlY3Rpb25ZIiwibWlkT2ZUaHJlZSIsIng0IiwieTQiLCJpbmZpbml0ZUxpbmVzIiwiZHgxMyIsImR4MjEiLCJkeDQzIiwiZHkxMyIsImR5MjEiLCJkeTQzIiwidWFfdCIsInViX3QiLCJ1X2IiLCJ1YSIsInViIiwiZmxwdFRocmVzaG9sZCIsIl9taW4iLCJfbWF4IiwiaGFsZlciLCJoYWxmSCIsInBvbHlnb25JbnRlcnNlY3RMaW5lIiwiaW50ZXJzZWN0aW9ucyIsImRvVHJhbnNmb3JtIiwiY3VycmVudFgiLCJjdXJyZW50WSIsIm5leHRYIiwibmV4dFkiLCJyb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lIiwibGluZXMiLCJsb3dlc3RJbnRlcnNlY3Rpb24iLCJsb3dlc3RTcXVhcmVkRGlzdGFuY2UiLCJzaG9ydGVuSW50ZXJzZWN0aW9uIiwiYW1vdW50IiwiZGlzcCIsImxlblJhdGlvIiwiZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlIiwic2lkZXMiLCJyb3RhdGlvblJhZGlhbnMiLCJnZW5lcmF0ZVVuaXROZ29uUG9pbnRzIiwiZml0UG9seWdvblRvU3F1YXJlIiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsInN4Iiwic3kiLCJfaTYiLCJpbmNyZW1lbnQiLCJzdGFydEFuZ2xlIiwiY3VycmVudEFuZ2xlIiwiZ2V0Um91bmRQb2x5Z29uUmFkaXVzIiwiZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoIiwiYmV6aWVyUHRzVG9RdWFkQ29lZmYiLCJnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyIsImhlaWdodE9mZnNldCIsIndpZHRoT2Zmc2V0IiwiY3RybFB0T2Zmc2V0UGN0Iiwic2F0UG9seWdvbkludGVyc2VjdGlvbiIsInBvbHkxIiwicG9seTIiLCJnZXRBeGVzIiwiYXhlcyIsIm5vcm1hbCIsInByb2plY3QiLCJheGlzIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJwb2ludCIsInByb2plY3Rpb24iLCJlcnIiLCJvdmVybGFwcyIsInByb2oxIiwicHJvajIiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwicGFnZVJhbmtEZWZhdWx0cyIsImRhbXBpbmdGYWN0b3IiLCJwcmVjaXNpb24iLCJpdGVyYXRpb25zIiwiZWxlc2ZuJG8iLCJwYWdlUmFuayIsIl9wYWdlUmFua0RlZmF1bHRzIiwibnVtTm9kZXNTcWQiLCJtYXRyaXgiLCJjb2x1bW5TdW0iLCJhZGRpdGlvbmFsUHJvYiIsInNyY0lkIiwidGd0SWQiLCJpbmRleE9mSWQiLCJfbiIsIl9uMiIsIl9uMyIsImVpZ2VudmVjdG9yIiwidGVtcCIsInByZXZpb3VzIiwiX2oyIiwiX240IiwiZGlmZiIsIl9pNyIsImRlbHRhIiwicmFuayIsImRlZmF1bHRzJGYiLCJlbGVzZm4kbiIsImRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkIiwiZGVncmVlcyIsIm1heERlZ3JlZSIsImN1cnJEZWdyZWUiLCJkZWdyZWVDZW50cmFsaXR5IiwiZGVncmVlIiwiaW5kZWdyZWVzIiwib3V0ZGVncmVlcyIsIm1heEluZGVncmVlIiwibWF4T3V0ZGVncmVlIiwiX2N1cnJEZWdyZWUiLCJpbmRlZ3JlZSIsIm91dGRlZ3JlZSIsImNhbGxpbmdFbGVzIiwiX29wdGlvbnMiLCJjb25uRWRnZXMiLCJpbmNvbWluZyIsIm91dGdvaW5nIiwia19pbiIsImtfb3V0Iiwic19pbiIsInNfb3V0IiwiZGMiLCJkY24iLCJkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXNlZCIsImRlZmF1bHRzJGUiLCJoYXJtb25pYyIsImVsZXNmbiRtIiwiY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQiLCJjbG9zZW5lc3NlcyIsIm1heENsb3NlbmVzcyIsImZ3IiwiY3VyckNsb3NlbmVzcyIsIm5vZGVfaSIsImNsb3NlbmVzcyIsImNsb3NlbmVzc0NlbnRyYWxpdHkiLCJfZGVmYXVsdHMyIiwidG90YWxEaXN0YW5jZSIsImNjIiwiY2NuIiwiY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGlzZWQiLCJkZWZhdWx0cyRkIiwiZWxlc2ZuJGwiLCJiZXR3ZWVubmVzc0NlbnRyYWxpdHkiLCJ3ZWlnaHRlZCIsIl9DIiwiQyIsIm91dGdvZXJzIiwib3Blbk5laWdoYm9yaG9vZCIsIlAiLCJfdmlkIiwiX3YiLCJ2RWxlIiwiZ2V0RWxlbWVudEJ5SWQiLCJlZGdlV2VpZ2h0IiwiX3ciLCJfdzIiLCJfdjIiLCJiZXR3ZWVubmVzcyIsImJldHdlZW5uZXNzTm9ybWFsaXplZCIsImJldHdlZW5uZXNzTm9ybWFsaXNlZCIsImJjIiwiZGVmYXVsdHMkYyIsImV4cGFuZEZhY3RvciIsImluZmxhdGVGYWN0b3IiLCJtdWx0RmFjdG9yIiwibWF4SXRlcmF0aW9ucyIsImF0dHJpYnV0ZXMiLCJzZXRPcHRpb25zJDMiLCJzZXRPcHRpb25zIiwiZ2V0U2ltaWxhcml0eSQxIiwiZ2V0U2ltaWxhcml0eSIsImFkZExvb3BzIiwiTSIsInN1bSIsImNvbCIsInJvdyIsIl9yb3ciLCJtbXVsdCIsIkIiLCJleHBhbmQiLCJfTSIsImluZmxhdGUiLCJoYXNDb252ZXJnZWQiLCJuMiIsInJvdW5kRmFjdG9yIiwidjEiLCJ2MiIsImFzc2lnbiQyIiwiY2x1c3RlcnMiLCJjbHVzdGVyIiwiaXNEdXBsaWNhdGUiLCJjMSIsImMyIiwicmVtb3ZlRHVwbGljYXRlcyIsIm1hcmtvdkNsdXN0ZXJpbmciLCJpZDJwb3NpdGlvbiIsInNpbSIsImlzU3RpbGxNb3ZpbmciLCJtYXJrb3ZDbHVzdGVyaW5nJDEiLCJtY2wiLCJpZGVudGl0eSQxIiwiaWRlbnRpdHkiLCJhYnNEaWZmIiwiYWRkQWJzRGlmZiIsImFkZFNxdWFyZWREaWZmIiwibWF4QWJzRGlmZiIsImN1cnJlbnRNYXgiLCJnZXREaXN0YW5jZSIsImdldFAiLCJnZXRRIiwiaW5pdCIsInBvc3QiLCJkaW0iLCJkaXN0YW5jZXMiLCJldWNsaWRlYW4iLCJzcXVhcmVkRXVjbGlkZWFuIiwibWFuaGF0dGFuIiwiY2x1c3RlcmluZ0Rpc3RhbmNlIiwibWV0aG9kIiwibm9kZVAiLCJub2RlUSIsImltcGwiLCJkZWZhdWx0cyRiIiwic2Vuc2l0aXZpdHlUaHJlc2hvbGQiLCJ0ZXN0TW9kZSIsInRlc3RDZW50cm9pZHMiLCJzZXRPcHRpb25zJDIiLCJjZW50cm9pZCIsIm1vZGUiLCJub05vZGVQIiwicmFuZG9tQ2VudHJvaWRzIiwibmRpbSIsImNlbnRyb2lkcyIsImNsYXNzaWZ5IiwiYnVpbGRDbHVzdGVyIiwiYXNzaWdubWVudCIsImhhdmVWYWx1ZXNDb252ZXJnZWQiLCJoYXZlTWF0cmljZXNDb252ZXJnZWQiLCJzZWVuQmVmb3JlIiwibWVkb2lkcyIsInJhbmRvbU1lZG9pZHMiLCJmaW5kQ29zdCIsInBvdGVudGlhbE5ld01lZG9pZCIsImNvc3QiLCJrTWVhbnMiLCJuZXdDZW50cm9pZCIsImtNZWRvaWRzIiwiY3VyQ29zdCIsIm1pbkNvc3RzIiwidXBkYXRlQ2VudHJvaWRzIiwiVSIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiX2MiLCJ1cGRhdGVNZW1iZXJzaGlwIiwiX1UiLCJhc3NpZ24kMSIsIl9jMiIsIl9jMyIsImZ1enp5Q01lYW5zIiwiZGVncmVlT2ZNZW1iZXJzaGlwIiwia0NsdXN0ZXJpbmciLCJmY20iLCJkZWZhdWx0cyRhIiwibGlua2FnZSIsInRocmVzaG9sZCIsImFkZERlbmRyb2dyYW0iLCJkZW5kcm9ncmFtRGVwdGgiLCJsaW5rYWdlQWxpYXNlcyIsInNldE9wdGlvbnMkMSIsInByZWZlcnJlZEFsaWFzIiwibWVyZ2VDbG9zZXN0IiwiZGlzdHMiLCJtaW5zIiwibWluS2V5IiwiYXR0cnMiLCJuMSIsIl9kaXN0IiwibWVyZ2VkIiwiY3VyIiwia2V5MSIsImtleTIiLCJfZ2V0QWxsQ2hpbGRyZW4iLCJnZXRBbGxDaGlsZHJlbiIsIl9idWlsZERlbmRyb2dyYW0iLCJidWlsZERlbmRyb2dyYW0iLCJsZWZ0U3RyIiwicmlnaHRTdHIiLCJfYnVpbGRDbHVzdGVyc0Zyb21UcmVlIiwiYnVpbGRDbHVzdGVyc0Zyb21UcmVlIiwibGVhdmVzIiwiaGllcmFyY2hpY2FsQ2x1c3RlcmluZyIsInJldENsdXN0ZXJzIiwiaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxIiwiaGNhIiwiZGVmYXVsdHMkOSIsInByZWZlcmVuY2UiLCJkYW1waW5nIiwibWluSXRlcmF0aW9ucyIsImRtcCIsInByZWYiLCJ2YWxpZFByZWZzIiwic29tZSIsImF0dHIiLCJnZXRQcmVmZXJlbmNlIiwiZmluZEV4ZW1wbGFycyIsIlIiLCJpbmRpY2VzIiwiYXNzaWduQ2x1c3RlcnMiLCJleGVtcGxhcnMiLCJlaSIsIl9laSIsImlpIiwibWF4SSIsIm1heFN1bSIsImFmZmluaXR5UHJvcGFnYXRpb24iLCJvbGQiLCJScCIsInNlIiwiX2k4IiwibWF4MiIsIkFTIiwiX2k5IiwiX2ozIiwiX2o0IiwiX2kxMCIsIkUiLCJfc3VtIiwiX2kxMSIsIl9qNSIsImV4ZW1wbGFyc0luZGljZXMiLCJjbHVzdGVySW5kaWNlcyIsIl9pMTIiLCJjbHVzdGVySW5kZXgiLCJhZmZpbml0eVByb3BhZ2F0aW9uJDEiLCJhcCIsImhpZXJob2x6ZXJEZWZhdWx0cyIsImVsZXNmbiRrIiwiaGllcmhvbHplciIsIl9oaWVyaG9semVyRGVmYXVsdHMiLCJkZmxhZyIsIm9kZEluIiwib2RkT3V0Iiwic3RhcnRWZXJ0ZXgiLCJpbmQiLCJvdXRkIiwiZDEiLCJkMiIsImlzRWRnZSIsInRyYWlsIiwid2FsayIsImN1cnJlbnROb2RlIiwic3VidG91ciIsImFkaiIsImFkalRhaWwiLCJhZGpIZWFkIiwiaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCIsImVkZ2VDb3VudCIsInN0YWNrIiwidmlzaXRlZEVkZ2VzIiwiYnVpbGRDb21wb25lbnQiLCJjdXRzZXQiLCJub2RlSWQiLCJjdXRWZXJ0ZXgiLCJfYmljb25uZWN0ZWRTZWFyY2giLCJiaWNvbm5lY3RlZFNlYXJjaCIsImxvdyIsInNvdXJjZUlkIiwidGFyZ2V0SWQiLCJvdGhlck5vZGVJZCIsImVkZ2VJZCIsImN1dFZlcnRpY2VzIiwiaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCQxIiwiaHRiYyIsImh0YiIsImhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWRDb21wb25lbnRzIiwidGFyamFuU3Ryb25nbHlDb25uZWN0ZWQiLCJfc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2giLCJzdHJvbmdseUNvbm5lY3RlZFNlYXJjaCIsInNvdXJjZU5vZGVJZCIsImV4cGxvcmVkIiwidGFyZ2V0Tm9kZUlkIiwiY29tcG9uZW50Tm9kZXMiLCJjb21wb25lbnRFZGdlcyIsImRpZmZlcmVuY2UiLCJ0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCQxIiwidHNjIiwidHNjYyIsInRhcmphblN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50cyIsImVsZXNmbiRqIiwicHJvcHMiLCJTVEFURV9QRU5ESU5HIiwiU1RBVEVfRlVMRklMTEVEIiwiU1RBVEVfUkVKRUNURUQiLCJfYXBpIiwiYXBpIiwiZXhlY3V0b3IiLCJzdGF0ZSIsImZ1bGZpbGxWYWx1ZSIsInJlamVjdFJlYXNvbiIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInByb3h5IiwiZnVsZmlsbCIsInJlamVjdCIsImRlbGl2ZXIiLCJjdXJyIiwicmVzb2x2ZXIiLCJleGVjdXRlIiwiZXhlY3V0ZV9oYW5kbGVycyIsImhhbmRsZXJzIiwic2V0SW1tZWRpYXRlIiwiY2IiLCJfcmVzb2x2ZSIsInJlc29sdmUiLCJyZXNvbHZlZCIsInBzIiwicmVzb2x2ZUFsbCIsInJlamVjdEFsbCIsInZhbHMiLCJkb25lQ291bnQiLCJpc1Byb21pc2UiLCJQcm9taXNlJDEiLCJQcm9taXNlIiwiQW5pbWF0aW9uIiwib3B0czIiLCJpc0NvcmUiLCJpc0VsZSIsImR1cmF0aW9uIiwic3RhcnRlZCIsInBsYXlpbmciLCJob29rZWQiLCJhcHBseWluZyIsInByb2dyZXNzIiwiY29tcGxldGVzIiwiZnJhbWVzIiwiY29tcGxldGUiLCJzdGFydFBvc2l0aW9uIiwic3RhcnRTdHlsZSIsImdldEFuaW1hdGlvblN0YXJ0U3R5bGUiLCJzdGFydFBhbiIsInN0YXJ0Wm9vbSIsImFuaWZuIiwiaG9vayIsInRBbmkiLCJhZGRUb0FuaW1hdGlvblBvb2wiLCJwbGF5Iiwic3RvcHBlZCIsInBhdXNlIiwic3RvcCIsInJld2luZCIsImZhc3Rmb3J3YXJkIiwid2FzUGxheWluZyIsImNvbXBsZXRlZCIsInN3YXAiLCJfcGEiLCJwcm9wIiwic3RhcnRTdHlsZVByb3AiLCJydW4iLCJydW5uaW5nIiwiZGVmaW5lJDMiLCJhbmltYXRlZCIsImFuaW1hdGVkSW1wbCIsInNlbGZJc0FycmF5TGlrZSIsInN0eWxlRW5hYmxlZCIsImNsZWFyUXVldWUiLCJjbGVhclF1ZXVlSW1wbCIsImRlbGF5IiwiZGVsYXlJbXBsIiwiYW5pbWF0ZSIsImRlbGF5QW5pbWF0aW9uIiwiZGVsYXlBbmltYXRpb25JbXBsIiwiYW5pbWF0aW9uSW1wbCIsInByb3BlcnRpZXMiLCJpc0VsZXMiLCJwcm9wZXJ0aWVzRW1wdHkiLCJnZXRQcm9wc0xpc3QiLCJwYW5CeSIsImN5UGFuIiwiY2VudGVyIiwiY2VudHJlIiwiY2VudGVyUGFuIiwiZ2V0Q2VudGVyUGFuIiwiZml0IiwiZml0VnAiLCJnZXRGaXRWaWV3cG9ydCIsInZwIiwiZ2V0Wm9vbWVkVmlld3BvcnQiLCJ6b29tZWQiLCJwYW5uZWQiLCJhbmltYXRlSW1wbCIsImFuaSIsInN0b3BJbXBsIiwianVtcFRvRW5kIiwiYW5pcyIsImFuaV9wIiwibm90aWZ5IiwiaXNBcnJheV8xIiwiaGFzUmVxdWlyZWRJc0FycmF5IiwicmVxdWlyZUlzQXJyYXkiLCJfaXNLZXkiLCJoYXNSZXF1aXJlZF9pc0tleSIsInJlcXVpcmVfaXNLZXkiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwiaXNLZXkiLCJpc0Z1bmN0aW9uXzEiLCJoYXNSZXF1aXJlZElzRnVuY3Rpb24iLCJyZXF1aXJlSXNGdW5jdGlvbiIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsIl9jb3JlSnNEYXRhIiwiaGFzUmVxdWlyZWRfY29yZUpzRGF0YSIsInJlcXVpcmVfY29yZUpzRGF0YSIsImNvcmVKc0RhdGEiLCJfaXNNYXNrZWQiLCJoYXNSZXF1aXJlZF9pc01hc2tlZCIsInJlcXVpcmVfaXNNYXNrZWQiLCJtYXNrU3JjS2V5IiwiSUVfUFJPVE8iLCJpc01hc2tlZCIsIl90b1NvdXJjZSIsImhhc1JlcXVpcmVkX3RvU291cmNlIiwicmVxdWlyZV90b1NvdXJjZSIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInRvU291cmNlIiwiX2Jhc2VJc05hdGl2ZSIsImhhc1JlcXVpcmVkX2Jhc2VJc05hdGl2ZSIsInJlcXVpcmVfYmFzZUlzTmF0aXZlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwicmVJc05hdGl2ZSIsImJhc2VJc05hdGl2ZSIsInBhdHRlcm4iLCJfZ2V0VmFsdWUiLCJoYXNSZXF1aXJlZF9nZXRWYWx1ZSIsInJlcXVpcmVfZ2V0VmFsdWUiLCJnZXRWYWx1ZSIsIl9nZXROYXRpdmUiLCJoYXNSZXF1aXJlZF9nZXROYXRpdmUiLCJyZXF1aXJlX2dldE5hdGl2ZSIsImdldE5hdGl2ZSIsIl9uYXRpdmVDcmVhdGUiLCJoYXNSZXF1aXJlZF9uYXRpdmVDcmVhdGUiLCJyZXF1aXJlX25hdGl2ZUNyZWF0ZSIsIm5hdGl2ZUNyZWF0ZSIsIl9oYXNoQ2xlYXIiLCJoYXNSZXF1aXJlZF9oYXNoQ2xlYXIiLCJyZXF1aXJlX2hhc2hDbGVhciIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiX2hhc2hEZWxldGUiLCJoYXNSZXF1aXJlZF9oYXNoRGVsZXRlIiwicmVxdWlyZV9oYXNoRGVsZXRlIiwiaGFzaERlbGV0ZSIsIl9oYXNoR2V0IiwiaGFzUmVxdWlyZWRfaGFzaEdldCIsInJlcXVpcmVfaGFzaEdldCIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaEdldCIsIl9oYXNoSGFzIiwiaGFzUmVxdWlyZWRfaGFzaEhhcyIsInJlcXVpcmVfaGFzaEhhcyIsImhhc2hIYXMiLCJfaGFzaFNldCIsImhhc1JlcXVpcmVkX2hhc2hTZXQiLCJyZXF1aXJlX2hhc2hTZXQiLCJoYXNoU2V0IiwiX0hhc2giLCJoYXNSZXF1aXJlZF9IYXNoIiwicmVxdWlyZV9IYXNoIiwiSGFzaCIsImVudHJpZXMiLCJfbGlzdENhY2hlQ2xlYXIiLCJoYXNSZXF1aXJlZF9saXN0Q2FjaGVDbGVhciIsInJlcXVpcmVfbGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVDbGVhciIsImVxXzEiLCJoYXNSZXF1aXJlZEVxIiwicmVxdWlyZUVxIiwiZXEiLCJfYXNzb2NJbmRleE9mIiwiaGFzUmVxdWlyZWRfYXNzb2NJbmRleE9mIiwicmVxdWlyZV9hc3NvY0luZGV4T2YiLCJhc3NvY0luZGV4T2YiLCJfbGlzdENhY2hlRGVsZXRlIiwiaGFzUmVxdWlyZWRfbGlzdENhY2hlRGVsZXRlIiwicmVxdWlyZV9saXN0Q2FjaGVEZWxldGUiLCJhcnJheVByb3RvIiwibGlzdENhY2hlRGVsZXRlIiwibGFzdEluZGV4IiwiX2xpc3RDYWNoZUdldCIsImhhc1JlcXVpcmVkX2xpc3RDYWNoZUdldCIsInJlcXVpcmVfbGlzdENhY2hlR2V0IiwibGlzdENhY2hlR2V0IiwiX2xpc3RDYWNoZUhhcyIsImhhc1JlcXVpcmVkX2xpc3RDYWNoZUhhcyIsInJlcXVpcmVfbGlzdENhY2hlSGFzIiwibGlzdENhY2hlSGFzIiwiX2xpc3RDYWNoZVNldCIsImhhc1JlcXVpcmVkX2xpc3RDYWNoZVNldCIsInJlcXVpcmVfbGlzdENhY2hlU2V0IiwibGlzdENhY2hlU2V0IiwiX0xpc3RDYWNoZSIsImhhc1JlcXVpcmVkX0xpc3RDYWNoZSIsInJlcXVpcmVfTGlzdENhY2hlIiwiTGlzdENhY2hlIiwiX01hcCIsImhhc1JlcXVpcmVkX01hcCIsInJlcXVpcmVfTWFwIiwiX21hcENhY2hlQ2xlYXIiLCJoYXNSZXF1aXJlZF9tYXBDYWNoZUNsZWFyIiwicmVxdWlyZV9tYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVDbGVhciIsIl9pc0tleWFibGUiLCJoYXNSZXF1aXJlZF9pc0tleWFibGUiLCJyZXF1aXJlX2lzS2V5YWJsZSIsImlzS2V5YWJsZSIsIl9nZXRNYXBEYXRhIiwiaGFzUmVxdWlyZWRfZ2V0TWFwRGF0YSIsInJlcXVpcmVfZ2V0TWFwRGF0YSIsImdldE1hcERhdGEiLCJfbWFwQ2FjaGVEZWxldGUiLCJoYXNSZXF1aXJlZF9tYXBDYWNoZURlbGV0ZSIsInJlcXVpcmVfbWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZURlbGV0ZSIsIl9tYXBDYWNoZUdldCIsImhhc1JlcXVpcmVkX21hcENhY2hlR2V0IiwicmVxdWlyZV9tYXBDYWNoZUdldCIsIm1hcENhY2hlR2V0IiwiX21hcENhY2hlSGFzIiwiaGFzUmVxdWlyZWRfbWFwQ2FjaGVIYXMiLCJyZXF1aXJlX21hcENhY2hlSGFzIiwibWFwQ2FjaGVIYXMiLCJfbWFwQ2FjaGVTZXQiLCJoYXNSZXF1aXJlZF9tYXBDYWNoZVNldCIsInJlcXVpcmVfbWFwQ2FjaGVTZXQiLCJtYXBDYWNoZVNldCIsIl9NYXBDYWNoZSIsImhhc1JlcXVpcmVkX01hcENhY2hlIiwicmVxdWlyZV9NYXBDYWNoZSIsIk1hcENhY2hlIiwibWVtb2l6ZV8xIiwiaGFzUmVxdWlyZWRNZW1vaXplIiwicmVxdWlyZU1lbW9pemUiLCJtZW1vaXplZCIsIkNhY2hlIiwiX21lbW9pemVDYXBwZWQiLCJoYXNSZXF1aXJlZF9tZW1vaXplQ2FwcGVkIiwicmVxdWlyZV9tZW1vaXplQ2FwcGVkIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJfc3RyaW5nVG9QYXRoIiwiaGFzUmVxdWlyZWRfc3RyaW5nVG9QYXRoIiwicmVxdWlyZV9zdHJpbmdUb1BhdGgiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwic3RyaW5nVG9QYXRoIiwicXVvdGUiLCJzdWJTdHJpbmciLCJfYXJyYXlNYXAiLCJoYXNSZXF1aXJlZF9hcnJheU1hcCIsInJlcXVpcmVfYXJyYXlNYXAiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiX2Jhc2VUb1N0cmluZyIsImhhc1JlcXVpcmVkX2Jhc2VUb1N0cmluZyIsInJlcXVpcmVfYmFzZVRvU3RyaW5nIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsInRvU3RyaW5nXzEiLCJoYXNSZXF1aXJlZFRvU3RyaW5nIiwicmVxdWlyZVRvU3RyaW5nIiwiX2Nhc3RQYXRoIiwiaGFzUmVxdWlyZWRfY2FzdFBhdGgiLCJyZXF1aXJlX2Nhc3RQYXRoIiwiY2FzdFBhdGgiLCJfdG9LZXkiLCJoYXNSZXF1aXJlZF90b0tleSIsInJlcXVpcmVfdG9LZXkiLCJ0b0tleSIsIl9iYXNlR2V0IiwiaGFzUmVxdWlyZWRfYmFzZUdldCIsInJlcXVpcmVfYmFzZUdldCIsImJhc2VHZXQiLCJnZXRfMSIsImhhc1JlcXVpcmVkR2V0IiwicmVxdWlyZUdldCIsImRlZmF1bHRWYWx1ZSIsImdldEV4cG9ydHMiLCJfZGVmaW5lUHJvcGVydHkiLCJoYXNSZXF1aXJlZF9kZWZpbmVQcm9wZXJ0eSIsInJlcXVpcmVfZGVmaW5lUHJvcGVydHkiLCJfYmFzZUFzc2lnblZhbHVlIiwiaGFzUmVxdWlyZWRfYmFzZUFzc2lnblZhbHVlIiwicmVxdWlyZV9iYXNlQXNzaWduVmFsdWUiLCJiYXNlQXNzaWduVmFsdWUiLCJfYXNzaWduVmFsdWUiLCJoYXNSZXF1aXJlZF9hc3NpZ25WYWx1ZSIsInJlcXVpcmVfYXNzaWduVmFsdWUiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiX2lzSW5kZXgiLCJoYXNSZXF1aXJlZF9pc0luZGV4IiwicmVxdWlyZV9pc0luZGV4IiwicmVJc1VpbnQiLCJpc0luZGV4IiwiX2Jhc2VTZXQiLCJoYXNSZXF1aXJlZF9iYXNlU2V0IiwicmVxdWlyZV9iYXNlU2V0IiwiYmFzZVNldCIsImN1c3RvbWl6ZXIiLCJuZXN0ZWQiLCJuZXdWYWx1ZSIsInNldF8xIiwiaGFzUmVxdWlyZWRTZXQiLCJyZXF1aXJlU2V0Iiwic2V0RXhwb3J0cyIsIl9jb3B5QXJyYXkiLCJoYXNSZXF1aXJlZF9jb3B5QXJyYXkiLCJyZXF1aXJlX2NvcHlBcnJheSIsInRvUGF0aF8xIiwiaGFzUmVxdWlyZWRUb1BhdGgiLCJyZXF1aXJlVG9QYXRoIiwidG9QYXRoIiwidG9QYXRoRXhwb3J0cyIsImRlZmluZSQyIiwiZmllbGQiLCJiaW5kaW5nRXZlbnQiLCJhbGxvd0JpbmRpbmciLCJhbGxvd1NldHRpbmciLCJhbGxvd0dldHRpbmciLCJzZXR0aW5nRXZlbnQiLCJzZXR0aW5nVHJpZ2dlcnNFdmVudCIsInRyaWdnZXJGbk5hbWUiLCJpbW11dGFibGVLZXlzIiwidXBkYXRlU3R5bGUiLCJiZWZvcmVHZXQiLCJiZWZvcmVTZXQiLCJvblNldCIsImNhblNldCIsImRhdGFJbXBsIiwiaXNQYXRoTGlrZSIsInZhbGlkIiwiY2hhbmdlIiwiX3ZhbGlkIiwiX2VsZSIsIm9uIiwicmVtb3ZlRGF0YSIsInRyaWdnZXJFdmVudCIsInJlbW92ZURhdGFJbXBsIiwibmFtZXMiLCJpX2EiLCJsX2EiLCJfaV9hIiwiX2xfYSIsIl9wcml2YXRlRmllbGRzIiwiX2tleXMiLCJfa2V5IiwidmFsaWRLZXlUb0RlbGV0ZSIsImRlZmluZSQxIiwiZXZlbnRBbGlhc2VzT24iLCJwcm90byIsImFkZExpc3RlbmVyIiwibGlzdGVuIiwidW5saXN0ZW4iLCJ1bmJpbmQiLCJyZW1vdmVMaXN0ZW5lciIsInRyaWdnZXIiLCJlbWl0IiwicG9uIiwicHJvbWlzZU9uIiwiZXZlbnRzIiwic2VsZWN0b3IiLCJvZmZBcmdzIiwib25BcmdzIiwiZGVmaW5lIiwiZWxlc2ZuJGkiLCJlbGVzZm4kaCIsIl9jbGFzc2VzIiwiY2hhbmdlZCIsImNsYXNzZXNTZXQiLCJlbGVDbGFzc2VzIiwiY2hhbmdlZEVsZSIsImVsZUhhc0NsYXNzIiwiYWRkQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsImhhc0NsYXNzIiwiY2xhc3NOYW1lIiwidG9nZ2xlIiwidG9nZ2xlVW5kZWZkIiwiaWwiLCJjaGFuZ2VkTm93IiwicmVtb3ZlQ2xhc3MiLCJmbGFzaENsYXNzIiwiY2xhc3NOYW1lcyIsInRva2VucyIsIm1ldGFDaGFyIiwiY29tcGFyYXRvck9wIiwiYm9vbE9wIiwibWV0YSIsInNlcGFyYXRvciIsImRlc2NlbmRhbnQiLCJjaGlsZCIsInN1YmplY3QiLCJkaXJlY3RlZEVkZ2UiLCJ1bmRpcmVjdGVkRWRnZSIsInZhcmlhYmxlIiwib3BzIiwib3AiLCJuZXdRdWVyeSIsImNoZWNrcyIsIlR5cGUiLCJHUk9VUCIsIkNPTExFQ1RJT04iLCJGSUxURVIiLCJEQVRBX0NPTVBBUkUiLCJEQVRBX0VYSVNUIiwiREFUQV9CT09MIiwiTUVUQV9DT01QQVJFIiwiU1RBVEUiLCJJRCIsIkNMQVNTIiwiVU5ESVJFQ1RFRF9FREdFIiwiRElSRUNURURfRURHRSIsIk5PREVfU09VUkNFIiwiTk9ERV9UQVJHRVQiLCJOT0RFX05FSUdIQk9SIiwiQ0hJTEQiLCJERVNDRU5EQU5UIiwiUEFSRU5UIiwiQU5DRVNUT1IiLCJDT01QT1VORF9TUExJVCIsIlRSVUUiLCJzdGF0ZVNlbGVjdG9ycyIsIm1hdGNoZXMiLCJ2aXNpYmxlIiwiaXNQYXJlbnQiLCJpc0NoaWxkbGVzcyIsImlzQ2hpbGQiLCJpc09ycGhhbiIsImlzU2ltcGxlIiwibG9va3VwIiwic2VsVG9GbiIsInN0YXRlU2VsZWN0b3JNYXRjaGVzIiwic2VsIiwic3RhdGVTZWxlY3RvclJlZ2V4IiwiY2xlYW5NZXRhQ2hhcnMiLCIkMSIsInJlcGxhY2VMYXN0UXVlcnkiLCJleGFtaW5pbmdRdWVyeSIsInJlcGxhY2VtZW50UXVlcnkiLCJleHBycyIsInF1ZXJ5IiwicmVnZXgiLCJwb3B1bGF0ZSIsIl9yZWYyIiwiX3JlZjMiLCJfcmVmNCIsIl9yZWY1IiwiX3JlZjYiLCJfcmVmNyIsIl9yZWY4IiwiX3JlZjkiLCJfcmVmMTAiLCJfcmVmMTEiLCJfcmVmMTIiLCJ2YWx1ZUlzU3RyaW5nIiwib3BlcmF0b3IiLCJfcmVmMTMiLCJfcmVmMTQiLCJfcmVmMTUiLCJfcmVmMTYiLCJjdXJyZW50U3ViamVjdCIsImNvbXBvdW5kQ291bnQiLCJsYXN0USIsIm5leHRRdWVyeSIsImVkZ2VRdWVyeSIsInNyY1RndFEiLCJfc291cmNlIiwiX3RhcmdldCIsIm5ob29kUSIsIm5laWdoYm9yIiwicGFyZW50Q2hpbGRRdWVyeSIsImNvbXBvdW5kIiwiX2NoaWxkIiwiX3BhcmVudCIsIl9wYXJlbnQyIiwiX2NoaWxkMiIsInBjUUNoZWNrcyIsImFuY0NoUXVlcnkiLCJhbmNlc3RvciIsIl9kZXNjZW5kYW50IiwiX2FuY2VzdG9yIiwiX2FuY2VzdG9yMiIsIl9kZXNjZW5kYW50MiIsImFkUUNoZWNrcyIsIm1vZGlmaWVyIiwidG9wUSIsInRvcENoayIsInRvcFR5cGUiLCJyZWdleE9iaiIsImNvbnN1bWVFeHByIiwicmVtYWluaW5nIiwiZXhwciIsImNvbnN1bWVkIiwiY29uc3VtZVdoaXRlc3BhY2UiLCJwYXJzZSIsImlucHV0VGV4dCIsImN1cnJlbnRRdWVyeSIsImV4cHJJbmZvIiwidG9TdHJpbmdDYWNoZSIsImNsZWFuIiwiY2xlYW5WYWwiLCJzcGFjZSIsImNoZWNrVG9TdHJpbmciLCJjaGVjayIsIl9vcGVyYXRvciIsIl9maWVsZCIsIl9maWVsZDIiLCJfb3BlcmF0b3IyIiwiX2ZpZWxkMyIsInF1ZXJ5VG9TdHJpbmciLCJsaHMiLCJyaHMiLCJyZWR1Y2UiLCJjaGsiLCJwYXJzZSQxIiwidmFsQ21wIiwiZmllbGRWYWwiLCJpc0ZpZWxkU3RyIiwiaXNGaWVsZE51bSIsImlzVmFsU3RyIiwiZmllbGRTdHIiLCJ2YWxTdHIiLCJjYXNlSW5zZW5zaXRpdmUiLCJub3RFeHByIiwiaXNJbmVxQ21wIiwiYm9vbENtcCIsImV4aXN0Q21wIiwiZGF0YSQxIiwibWF0Y2hlcyQxIiwiZXZlcnkiLCJzdGF0ZVNlbGVjdG9yIiwicUEiLCJxQiIsImluY29tZXJzIiwiYW5jZXN0b3JzIiwiZGVzY2VuZGFudHMiLCJzZWxlY3RvckZ1bmN0aW9uIiwidGV4dCIsIm1hdGNoaW5nIiwiU2VsZWN0b3IiLCJhZGRRdWVyeSIsImludmFsaWQiLCJzZWxmbiIsInNhbWVUZXh0Iiwib3RoZXJTZWwiLCJlbGVzZm4kZyIsImFsbEFyZSIsInNlbE9iaiIsImlzIiwidGhpc0xlbmd0aCIsImNvbGxlY3Rpb25MZW5ndGgiLCJhbnlTYW1lIiwiYWxsQXJlTmVpZ2hib3JzIiwibmhvb2QiLCJhbGxBcmVOZWlnaGJvdXJzIiwiZXF1YWwiLCJlcXVhbHMiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0Iiwic2VsZWN0b3JPckVsZXMiLCJ0Y2giLCJjaCIsImNhY2hlSGl0IiwiZWxlc2ZuJGYiLCJwYXJlbnRzIiwibm9uZW1wdHkiLCJjb21tb25BbmNlc3RvcnMiLCJvcnBoYW5zIiwic3RkRmlsdGVyIiwibm9ub3JwaGFucyIsImVsZUNoaWxkcmVuIiwic2libGluZ3MiLCJub3QiLCJlbGVtZW50cyIsImZvckVhY2hDb21wb3VuZCIsImluY2x1ZGVTZWxmIiwicmVjdXJzaXZlU3RlcCIsImRpZCIsImhhc0NvbXBvdW5kcyIsImhhc0NvbXBvdW5kTm9kZXMiLCJhZGRDaGlsZHJlbiIsImZvckVhY2hEb3duIiwiYWRkUGFyZW50IiwiZm9yRWFjaFVwIiwiYWRkUGFyZW50QW5kQ2hpbGRyZW4iLCJmb3JFYWNoVXBBbmREb3duIiwiZm4kNSIsImVsZXNmbiRlIiwicmVtb3ZlU2NyYXRjaCIsInJlbW92ZVJzY3JhdGNoIiwicmVtb3ZlQXR0ciIsImVsZXNmbiRkIiwiZGVmaW5lRGVncmVlRnVuY3Rpb24iLCJpbmNsdWRlTG9vcHMiLCJkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbiIsImRlZ3JlZUZuIiwibWluRGVncmVlIiwibWluSW5kZWdyZWUiLCJtaW5PdXRkZWdyZWUiLCJ0b3RhbERlZ3JlZSIsImZuJDQiLCJlbGVzZm4kYyIsImJlZm9yZVBvc2l0aW9uU2V0IiwibmV3UG9zIiwic2lsZW50Iiwib2xkUG9zIiwiZGlydHlCb3VuZGluZ0JveENhY2hlIiwicG9zaXRpb25EZWYiLCJ2YWxpZEtleXMiLCJ1cGRhdGVDb21wb3VuZEJvdW5kcyIsImRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSIsInNpbGVudFBvc2l0aW9uIiwicG9zaXRpb25zIiwiX2ZuIiwic3RhcnRCYXRjaCIsIl9wb3MiLCJlbmRCYXRjaCIsInNpbGVudFBvc2l0aW9ucyIsInNpbGVudFNoaWZ0Iiwic2V0dGluZyIsInJlbGF0aXZlUG9zaXRpb24iLCJwcG9zIiwiX2VsZTIiLCJoYXNQYXJlbnQiLCJyZWxhdGl2ZVRvUGFyZW50Iiwib3JpZ2luIiwiX2hhc1BhcmVudCIsIl9yZWxhdGl2ZVRvUGFyZW50IiwiX29yaWdpbiIsIm1vZGVsUG9zaXRpb24iLCJtb2RlbFBvc2l0aW9ucyIsInJlbmRlcmVkUG9pbnQiLCJyZWxhdGl2ZVBvaW50IiwiZm4kMyIsImVsZXNmbiRiIiwicmVuZGVyZWRCb3VuZGluZ0JveCIsImVtaXRBbmROb3RpZnkiLCJmb3JjZSIsImJhdGNoaW5nIiwidXBkYXRlIiwiaW5jbHVkZUxhYmVscyIsInBzdHlsZSIsInBmVmFsdWUiLCJpbmNsdWRlT3ZlcmxheXMiLCJ1c2VDYWNoZSIsImNvbXB1dGVCaWFzVmFsdWVzIiwicHJvcERpZmYiLCJwcm9wQmlhcyIsInByb3BCaWFzQ29tcGxlbWVudCIsImJpYXNEaWZmIiwiYmlhc0NvbXBsZW1lbnREaWZmIiwiYmlhc1RvdGFsIiwiY29tcHV0ZVBhZGRpbmdWYWx1ZXMiLCJwYWRkaW5nT2JqZWN0IiwicmVsYXRpdmVUbyIsInVuaXRzIiwibGVmdFZhbCIsInJpZ2h0VmFsIiwidG9wVmFsIiwiYm90dG9tVmFsIiwid2lkdGhCaWFzRGlmZnMiLCJkaWZmTGVmdCIsImRpZmZSaWdodCIsImhlaWdodEJpYXNEaWZmcyIsImRpZmZUb3AiLCJkaWZmQm90dG9tIiwibm9uaW5mIiwidXBkYXRlQm91bmRzIiwidXBkYXRlQm91bmRzRnJvbUJveCIsImIyIiwicHJlZml4ZWRQcm9wZXJ0eSIsInVwZGF0ZUJvdW5kc0Zyb21BcnJvdyIsImJvdW5kcyIsImhlYWRsZXNzIiwiaGFsZkFyVyIsImFycm93V2lkdGgiLCJhcnJvd1R5cGUiLCJzcmNYIiwic3JjWSIsInRndFgiLCJ0Z3RZIiwibWlkWCIsIm1pZFkiLCJiYnMiLCJ1cGRhdGVCb3VuZHNGcm9tTGFiZWwiLCJwcmVmaXhEYXNoIiwibGFiZWwiLCJzdHJWYWx1ZSIsImhhbGlnbiIsInZhbGlnbiIsImxhYmVsV2lkdGgiLCJsYWJlbEhlaWdodCIsImxhYmVsWCIsImxhYmVsWSIsIm1hcmdpblgiLCJtYXJnaW5ZIiwicm90YXRpb24iLCJvdXRsaW5lV2lkdGgiLCJib3JkZXJXaWR0aCIsImhhbGZCb3JkZXJXaWR0aCIsIm1hcmdpbk9mRXJyb3IiLCJsaCIsImx3IiwibHdfMiIsImxoXzIiLCJsZWZ0UGFkIiwicmlnaHRQYWQiLCJ0b3BQYWQiLCJib3RQYWQiLCJiYlByZWZpeCIsImlzQXV0b3JvdGF0ZSIsImlzUGZWYWx1ZSIsInRoZXRhIiwieG8iLCJ5byIsInJvdGF0ZSIsInB4MXkxIiwicHgxeTIiLCJweDJ5MSIsInB4MnkyIiwiYmJQcmVmaXhSb3QiLCJiYlJvdCIsInVwZGF0ZUJvdW5kc0Zyb21PdXRsaW5lIiwib3V0bGluZU9wYWNpdHkiLCJvdXRsaW5lT2Zmc2V0IiwiZXhwYW5zaW9uIiwidXBkYXRlQm91bmRzRnJvbU1pdGVyIiwib3BhY2l0eSIsImV4cGFuc2lvblNpemUiLCJleHBhbnNpb25Qb3NpdGlvbiIsInVzZUZhbGxiYWNrVmFsdWUiLCJzaGFwZSIsInJzaGFwZSIsInJlbmRlcmVyIiwibm9kZVNoYXBlcyIsIl9lbGUkcG9zaXRpb24iLCJoYXNNaXRlckJvdW5kcyIsIm1iYiIsIm1pdGVyQm91bmRzIiwidXBkYXRlQm91bmRzRnJvbU1pdGVyQm9yZGVyIiwiYm9yZGVyT3BhY2l0eSIsImJvcmRlclBvc2l0aW9uIiwiYm91bmRpbmdCb3hJbXBsIiwiZXgxIiwiZXgyIiwiZXkxIiwiZXkyIiwibWFudWFsRXhwYW5zaW9uIiwiaXNEaXNwbGF5ZWQiLCJkaXNwbGF5ZWQiLCJvdmVybGF5T3BhY2l0eSIsIm92ZXJsYXlQYWRkaW5nIiwidW5kZXJsYXlPcGFjaXR5IiwidW5kZXJsYXlQYWRkaW5nIiwiaW5jbHVkZVVuZGVybGF5cyIsIndIYWxmIiwiaW5jbHVkZU5vZGVzIiwib3V0ZXJXaWR0aCIsIm91dGVySGVpZ2h0IiwiaW5jbHVkZU91dGxpbmVzIiwiaW5jbHVkZUVkZ2VzIiwiY3VydmVTdHlsZSIsImhwdHMiLCJoYXlzdGFja1B0cyIsIl90ZW1wIiwiYmV6aWVyUHRzIiwibGluZVB0cyIsIm4xcG9zIiwibjJwb3MiLCJfdGVtcDIiLCJfdGVtcDMiLCJnaG9zdCIsImd4IiwiZ3kiLCJiYkJvZHkiLCJiYk92ZXJsYXkiLCJiYkxhYmVscyIsImluY2x1ZGVNYWluTGFiZWxzIiwiaW5jbHVkZVNvdXJjZUxhYmVscyIsImluY2x1ZGVUYXJnZXRMYWJlbHMiLCJnZXRLZXkiLCJ0ZiIsImluY3VkZU5vZGVzIiwiZ2V0Qm91bmRpbmdCb3hQb3NLZXkiLCJjYWNoZWRCb3VuZGluZ0JveEltcGwiLCJkZWZCYk9wdHNLZXkiLCJ1c2luZ0RlZk9wdHMiLCJkZWZCYk9wdHMiLCJiYkNhY2hlUG9zS2V5IiwibWFpblJvdCIsInNvdXJjZVJvdCIsInRhcmdldFJvdCIsImZpbGxlZEJiT3B0cyIsImlzRGlydHkiLCJzdHlsZURpcnR5IiwicmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlIiwiYm91bmRpbmdCb3hBdCIsInN0b3JlT2xkUG9zIiwiYmJBdE9sZFBvcyIsImdldE9sZFBvcyIsImJvdW5kaW5nYm94IiwicmVuZGVyZWRCb3VuZGluZ2JveCIsImZuJDIiLCJlbGVzZm4kYSIsImRlZmluZURpbUZucyIsInVwcGVyY2FzZU5hbWUiLCJhdXRvTmFtZSIsImxhYmVsTmFtZSIsIm91dGVyTmFtZSIsInVwcGVyY2FzZU91dGVyTmFtZSIsImRpbUltcGwiLCJvdXRlckRpbUltcGwiLCJib3JkZXJQb3MiLCJib3JkZXIiLCJyZW5kZXJlZERpbUltcGwiLCJyZW5kZXJlZE91dGVyRGltSW1wbCIsIm9kIiwicGFkZGVkSGVpZ2h0IiwicGFkZGVkV2lkdGgiLCJ3aWR0aEhlaWdodCIsImlmRWRnZSIsInRha2VzVXBTcGFjZSIsImlmRWRnZVJlbmRlcmVkUG9zaXRpb24iLCJnZXRQb2ludCIsImlmRWRnZVJlbmRlcmVkUG9zaXRpb25zIiwiZ2V0UG9pbnRzIiwiY29udHJvbFBvaW50cyIsImdldENvbnRyb2xQb2ludHMiLCJzZWdtZW50UG9pbnRzIiwiZ2V0U2VnbWVudFBvaW50cyIsInNvdXJjZUVuZHBvaW50IiwiZ2V0U291cmNlRW5kcG9pbnQiLCJ0YXJnZXRFbmRwb2ludCIsImdldFRhcmdldEVuZHBvaW50IiwibWlkcG9pbnQiLCJnZXRFZGdlTWlkcG9pbnQiLCJtdWx0IiwicmVuZGVyZWROYW1lIiwic3Vic3RyIiwiZWRnZVBvaW50cyIsInNwZWMiLCJyTmFtZSIsImRpbWVuc2lvbnMiLCJFdmVudCIsInJlY3ljbGUiLCJyZXR1cm5GYWxzZSIsInJldHVyblRydWUiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNEZWZhdWx0UHJldmVudGVkIiwicHJldmVudERlZmF1bHQiLCJkZWZhdWx0UHJldmVudGVkIiwib3JpZ2luYWxFdmVudCIsIm5hbWVzcGFjZSIsImxheW91dCIsInRpbWVTdGFtcCIsInN0b3BQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImV2ZW50UmVnZXgiLCJ1bml2ZXJzYWxOYW1lc3BhY2UiLCJkZWZhdWx0cyQ4IiwicXVhbGlmaWVyQ29tcGFyZSIsInExIiwicTIiLCJldmVudE1hdGNoZXMiLCJhZGRFdmVudEZpZWxkcyIsImNhbGxiYWNrQ29udGV4dCIsImNvbnRleHQiLCJiZWZvcmVFbWl0IiwiYWZ0ZXJFbWl0IiwiYnViYmxlIiwiZGVmYXVsdHNLZXlzIiwiZW1wdHlPcHRzIiwiRW1pdHRlciIsImVtaXR0aW5nIiwiZm9yRWFjaEV2ZW50IiwiaGFuZGxlciIsInF1YWxpZmllciIsImNvbmYiLCJjb25mT3ZlcnJpZGVzIiwiZXZlbnRMaXN0IiwiZXZ0IiwibWFrZUV2ZW50T2JqIiwiZm9yRWFjaEV2ZW50T2JqIiwiZXZlbnRPYmoiLCJvbmUiLCJsaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImV4dHJhUGFyYW1zIiwibWFudWFsQ2FsbGJhY2siLCJudW1MaXN0ZW5lcnNCZWZvcmVFbWl0IiwiX2xvb3AyIiwiZW1pdHRlck9wdGlvbnMkMSIsInNlbGVjdG9yMSIsInNlbGVjdG9yMiIsIm9uY2UiLCJvbmNlQ29sbGVjdGlvbiIsImFyZ1NlbGVjdG9yJDEiLCJhcmdTZWxlY3RvciIsImFyZyIsImVsZXNmbiQ5IiwiZW1pdHRlciIsImFyZ1NlbCIsImVsZXNmbiQ4IiwiX2ZpbHRlciIsImZpbHRlckVsZXMiLCJpbmNsdWRlIiwidG9SZW1vdmUiLCJyZW1vdmUiLCJhYnNvbHV0ZUNvbXBsZW1lbnQiLCJtdXRhYmxlRWxlbWVudHMiLCJjb2wxIiwiY29sMiIsImNvbDFTbWFsbGVyIiwiY29sUyIsImNvbEwiLCJ4b3IiLCJpbk90aGVyIiwiYm90aCIsInJldEVsZXMiLCJ0b0FkZCIsInNwYXduU2VsZiIsInRvQWRkRWxlIiwidW5tZXJnZUF0IiwidW5tZXJnZWRMYXN0RWxlIiwibGFzdEVsZUkiLCJsYXN0RWxlIiwibGFzdEVsZUlkIiwidW5tZXJnZU9uZSIsInVubWVyZ2UiLCJ0b1JtRm4iLCJtYXBGbiIsImluaXRpYWxWYWx1ZSIsInZhbEZuIiwibWF4RWxlIiwibWluRWxlIiwiZm4kMSIsInVuaW9uIiwib3IiLCJyZWxhdGl2ZUNvbXBsZW1lbnQiLCJzdWJ0cmFjdCIsImFuZCIsInN5bW1ldHJpY0RpZmZlcmVuY2UiLCJzeW1kaWZmIiwiZm5GaWx0ZXIiLCJmaWx0ZXJGbiIsImNvbXBsZW1lbnQiLCJhYnNjb21wIiwiZWxlc2ZuJDciLCJ6SW5kZXhTb3J0IiwiZ2V0RGVwdGgiLCJ6RGVwdGgiLCJkZXB0aERpZmYiLCJnZXRFbGVEZXB0aCIsImVsZURpZmYiLCJ6RGlmZiIsInBvb2xJbmRleCIsImVsZXNmbiQ2IiwidGhpc1NpemUiLCJmaXJzdCIsImxhc3QiLCJzb3J0Rm4iLCJzb3J0ZWQiLCJzb3J0QnlaSW5kZXgiLCJzcmNEZXB0aCIsInRndERlcHRoIiwiZWFjaCIsImRlZmluZVN5bWJvbEl0ZXJhdG9yIiwidHlwZW9mVW5kZWYiLCJpc0l0ZXJhdG9yU3VwcG9ydGVkIiwiZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyIsIm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscyIsImVsZXNmbiQ1IiwibGF5b3V0RGltZW5zaW9ucyIsImRpbXMiLCJiYkRpbSIsImxheW91dFBvc2l0aW9ucyIsImxheW91dEVsZXMiLCJnZXRNZW1vaXplS2V5IiwiZm5NZW0iLCJhbmltYXRpb25zIiwiY2FsY3VsYXRlU3BhY2luZyIsInNwYWNpbmciLCJub2Rlc0JiIiwic3BhY2luZ1ZlY3RvciIsInVzZVNwYWNpbmdGYWN0b3IiLCJzcGFjaW5nRmFjdG9yIiwic3BhY2luZ0JiIiwiZ2V0RmluYWxQb3MiLCJ0cmFuc2Zvcm0iLCJhbmltYXRlTm9kZSIsImFuaW1hdGVGaWx0ZXIiLCJhbmltYXRpb25EdXJhdGlvbiIsImVhc2luZyIsImFuaW1hdGlvbkVhc2luZyIsImZpdEFuaSIsInpvb21QYW5BbmkiLCJyZWFkeSIsIm1ha2VMYXlvdXQiLCJjcmVhdGVMYXlvdXQiLCJzdHlsZUNhY2hlIiwiY2FjaGVTdHlsZUZ1bmN0aW9uIiwiY2FjaGVkU3R5bGVGdW5jdGlvbiIsImNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbiIsInNlbGZGbiIsImNhY2hlZFByb3RvdHlwZVN0eWxlRnVuY3Rpb24iLCJlbGVzZm4kNCIsImRpcnR5U3R5bGVDYWNoZSIsImRpcnR5Iiwibm90aWZ5UmVuZGVyZXIiLCJiRWxlcyIsImJhdGNoU3R5bGVFbGVzIiwidXBkYXRlZEVsZXMiLCJjaGFuZ2VkRWxlcyIsImNsZWFuU3R5bGUiLCJwYXJzZWRTdHlsZSIsInByb3BlcnR5IiwiaW5jbHVkZU5vbkRlZmF1bHQiLCJvdmVycmlkZGVuU3R5bGUiLCJnZXREZWZhdWx0UHJvcGVydHkiLCJudW1lcmljU3R5bGUiLCJudW1lcmljU3R5bGVVbml0cyIsInJlbmRlcmVkU3R5bGUiLCJnZXRSZW5kZXJlZFN0eWxlIiwidXBkYXRlVHJhbnNpdGlvbnMiLCJhcHBseUJ5cGFzcyIsImdldFN0eWxlUHJvcGVydHlWYWx1ZSIsImdldFJhd1N0eWxlIiwicmVtb3ZlU3R5bGUiLCJyZW1vdmVBbGxCeXBhc3NlcyIsInJlbW92ZUJ5cGFzc2VzIiwic2hvdyIsImhpZGUiLCJlZmZlY3RpdmVPcGFjaXR5IiwicGFyZW50T3BhY2l0eSIsImNoZWNrQ29tcG91bmQiLCJwYXJlbnRPayIsImRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uIiwic3BlY3MiLCJvayIsImVkZ2VPa1ZpYU5vZGUiLCJlbGVUYWtlc1VwU3BhY2UiLCJlbGVJbnRlcmFjdGl2ZSIsInBhcmVudEludGVyYWN0aXZlIiwiaW50ZXJhY3RpdmUiLCJub25pbnRlcmFjdGl2ZSIsImVsZVZpc2libGUiLCJlZGdlVmlzaWJsZVZpYU5vZGUiLCJoaWRkZW4iLCJpc0J1bmRsZWRCZXppZXIiLCJyZW5kZXJlZENzcyIsInJlbW92ZUJ5cGFzcyIsInJlbW92ZUNzcyIsImVsZXNmbiQzIiwiZGVmaW5lU3dpdGNoRnVuY3Rpb24iLCJfaGFuZGxlciIsImFkZGxFdmVudHMiLCJhYmxlIiwiYWJsZUZpZWxkIiwib3ZlcnJpZGVBYmxlIiwiY2hhbmdlZENvbGwiLCJkZWZpbmVTd2l0Y2hTZXQiLCJvdmVycmlkZUZpZWxkIiwiYXV0b2xvY2siLCJhdXRvdW5ncmFiaWZ5IiwiYXV0b3Vuc2VsZWN0aWZ5IiwiZGVzZWxlY3QiLCJ1bnNlbGVjdCIsImluYWN0aXZlIiwiZWxlc2ZuJDIiLCJkZWZpbmVEYWdFeHRyZW1pdHkiLCJkYWdFeHRyZW1pdHlJbXBsIiwiZGlzcXVhbGlmaWVkIiwibm9JbmNvbWluZ0VkZ2VzIiwibm9PdXRnb2luZ0VkZ2VzIiwiZGVmaW5lRGFnT25lSG9wIiwib0VsZXMiLCJkZWZpbmVEYWdBbGxIb3BzIiwic0VsZXMiLCJzRWxlc0lkcyIsIm5ld05leHQiLCJuaWQiLCJjbGVhclRyYXZlcnNhbENhY2hlIiwic3VjY2Vzc29ycyIsInByZWRlY2Vzc29ycyIsIm90aGVyTm9kZSIsImNsb3NlZE5laWdoYm9yaG9vZCIsIm5laWdoYm91cmhvb2QiLCJjbG9zZWROZWlnaGJvdXJob29kIiwib3Blbk5laWdoYm91cmhvb2QiLCJzb3VyY2VJbXBsIiwidGFyZ2V0SW1wbCIsInNvdXJjZXMiLCJkZWZpbmVTb3VyY2VGdW5jdGlvbiIsInRhcmdldHMiLCJkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbiIsInRoaXNJc1NyYyIsImVkZ2VzV2l0aEltcGwiLCJvdGhlck5vZGVzIiwiZWRnZURhdGEiLCJ0aGlzVG9PdGhlciIsIm90aGVyVG9UaGlzIiwiZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyIiwidGhpc0lzVGd0IiwicGFyYWxsZWxFZGdlcyIsImRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbiIsImNvZGlyZWN0ZWRFZGdlcyIsImNvZGlyZWN0ZWQiLCJwYXJhbGxlbEVkZ2VzSW1wbCIsImVkZ2UxIiwiZWRnZTFfcCIsInNyYzEiLCJzcmNpZDEiLCJ0Z3RpZDEiLCJzcmNFZGdlczEiLCJlZGdlMiIsImVkZ2UyZGF0YSIsInRndGlkMiIsInNyY2lkMiIsIm9wcGRpcmVjdGVkIiwidmlzaXRlZCIsInVudmlzaXRlZCIsInZpc2l0SW5Db21wb25lbnQiLCJjbXB0IiwiY29tcG9uZW50c09mIiwiQ29sbGVjdGlvbiIsInVuaXF1ZSIsImNyZWF0ZWRFbGVtZW50cyIsImVsZXNJZHMiLCJqc29uIiwiX2RhdGEiLCJfbCIsImVsZW1lbnQkMSIsImxhenlNYXAiLCJyZWJ1aWxkTWFwIiwiZWxlc2ZuJDEiLCIkaWQiLCJfZGF0YTIiLCJtb3ZlIiwibmV3UGFyZW50VmFsU3BlY2QiLCJjaGVja1N3aXRjaCIsInRydWVGbk5hbWUiLCJmYWxzZUZuTmFtZSIsIm9ial9rIiwianNvbnMiLCJlbGVzQXJyIiwiYWRkVG9Qb29sIiwiY3lfcCIsInJlbW92ZUZyb21FbGVtZW50cyIsIl9kYXRhMyIsImZpZWxkcyIsImZpZWxkc0xlbmd0aCIsImJhZFNvdXJjZU9yVGFyZ2V0IiwiX2RhdGE0IiwicGFyZW50SWQiLCJzcGVjaWZpZWRQYXJlbnQiLCJzZWxmQXNQYXJlbnQiLCJyZXN0b3JlZCIsIl9lbGUzIiwidG9VcGRhdGVTdHlsZSIsImluc2lkZSIsInJlbW92ZUZyb21Qb29sIiwiZWxlc1RvUmVtb3ZlIiwiZWxlc1RvUmVtb3ZlSWRzIiwiYWRkQ29ubmVjdGVkRWRnZXMiLCJhbHJlYWR5QWRkZWQiLCJyZW1vdmVFZGdlUmVmIiwicmVtb3ZlUGFyYWxsZWxSZWYiLCJwbGxFZGdlIiwiYWx0ZXJlZFBhcmVudHMiLCJpZHMiLCJyZW1vdmVDaGlsZFJlZiIsInBpZCIsIl9lbGU0IiwicGxsRWRnZXMiLCJlbGVzU3RpbGxJbnNpZGUiLCJfZWxlNSIsInJlbW92ZWRFbGVtZW50cyIsIl9lbGU2Iiwic3RydWN0IiwibW9kaWZ5UG9vbCIsInNyY0V4aXN0cyIsInRndEV4aXN0cyIsImJhdGNoIiwiX2RhdGE1IiwicGFyZW50RXhpc3RzIiwicGlkVG9Bc3NpZ24iLCJ1cGRhdGVkIiwiX2RhdGE2IiwiY29yZWZuJDkiLCJfanNvbnMiLCJlbGVzQnlHcm91cCIsIl9qc29uczIiLCJncnMiLCJlbGVzQXJyYXkiLCJqbCIsIl9qc29uIiwiZ2VuZXJhdGVDdWJpY0JlemllciIsIm1YMSIsIm1ZMSIsIm1YMiIsIm1ZMiIsIk5FV1RPTl9JVEVSQVRJT05TIiwiTkVXVE9OX01JTl9TTE9QRSIsIlNVQkRJVklTSU9OX1BSRUNJU0lPTiIsIlNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TIiwia1NwbGluZVRhYmxlU2l6ZSIsImtTYW1wbGVTdGVwU2l6ZSIsImZsb2F0MzJBcnJheVN1cHBvcnRlZCIsIkZsb2F0MzJBcnJheSIsIm1TYW1wbGVWYWx1ZXMiLCJhQTEiLCJhQTIiLCJjYWxjQmV6aWVyIiwiYVQiLCJnZXRTbG9wZSIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYVgiLCJhR3Vlc3NUIiwiY3VycmVudFNsb3BlIiwiY2FsY1NhbXBsZVZhbHVlcyIsImJpbmFyeVN1YmRpdmlkZSIsImFBIiwiYUIiLCJjdXJyZW50VCIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZ3Vlc3NGb3JUIiwiaW5pdGlhbFNsb3BlIiwiX3ByZWNvbXB1dGVkIiwicHJlY29tcHV0ZSIsImdlbmVyYXRlU3ByaW5nUks0Iiwic3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUiLCJ0ZW5zaW9uIiwiZnJpY3Rpb24iLCJzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUiLCJpbml0aWFsU3RhdGUiLCJkdCIsImRlcml2YXRpdmUiLCJkdiIsInNwcmluZ0ludGVncmF0ZVN0YXRlIiwiZHhkdCIsImR2ZHQiLCJzcHJpbmdSSzRGYWN0b3J5IiwiaW5pdFN0YXRlIiwidGltZV9sYXBzZWQiLCJEVCIsImhhdmVfZHVyYXRpb24iLCJsYXN0X3N0YXRlIiwicGVyY2VudENvbXBsZXRlIiwiY3ViaWNCZXppZXIiLCJiZXppZXIiLCJwZXJjZW50IiwiZWFzaW5ncyIsImxpbmVhciIsInNwcmluZyIsImdldEVhc2VkVmFsdWUiLCJlYXNpbmdGbiIsInJvdW5kVmFsdWUiLCJlYXNlIiwic3RhcnRQcm9wIiwiZW5kUHJvcCIsInByb3BTcGVjIiwiZWFzZWRBcnIiLCJzaSIsInN0ZXAkMSIsInBFYXNpbmciLCJzdGFydFRpbWUiLCJlYXNpbmdJbXBsIiwiZWFzaW5nVmFscyIsImVhc2luZ1Byb3AiLCJzdGFydFBvcyIsImVuZFBvcyIsImVuZFBhbiIsImFuaW1hdGluZ1BhbiIsImVuZFpvb20iLCJhbmltYXRpbmdab29tIiwibWluWm9vbSIsIm1heFpvb20iLCJfbmFtZSIsImVhc2VkVmFsIiwib3ZlcnJpZGVCeXBhc3MiLCJzdGFydEFuaW1hdGlvbiIsInN0ZXBBbGwiLCJhbmlFbGVzIiwiZG9uZUVsZXMiLCJzdGVwT25lIiwicmFuQW5pcyIsImNhbGxiYWNrcyIsIl9jYWxsYmFja3MiLCJzdGVwIiwicmFuRWxlQW5pIiwiaGFuZGxlZFRoaXNFbGUiLCJyYW5Db3JlQW5pIiwiY29yZWZuJDgiLCJzdG9wQW5pbWF0aW9uTG9vcCIsImFuaW1hdGlvbnNSdW5uaW5nIiwic3RhcnRBbmltYXRpb25Mb29wIiwiaGVhZGxlc3NTdGVwIiwiYW5pbWF0aW9uU3RlcCIsImJlZm9yZVJlbmRlciIsInJlbmRlcmVyQW5pbWF0aW9uU3RlcCIsIndpbGxEcmF3IiwiYmVmb3JlUmVuZGVyUHJpb3JpdGllcyIsImVtaXR0ZXJPcHRpb25zIiwiZWxlc2ZuIiwiY29yZWZuJDciLCJwbmciLCJqcGciLCJiZyIsImpwZWciLCJjb3JlZm4kNiIsIkxheW91dCIsImV4dGVuc2lvbiIsImNvcmVmbiQ1IiwiZXZlbnROYW1lIiwiZXZlbnRFbGVzIiwiYmF0Y2hOb3RpZmljYXRpb25zIiwibm90aWZpY2F0aW9uc0VuYWJsZWQiLCJkZXN0cm95ZWQiLCJub3RpZmljYXRpb25zIiwiYm9vbCIsIm5vTm90aWZpY2F0aW9ucyIsImJhdGNoQ291bnQiLCJiYXRjaERhdGEiLCJyZW5kZXJlckRlZmF1bHRzIiwiaGlkZUVkZ2VzT25WaWV3cG9ydCIsInRleHR1cmVPblZpZXdwb3J0IiwibW90aW9uQmx1ciIsIm1vdGlvbkJsdXJPcGFjaXR5IiwicGl4ZWxSYXRpbyIsImRlc2t0b3BUYXBUaHJlc2hvbGQiLCJ0b3VjaFRhcFRocmVzaG9sZCIsIndoZWVsU2Vuc2l0aXZpdHkiLCJkZWJ1ZyIsInNob3dGcHMiLCJ3ZWJnbCIsIndlYmdsRGVidWciLCJ3ZWJnbERlYnVnU2hvd0F0bGFzZXMiLCJ3ZWJnbFRleFNpemUiLCJ3ZWJnbFRleFJvd3MiLCJ3ZWJnbFRleFJvd3NOb2RlcyIsIndlYmdsQmF0Y2hTaXplIiwid2ViZ2xUZXhQZXJCYXRjaCIsIndlYmdsQmdDb2xvciIsImNvcmVmbiQ0IiwicmVuZGVyVG8iLCJweFJhdGlvIiwiZm9yY2VSZW5kZXIiLCJyZXNpemUiLCJpbnZhbGlkYXRlU2l6ZSIsImluaXRSZW5kZXJlciIsIlJlbmRlcmVyUHJvdG8iLCJyT3B0cyIsImRlc3Ryb3lSZW5kZXJlciIsImRvbUVsZSIsImNvbnRhaW5lciIsIl9jeXJlZyIsImNoaWxkTm9kZXMiLCJyZW1vdmVDaGlsZCIsIm9uUmVuZGVyIiwib2ZmUmVuZGVyIiwiaW52YWxpZGF0ZURpbWVuc2lvbnMiLCJjb3JlZm4kMyIsInN0eWZuJDgiLCJGQUxTRSIsImllIiwiY3h0TWV0YSIsImdldENvbnRleHRNZXRhIiwiY3h0U3R5bGUiLCJnZXRDb250ZXh0U3R5bGUiLCJhcHAiLCJhcHBseUNvbnRleHRTdHlsZSIsImFwcGxpZWRJbml0U3R5bGUiLCJkaWZmUHJvcHMiLCJoaW50c0RpZmYiLCJ1cGRhdGVTdHlsZUhpbnRzIiwiZ2V0UHJvcGVydGllc0RpZmYiLCJvbGRDeHRLZXkiLCJuZXdDeHRLZXkiLCJwcm9wRGlmZnMiLCJkdWFsQ3h0S2V5IiwiY2FjaGVkVmFsIiwiYWRkZWRQcm9wIiwiY3h0Iiwib2xkSGFzQ3h0IiwibmV3SGFzQ3h0IiwiY3h0SGFzRGlmZmVkIiwiY3h0SGFzTWFwcGVkUHJvcHMiLCJtYXBwZWRQcm9wZXJ0aWVzIiwibGF0ZXJDeHRPdmVycmlkZXMiLCJsYXRlckN4dCIsImhhc0xhdGVyQ3h0IiwiY3h0S2V5IiwicHJldktleSIsInN0eWxlQ3h0S2V5IiwiY29udGV4dFNlbGVjdG9yTWF0Y2hlcyIsImRpZmZQcm9wTmFtZXMiLCJjeHRTdHlsZXMiLCJjb250ZXh0U3R5bGVzIiwiaGFzQ3h0IiwicmV0RGlmZlByb3BzIiwidHlwZXMiLCJkaWZmUHJvcE5hbWUiLCJjeHRQcm9wIiwiZWxlUHJvcCIsImRlbGV0ZUJ5cGFzc2VkIiwibWFwcGVkIiwibWFwcGluZyIsImZuVmFsdWUiLCJwcmV2Rm5WYWx1ZSIsInJldERpZmZQcm9wIiwiYXBwbHlQYXJzZWRQcm9wZXJ0eSIsImJ5cGFzc2VkIiwicHJvcE5hbWVzIiwicHJvcGVydHlHcm91cE5hbWVzIiwicHJvcEdyS2V5cyIsInByb3BlcnR5R3JvdXBLZXlzIiwicHJvcEhhc2giLCJzZWVkS2V5IiwiZ2V0UHJvcGVydGllc0hhc2giLCJvbGRTdHlsZUtleSIsInN0eWxlS2V5Iiwib3ZlcnJpZGRlblN0eWxlcyIsImdyS2V5IiwidXBkYXRlR3JLZXkxIiwidXBkYXRlR3JLZXkyIiwidXBkYXRlR3JLZXkiLCJ1cGRhdGVHcktleVdTdHIiLCJzdHJWYWwiLCJjbGVhbk51bSIsInBhcnNlZFByb3AiLCJwcm9wSW5mbyIsIl9ncktleSIsImdyb3VwS2V5Iiwibm9ybWFsaXplZE51bWJlclZhbCIsImhhc2hPdmVycmlkZSIsIm51bWJlclZhbCIsImVudW1zIiwiaGF2ZU5vcm1OdW0iLCJoYXZlVW5pdGVkTnVtIiwiaGF2ZU51bSIsIm11bHRpcGxlIiwiX2dyS2V5MiIsImdySGFzaCIsInNrIiwibGFiZWxEaW1zS2V5IiwibGFiZWxEaW1lbnNpb25zIiwibGFiZWxLZXlzIiwibGFiZWxLZXkiLCJsYWJlbFN0eWxlS2V5IiwiY29tbW9uTGFiZWwiLCJzb3VyY2VMYWJlbEtleXMiLCJzb3VyY2VMYWJlbEtleSIsInNvdXJjZUxhYmVsU3R5bGVLZXkiLCJ0YXJnZXRMYWJlbEtleXMiLCJ0YXJnZXRMYWJlbEtleSIsInRhcmdldExhYmVsU3R5bGVLZXkiLCJfcCRzdHlsZUtleXMiLCJub2RlQm9keSIsIm5vZGVCb3JkZXIiLCJub2RlT3V0bGluZSIsImJhY2tncm91bmRJbWFnZSIsInBpZSIsInN0cmlwZSIsIm5vZGVLZXlzIiwibm9kZUtleSIsImhhc1BpZSIsImhhc1N0cmlwZSIsImNsZWFyU3R5bGVIaW50cyIsImZsYXRQcm9wIiwicHJvcElzQnlwYXNzIiwib3JpZ1Byb3AiLCJvcmlnUHJvcElzQnlwYXNzIiwiZmxhdFByb3BNYXBwaW5nIiwiZ2V0VmFsIiwiY2hlY2tUcmlnZ2VycyIsImZyb21WYWwiLCJ0b1ZhbCIsImRlbGV0ZUJ5cGFzcyIsInByaW50TWFwcGluZ0VyciIsIm1hcERhdGEiLCJmaWVsZFdpZHRoIiwiZmllbGRNYXgiLCJmaWVsZE1pbiIsInIxIiwidmFsdWVNaW4iLCJyMiIsInZhbHVlTWF4IiwiZzEiLCJnMiIsImIxIiwiYTEiLCJhMiIsImNsciIsImNhbGNWYWx1ZSIsIl9maWVsZHMiLCJfZmllbGRWYWwiLCJmblJldFZhbCIsImNsZWFuRWxlbWVudHMiLCJrZWVwQnlwYXNzZXMiLCJhbnlQcmV2Iiwic3R5UHJvcCIsImRpZmZQcm9wIiwicHJldlByb3AiLCJmcm9tUHJvcCIsInRvUHJvcCIsImluaXRWYWwiLCJpbml0RHQiLCJ0cmFuc2l0aW9uaW5nIiwiY2hlY2tUcmlnZ2VyIiwiZnJvbVZhbHVlIiwidG9WYWx1ZSIsImdldFRyaWdnZXIiLCJvblRyaWdnZXIiLCJ0cmlnZ2VyQ2hlY2siLCJjaGVja1pPcmRlclRyaWdnZXIiLCJ0cmlnZ2Vyc1pPcmRlciIsImNoZWNrQm91bmRzVHJpZ2dlciIsInRyaWdnZXJzQm91bmRzIiwiY2hlY2tDb25uZWN0ZWRFZGdlc0JvdW5kc1RyaWdnZXIiLCJ0cmlnZ2Vyc0JvdW5kc09mQ29ubmVjdGVkRWRnZXMiLCJjaGVja1BhcmFsbGVsRWRnZXNCb3VuZHNUcmlnZ2VyIiwidHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsRWRnZXMiLCJzdHlmbiQ3IiwiaXNCeXBhc3MiLCJfcGFyc2VkUHJvcCIsInNwZWNpZmllZFByb3BzIiwiX25hbWUyIiwiX3ZhbHVlIiwiX3BhcnNlZFByb3AyIiwiX3Byb3AiLCJpc0NvbG9yIiwiaXNNdWx0aSIsIm11dGlwbGUiLCJvbGRWYWx1ZSIsInByb3BlcnR5TmFtZXMiLCJzdHlmbiQ2IiwiZ2V0RW1TaXplSW5QaXhlbHMiLCJweCIsImNvbnRhaW5lckNzcyIsImNvbnRhaW5lcldpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic3R5Zm4kNSIsImlzUmVuZGVyZWRWYWwiLCJnZXRJbmRleGVkU3R5bGUiLCJzdWJwcm9wZXJ0eSIsImFsaWFzIiwicG9pbnRzVG8iLCJzdHlsZVByb3AiLCJnZXRSZW5kZXJlZFZhbHVlIiwiZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHMiLCJpc0FycmF5VmFsdWUiLCJoYXZlVW5pdHMiLCJhbmlQcm9wcyIsImFuaVByb3AiLCJwcm9wc09iaiIsImdldE5vbkRlZmF1bHRQcm9wZXJ0aWVzSGFzaCIsImNoVmFsIiwic3R5Zm4kNCIsImFwcGVuZEZyb21Kc29uIiwiZnJvbUpzb24iLCJyZXNldFRvRGVmYXVsdCIsImRlZmF1bHRMZW5ndGgiLCJzdHlmbiQzIiwiYXBwZW5kRnJvbVN0cmluZyIsInNlbEFuZEJsb2NrU3RyIiwiYmxvY2tSZW0iLCJwcm9wQW5kVmFsU3RyIiwicmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nIiwicmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0iLCJub3RoaW5nTGVmdFRvUGFyc2UiLCJzZWxBbmRCbG9jayIsInNlbGVjdG9yU3RyIiwiYmxvY2tTdHIiLCJpbnZhbGlkQmxvY2siLCJfbm90aGluZ0xlZnRUb1BhcnNlIiwicHJvcEFuZFZhbCIsInByb3BTdHIiLCJmcm9tU3RyaW5nIiwic3R5Zm4kMiIsImhleDMkMSIsImhleDYkMSIsIm1hcEFyZyIsInVybFJlZ2V4ZXMiLCJpbXBsaWNpdFVuaXRzIiwicGVyY2VudGFnZXMiLCJ6ZXJvT25lTnVtYmVyIiwidW5pdGxlc3MiLCJ6ZXJvT25lTnVtYmVycyIsIm5PbmVPbmVOdW1iZXIiLCJub25OZWdhdGl2ZUludCIsIm5vbk5lZ2F0aXZlTnVtYmVyIiwibm9kZVNpemUiLCJudW1iZXJzIiwicG9zaXRpdmVOdW1iZXIiLCJzdHJpY3RNaW4iLCJiaWRpcmVjdGlvbmFsU2l6ZSIsImJpZGlyZWN0aW9uYWxTaXplTWF5YmVQZXJjZW50IiwiYWxsb3dQZXJjZW50IiwiYmlkaXJlY3Rpb25hbFNpemVzIiwic2l6ZU1heWJlUGVyY2VudCIsImF4aXNEaXJlY3Rpb24iLCJheGlzRGlyZWN0aW9uRXhwbGljaXQiLCJheGlzRGlyZWN0aW9uUHJpbWFyeSIsInBhZGRpbmdSZWxhdGl2ZVRvIiwiYmdXSCIsImJnUG9zIiwiYmdSZWxhdGl2ZVRvIiwiYmdSZXBlYXQiLCJiZ0ZpdCIsImJnQ3Jvc3NPcmlnaW4iLCJiZ0NsaXAiLCJiZ0NvbnRhaW5tZW50IiwiYm94U2VsZWN0aW9uIiwiZmlsbCIsImJvb2xzIiwibGluZVN0eWxlIiwibGluZUNhcCIsImxpbmVQb3NpdGlvbiIsImxpbmVKb2luIiwiYm9yZGVyU3R5bGUiLCJyYWRpdXNUeXBlIiwiZm9udEZhbWlseSIsImZvbnRTdHlsZSIsImZvbnRXZWlnaHQiLCJ0ZXh0RGVjb3JhdGlvbiIsInRleHRUcmFuc2Zvcm0iLCJ0ZXh0V3JhcCIsInRleHRPdmVyZmxvd1dyYXAiLCJ0ZXh0QmFja2dyb3VuZFNoYXBlIiwibm9kZVNoYXBlIiwib3ZlcmxheVNoYXBlIiwiY29tcG91bmRJbmNsdWRlTGFiZWxzIiwiYXJyb3dTaGFwZSIsImFycm93RmlsbCIsImRpc3BsYXkiLCJ2aXNpYmlsaXR5IiwiekNvbXBvdW5kRGVwdGgiLCJ6SW5kZXhDb21wYXJlIiwianVzdGlmaWNhdGlvbiIsImxheW91dERhdGEiLCJtYXBMYXlvdXREYXRhIiwibWFwU2NyYXRjaCIsInVybCIsInJlZ2V4ZXMiLCJzaW5nbGVSZWdleE1hdGNoVmFsdWUiLCJ1cmxzIiwicHJvcExpc3QiLCJ0ZXh0Um90YXRpb24iLCJwb2x5Z29uUG9pbnRMaXN0IiwiZXZlbk11bHRpcGxlIiwiZWRnZURpc3RhbmNlcyIsImVkZ2VFbmRwb2ludCIsInNpbmdsZUVudW0iLCJ2YWxpZGF0ZSIsInZhbEFyciIsInVuaXRzQXJyIiwiZ3JhZGllbnREaXJlY3Rpb24iLCJib3VuZHNFeHBhbnNpb24iLCJ6ZXJvTm9uWmVybyIsInZhbDEiLCJ2YWwyIiwiYW55IiwiZW1wdHlOb25FbXB0eSIsInN0cjEiLCJzdHIyIiwiZW1wdHkxIiwiZW1wdHkyIiwibWFpbkxhYmVsIiwic291cmNlTGFiZWwiLCJ0YXJnZXRMYWJlbCIsImJlaGF2aW9yIiwib3ZlcmxheSIsInVuZGVybGF5IiwidHJhbnNpdGlvbiIsIm5vZGVTaXplSGFzaE92ZXJyaWRlIiwiZWRnZUxpbmUiLCJwaWVCYWNrZ3JvdW5kTiIsInN0cmlwZUJhY2tncm91bmROIiwiZWRnZUFycm93IiwiYXJyb3dQcmVmaXhlcyIsInByb3BHcm91cHMiLCJwcm9wZXJ0eUdyb3VwcyIsInByb3BHcm91cE5hbWVzIiwicHJvcEdyb3VwS2V5cyIsImFsaWFzZXMiLCJwb2ludHNUb1Byb3AiLCJhbGlhc1Byb3AiLCJnZXREZWZhdWx0UHJvcGVydGllcyIsImRlZmF1bHRQcm9wZXJ0aWVzIiwicmF3UHJvcHMiLCJwYXJzZWRQcm9wcyIsImFkZERlZmF1bHRTdHlsZXNoZWV0Iiwic3R5Zm4kMSIsInByb3BJc0ZsYXQiLCJwYXJzZUltcGxXYXJuIiwiZmxhdEtleSIsImJ5cGFzc0tleSIsInZhbHVlS2V5IiwiYXJnSGFzaCIsInByb3BDYWNoZSIsInBhcnNlSW1wbCIsInBhc3NlZFZhbHVlIiwidHJpbSIsIl9tYXBwZWQiLCJwZlZhbEFyciIsImhhc0VudW0iLCJjaGVja0VudW1zIiwiZW4iLCJ1bml0c1JlZ2V4Iiwic3RyaWN0TWF4IiwicHJvcHNTdHIiLCJwcm9wc1NwbGl0IiwidHVwbGUiLCJlbnVtUHJvcCIsIl9TdHlsZSIsIlN0eWxlIiwiY29yZVN0eWxlIiwic3R5Zm4iLCJlbGVfcCIsIm1hcFZhbCIsImNzc1J1bGUiLCJjdXJyZW50U2VsZWN0b3JJc0NvcmUiLCJhcHBlbmQiLCJhcHBlbmRUb1N0eWxlIiwiY29yZWZuJDIiLCJuZXdTdHlsZSIsInNldFN0eWxlIiwiZ2VuZXJhdGVTdHlsZSIsImRlZmF1bHRTZWxlY3Rpb25UeXBlIiwiY29yZWZuJDEiLCJzZWxlY3Rpb25UeXBlIiwic2VsVHlwZSIsInBhbm5pbmdFbmFibGVkIiwidXNlclBhbm5pbmdFbmFibGVkIiwiem9vbWluZ0VuYWJsZWQiLCJ1c2VyWm9vbWluZ0VuYWJsZWQiLCJib3hTZWxlY3Rpb25FbmFibGVkIiwiYXJnMCIsImdjIiwidmlld3BvcnRTdGF0ZSIsImJiZSIsInpvb21SYW5nZSIsImN1cnJlbnRQYW4iLCJjdXJyZW50Wm9vbSIsImJhaWwiLCJsZXZlbCIsInBhbjEiLCJ6b29tMSIsInpvb20yIiwicGFuMiIsInZpZXdwb3J0Iiwiem9vbURlZmQiLCJwYW5EZWZkIiwiem9vbUZhaWxlZCIsInBhbkZhaWxlZCIsInoiLCJjYW5jZWxPbkZhaWxlZFpvb20iLCJyZXNldCIsInNpemVDYWNoZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZXh0ZW50IiwicmIiLCJyZW5kZXJlZEV4dGVudCIsIm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUiLCJfaW50IiwiYXV0b2xvY2tOb2RlcyIsImF1dG91bmdyYWJpZnlOb2RlcyIsIkNvcmUiLCJyZWciLCJkZXN0cm95IiwicmVhZGllcyIsImhlYWQiLCJkZWZWYWwiLCJkZWYiLCJhbHRWYWwiLCJsb2FkRXh0RGF0YSIsImV4dERhdGEiLCJhbnlJc1Byb21pc2UiLCJyZW5kZXJlck9wdGlvbnMiLCJzZXRFbGVzQW5kTGF5b3V0Iiwib25sb2FkIiwib25kb25lIiwib2xkRWxlcyIsImxheW91dE9wdHMiLCJ0aGVucyIsImluaXRTdHlsZSIsImluaXRFbGVzIiwiY29yZWZuIiwiaXNSZWFkeSIsImlzSGVhZGxlc3MiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJtb3VudCIsInVubW91bnQiLCJnZXRGcmVzaFJlZiIsImlkSW5Kc29uIiwidXBkYXRlRWxlcyIsImdyIiwidG9Nb2QiLCJfdG9Nb2QkX2kiLCJwYXJlbnRzVG9SZW1vdmUiLCJmbGF0IiwiZGVmYXVsdHMkNyIsImNpcmNsZSIsImdyaWQiLCJhdm9pZE92ZXJsYXAiLCJkZXB0aFNvcnQiLCJkZXByZWNhdGVkT3B0aW9uRGVmYXVsdHMiLCJtYXhpbWFsIiwiYWN5Y2xpYyIsInNldEluZm8iLCJCcmVhZHRoRmlyc3RMYXlvdXQiLCJncmFwaCIsIm1heGltYWxBZGp1c3RtZW50cyIsImhhc0JvdW5kaW5nQm94Iiwic3RydWN0dXJlZENsb25lIiwicm9vdHNBcnJheSIsImNvbXAiLCJjb21wUm9vdHMiLCJkZXB0aHMiLCJmb3VuZEJ5QmZzIiwiYWRkVG9EZXB0aCIsImNoYW5nZURlcHRoIiwibmV3RGVwdGgiLCJwTm9kZSIsIm9ycGhhbk5vZGVzIiwiYXNzaWduRGVwdGhzQXQiLCJhZGp1c3RNYXhpbWFsbHkiLCJzaGlmdGVkIiwiZUluZm8iLCJtYXhEZXB0aCIsImluY21yIiwiaUluZm8iLCJlbnF1ZXVlIiwiZGVxdWV1ZSIsImRpZFNoaWZ0IiwibWluRGlzdGFuY2UiLCJuYmIiLCJjYWNoZWRXZWlnaHRlZFBlcmNlbnQiLCJnZXRXZWlnaHRlZFBlcmNlbnQiLCJlbGVEZXB0aCIsInNhbXBsZXMiLCJiZiIsIm5EZXB0aCIsImFwY3QiLCJicGN0IiwiZGVwdGhzTGVuIiwib3JwaGFuRGVwdGgiLCJhc3NpZ25EZXB0aHMiLCJiaWdnZXN0RGVwdGhTaXplIiwiYXZlTm9kZVNpemUiLCJhY2MiLCJkaXN0YW5jZVkiLCJtYXhEZXB0aFNpemUiLCJnZXRQb3NpdGlvblRvcEJvdHRvbSIsIl9nZXRJbmZvMiIsInJhZGl1c1N0ZXBTaXplIiwiZGVwdGhTaXplIiwiZGlzdGFuY2VYIiwiZXBvcyIsInJvdGF0ZURlZ3JlZXMiLCJnZXRQb3NpdGlvbiIsImRlZmF1bHRzJDYiLCJzd2VlcCIsImNsb2Nrd2lzZSIsIkNpcmNsZUxheW91dCIsImNvdW50ZXJjbG9ja3dpc2UiLCJkVGhldGEiLCJkY29zIiwiZHNpbiIsInJNaW4iLCJnZXRQb3MiLCJyeCIsInJ5IiwiZGVmYXVsdHMkNSIsImVxdWlkaXN0YW50IiwibWluTm9kZVNwYWNpbmciLCJjb25jZW50cmljIiwibGV2ZWxXaWR0aCIsIkNvbmNlbnRyaWNMYXlvdXQiLCJub2RlVmFsdWVzIiwibWF4Tm9kZVNpemUiLCJsZXZlbHMiLCJjdXJyZW50TGV2ZWwiLCJtaW5EaXN0IiwiZmlyc3RMdmxIYXNNdWx0aSIsIm1heFIiLCJyU3RlcCIsInJEZWx0YU1heCIsIl9yIiwiX2xldmVsIiwickRlbHRhIiwiX2xldmVsMiIsIl9sZXZlbDMiLCJfZFRoZXRhIiwiX3IyIiwiX3ZhbCIsIkRFQlVHIiwiZGVmYXVsdHMkNCIsImFuaW1hdGlvblRocmVzaG9sZCIsInJlZnJlc2giLCJyYW5kb21pemUiLCJjb21wb25lbnRTcGFjaW5nIiwibm9kZVJlcHVsc2lvbiIsIm5vZGVPdmVybGFwIiwiaWRlYWxFZGdlTGVuZ3RoIiwiZWRnZUVsYXN0aWNpdHkiLCJuZXN0aW5nRmFjdG9yIiwiZ3Jhdml0eSIsImluaXRpYWxUZW1wIiwiY29vbGluZ0ZhY3RvciIsIm1pblRlbXAiLCJDb3NlTGF5b3V0Iiwibm90RWRnZXMiLCJoYXNTb3VyY2UiLCJoYXNUYXJnZXQiLCJsYXlvdXRJbmZvIiwiY3JlYXRlTGF5b3V0SW5mbyIsInByaW50TGF5b3V0SW5mbyIsInJhbmRvbWl6ZVBvc2l0aW9ucyIsInJlZnJlc2hQb3NpdGlvbnMiLCJtYWluTG9vcCIsInRlbXBlcmF0dXJlIiwiZ2V0U2NhbGVkUG9zIiwiZ2V0U2NhbGVJbkJvdW5kc0ZuIiwibG9vcFJldCIsIl9mcmFtZSIsImZyYW1lIiwic2VwYXJhdGVDb21wb25lbnRzIiwidGhyZWFkIiwiaXNDb21wb3VuZCIsImxheW91dE5vZGVzIiwiaWRUb0luZGV4IiwiZ3JhcGhTZXQiLCJpbmRleFRvR3JhcGgiLCJsYXlvdXRFZGdlcyIsImVkZ2VTaXplIiwiaWQyY21wdElkIiwidGVtcE5vZGUiLCJpc0xvY2tlZCIsImNtcHRJZCIsInBvc2l0aW9uWCIsInBvc2l0aW9uWSIsInBhZExlZnQiLCJwYWRSaWdodCIsInBhZFRvcCIsInBhZEJvdHRvbSIsInRlbXBHcmFwaCIsInBfaWQiLCJub2RlX2lkIiwibm9kZV9peCIsInRlbXBFZGdlIiwiaWRlYWxMZW5ndGgiLCJlbGFzdGljaXR5Iiwic291cmNlSXgiLCJ0YXJnZXRJeCIsInNvdXJjZUdyYXBoIiwidGFyZ2V0R3JhcGgiLCJsY2EiLCJmaW5kTENBIiwibGNhR3JhcGgiLCJfZmluZExDQV9hdXgiLCJjb3VudCIsImZpbmRMQ0FfYXV4IiwiZ3JhcGhJeCIsIm5vZGVJeCIsImNoaWxkR3JhcGhJeCIsImNvc2VCQiIsImxub2RlIiwicGN0WCIsInBjdFkiLCJjYWxjdWxhdGVOb2RlRm9yY2VzIiwiY2FsY3VsYXRlRWRnZUZvcmNlcyIsImNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMiLCJwcm9wYWdhdGVGb3JjZXMiLCJ1cGRhdGVQb3NpdGlvbnMiLCJyYW5kb21EaXN0YW5jZSIsImNtcHRJZDEiLCJjbXB0SWQyIiwiZGlyZWN0aW9uWCIsImRpcmVjdGlvblkiLCJtYXhSYW5kRGlzdCIsIm92ZXJsYXAiLCJub2Rlc092ZXJsYXAiLCJmb3JjZVgiLCJmb3JjZVkiLCJwb2ludDEiLCJmaW5kQ2xpcHBpbmdQb2ludCIsInBvaW50MiIsImRpc3RhbmNlU3FyIiwiZFgiLCJkWSIsIm92ZXJsYXBYIiwib3ZlcmxhcFkiLCJYIiwiWSIsIkgiLCJXIiwiZGlyU2xvcGUiLCJub2RlU2xvcGUiLCJseCIsImx5IiwiZGlzdFRocmVzaG9sZCIsImZ4IiwiZnkiLCJub2RlSW5kZXgiLCJvZmZYIiwib2ZmWSIsImNoaWxkTm9kZSIsInRlbXBGb3JjZSIsImxpbWl0Rm9yY2UiLCJfdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzIiwidXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzIiwiZmxhZyIsImNpZCIsInRvdGFsQSIsInVzZWRXIiwicm93SCIsIm1heFJvd1ciLCJkZWZhdWx0cyQzIiwiYXZvaWRPdmVybGFwUGFkZGluZyIsImNvbmRlbnNlIiwicm93cyIsImNvbHMiLCJHcmlkTGF5b3V0IiwiY2VsbHMiLCJzcGxpdHMiLCJzbWFsbCIsImxhcmdlIiwib1Jvd3MiLCJvQ29scyIsImNvbHVtbnMiLCJzbSIsImxnIiwiX3NtIiwiX2xnIiwiY2VsbFdpZHRoIiwiY2VsbEhlaWdodCIsImNlbGxVc2VkIiwidXNlZCIsInVzZSIsIm1vdmVUb05leHRDZWxsIiwiaWQybWFuUG9zIiwicmNQb3MiLCJkZWZhdWx0cyQyIiwiTnVsbExheW91dCIsImRlZmF1bHRzJDEiLCJQcmVzZXRMYXlvdXQiLCJwb3NJc0ZuIiwiUmFuZG9tTGF5b3V0IiwiTnVsbFJlbmRlcmVyIiwidGhyb3dJbWdFcnIiLCJCUnAkZiIsImFycm93U2hhcGVXaWR0aCIsInJlZ2lzdGVyQXJyb3dTaGFwZXMiLCJhcnJvd1NoYXBlcyIsImJiQ29sbGlkZSIsInRyYW5zbGF0aW9uIiwiZWRnZVdpZHRoIiwieFJvdGF0ZWQiLCJ5Um90YXRlZCIsInhTY2FsZWQiLCJ5U2NhbGVkIiwieFRyYW5zbGF0ZWQiLCJ5VHJhbnNsYXRlZCIsInJldFB0cyIsInBvaW50c1RvQXJyIiwic3RhbmRhcmRHYXAiLCJkZWZpbmVBcnJvd1NoYXBlIiwiZGVmbiIsImNvbGxpZGUiLCJyb3VnaENvbGxpZGUiLCJkcmF3IiwiYXJyb3dTaGFwZUltcGwiLCJnYXAiLCJjb250cm9sUG9pbnQiLCJwdHNUcmFucyIsImN0cmxQdCIsImN0cmxQdFRyYW5zIiwicG9pbnRzVGVlIiwidHJpUHRzIiwidGVlUHRzIiwicG9pbnRzVHIiLCJjaXJjbGVJbnNpZGUiLCJnZXRBcnJvd1dpZHRoIiwiYmFzZUNyb3NzTGluZVB0cyIsImNyb3NzTGluZVB0cyIsInNoaWZ0RmFjdG9yIiwieTAiLCJCUnAkZSIsInByb2plY3RJbnRvVmlld3BvcnQiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9mZnNldHMiLCJmaW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImNvbnRhaW5lckJCIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInN0eWxlVmFsdWUiLCJwYWRkaW5nSG9yIiwicGFkZGluZ1ZlciIsImJvcmRlckhvciIsInVuc2NhbGVkVyIsInVuc2NhbGVkSCIsImludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSIsImZpbmROZWFyZXN0RWxlbWVudCIsImludGVyYWN0aXZlRWxlbWVudHNPbmx5IiwiaXNUb3VjaCIsImZpbmROZWFyZXN0RWxlbWVudHMiLCJnZXRDYWNoZWRaU29ydGVkRWxlcyIsIm5lYXIiLCJlZGdlVGhyZXNob2xkIiwibm9kZVRocmVzaG9sZCIsImxhYmVsVGhyZXNob2xkIiwibWluU3FEaXN0IiwibmVhckVkZ2UiLCJuZWFyTm9kZSIsImFkZEVsZSIsInNxRGlzdCIsImNoZWNrTm9kZSIsImh3IiwiaGgiLCJycyIsImdldE5vZGVTaGFwZSIsImNoZWNrUG9pbnQiLCJjaGVja0VkZ2UiLCJzdHlsZVdpZHRoIiwid2lkdGhTcSIsIndpZHRoMiIsImVkZ2VUeXBlIiwiYWxscHRzIiwiYXJTaXplIiwiYXJyb3dzIiwiYXJyb3dTdGFydFgiLCJhcnJvd1N0YXJ0WSIsInNyY0Fycm93QW5nbGUiLCJhcnJvd0VuZFgiLCJhcnJvd0VuZFkiLCJ0Z3RBcnJvd0FuZ2xlIiwibWlkc3JjQXJyb3dBbmdsZSIsIm1pZHRndEFycm93QW5nbGUiLCJhciIsInByZXByb3AiLCJwcmUiLCJjaGVja0xhYmVsIiwidGgiLCJldmVudHNFbmFibGVkIiwib3giLCJveSIsImdldEFsbEluQm94IiwieDFjIiwieDJjIiwieTFjIiwieTJjIiwiYm94QmIiLCJzZWxlY3Rpb25Cb3giLCJib3hFZGdlcyIsImdldFJvdGF0ZWRMYWJlbEJveCIsImRvTGluZXNJbnRlcnNlY3QiLCJjY3ciLCJ0ZXh0RXZlbnRzIiwibm9kZUJveFNlbGVjdE1vZGUiLCJsYWJlbEJveFNlbGVjdEVuYWJsZWQiLCJub2RlQmIiLCJyb3RhdGVkTGFiZWxCb3giLCJub2RlQm9keUJiIiwibm9kZUJvZHlDb3JuZXJzIiwiX3JvdGF0ZWRMYWJlbEJveCIsImVkZ2VCb3hTZWxlY3RNb2RlIiwiZW5kWCIsImVuZFkiLCJhbGxJbnNpZGUiLCJfc2VsZWN0ZWQiLCJfcHRzIiwic2VnU3RhcnQiLCJzZWdFbmQiLCJfYm94RWRnZXMkYiIsImJveFN0YXJ0IiwiYm94RW5kIiwiQlJwJGQiLCJjYWxjdWxhdGVBcnJvd0FuZ2xlcyIsImlzSGF5c3RhY2siLCJpc0JlemllciIsImlzTXVsdGliZXppZXIiLCJpc1NlZ21lbnRzIiwiaXNTZWxmIiwic2VncHRzIiwiYlgiLCJiWSIsImkyIiwiaTEiLCJpc1JvdW5kIiwibWlkVmVjdG9yIiwiY3B0cyIsImN0cmxwdHMiLCJicDB4IiwiYnAweSIsImJwMXgiLCJicDF5IiwiaWMiLCJtaWREaXNwWCIsIm1pZERpc3BZIiwiaTMiLCJnZXRBcnJvd0hlaWdodCIsImFycm93V2lkdGhDYWNoZSIsInNpbkEiLCJzaW5BOTAiLCJyYWREaXJlY3Rpb24iLCJkcmF3RGlyZWN0aW9uIiwiaGFsZkFuZ2xlIiwiY1JhZGl1cyIsImxlbk91dCIsImxpbWl0IiwibGFzdFBvaW50IiwiYXNWZWMiLCJwcCIsIm54IiwibnkiLCJhbmciLCJpbnZlcnRWZWMiLCJvcmlnaW5hbFYiLCJpbnZlcnRlZFYiLCJjYWxjQ29ybmVyQXJjIiwicHJldmlvdXNQb2ludCIsImN1cnJlbnRQb2ludCIsIm5leHRQb2ludCIsInJhZGl1c01heCIsImlzQXJjUmFkaXVzIiwiYXNpbiIsImRyYXdQcmVwYXJlZFJvdW5kQ29ybmVyIiwiY3R4Iiwicm91bmRDb3JuZXIiLCJsaW5lVG8iLCJhcmMiLCJlbmRBbmdsZSIsImNvdW50ZXJDbG9ja3dpc2UiLCJnZXRSb3VuZENvcm5lciIsIkFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UIiwiQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlRfTCIsIkJScCRjIiwiZmluZE1pZHB0UHRzRXRjIiwicGFpckluZm8iLCJwb3NQdHMiLCJpbnRlcnNlY3Rpb25QdHMiLCJ2ZWN0b3JOb3JtSW52ZXJzZSIsIm1pZHB0UHRzIiwic3JjTWFuRW5kcHQiLCJ0Z3RNYW5FbmRwdCIsImhhdmVNYW51YWxFbmRQdHMiLCJyZWNhbGNWZWN0b3JOb3JtSW52ZXJzZSIsIl90aGlzJG1hbnVhbEVuZHB0VG9QeCIsIm1hbnVhbEVuZHB0VG9QeCIsIl90aGlzJG1hbnVhbEVuZHB0VG9QeDIiLCJfdGhpcyRtYW51YWxFbmRwdFRvUHgzIiwiX3RoaXMkbWFudWFsRW5kcHRUb1B4NCIsImVuZFB0cyIsImZpbmRIYXlzdGFja1BvaW50cyIsImhheXN0YWNrIiwic3JjUG9zIiwidGd0UG9zIiwic3JjVyIsInRndFciLCJzcmNIIiwidGd0SCIsImhhbGZSYWRpdXMiLCJzdG9yZUVkZ2VQcm9qZWN0aW9ucyIsInJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMiLCJjYWxjdWxhdGVMYWJlbEFuZ2xlcyIsImZpbmRTZWdtZW50c1BvaW50cyIsInNlZ21lbnRXcyIsInNlZ21lbnREcyIsInNlZ21lbnRScyIsInNlZ21lbnRUcyIsInNlZ21lbnRzTiIsImxhc3RSYWRpdXMiLCJsYXN0UmFkaXVzVHlwZSIsInJhZGlpIiwidzEiLCJ3MiIsIl90aGlzJGZpbmRNaWRwdFB0c0V0YyIsImFkanVzdGVkTWlkcHQiLCJmaW5kTG9vcFBvaW50cyIsImVkZ2VJc1VuYnVuZGxlZCIsImRpckNvdW50cyIsImN0cmxwdERpc3RzIiwiY3RybHB0RGlzdCIsImxvb3BEaXIiLCJsb29wU3dwIiwic3RlcFNpemUiLCJsb29wRGlzdCIsImxvb3BBbmdsZSIsIm91dEFuZ2xlIiwiaW5BbmdsZSIsImZpbmRDb21wb3VuZExvb3BQb2ludHMiLCJsb29wVyIsImxvb3BhUG9zIiwibG9vcGJQb3MiLCJsb29wUG9zIiwibWluQ29tcG91bmRTdHJldGNoIiwiY29tcG91bmRTdHJldGNoQSIsImNvbXBvdW5kU3RyZXRjaEIiLCJmaW5kU3RyYWlnaHRFZGdlUG9pbnRzIiwiZmluZEJlemllclBvaW50cyIsImVkZ2VJc1N3YXBwZWQiLCJjdHJscHRXcyIsImJlemllck4iLCJjdHJscHRXZWlnaHQiLCJtdWx0aSIsIm5vcm1jdHJscHREaXN0IiwibWFuY3RybHB0RGlzdCIsInNpZ24iLCJkaXN0YW5jZUZyb21NaWRwb2ludCIsIl90aGlzJGZpbmRNaWRwdFB0c0V0YzIiLCJmaW5kVGF4aVBvaW50cyIsIlZFUlRJQ0FMIiwiSE9SSVpPTlRBTCIsIkxFRlRXQVJEIiwiUklHSFRXQVJEIiwiRE9XTldBUkQiLCJVUFdBUkQiLCJBVVRPIiwiZEluY2x1ZGVzTm9kZUJvZHkiLCJ0YXhpRGlyIiwicmF3VGF4aURpciIsInRheGlUdXJuIiwidHVybklzUGVyY2VudCIsInRheGlUdXJuUGZWYWwiLCJ0dXJuSXNOZWdhdGl2ZSIsIm1pbkQiLCJkdyIsImRoIiwicGR4IiwicGR5Iiwic3ViRFdIIiwiZHh5IiwiZHdoIiwiaXNFeHBsaWNpdERpciIsImlzVmVydCIsInBsIiwic2duTCIsImZvcmNlZERpciIsImdldElzVG9vQ2xvc2UiLCJpc1Rvb0Nsb3NlU3JjIiwiaXNUb29DbG9zZVRndCIsImlzVG9vQ2xvc2UiLCJsU2hhcGVJbnNpZGVTcmMiLCJsU2hhcGVJbnNpZGVUZ3QiLCJfbFNoYXBlSW5zaWRlU3JjIiwiX2xTaGFwZUluc2lkZVRndCIsIl95IiwiX3giLCJfeDIiLCJfeDMiLCJfeTIiLCJfeTMiLCJfeTQiLCJfeDQiLCJfeDUiLCJfeDYiLCJfeTUiLCJfeTYiLCJ0cnlUb0NvcnJlY3RJbnZhbGlkUG9pbnRzIiwic3JjU2hhcGUiLCJ0Z3RTaGFwZSIsInNyY0Nvcm5lclJhZGl1cyIsInRndENvcm5lclJhZGl1cyIsInNyY1JzIiwidGd0UnMiLCJiYWRTdGFydCIsImJhZEFTdGFydCIsImJhZEVuZCIsImJhZEFFbmQiLCJtaW5DcEFEaXN0RmFjdG9yIiwiYXJyb3dXIiwibWluQ3BBRGlzdCIsInN0YXJ0QUNwRGlzdCIsImNsb3NlU3RhcnRBQ3AiLCJlbmRBQ3BEaXN0IiwiY2xvc2VFbmRBQ3AiLCJvdmVybGFwcGluZyIsImNwRCIsImNwTCIsImNwTSIsImNwUHJvaiIsInNyY0N0cmxQdEludG4iLCJpbnRlcnNlY3RMaW5lIiwiX2NwRCIsIl9jcEwiLCJfY3BNIiwiX3JhZGl1cyIsIl9jcFByb2oiLCJ0Z3RDdHJsUHRJbnRuIiwiZmluZEVuZHBvaW50cyIsInN0b3JlQWxscHRzIiwibXQiLCJyb3VuZENvcm5lcnMiLCJmYWN0b3IiLCJjaGVja0ZvckludmFsaWRFZGdlV2FybmluZyIsImxvZ2dlZEVyciIsImZpbmRFZGdlQ29udHJvbFBvaW50cyIsImhhc2hUYWJsZSIsInBhaXJJZCIsInBhaXJJZHMiLCJoYXlzdGFja0VkZ2VzIiwiZWRnZUlzQmV6aWVyIiwic3JjSW5kZXgiLCJ0Z3RJbmRleCIsInRhYmxlRW50cnkiLCJoYXNVbmJ1bmRsZWQiLCJoYXNCZXppZXIiLCJfcGFpcklkcyRwIiwic3dhcHBlZHBhaXJJbmZvIiwiZmlyc3RFZGdlIiwiX2N1cnZlU3R5bGUiLCJfZWRnZUlzVW5idW5kbGVkIiwiY2FsY3VsYXRlZEludGVyc2VjdGlvbiIsInNyY091dHNpZGUiLCJzcmNJbnRuIiwidGd0T3V0c2lkZSIsInRndEludG4iLCJ2ZWN0b3IiLCJ2ZWN0b3JOb3JtIiwicGFzc2VkUGFpckluZm8iLCJzdGFydHNXaXRoIiwiZ2V0UHRzIiwiQlJwJGIiLCJucG9zIiwiX3RndE1hbkVuZHB0JHBmVmFsdWUiLCJfc3JjTWFuRW5kcHQkcGZWYWx1ZSIsInRndEFyU2hhcGUiLCJzcmNBclNoYXBlIiwiZXQiLCJ0YXhpIiwic2VnbWVudHMiLCJoYXNFbmRwdHMiLCJvdmVycmlkZUVuZHB0cyIsInNyY01hbkVuZHB0VmFsIiwidGd0TWFuRW5kcHRWYWwiLCJwMV9pIiwicDJfaSIsInRndE1hbkVuZHB0UHQiLCJzcmNNYW5FbmRwdFB0IiwiY3BTdGFydCIsImNwRW5kIiwic3JjQXJyb3dGcm9tUHQiLCJ0Z3RBcnJvd0Zyb21QdCIsInRycyIsImx3MiIsImxoMiIsInZhIiwiaGEiLCJsYWJlbEludGVyc2VjdCIsInJlZlB0IiwiaW50U3FkaXN0IiwibGFiSW50U3FkaXN0IiwibGFiSW50MlNxRGlzdCIsImFycm93RW5kIiwiZWRnZUVuZCIsInNycyIsIl9sdyIsIl9saCIsIl9seCIsIl9seSIsIl9sdzIiLCJfbGgyIiwiX3ZhIiwiX2hhIiwiX2xhYmVsSW50ZXJzZWN0IiwiX3JlZlB0IiwiX2ludFNxZGlzdCIsIl9sYWJJbnRTcWRpc3QiLCJfbWluU3FEaXN0IiwiX2xhYkludDJTcURpc3QiLCJhcnJvd1N0YXJ0IiwiZWRnZVN0YXJ0IiwiYmFkTGluZSIsIkJScCRhIiwicHVzaEJlemllclB0cyIsInFiZXppZXJBdCQxIiwiYnB0cyIsImJlemllclByb2pQY3RzIiwibHB0cyIsInJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zIiwiQlJwJDkiLCJyZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24iLCJjb250ZW50IiwidGV4dFgiLCJ0ZXh0WSIsIm5vZGVXaWR0aCIsIm5vZGVIZWlnaHQiLCJub2RlUG9zIiwidGV4dEhhbGlnbiIsInRleHRWYWxpZ24iLCJhcHBseUxhYmVsRGltZW5zaW9ucyIsImxpbmVBbmdsZUZyb21EZWx0YSIsImxpbmVBbmdsZSIsImJlemllckFuZ2xlIiwidDAiLCJscDAiLCJscDEiLCJzZXRScyIsIm1pZEFuZ2xlIiwiX2NyZWF0ZUNvbnRyb2xQb2ludEluZm8iLCJjcmVhdGVDb250cm9sUG9pbnRJbmZvIiwic3RhcnREaXN0IiwiblByb2pzIiwiYWRkU2VnbWVudCIsImNwIiwicHJldlNlZ21lbnQiLCJzZWdtZW50IiwicHJldkNwIiwiY2FsY3VsYXRlRW5kUHJvamVjdGlvbiIsImlzU3JjIiwiY3BzIiwidG90YWxEaXN0IiwiX2NwIiwiX3NlZyIsImxhc3RTZWciLCJzZWciLCJ0U2VnbWVudCIsInNlZ0R0IiwiZGkiLCJkMCIsInBEIiwiX3QiLCJhcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zIiwiZ2V0TGFiZWxUZXh0IiwiY2FjaGVLZXkiLCJsYWJlbERpbXMiLCJjYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMiLCJsaW5lSGVpZ2h0IiwibnVtTGluZXMiLCJub3JtUGVyTGluZUhlaWdodCIsImxhYmVsTGluZUhlaWdodCIsInBmZCIsIndyYXBTdHlsZSIsInp3c3AiLCJtYXhXIiwib3ZlcmZsb3ciLCJvdmVyZmxvd0FueSIsIndyYXBwZWRMaW5lcyIsInNlcGFyYXRvclJlZ2V4IiwibGluZURpbXMiLCJsaW5lVyIsInByb2Nlc3NlZExpbmUiLCJzZXBhcmF0b3JNYXRjaGVzIiwibWF0Y2hBbGwiLCJzdWJsaW5lIiwicHJldmlvdXNJbmRleCIsInNlcGFyYXRvck1hdGNoIiwid29yZFNlcGFyYXRvciIsIndvcmQiLCJ0ZXN0TGluZSIsInRlc3REaW1zIiwidGVzdFciLCJfbWF4VyIsImVsbGlwc2l6ZWQiLCJlbGxpcHNpcyIsImluY0xhc3RDaCIsIndpZHRoV2l0aE5leHRDaCIsImdldExhYmVsSnVzdGlmaWNhdGlvbiIsImZTdHlsZSIsImZhbWlseSIsImNhbnZhcyIsImxhYmVsQ2FsY0NhbnZhcyIsImMyZCIsImxhYmVsQ2FsY0NhbnZhc0NvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsImRzIiwiekluZGV4IiwicG9pbnRlckV2ZW50cyIsImZvbnQiLCJtZXRyaWNzIiwibWVhc3VyZVRleHQiLCJjYWxjdWxhdGVMYWJlbEFuZ2xlIiwicm90Iiwicm90U3RyIiwibGFiZWxBdXRvQW5nbGUiLCJsYWJlbEFuZ2xlIiwic291cmNlTGFiZWxBbmdsZSIsInRhcmdldExhYmVsQW5nbGUiLCJCUnAkOCIsIlRPT19TTUFMTF9DVVRfUkVDVCIsIndhcm5lZEN1dFJlY3QiLCJtYWtlUG9seWdvbiIsIkJScCQ3IiwicmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyIsImVsZXNUb1VwZGF0ZSIsImRpcnR5U3R5bGVDYWNoZXMiLCJjbGVhbkNvbm5lY3RlZCIsImJpbmRlciIsIm9uRGlydHlCb3VuZHMiLCJvbkRpcnR5U3R5bGUiLCJ1cGRhdGVFbGVDYWxjcyIsImZucyIsIm9uVXBkYXRlRWxlQ2FsY3NGbnMiLCJmbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSIsImVsZUNhbGNzIiwib25VcGRhdGVFbGVDYWxjcyIsImlzQ2xlYW5Db25uZWN0ZWQiLCJfcDIiLCJfcnN0eWxlIiwibm9kZVciLCJub2RlSCIsIl9wMyIsIl9yc3R5bGUyIiwiQlJwJDYiLCJ1cGRhdGVDYWNoZWRHcmFiYmVkRWxlcyIsImNhY2hlZFpTb3J0ZWRFbGVzIiwiZHJhZyIsIm5vbmRyYWciLCJncmFiVGFyZ2V0cyIsImluRHJhZ0xheWVyIiwiaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzIiwiZm9yY2VSZWNhbGMiLCJCUnAkNSIsIkJScCQ0IiwiZ2V0Q2FjaGVkSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9uTG9hZCIsImltYWdlQ2FjaGUiLCJpbWFnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJJbWFnZSIsImRhdGFVcmlQcmVmaXgiLCJpc0RhdGFVcmkiLCJCUnAkMyIsInJlZ2lzdGVyQmluZGluZyIsInVzZUNhcHR1cmUiLCJ0Z3RJc0RvbSIsImJvZHkiLCJzdXBwb3J0c1Bhc3NpdmVFdmVudHMiLCJzdXBwb3J0c1Bhc3NpdmUiLCJjYXB0dXJlIiwicGFzc2l2ZSIsImJpbmRpbmdzIiwibm9kZUlzRHJhZ2dhYmxlIiwibm9kZUlzR3JhYmJhYmxlIiwibG9hZCIsImlzU2VsZWN0ZWQiLCJnZXRTaGFkb3dSb290Iiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsIm5vZGVUeXBlIiwiaG9zdCIsInRyaWdnZXJFdmVudHMiLCJpc011bHRTZWxLZXlEb3duIiwic2hpZnRLZXkiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsbG93UGFubmluZ1Bhc3N0aHJvdWdoIiwiZG93biIsImRvd25zIiwiYWxsb3dQYXNzdGhyb3VnaCIsInNldEdyYWJiZWQiLCJzZXRGcmVlZCIsInNldEluRHJhZ0xheWVyIiwic2V0T3V0RHJhZ0xheWVyIiwic2V0R3JhYlRhcmdldCIsImlzR3JhYlRhcmdldCIsInJlbW92ZUdyYWJUYXJnZXQiLCJhZGRUb0RyYWdMaXN0IiwibGlzdCIsImFkZFRvTGlzdCIsImxpc3RIYXNFbGUiLCJhZGREZXNjZW5kYW50c1RvRHJhZyIsImlubmVyTm9kZXMiLCJhZGROb2Rlc1RvRHJhZyIsInVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyIiwiYWRkTm9kZVRvRHJhZyIsImZyZWVEcmFnZ2VkRWxlbWVudHMiLCJncmFiYmVkRWxlcyIsImJsdXJBY3RpdmVEb21FbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJoYXZlTXV0YXRpb25zQXBpIiwiTXV0YXRpb25PYnNlcnZlciIsImhhdmVSZXNpemVPYnNlcnZlckFwaSIsIlJlc2l6ZU9ic2VydmVyIiwicmVtb3ZlT2JzZXJ2ZXIiLCJtdXRucyIsIm11dG4iLCJyTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJyTm9kZSIsInBhcmVudE5vZGUiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwib25SZXNpemUiLCJzdHlsZU9ic2VydmVyIiwicmVzaXplT2JzZXJ2ZXIiLCJpbnZhbGlkYXRlQ29vcmRzIiwiaW5Cb3hTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJldmVudEluQ29udGFpbmVyIiwiY29udGFpbmVyUGFnZUNvb3JkcyIsInRvdWNoZXMiLCJhdExlYXN0T25lUG9zSW5zaWRlIiwidFBhcmVudCIsImNvbnRhaW5lcklzVGFyZ2V0IiwibW91c2Vkb3duSGFuZGxlciIsImhvdmVyRGF0YSIsIndoaWNoIiwiZ3BvcyIsInNlbGVjdCIsIm5lYXJzIiwiZHJhZ2dlZEVsZW1lbnRzIiwiZHJhZ0RhdGEiLCJwb3NzaWJsZURyYWdFbGVtZW50cyIsIm1kb3duUG9zIiwibWRvd25HUG9zIiwibWFrZUV2ZW50IiwiY2hlY2tGb3JUYXBob2xkIiwidGFwaG9sZENhbmNlbGxlZCIsInRhcGhvbGRUaW1lb3V0IiwidGFwaG9sZER1cmF0aW9uIiwiY3h0U3RhcnRlZCIsImN4dEV2dCIsImFjdGl2YXRlIiwiZG93blRpbWUiLCJnZXRUaW1lIiwiY3h0RHJhZ2dlZCIsInRyaWdnZXJHcmFiIiwic2VsZWN0ZWROb2RlcyIsInJlZHJhd0hpbnQiLCJiZ0FjdGl2ZVBvc2lzdGlvbiIsInJlZHJhdyIsInNoYWRvd1Jvb3QiLCJtb3VzZW1vdmVIYW5kbGVyIiwiZHJhZ2dpbmdFbGVzIiwiZHJhZ2dpbmciLCJzZWxlY3RpbmciLCJpc092ZXJUaHJlc2hvbGREcmFnIiwiZHgyIiwiZHkyIiwiZGlzdDIiLCJkZXNrdG9wVGFwVGhyZXNob2xkMiIsIm11bHRTZWxLZXlEb3duIiwidXBkYXRlRHJhZ0RlbHRhIiwiZHJhZ0RlbHRhIiwiZ29JbnRvQm94TW9kZSIsImN4dE92ZXIiLCJkZWx0YVAiLCJqdXN0U3RhcnRlZFBhbiIsIm1kUG9zIiwiZHJhZ2dlZCIsInVuYWN0aXZhdGUiLCJkaWREcmFnIiwianVzdFN0YXJ0ZWREcmFnIiwidG90YWxTaGlmdCIsImNsaWNrVGltZW91dCIsImRpZERvdWJsZUNsaWNrIiwicHJldkNsaWNrVGltZVN0YW1wIiwibW91c2V1cEhhbmRsZXIiLCJjeHRUYXAiLCJlbGVXb3VsZEJlU2VsZWN0ZWQiLCJkb3duV2FzR3JhYmJlZCIsIndoZWVsRGVsdGFzIiwid2hlZWxEZWx0YU4iLCJpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlIiwiaW5hY2N1cmF0ZVNjcm9sbEZhY3RvciIsImFsbEFyZURpdmlzaWJsZUJ5IiwiYWxsQXJlU2FtZU1hZ25pdHVkZSIsImZpcnN0TWFnIiwid2hlZWxIYW5kbGVyIiwiY2xhbXAiLCJkZWx0YVkiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJ3ZHMiLCJzY3JvbGxpbmdQYWdlIiwid2hlZWxab29taW5nIiwid2hlZWxUaW1lb3V0IiwibmVlZHNXaGVlbEZpeCIsImRlbHRhTW9kZSIsIm5ld1pvb20iLCJnZXN0dXJlU3RhcnRab29tIiwic2Nyb2xsSGFuZGxlciIsInNjcm9sbGluZ1BhZ2VUaW1lb3V0IiwiZ2VzdHVyZVN0YXJ0SGFuZGxlciIsImhhc1RvdWNoU3RhcnRlZCIsIm1vdXNlT3V0SGFuZGxlciIsIm1vdXNlT3ZlckhhbmRsZXIiLCJmMXgxIiwiZjF5MSIsImYyeDEiLCJmMnkxIiwiZGlzdGFuY2UxIiwiZGlzdGFuY2UxU3EiLCJjZW50ZXIxIiwibW9kZWxDZW50ZXIxIiwiY29udGFpbmVyV2lkdGgiLCJjb250YWluZXJIZWlnaHQiLCJ0d29GaW5nZXJzU3RhcnRJbnNpZGUiLCJkaXN0YW5jZVNxIiwidG91Y2hzdGFydEhhbmRsZXIiLCJ0b3VjaERhdGEiLCJlYXJsaWVyIiwic2luZ2xlVG91Y2hNb3ZlZCIsInRvdWNoRHJhZ0VsZXMiLCJjeHREaXN0VGhyZXNob2xkIiwiY3h0RGlzdFRocmVzaG9sZFNxIiwibmVhcjEiLCJuZWFyMiIsInN0YXJ0cyIsImRyYWdnZWRFbGVzIiwic2luZ2xlVG91Y2hTdGFydFRpbWUiLCJwaW5jaGluZyIsInNQb3MiLCJ0b3VjaDAiLCJzdGFydEdQb3NpdGlvbiIsInRvdWNobW92ZUhhbmRsZXIiLCJzdGFydEdQb3MiLCJ0b3VjaFRhcFRocmVzaG9sZDIiLCJmMXgyIiwiZjF5MiIsImYyeDIiLCJmMnkyIiwiZGlzdGFuY2UyU3EiLCJmYWN0b3JTcSIsImRpc3RUaHJlc2hvbGRTcSIsImZhY3RvclRocmVzaG9sZCIsImZhY3RvclRocmVzaG9sZFNxIiwibGFzdFRocmVlVG91Y2giLCJkaWRTZWxlY3QiLCJkZV9wIiwiX3N0YXJ0IiwiZGlzdGFuY2UyIiwiZGYxeCIsImRmMXkiLCJkZjJ4IiwiZGYyeSIsInR4IiwidHkiLCJjdHJ4IiwiY3RyeSIsInN3aXBlUGFubmluZyIsInRvdWNoY2FuY2VsSGFuZGxlciIsInRvdWNoZW5kSGFuZGxlciIsImRpZERvdWJsZVRvdWNoIiwidG91Y2hUaW1lb3V0IiwicHJldlRvdWNoVGltZVN0YW1wIiwiY3R4VGFwZW5kIiwiY3R4VGFwIiwic3RhcnRXYXNHcmFiYmVkIiwicmRpc3QyIiwiVG91Y2hFdmVudCIsInBvaW50ZXJzIiwibWFrZVRvdWNoIiwiaWRlbnRpZmllciIsInBvaW50ZXJJZCIsInBhZ2VYIiwicGFnZVkiLCJyYWRpdXNYIiwicmFkaXVzWSIsInNjcmVlblgiLCJzY3JlZW5ZIiwibWFrZVBvaW50ZXIiLCJ0b3VjaCIsImFkZFBvaW50ZXIiLCJyZW1vdmVQb2ludGVyIiwidXBkYXRlUG9pbnRlciIsImFkZFRvdWNoZXNUb0V2ZW50IiwicG9pbnRlcklzTW91c2UiLCJwb2ludGVyVHlwZSIsIkJScCQyIiwiZ2VuZXJhdGVQb2x5Z29uIiwibm9kZVNoYXBlSW1wbCIsInN0cm9rZVBvc2l0aW9uIiwiZ2VuZXJhdGVFbGxpcHNlIiwiZ2VuZXJhdGVSb3VuZFBvbHlnb24iLCJnZXRPckNyZWF0ZUNvcm5lcnMiLCJnZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlIiwiZGlhbSIsImdlbmVyYXRlQ3V0UmVjdGFuZ2xlIiwiY29ybmVyTGVuZ3RoIiwiZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyIsImNsIiwieEJlZ2luIiwieEVuZCIsInlCZWdpbiIsInlFbmQiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3R0b21SaWdodCIsImJvdHRvbUxlZnQiLCJjUHRzIiwiY3V0VHJpYW5nbGVQdHMiLCJnZW5lcmF0ZUJhcnJlbCIsImJQdHMiLCJnZW5lcmF0ZUJhcnJlbEJlemllclB0cyIsImFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMiLCJtMCIsIm0xIiwibTIiLCJjdXJ2ZUNvbnN0YW50cyIsImhPZmZzZXQiLCJ3T2Zmc2V0IiwiY3RybFB0WE9mZnNldCIsImlzVG9wIiwiaXNCb3R0b20iLCJiYXJyZWxDdXJ2ZVB0cyIsImdldEN1cnZlVCIsImN1cnZlUHRzIiwieDAiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwiY29lZmYiLCJ2YWxpZFJvb3RzIiwiY3VydmVSZWdpb25zIiwiY29ybmVyUHRzIiwiYmV6WSIsImdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUiLCJ0b3BJbnRlcnNlY3Rpb25zIiwicmVnaXN0ZXJOb2RlU2hhcGVzIiwiZGlhbW9uZFBvaW50cyIsInN0YXI1UG9pbnRzIiwib3V0ZXJQb2ludHMiLCJpbm5lclBvaW50cyIsImlubmVyUmFkaXVzIiwidGFnUG9pbnRzIiwiQlJwJDEiLCJ0aW1lVG9SZW5kZXIiLCJyZWRyYXdUb3RhbFRpbWUiLCJyZWRyYXdDb3VudCIsImF2ZXJhZ2VSZWRyYXdUaW1lIiwibGFzdFJlZHJhd1RpbWUiLCJsYXN0RHJhd1RpbWUiLCJyZXF1ZXN0ZWRGcmFtZSIsInJlbmRlck9wdGlvbnMiLCJwcmlvcml0eSIsImNicyIsImJlZm9yZVJlbmRlckNhbGxiYWNrcyIsInN0YXJ0UmVuZGVyTG9vcCIsInJlbmRlckxvb3BTdGFydGVkIiwiX3JlbmRlckZuIiwicmVuZGVyRm4iLCJyZXF1ZXN0VGltZSIsInNraXBGcmFtZSIsInJlbmRlciIsImVuZFRpbWUiLCJCYXNlUmVuZGVyZXIiLCJCUiIsIkJScCIsImNsaWVudEZ1bmN0aW9ucyIsImN0ciIsInN0eWxlc2hlZXRJZCIsInN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzIiwidGV4dENvbnRlbnQiLCJpbnNlcnRCZWZvcmUiLCJjb21wdXRlZFN0eWxlIiwidHJpZ2dlck1vZGUiLCJpbml0aWFsUGFuIiwicmVkcmF3cyIsIm1vdGlvbkJsdXJFbmFibGVkIiwiZm9yY2VkUGl4ZWxSYXRpbyIsIm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kiLCJtb3Rpb25CbHVyUHhSYXRpbyIsIm1iUHhSQmx1cnJ5IiwibWluTWJMb3dRdWFsRnJhbWVzIiwiZnVsbFF1YWxpdHlNYiIsImNsZWFyZWRGb3JNb3Rpb25CbHVyIiwiZWxlVHhyRGVxIiwibHlyVHhyRGVxIiwibHlyVHhyU2tpcCIsIm1hdGNoQ2FudmFzU2l6ZSIsImJpbmRpbmciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsImxhYmVsQ2FsY0RpdiIsImZ1bGxGcHNUaW1lIiwiZGVmcyIsInNldHVwRGVxdWV1ZWluZyIsInNldHVwRGVxdWV1ZWluZ0ltcGwiLCJkZXF1ZXVlaW5nU2V0dXAiLCJxdWV1ZVJlZHJhdyIsImRlcVJlZHJhd1RocmVzaG9sZCIsImZyYW1lU3RhcnRUaW1lIiwiYXZnUmVuZGVyVGltZSIsInJlbmRlclRpbWUiLCJkZXFkIiwiZ2V0UGl4ZWxSYXRpbyIsImZyYW1lRHVyYXRpb24iLCJ0aW1lQXZhaWxhYmxlIiwiZGVxRmFzdENvc3QiLCJkZXFDb3N0IiwiZGVxQXZnQ29zdCIsImRlcU5vRHJhd0Nvc3QiLCJ0aGlzRGVxZCIsImRlcSIsIm9uRGVxZCIsInNob3VsZFJlZHJhdyIsIkVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAiLCJkb2VzRWxlSW52YWxpZGF0ZUtleSIsImlkc0J5S2V5Iiwia2V5Rm9ySWQiLCJjYWNoZXNCeUx2bCIsImx2bHMiLCJnZXRJZHNGb3IiLCJhZGRJZEZvcktleSIsImRlbGV0ZUlkRm9yS2V5IiwiZ2V0TnVtYmVyT2ZJZHNGb3JLZXkiLCJ1cGRhdGVLZXlNYXBwaW5nRm9yIiwiY3VycktleSIsImRlbGV0ZUtleU1hcHBpbmdGb3IiLCJrZXlIYXNDaGFuZ2VkRm9yIiwibmV3S2V5IiwiaXNJbnZhbGlkIiwiZ2V0Q2FjaGVzQXQiLCJsdmwiLCJjYWNoZXMiLCJnZXRDYWNoZSIsImdldEZvckNhY2hlZEtleSIsImhhc0NhY2hlIiwic2V0Q2FjaGUiLCJkZWxldGVDYWNoZSIsImludmFsaWRhdGVLZXkiLCJpbnZhbGlkYXRlIiwiZW50aXJlS2V5SW52YWxpZGF0ZWQiLCJtaW5UeHJIIiwidHhyU3RlcEgiLCJtaW5MdmwkMSIsIm1heEx2bCQxIiwibWF4Wm9vbSQxIiwiZWxlVHhyU3BhY2luZyIsImRlZlR4cldpZHRoIiwibWF4VHhyVyIsIm1heFR4ckgiLCJtaW5VdGlsaXR5IiwibWF4RnVsbG5lc3MiLCJtYXhGdWxsbmVzc0NoZWNrcyIsImRlcUNvc3QkMSIsImRlcUF2Z0Nvc3QkMSIsImRlcU5vRHJhd0Nvc3QkMSIsImRlcUZhc3RDb3N0JDEiLCJkZXFSZWRyYXdUaHJlc2hvbGQkMSIsIm1heERlcVNpemUkMSIsImdldFR4clJlYXNvbnMiLCJkb3duc2NhbGUiLCJoaWdoUXVhbGl0eSIsImluaXREZWZhdWx0cyIsImRyYXdFbGVtZW50IiwiZ2V0Qm91bmRpbmdCb3giLCJnZXRSb3RhdGlvblBvaW50IiwiZ2V0Um90YXRpb25PZmZzZXQiLCJpc1Zpc2libGUiLCJhbGxvd0VkZ2VUeHJDYWNoaW5nIiwiYWxsb3dQYXJlbnRUeHJDYWNoaW5nIiwiRWxlbWVudFRleHR1cmVDYWNoZSIsImluaXRPcHRpb25zIiwib25EZXF1ZXVlcyIsIkVUQ3AiLCJyZWFzb25zIiwiZ2V0VGV4dHVyZVF1ZXVlIiwidHhySCIsImVsZUltZ0NhY2hlcyIsImdldFJldGlyZWRUZXh0dXJlUXVldWUiLCJydHh0clFzIiwicmV0aXJlZCIsInJ0eHRyUSIsImdldEVsZW1lbnRRdWV1ZSIsImVsZUNhY2hlUXVldWUiLCJyZXFzIiwiZ2V0RWxlbWVudEtleVRvUXVldWUiLCJrMnEiLCJlbGVLZXlUb0NhY2hlUXVldWUiLCJnZXRFbGVtZW50IiwicmVhc29uIiwiZWxlU2NhbGVkSCIsImVsZVNjYWxlZFciLCJzY2FsZWRMYWJlbFNob3duIiwiZWxlVGV4dEJpZ2dlclRoYW5NaW4iLCJlbGVDYWNoZSIsImludmFsaWRhdGVkIiwidGV4dHVyZSIsImludmFsaWRhdGVkV2lkdGgiLCJ0eHJRIiwidHhyIiwiYWRkTmV3VHhyIiwicmVjeWNsZVRleHR1cmUiLCJhZGRUZXh0dXJlIiwidXNlZFdpZHRoIiwic2NhbGFibGVGcm9tIiwib3RoZXJDYWNoZSIsImRlcWluZyIsImhpZ2hRdWFsaXR5UmVxIiwiZG93bnNjYWxlUmVxIiwiaGlnaGVyQ2FjaGUiLCJvbmVVcENhY2hlIiwiZHJhd0ltYWdlIiwic2V0VHJhbnNmb3JtIiwiY2xlYXJSZWN0IiwicXVldWVFbGVtZW50IiwibG93ZXJDYWNoZSIsIl9sMiIsInRyYW5zbGF0ZSIsImVsZUNhY2hlcyIsImNoZWNrVGV4dHVyZUZ1bGxuZXNzIiwiaW52YWxpZGF0ZUVsZW1lbnRzIiwiaW52YWxpZGF0ZUVsZW1lbnQiLCJub090aGVyRWxlc1VzZUNhY2hlIiwiX2NhY2hlIiwiY2hlY2tUZXh0dXJlVXRpbGl0eSIsInJlbW92ZUZyb21RdWV1ZSIsInJldGlyZVRleHR1cmUiLCJmdWxsbmVzc0NoZWNrcyIsIm1pblciLCJtYWtlT2Zmc2NyZWVuQ2FudmFzIiwiZXhpc3RpbmdSZXEiLCJyZXEiLCJkZXF1ZXVlZCIsImNhY2hlRXhpc3RzIiwib25EZXF1ZXVlIiwib2ZmRGVxdWV1ZSIsImRlZk51bUxheWVycyIsIm1pbkx2bCIsIm1heEx2bCIsInJlZmluZUVsZURlYm91bmNlVGltZSIsIm1heERlcVNpemUiLCJpbnZhbGlkVGhyZXNob2xkIiwibWF4TGF5ZXJBcmVhIiwibWF4TGF5ZXJEaW0iLCJ1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMiLCJMYXllcmVkVGV4dHVyZUNhY2hlIiwibGF5ZXJzQnlMZXZlbCIsImZpcnN0R2V0IiwibGFzdEludmFsaWRhdGlvblRpbWUiLCJza2lwcGluZyIsImVsZVR4ckRlcXMiLCJzY2hlZHVsZUVsZW1lbnRSZWZpbmVtZW50IiwicmVmaW5lRWxlbWVudFRleHR1cmVzIiwicVNvcnQiLCJsYXllcnNRdWV1ZSIsIkxUQ3AiLCJsYXllcklkUG9vbCIsIk1BWF9JTlQiLCJtYWtlTGF5ZXIiLCJsYXllciIsImVsZXNRdWV1ZSIsImdldExheWVycyIsInZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nIiwibGF5ZXJzQnlMdmwiLCJsYXllcnMiLCJsdmxDb21wbGV0ZSIsImxldmVsSXNDb21wbGV0ZSIsInRtcExheWVycyIsImNoZWNrVGVtcExldmVscyIsImNhblVzZUFzVG1wTHZsIiwiY2hlY2tMdmxzIiwiZGlyIiwiZ2V0QmIiLCJhZnRlciIsImFyZWEiLCJtYXhFbGVzUGVyTGF5ZXIiLCJhbGxvd0xhenlRdWV1ZWluZyIsImltZ0xheWVyQ2FjaGVzIiwiZXhpc3RpbmdMYXllciIsInF1ZXVlTGF5ZXIiLCJkcmF3RWxlSW5MYXllciIsImdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbCIsInNldEltZ1Ntb290aGluZyIsImRyYXdDYWNoZWRFbGVtZW50IiwibnVtRWxlc0luTGF5ZXJzIiwiaW52YWxpZGF0ZUxheWVyIiwidXBkYXRlRWxlbWVudHNJbkxheWVycyIsImhhdmVMYXllcnMiLCJpbnZhbEFzc29jTGF5ZXJzIiwicmVwbGFjZW1lbnQiLCJyZWZpbmVFYWNoRWxlIiwickx5ciIsInJlcGxhY2VzIiwiZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50IiwiZWxlc1EiLCJoYXNJZCIsImVsZURlcXMiLCJhcHBseUxheWVyUmVwbGFjZW1lbnQiLCJyZXF1ZXN0UmVkcmF3IiwibGF5ZXJzSW5MZXZlbCIsInJlcGxhY2VkIiwiQ1JwJGIiLCJ0cmlhbmdsZUJhY2tjdXJ2ZSIsImZpcnN0UHQiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwidHJpYW5nbGVUZWUiLCJ0cmlhbmdsZVBvaW50cyIsInRlZVBvaW50cyIsImJlZ2luUGF0aCIsImZpcnN0VGVlUHQiLCJtb3ZlVG8iLCJjbG9zZVBhdGgiLCJjaXJjbGVUcmlhbmdsZSIsImZpcnN0VHJQdCIsImNpcmNsZSQxIiwiQ1JwJGEiLCJzaGlmdFRvT3JpZ2luV2l0aEJiIiwic2hvd0xhYmVsIiwic2hvd092ZXJsYXkiLCJzaG93T3BhY2l0eSIsImRyYXdOb2RlIiwiZHJhd0VkZ2UiLCJkcmF3RWxlbWVudE92ZXJsYXkiLCJkcmF3Tm9kZU92ZXJsYXkiLCJkcmF3RWRnZU92ZXJsYXkiLCJkcmF3RWxlbWVudFVuZGVybGF5IiwiZHJhd05vZGVVbmRlcmxheSIsImRyYXdFZGdlVW5kZXJsYXkiLCJkcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24iLCJlbGVUeHJDYWNoZSIsImdldFJvdGF0aW9uIiwiZ2V0T3BhY2l0eSIsInNtb290aCIsInJvdFB0IiwiZ2V0SW1nU21vb3RoaW5nIiwib2xkR2xvYmFsQWxwaGEiLCJnbG9iYWxBbHBoYSIsImdldFplcm9Sb3RhdGlvbiIsImdldExhYmVsUm90YXRpb24iLCJnZXRUZXh0QW5nbGUiLCJnZXRTb3VyY2VMYWJlbFJvdGF0aW9uIiwiZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiIsImdldFRleHRPcGFjaXR5IiwicmVxdWVzdEhpZ2hRdWFsaXR5IiwiX3IkZGF0YSIsImxibFR4ckNhY2hlIiwic2xiVHhyQ2FjaGUiLCJ0bGJUeHJDYWNoZSIsImRyYXdFbGVtZW50cyIsImRyYXdDYWNoZWRFbGVtZW50cyIsImRyYXdDYWNoZWROb2RlcyIsImRyYXdMYXllcmVkRWxlbWVudHMiLCJseXJUeHJDYWNoZSIsIkNScCQ5IiwiZHJhd0xhYmVsIiwic2hvdWxkRHJhd092ZXJsYXkiLCJzaG91bGREcmF3T3BhY2l0eSIsImxpbmVPcGFjaXR5IiwibGluZU91dGxpbmVXaWR0aCIsImxpbmVPdXRsaW5lQ29sb3IiLCJlZmZlY3RpdmVMaW5lT3BhY2l0eSIsImVmZmVjdGl2ZUFycm93T3BhY2l0eSIsImRyYXdMaW5lIiwic3Ryb2tlT3BhY2l0eSIsImVsZVN0cm9rZVN0eWxlIiwiZHJhd0VkZ2VUcmlhbmdsZVBhdGgiLCJsaW5lV2lkdGgiLCJkcmF3RWRnZVBhdGgiLCJkcmF3TGluZU91dGxpbmUiLCJjb2xvclN0cm9rZVN0eWxlIiwiZHJhd092ZXJsYXkiLCJkcmF3VW5kZXJsYXkiLCJkcmF3QXJyb3dzIiwiYXJyb3dPcGFjaXR5IiwiZHJhd0Fycm93aGVhZHMiLCJkcmF3VGV4dCIsImRyYXdFbGVtZW50VGV4dCIsImdob3N0T3BhY2l0eSIsImVmZmVjdGl2ZUdob3N0T3BhY2l0eSIsImRyYXdFZGdlT3ZlcmxheVVuZGVybGF5Iiwib3ZlcmxheU9yVW5kZXJsYXkiLCJpbmNsdWRlcyIsInVzZVBhdGhzIiwiY2FudmFzQ3h0IiwicGF0aENhY2hlSGl0IiwibGluZURhc2hQYXR0ZXJuIiwibGluZURhc2hPZmZzZXQiLCJwYXRoQ2FjaGVLZXkiLCJrZXlNYXRjaGVzIiwicGF0aENhY2hlIiwiUGF0aDJEIiwic2V0TGluZURhc2giLCJzdHJva2UiLCJmaWxsU3R5bGUiLCJzdHJva2VTdHlsZSIsInRyaWFuZ2xlSGVhZCIsImRyYXdBcnJvd2hlYWQiLCJhcnJvd0NsZWFyRmlsbCIsInBBcnJvd1dpZHRoIiwiZWRnZU9wYWNpdHkiLCJnY28iLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJjb2xvckZpbGxTdHlsZSIsImRyYXdBcnJvd1NoYXBlIiwic2hhcGVXaWR0aCIsImNhbnZhc0NvbnRleHQiLCJzaGFwZUltcGwiLCJhcnJvd1BhdGhDYWNoZSIsImNhY2hlZFBhdGgiLCJDUnAkOCIsInNhZmVEcmF3SW1hZ2UiLCJpbWciLCJpeCIsIml5IiwiaXciLCJpaCIsImRyYXdJbnNjcmliZWRJbWFnZSIsIm5vZGVPcGFjaXR5Iiwic3R5bGVPYmoiLCJyZXBlYXQiLCJwYWRkaW5nWDIiLCJub2RlVFciLCJub2RlVEgiLCJjbGlwIiwic2hvdWxkQ2xpcCIsImltZ09wYWNpdHkiLCJpbWdXIiwiY2FjaGVkVyIsImltZ0giLCJjYWNoZWRIIiwiYXBwZW5kQ2hpbGQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInBvc1hVbml0cyIsInBvc1hQZlZhbCIsIm9mZlhVbml0cyIsIm9mZlhQZlZhbCIsInBvc1lVbml0cyIsInBvc1lQZlZhbCIsIm9mZllVbml0cyIsIm9mZllQZlZhbCIsImdBbHBoYSIsInNtb290aGluZ0VuYWJsZWQiLCJpc1Ntb290aGluZ1N3aXRjaGVkIiwic2F2ZSIsImNyZWF0ZVBhdHRlcm4iLCJDUnAkNyIsImNvbXB1dGVkU2l6ZSIsIm1pblNpemUiLCJ1c2VFbGVPcGFjaXR5IiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiX2xhYmVsIiwic3JjTGFiZWwiLCJ0Z3RMYWJlbCIsImFwcGx5Um90YXRpb24iLCJnZXRGb250Q2FjaGUiLCJmb250Q2FjaGVzIiwic2V0dXBUZXh0U3R5bGUiLCJsYWJlbFN0eWxlIiwibGFiZWxTaXplIiwibGFiZWxGYW1pbHkiLCJsYWJlbFdlaWdodCIsIm91dGxpbmVDb2xvciIsImRpYW1ldGVyIiwicm91bmRSZWN0IiwicGRhc2giLCJ0ZXh0QW5nbGUiLCJvcmdUZXh0WCIsIm9yZ1RleHRZIiwidGV4dFciLCJ0ZXh0SCIsImJhY2tncm91bmRPcGFjaXR5IiwidGV4dEJvcmRlcldpZHRoIiwiYmFja2dyb3VuZFBhZGRpbmciLCJzdHlsZVNoYXBlIiwicm91bmRlZCIsImNpcmNsZWQiLCJyb3VuZFJhZGl1cyIsInRleHRGaWxsIiwidGV4dFN0cm9rZSIsInRleHRMaW5lV2lkdGgiLCJ0ZXh0QmFja2dyb3VuZENvbG9yIiwidGV4dEJvcmRlckNvbG9yIiwidGV4dEJvcmRlclN0eWxlIiwiZG9GaWxsIiwiZG9TdHJva2UiLCJiZ1giLCJiZ1kiLCJiZ1ciLCJiZ0giLCJ3aGl0ZVdpZHRoIiwiaGFsZlRleHRXIiwic3Ryb2tlVGV4dCIsImZpbGxUZXh0IiwiQ1JwJDYiLCJlbGVPcGFjaXR5IiwiYmdJbWdQcm9wIiwidXJsRGVmaW5lZCIsIm51bUltYWdlcyIsImRlZmQiLCJiZ0ltZ0Nyb3NzT3JpZ2luIiwiYmFja2dyb3VuZFRpbWVzdGFtcCIsImRhcmtuZXNzIiwiYmdPcGFjaXR5IiwiYm9yZGVyQ29sb3IiLCJib3JkZXJKb2luIiwiYm9yZGVyQ2FwIiwiYm9yZGVyUGF0dGVybiIsImJvcmRlck9mZnNldCIsIm91dGxpbmVTdHlsZSIsInNldHVwU2hhcGVDb2xvciIsImJnT3B5IiwiZWxlRmlsbFN0eWxlIiwic2V0dXBCb3JkZXJDb2xvciIsImJkck9weSIsInNldHVwT3V0bGluZUNvbG9yIiwib3Rsbk9weSIsImdldFBhdGgiLCJub2RlUGF0aENhY2hlIiwic2hhcGVQdHMiLCJzaGFwZVBhdGgiLCJkcmF3U2hhcGUiLCJkcmF3SW1hZ2VzIiwicHJldkJnaW5nIiwidG90YWxDb21wbGV0ZWQiLCJkcmF3UGllIiwicmVkcmF3U2hhcGUiLCJwaWVPcGFjaXR5IiwiZHJhd1N0cmlwZSIsInN0cmlwZU9wYWNpdHkiLCJkYXJrZW4iLCJkYXJrZW5PcGFjaXR5IiwiZHJhd0JvcmRlciIsInJlZ2lvbiIsImFkZFBhdGgiLCJkcmF3T3V0bGluZSIsImJXaWR0aCIsInNjYWxlWCIsInNjYWxlWSIsInNXaWR0aCIsInNIZWlnaHQiLCJfcGF0aCIsIm91dGxpbmVQYXRoIiwiZHJhd0VsbGlwc2VQYXRoIiwic011bHQiLCJkcmF3Um91bmRQb2x5Z29uUGF0aCIsImRyYXdSb3VuZFJlY3RhbmdsZVBhdGgiLCJkcmF3Q3V0UmVjdGFuZ2xlUGF0aCIsImRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgiLCJkcmF3QmFycmVsUGF0aCIsImRyYXdQb2x5Z29uUGF0aCIsIl9wYWQiLCJlZmZHaG9zdE9wYWNpdHkiLCJkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSIsImN5U3R5bGUiLCJwaWVTaXplIiwiaG9sZSIsIm92ZXJhbGxTdGFydEFuZ2xlIiwiaG9sZVJhZGl1cyIsImxhc3RQZXJjZW50IiwiYW5nbGVTdGFydCIsImFuZ2xlRGVsdGEiLCJhbmdsZUVuZCIsInN0cmlwZVNpemUiLCJzdHJpcGVXIiwic3RyaXBlSCIsIkNScCQ1IiwibW90aW9uQmx1ckRlbGF5IiwiY29udGV4dHMiLCJiYWNraW5nU3RvcmUiLCJiYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJwYWludENhY2hlIiwicGFpbnRDYWNoZXMiLCJuZWVkVG9DcmVhdGVDYWNoZSIsImNyZWF0ZUdyYWRpZW50U3R5bGVGb3IiLCJzaGFwZVN0eWxlTmFtZSIsImdyYWRpZW50U3R5bGUiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsIl9lbmQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsIl93aWR0aCIsIl9oZWlnaHQiLCJoYXNQb3NpdGlvbnMiLCJhZGRDb2xvclN0b3AiLCJncmFkaWVudEZpbGxTdHlsZSIsImJhY2tncm91bmRGaWxsIiwiYmFja2dyb3VuZENvbG9yIiwiZ3JhZGllbnRTdHJva2VTdHlsZSIsImxpbmVGaWxsIiwibGluZUNvbG9yIiwibWJQeFJhdGlvIiwiYnVmZmVyQ2FudmFzZXMiLCJNT1RJT05CTFVSX0JVRkZFUl9OT0RFIiwiTU9USU9OQkxVUl9CVUZGRVJfRFJBRyIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiY2FudmFzQ29udGFpbmVyIiwiQ0FOVkFTX0xBWUVSUyIsImNhbnZhc2VzIiwiQlVGRkVSX0NPVU5UIiwidGV4dHVyZU11bHQiLCJURVhUVVJFX0JVRkZFUiIsImZvcmNlZENvbnRleHQiLCJmb3JjZWRab29tIiwiZm9yY2VkUGFuIiwiZHJhd0FsbExheWVycyIsImZvcmNlZFB4UmF0aW8iLCJjbGVhckNhbnZhcyIsIk5PREUiLCJEUkFHIiwiZHJhd09ubHlOb2RlTGF5ZXIiLCJuZWVkRHJhdyIsImNhbnZhc05lZWRzUmVkcmF3IiwidGV4dHVyZURyYXciLCJpbk5vZGVEcmFnR2VzdHVyZSIsIm1vdGlvbkJsdXJGYWRlRWZmZWN0IiwicHJldlB4UmF0aW8iLCJtb3Rpb25CbHVyVGltZW91dCIsIm1iRnJhbWVzIiwiY2xlYXJpbmdNb3Rpb25CbHVyIiwidGV4dHVyZURyYXdMYXN0RnJhbWUiLCJTRUxFQ1RfQk9YIiwiZWZmZWN0aXZlWm9vbSIsImVmZmVjdGl2ZVBhbiIsInByZXZWcCIsInByZXZWaWV3cG9ydCIsInZpZXdwb3J0SXNEaWZmIiwibWJjbGVhciIsImZpbGxSZWN0Iiwic2V0Q29udGV4dFRyYW5zZm9ybSIsImVQYW4iLCJlWm9vbSIsImJ1ZmZlckNvbnRleHRzIiwidGV4dHVyZUNhY2hlIiwibXBhbiIsIm91dHNpZGVCZ0NvbG9yIiwib3V0c2lkZUJnT3BhY2l0eSIsInZwTWFuaXAiLCJoaWRlRWRnZXMiLCJuZWVkTWJDbGVhciIsInVzZUJ1ZmZlciIsImRyYXdEZWJ1Z1BvaW50cyIsImRyYXdTZWxlY3Rpb25SZWN0YW5nbGUiLCJjeHROb2RlIiwidHh0Tm9kZSIsImN4dERyYWciLCJ0eHREcmFnIiwiZHJhd01vdGlvbkJsdXIiLCJ0eHQiLCJuZWVkQ2xlYXIiLCJweHIiLCJtb3Rpb25CbHVyQ2xlYXJlZCIsImZwc0hlaWdodCIsInN0cm9rZVJlY3QiLCJmcHMiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsIm1heEZwcyIsImNvbXBpbGVTaGFkZXIiLCJnbCIsInNoYWRlciIsImNyZWF0ZVNoYWRlciIsInNoYWRlclNvdXJjZSIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTb3VyY2UiLCJmcmFnZW1lbnRTb3VyY2UiLCJ2ZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJwcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJjcmVhdGVUZXh0dXJlQ2FudmFzIiwiZ2V0RWZmZWN0aXZlUGFuWm9vbSIsImdldEVmZmVjdGl2ZVpvb20iLCJpc1NpbXBsZVNoYXBlIiwiYXJyYXlFcXVhbCIsInRvV2ViR0xDb2xvciIsIm91dEFycmF5IiwiaW5kZXhUb1ZlYzQiLCJ2ZWM0VG9JbmRleCIsInZlYzQiLCJjcmVhdGVUZXh0dXJlIiwiZGVidWdJRCIsImJ1ZmZlciIsIm9mZnNjcmVlbkNhbnZhcyIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIkxJTkVBUiIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIkxJTkVBUl9NSVBNQVBfTkVBUkVTVCIsInBpeGVsU3RvcmVpIiwiVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMIiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwiZ2VuZXJhdGVNaXBtYXAiLCJkZWxldGVUZXh0dXJlIiwiZ2V0VHlwZUluZm8iLCJnbHNsVHlwZSIsIkZMT0FUIiwiSU5UIiwiY3JlYXRlVHlwZWRBcnJheSIsImdsVHlwZSIsImRhdGFPclNpemUiLCJJbnQzMkFycmF5IiwiY3JlYXRlVHlwZWRBcnJheVZpZXciLCJzdHJpZGUiLCJjcmVhdGVCdWZmZXJTdGF0aWNEcmF3IiwiYXR0cmlidXRlTG9jIiwiZGF0YUFycmF5IiwiX2dldFR5cGVJbmZvIiwiX2dldFR5cGVJbmZvMiIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwidmVydGV4QXR0cmliSVBvaW50ZXIiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsImNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3IiwiaW5zdGFuY2VzIiwiX2dldFR5cGVJbmZvMyIsIl9nZXRUeXBlSW5mbzQiLCJieXRlcyIsIkRZTkFNSUNfRFJBVyIsInZlcnRleEF0dHJpYkRpdmlzb3IiLCJ2aWV3cyIsImdldFZpZXciLCJzZXRQb2ludCIsInZpZXciLCJidWZmZXJTdWJEYXRhIiwiY3JlYXRlM3gzTWF0cml4QnVmZmVyRHluYW1pY0RyYXciLCJtYXRyaXhTaXplIiwibWF0cml4RGF0YSIsIm1hdHJpeFZpZXdzIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJsb2MiLCJnZXRNYXRyaXhWaWV3Iiwic2V0RGF0YSIsImNyZWF0ZVBpY2tpbmdGcmFtZUJ1ZmZlciIsImZiIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsInRhcmdldFRleHR1cmUiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwic2V0RnJhbWVidWZmZXJBdHRhY2htZW50U2l6ZXMiLCJBUlJBWV9UWVBFIiwibXVsdGlwbHkiLCJhMDAiLCJhMDEiLCJhMDIiLCJhMTAiLCJhMTEiLCJhMTIiLCJhMjAiLCJhMjEiLCJhMjIiLCJiMDAiLCJiMDEiLCJiMDIiLCJiMTAiLCJiMTEiLCJiMTIiLCJiMjAiLCJiMjEiLCJiMjIiLCJyYWQiLCJBdGxhcyIsInRleFNpemUiLCJ0ZXhSb3dzIiwidGV4SGVpZ2h0IiwiZW5hYmxlV3JhcHBpbmciLCJuZWVkc0J1ZmZlciIsImZyZWVQb2ludGVyIiwia2V5VG9Mb2NhdGlvbiIsImxvY2siLCJnZXRLZXlzIiwiZ2V0U2NhbGUiLCJtYXhUZXhXaWR0aCIsInRleFciLCJ0ZXhIIiwiZG9EcmF3aW5nIiwiX3RoaXMkZ2V0U2NhbGUiLCJkcmF3QXQiLCJsb2NhdGlvbiIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwibG9jYXRpb25zIiwiZHJhd05vcm1hbCIsImRyYXdXcmFwcGVkIiwiZmlyc3RUZXhXIiwic2Vjb25kVGV4VyIsIl9keSIsIm1vdmVUb1N0YXJ0T2ZOZXh0Um93IiwiZ2V0T2Zmc2V0cyIsImlzRW1wdHkiLCJjYW5GaXQiLCJfdGhpcyRnZXRTY2FsZTIiLCJidWZmZXJJZk5lZWRlZCIsImRpc3Bvc2UiLCJBdGxhc0NvbGxlY3Rpb24iLCJhdGxhc2VzIiwic3R5bGVLZXlUb0F0bGFzIiwibWFya2VkS2V5cyIsIl9jcmVhdGVBdGxhcyIsIl9nZXRTY3JhdGNoQ2FudmFzIiwiYXRsYXMiLCJnZXRBdGxhcyIsImhhc0F0bGFzIiwibWFya0tleUZvckdDIiwiX3RoaXMyIiwibmV3QXRsYXNlcyIsIm5ld1N0eWxlS2V5VG9BdGxhcyIsIm5ld0F0bGFzIiwia2V5c1RvQ29sbGVjdCIsIl9hdGxhcyRnZXRPZmZzZXRzIiwiX2F0bGFzJGdldE9mZnNldHMyIiwiczEiLCJzMiIsIl9jb3B5VGV4dHVyZVRvTmV3QXRsYXMiLCJvbGRBdGxhcyIsIl9vbGRBdGxhcyRnZXRPZmZzZXRzIiwiX29sZEF0bGFzJGdldE9mZnNldHMyIiwiZ2V0Q291bnRzIiwia2V5Q291bnQiLCJhdGxhc0NvdW50IiwidmFsdWVzIiwic2V0MSIsInNldDIiLCJBdGxhc01hbmFnZXIiLCJnbG9iYWxPcHRpb25zIiwiYXRsYXNTaXplIiwibWF4QXRsYXNlc1BlckJhdGNoIiwicmVuZGVyVHlwZXMiLCJjb2xsZWN0aW9ucyIsInR5cGVBbmRJZFRvS2V5IiwiZ2V0QXRsYXNTaXplIiwiYWRkQXRsYXNDb2xsZWN0aW9uIiwiY29sbGVjdGlvbk5hbWUiLCJhdGxhc0NvbGxlY3Rpb25PcHRpb25zIiwiX3RoaXMkZ2xvYmFsT3B0aW9ucyIsImNhY2hlZENyZWF0ZVRleHR1cmVDYW52YXMiLCJfY2FjaGVTY3JhdGNoQ2FudmFzIiwiYXRsYXNDb2xsZWN0aW9uIiwiYWRkUmVuZGVyVHlwZSIsInJlbmRlclR5cGVPcHRpb25zIiwiZ2V0UmVuZGVyVHlwZU9wdHMiLCJnZXRBdGxhc0NvbGxlY3Rpb24iLCJwcmV2VyIsInByZXZIIiwic2NyYXRjaENhbnZhcyIsInJlbmRlclR5cGUiLCJfdGhpczMiLCJfcmVmMiRmb3JjZVJlZHJhdyIsImZvcmNlUmVkcmF3IiwiX3JlZjIkZmlsdGVyRWxlIiwiZmlsdGVyRWxlIiwiX3JlZjIkZmlsdGVyVHlwZSIsImZpbHRlclR5cGUiLCJuZWVkR0MiLCJydW5HQ05vdyIsIl9pdGVyYXRvcjMiLCJfc3RlcDMiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0Iiwia2V5QXJyYXkiLCJnZXRJRCIsIm1hcEtleSIsIm9sZEtleUFycmF5Iiwib2xkS2V5IiwiX2l0ZXJhdG9yNSIsIl9zdGVwNSIsImdldE9yQ3JlYXRlQXRsYXMiLCJkcmF3biIsImRyYXdDbGlwcGVkIiwiZ2V0QXRsYXNJbmZvIiwiX3RoaXM0IiwiX2F0bGFzJGdldE9mZnNldHMzIiwiX2F0bGFzJGdldE9mZnNldHM0IiwidGV4MSIsInRleDIiLCJ0ZXgiLCJnZXREZWJ1Z0luZm8iLCJkZWJ1Z0luZm8iLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiX3N0ZXA2JHZhbHVlIiwiX2NvbGxlY3Rpb24kZ2V0Q291bnRzIiwiQXRsYXNCYXRjaE1hbmFnZXIiLCJiYXRjaEF0bGFzZXMiLCJnZXRNYXhBdGxhc2VzUGVyQmF0Y2giLCJnZXRJbmRleEFycmF5IiwiZ2V0QXRsYXNDb3VudCIsImdldEF0bGFzZXMiLCJjYW5BZGRUb0N1cnJlbnRCYXRjaCIsImdldEF0bGFzSW5kZXhGb3JCYXRjaCIsImF0bGFzSUQiLCJjaXJjbGVTRCIsInJlY3RhbmdsZVNEIiwicm91bmRSZWN0YW5nbGVTRCIsImVsbGlwc2VTRCIsIlJFTkRFUl9UQVJHRVQiLCJTQ1JFRU4iLCJzY3JlZW4iLCJQSUNLSU5HIiwicGlja2luZyIsIlRFWF9QSUNLSU5HX01PREUiLCJJR05PUkUiLCJVU0VfQkIiLCJURVhUVVJFIiwiRURHRV9TVFJBSUdIVCIsIkVER0VfQ1VSVkVfU0VHTUVOVCIsIkVER0VfQVJST1ciLCJSRUNUQU5HTEUiLCJST1VORF9SRUNUQU5HTEUiLCJCT1RUT01fUk9VTkRfUkVDVEFOR0xFIiwiRUxMSVBTRSIsIkVsZW1lbnREcmF3aW5nV2ViR0wiLCJtYXhJbnN0YW5jZXMiLCJiZ0NvbG9yIiwiYmF0Y2hEZWJ1Z0luZm8iLCJhdGxhc01hbmFnZXIiLCJiYXRjaE1hbmFnZXIiLCJzaW1wbGVTaGFwZU9wdGlvbnMiLCJfY3JlYXRlU2hhZGVyUHJvZ3JhbSIsInBpY2tpbmdQcm9ncmFtIiwidmFvIiwiX2NyZWF0ZVZBTyIsImFkZFRleHR1cmVBdGxhc1JlbmRlclR5cGUiLCJ0eXBlTmFtZSIsImFkZFNpbXBsZVNoYXBlUmVuZGVyVHlwZSIsInJlbmRlclRhcmdldCIsInZlcnRleFNoYWRlclNvdXJjZSIsImlkeHMiLCJmcmFnbWVudFNoYWRlclNvdXJjZSIsImFQb3NpdGlvbiIsImdldEF0dHJpYkxvY2F0aW9uIiwiYUluZGV4IiwiYVZlcnRUeXBlIiwiYVRyYW5zZm9ybSIsImFBdGxhc0lkIiwiYVRleCIsImFQb2ludEFQb2ludEIiLCJhUG9pbnRDUG9pbnREIiwiYUxpbmVXaWR0aCIsImFDb2xvciIsImFDb3JuZXJSYWRpdXMiLCJhQm9yZGVyQ29sb3IiLCJ1UGFuWm9vbU1hdHJpeCIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInVBdGxhc1NpemUiLCJ1QkdDb2xvciIsInVab29tIiwidVRleHR1cmVzIiwidW5pdFNxdWFyZSIsInZlcnRleENvdW50IiwiY3JlYXRlVmVydGV4QXJyYXkiLCJiaW5kVmVydGV4QXJyYXkiLCJ0cmFuc2Zvcm1CdWZmZXIiLCJpbmRleEJ1ZmZlciIsInZlcnRUeXBlQnVmZmVyIiwiYXRsYXNJZEJ1ZmZlciIsInRleEJ1ZmZlciIsInBvaW50QVBvaW50QkJ1ZmZlciIsInBvaW50Q1BvaW50REJ1ZmZlciIsImxpbmVXaWR0aEJ1ZmZlciIsImNvbG9yQnVmZmVyIiwiY29ybmVyUmFkaXVzQnVmZmVyIiwiYm9yZGVyQ29sb3JCdWZmZXIiLCJfYnVmZmVycyIsInN0YXJ0RnJhbWUiLCJwYW5ab29tTWF0cml4Iiwid3JhcHBlZENvdW50Iiwic2ltcGxlQ291bnQiLCJpbnN0YW5jZUNvdW50IiwiZW5kRnJhbWUiLCJfaXNWaXNpYmxlIiwiZHJhd1RleHR1cmUiLCJlbGVJbmRleCIsIl9pc1ZhbGlkRWRnZSIsImdldFRleFBpY2tpbmdNb2RlIiwiZHJhd1BpY2tpbmdSZWN0YW5nbGUiLCJhdGxhc0luZm9BcnJheSIsImF0bGFzSW5mbyIsImF0bGFzSW5kZXgiLCJfYXJyIiwiX2FyciRfaSIsImluc3RhbmNlIiwiaW5kZXhWaWV3IiwiYXRsYXNJZFZpZXciLCJ0ZXhWaWV3IiwibWF0cml4VmlldyIsInNldFRyYW5zZm9ybU1hdHJpeCIsInNoYXBlUHJvcHMiLCJyYXRpbyIsImFkakJCIiwiX2dldEFkanVzdGVkQkIiLCJfYXBwbHlUcmFuc2Zvcm1NYXRyaXgiLCJfYmIiLCJfYWRqQkIiLCJfb3B0cyRnZXRSb3RhdGlvblBvaW4iLCJhZGpXIiwiY29sb3JWaWV3IiwidmVydFR5cGUiLCJfZ2V0VmVydFR5cGVGb3JTaGFwZSIsIl9nZXRDb3JuZXJSYWRpdXMiLCJyYWRpdXNWaWV3IiwibGluZVdpZHRoVmlldyIsImJvcmRlckNvbG9yVmlldyIsInNoYXBlUHJvcCIsInJhZGl1c1Byb3AiLCJkcmF3RWRnZUFycm93IiwiYmFzZU9wYWNpdHkiLCJzY2FsZSQxIiwiZHJhd0VkZ2VMaW5lIiwiX2dldEVkZ2VQb2ludHMiLCJzb3VyY2VUYXJnZXRWaWV3IiwiX2luc3RhbmNlIiwiX2luZGV4VmlldyIsIl9jb2xvclZpZXciLCJfbGluZVdpZHRoQnVmZmVyIiwicEF4IiwicEF5IiwicEJ4IiwicEJ5IiwicEN4IiwicEN5IiwicER4IiwicER5IiwicG9pbnRBQlZpZXciLCJwb2ludENEVmlldyIsIm51bVNlZ21lbnRzIiwiX2dldE51bVNlZ21lbnRzIiwiX2dldEN1cnZlU2VnbWVudFBvaW50cyIsImN1cnZlUG9pbnRzIiwiX3NldEN1cnZlUG9pbnQiLCJjcGkiLCJuZXdwb2ludHMiLCJ1c2VQcm9ncmFtIiwiYnVmZmVycyIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInVuaWZvcm0xaSIsInVuaWZvcm0xZiIsInVuaWZvcm1NYXRyaXgzZnYiLCJ1bmlmb3JtNGZ2IiwiZHJhd0FycmF5c0luc3RhbmNlZCIsIlRSSUFOR0xFUyIsInRvdGFsQXRsYXNlcyIsImJhdGNoSW5mbyIsInRvdGFsSW5zdGFuY2VzIiwiQ1JwJDQiLCJpbml0V2ViZ2wiLCJXRUJHTCIsImdldEJHQ29sb3IiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfVEVYVFVSRV9TSVpFIiwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJwaWNraW5nRnJhbWVCdWZmZXIiLCJuZWVkc0RyYXciLCJkcmF3aW5nIiwiaXNMYWJlbFZpc2libGUiLCJpc0xheWVyVmlzaWJsZSIsImdldEJCRm9yU2ltcGxlU2hhcGUiLCJfbm9kZSRwb3NpdGlvbiIsImdldFN0eWxlS2V5IiwiZ2V0RWxlbWVudEJveCIsImdldFN0eWxlS2V5c0ZvckxhYmVsIiwiZ2V0TGFiZWxLZXkiLCJnZXRCb3VuZGluZ0JveEZvckxhYmVsIiwiZ2V0TGFiZWxCb3giLCJnZXRMYWJlbFJvdGF0aW9uUG9pbnQiLCJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0IiwiZ2V0U291cmNlTGFiZWxLZXkiLCJnZXRTb3VyY2VMYWJlbEJveCIsImRyYXdTb3VyY2VMYWJlbCIsImdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCIsImdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQiLCJnZXRUYXJnZXRMYWJlbEtleSIsImdldFRhcmdldExhYmVsQm94IiwiZHJhd1RhcmdldExhYmVsIiwiZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50IiwiZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCIsInNldEdDRmxhZyIsImdjTmVlZGVkIiwib3ZlcnJpZGVDYW52YXNSZW5kZXJlckZ1bmN0aW9ucyIsImNzc0NvbG9yIiwiZ2V0TGFiZWxMaW5lcyIsInVpIiwibGluZUluZGV4IiwicmVuZGVyQ2FudmFzIiwiY2xlYXJXZWJnbCIsInJlbmRlcldlYmdsIiwiYmFzZUZ1bmMiLCJmaW5kTmVhcmVzdEVsZW1lbnRzV2ViZ2wiLCJfYmFzZUZ1bmMiLCJfYmFzZUZ1bmMyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJjcmVhdGVQYW5ab29tTWF0cml4IiwiX3V0aWwkZ2V0RWZmZWN0aXZlUGFuIiwicHJvamVjdGlvbiQxIiwicHJvZHVjdCIsIl91dGlsJGdldEVmZmVjdGl2ZVBhbjIiLCJkcmF3QXhlcyIsImRyYXdBdGxhc2VzIiwiZ2V0UGlja2luZ0luZGV4ZXMiLCJfdXRpbCRnZXRFZmZlY3RpdmVQYW4zIiwiX3V0aWwkbW9kZWxUb1JlbmRlcmVkIiwiX3V0aWwkbW9kZWxUb1JlbmRlcmVkMiIsImNYMSIsImNZMSIsIlVpbnQ4QXJyYXkiLCJyZWFkUGl4ZWxzIiwiaW5kZXhlcyIsInBpeGVsIiwiQm9vbGVhbiIsImRyYXdFbGUiLCJlbGVDb3VudCIsImNsZWFyQ29sb3IiLCJlbmFibGUiLCJCTEVORCIsImJsZW5kRnVuYyIsIk9ORSIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJkaXNhYmxlIiwiY29tcGFjdCIsInJlcG9ydCIsIkNScCQzIiwiYXJjVG8iLCJiYXJyZWxDdXJ2ZUNvbnN0YW50cyIsInNpbjAiLCJjb3MwIiwiZWxsaXBzZVN0ZXBTaXplIiwiZWxsaXBzZSIsInhQb3MiLCJ5UG9zIiwicnciLCJyaCIsIkNScCQyIiwiYnVmZmVyQ2FudmFzSW1hZ2UiLCJjdHJSZWN0IiwiZnVsbCIsInNwZWNkTWF4RGltcyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWF4U2NhbGVXIiwibWF4U2NhbGVIIiwiYnVmZkNhbnZhcyIsImJ1ZmZDeHQiLCJ6c29ydGVkRWxlcyIsImI2NFRvQmxvYiIsImI2NCIsIm1pbWVUeXBlIiwiYXRvYiIsImJ1ZmYiLCJBcnJheUJ1ZmZlciIsImJ1ZmZVaW50OCIsIkJsb2IiLCJiNjRVcmlUb0I2NCIsImI2NHVyaSIsIm91dHB1dCIsImdldEI2NFVyaSIsInRvRGF0YVVSTCIsInF1YWxpdHkiLCJ0b0Jsb2IiLCJibG9iIiwiQ1JwJDEiLCJDUiIsIkNhbnZhc1JlbmRlcmVyIiwiQ1JwIiwiQ0FOVkFTX1RZUEVTIiwidGFwSGxPZmZBdHRyIiwidGFwSGxPZmZTdHlsZSIsImNvbnRhaW5lclN0eWxlIiwic3R5bGVNYXAiLCJzZXRBdHRyaWJ1dGUiLCJ0b3BDYW52YXMiLCJwYXRoc0VuYWJsZWQiLCJlbXB0eUJiIiwiZ2V0Qm94Q2VudGVyIiwiZ2V0Q2VudGVyT2Zmc2V0IiwiYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQiLCJvbGRCYWNrZ3JvdW5kVGltZXN0YW1wIiwiaXNMYWJlbFZpc2libGVBdFNjYWxlIiwiZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQiLCJhZGRUZXh0TWFyZ2luIiwiZ2V0UnNQdCIsImdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCIsImludmFsaWRhdGVUZXh0dXJlQ2FjaGVzIiwicmVmaW5lSW5MYXllcnMiLCJwYXRoc0ltcGxkIiwicGF0aDJkRW5hYmxlZCIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsIndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiT2Zmc2NyZWVuQ2FudmFzIiwiaW5jRXh0cyIsImV4dGVuc2lvbnMiLCJtb2R1bGVzIiwic2V0RXh0ZW5zaW9uIiwicmVnaXN0cmFudCIsImV4dCIsIm92ZXJyaWRlRXJyIiwibGF5b3V0UHJvdG8iLCJvcHRMYXlvdXRGbnMiLCJmbk5hbWUiLCJyZWdTdG9wIiwiZ2V0Q3kiLCJlbWl0dGVyT3B0cyIsImdldEV4dGVuc2lvbiIsImJQcm90byIsIlJlZ2lzdHJhbnRSZW5kZXJlciIsInJQcm90byIsIlJlbmRlcmVyIiwicE5hbWUiLCJwVmFsIiwiZXhpc3RzSW5SIiwiX3BOYW1lIiwic2V0TW9kdWxlIiwibW9kdWxlVHlwZSIsIm1vZHVsZU5hbWUiLCJnZXRNb2R1bGUiLCJfU3R5bGVzaGVldCIsIlN0eWxlc2hlZXQiLCJzaGVldGZuIiwidmVyc2lvbiIsImN5dG9zY2FwZSIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape/dist/cytoscape.esm.mjs\n");

/***/ })

};
;