"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-harden";
exports.ids = ["vendor-chunks/rehype-harden"];
exports.modules = {

/***/ "(ssr)/./node_modules/rehype-harden/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rehype-harden/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   harden: () => (/* binding */ harden)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/rehype-harden/node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n\nfunction harden({ defaultOrigin = \"\", allowedLinkPrefixes = [], allowedImagePrefixes = [], allowDataImages = false, allowedProtocols = [], blockedImageClass = \"inline-block bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400 px-3 py-1 rounded text-sm\", blockedLinkClass = \"text-gray-500\", }) {\n    // Only require defaultOrigin if we have specific prefixes (not wildcard only)\n    const hasSpecificLinkPrefixes = allowedLinkPrefixes.length && !allowedLinkPrefixes.every((p) => p === \"*\");\n    const hasSpecificImagePrefixes = allowedImagePrefixes.length &&\n        !allowedImagePrefixes.every((p) => p === \"*\");\n    if (!defaultOrigin && (hasSpecificLinkPrefixes || hasSpecificImagePrefixes)) {\n        throw new Error(\"defaultOrigin is required when allowedLinkPrefixes or allowedImagePrefixes are provided\");\n    }\n    return (tree) => {\n        const visitor = createVisitor(defaultOrigin, allowedLinkPrefixes, allowedImagePrefixes, allowDataImages, allowedProtocols, blockedImageClass, blockedLinkClass);\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, visitor);\n    };\n}\nfunction parseUrl(url, defaultOrigin) {\n    if (typeof url !== \"string\")\n        return null;\n    try {\n        // Try to parse as absolute URL first\n        return new URL(url);\n    }\n    catch {\n        // If that fails and we have a defaultOrigin, try with it\n        if (defaultOrigin) {\n            try {\n                return new URL(url, defaultOrigin);\n            }\n            catch {\n                return null;\n            }\n        }\n        // For relative URLs without defaultOrigin, use a dummy base to parse them\n        // This allows wildcard \"*\" to work with relative URLs\n        if (url.startsWith(\"/\") || url.startsWith(\"./\") || url.startsWith(\"../\")) {\n            try {\n                return new URL(url, \"http://example.com\");\n            }\n            catch {\n                return null;\n            }\n        }\n        return null;\n    }\n}\nfunction isPathRelativeUrl(url) {\n    if (typeof url !== \"string\")\n        return false;\n    return url.startsWith(\"/\") || url.startsWith(\"./\") || url.startsWith(\"../\");\n}\nconst safeProtocols = new Set([\n    \"https:\",\n    \"http:\",\n    \"irc:\",\n    \"ircs:\",\n    \"mailto:\",\n    \"xmpp:\",\n    \"blob:\",\n]);\n// Protocols that should NEVER be allowed for security reasons\nconst blockedProtocols = new Set([\n    \"javascript:\",\n    \"data:\",\n    \"file:\",\n    \"vbscript:\",\n]);\nfunction transformUrl(url, allowedPrefixes, defaultOrigin, allowDataImages = false, isImage = false, allowedProtocols = []) {\n    if (!url)\n        return null;\n    // Allow hash-only (fragment-only) URLs - they navigate within the current page\n    if (typeof url === \"string\" && url.startsWith(\"#\") && !isImage) {\n        // Hash-only URLs don't need defaultOrigin validation\n        // Just verify it's a valid fragment identifier\n        try {\n            // Use a dummy base to validate the hash format\n            const testUrl = new URL(url, \"http://example.com\");\n            if (testUrl.hash === url) {\n                return url;\n            }\n        }\n        catch {\n            // Invalid hash format, fall through to normal validation\n        }\n    }\n    // Handle data: URLs for images if allowDataImages is enabled\n    if (typeof url === \"string\" && url.startsWith(\"data:\")) {\n        // Only allow data: URLs for images when explicitly enabled\n        if (isImage && allowDataImages && url.startsWith(\"data:image/\")) {\n            return url;\n        }\n        return null;\n    }\n    // Handle blob: URLs - these are browser-generated URLs for local objects\n    if (typeof url === \"string\" && url.startsWith(\"blob:\")) {\n        // blob: URLs are valid and safe - they reference in-memory objects\n        // They can only reference content already loaded in the browser\n        try {\n            // Validate it's a properly formatted blob URL\n            // blob: URLs should have the format: blob:<origin>/<uuid> or blob:null/<uuid>\n            const blobUrl = new URL(url);\n            if (blobUrl.protocol === \"blob:\" && url.length > 5) {\n                // Ensure there's actual content after \"blob:\"\n                const afterProtocol = url.substring(5);\n                if (afterProtocol && afterProtocol.length > 0 && afterProtocol !== \"invalid\") {\n                    return url;\n                }\n            }\n        }\n        catch {\n            return null;\n        }\n        // If we get here, the blob URL is malformed\n        return null;\n    }\n    const parsedUrl = parseUrl(url, defaultOrigin);\n    if (!parsedUrl)\n        return null;\n    // Block dangerous protocols - these should NEVER be allowed\n    // Exception: data: is allowed for images if allowDataImages is true (handled above)\n    if (blockedProtocols.has(parsedUrl.protocol)) {\n        return null;\n    }\n    // Check if protocol is allowed\n    const isProtocolAllowed = safeProtocols.has(parsedUrl.protocol) ||\n        allowedProtocols.includes(parsedUrl.protocol) ||\n        allowedProtocols.includes(\"*\");\n    if (!isProtocolAllowed)\n        return null;\n    // mailto: and other custom protocols can just return as-is\n    if (parsedUrl.protocol === \"mailto:\" || !parsedUrl.protocol.match(/^https?:$/)) {\n        return parsedUrl.href;\n    }\n    // If the input is path relative, we output a path relative URL as well,\n    // however, we always run the same checks on an absolute URL and we\n    // always reconstruct the output from the parsed URL to ensure that\n    // the output is always a valid URL.\n    const inputWasRelative = isPathRelativeUrl(url);\n    if (parsedUrl &&\n        allowedPrefixes.some((prefix) => {\n            const parsedPrefix = parseUrl(prefix, defaultOrigin);\n            if (!parsedPrefix) {\n                return false;\n            }\n            if (parsedPrefix.origin !== parsedUrl.origin) {\n                return false;\n            }\n            return parsedUrl.href.startsWith(parsedPrefix.href);\n        })) {\n        if (inputWasRelative) {\n            return parsedUrl.pathname + parsedUrl.search + parsedUrl.hash;\n        }\n        return parsedUrl.href;\n    }\n    // Check for wildcard - allow all URLs\n    if (allowedPrefixes.includes(\"*\")) {\n        // Wildcard only allows http and https URLs\n        if (parsedUrl.protocol !== \"https:\" && parsedUrl.protocol !== \"http:\") {\n            return null;\n        }\n        if (inputWasRelative) {\n            return parsedUrl.pathname + parsedUrl.search + parsedUrl.hash;\n        }\n        return parsedUrl.href;\n    }\n    return null;\n}\nconst SEEN = Symbol(\"node-seen\");\nconst createVisitor = (defaultOrigin, allowedLinkPrefixes, allowedImagePrefixes, allowDataImages, allowedProtocols, blockedImageClass, blockedLinkClass) => {\n    const visitor = (node, index, parent) => {\n        if (node.type !== \"element\" ||\n            // @ts-expect-error\n            node[SEEN]) {\n            return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n        }\n        if (node.tagName === \"a\") {\n            const transformedUrl = transformUrl(node.properties.href, allowedLinkPrefixes, defaultOrigin, false, false, allowedProtocols);\n            if (transformedUrl === null) {\n                // @ts-expect-error\n                node[SEEN] = true;\n                // We need to eagerly visit children so that we catch any nested nastiness as well,\n                // prior to modifying the node's parent.\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(node, visitor);\n                if (parent && typeof index === \"number\") {\n                    parent.children[index] = {\n                        type: \"element\",\n                        tagName: \"span\",\n                        properties: {\n                            title: \"Blocked URL: \" + String(node.properties.href),\n                            class: blockedLinkClass,\n                        },\n                        children: [\n                            ...node.children,\n                            {\n                                type: \"text\",\n                                value: \" [blocked]\",\n                            },\n                        ],\n                    };\n                }\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.SKIP;\n            }\n            else {\n                node.properties.href = transformedUrl;\n                node.properties.target = \"_blank\";\n                node.properties.rel = \"noopener noreferrer\";\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n            }\n        }\n        if (node.tagName === \"img\") {\n            const transformedUrl = transformUrl(node.properties.src, allowedImagePrefixes, defaultOrigin, allowDataImages, true, allowedProtocols);\n            if (transformedUrl === null) {\n                // @ts-expect-error\n                node[SEEN] = true;\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(node, visitor);\n                if (parent && typeof index === \"number\") {\n                    parent.children[index] = {\n                        type: \"element\",\n                        tagName: \"span\",\n                        properties: {\n                            class: blockedImageClass,\n                        },\n                        children: [\n                            {\n                                type: \"text\",\n                                value: \"[Image blocked: \" +\n                                    String(node.properties.alt || \"No description\") +\n                                    \"]\",\n                            },\n                        ],\n                    };\n                }\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.SKIP;\n            }\n            else {\n                node.properties.src = transformedUrl;\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n            }\n        }\n        return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n    };\n    return visitor;\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVoeXBlLWhhcmRlbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RDtBQUNsRCxrQkFBa0IsMFJBQTBSO0FBQ25UO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFRO0FBQy9CO0FBQ0E7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9jaGFpemhlbmh1YS9Db2Rlcy91bmNhcnZlL2UyZS9leGFtcGxlcy90cmF2ZWwtdWkvbm9kZV9tb2R1bGVzL3JlaHlwZS1oYXJkZW4vZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05USU5VRSwgU0tJUCwgdmlzaXQgfSBmcm9tIFwidW5pc3QtdXRpbC12aXNpdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGhhcmRlbih7IGRlZmF1bHRPcmlnaW4gPSBcIlwiLCBhbGxvd2VkTGlua1ByZWZpeGVzID0gW10sIGFsbG93ZWRJbWFnZVByZWZpeGVzID0gW10sIGFsbG93RGF0YUltYWdlcyA9IGZhbHNlLCBhbGxvd2VkUHJvdG9jb2xzID0gW10sIGJsb2NrZWRJbWFnZUNsYXNzID0gXCJpbmxpbmUtYmxvY2sgYmctZ3JheS0yMDAgZGFyazpiZy1ncmF5LTcwMCB0ZXh0LWdyYXktNjAwIGRhcms6dGV4dC1ncmF5LTQwMCBweC0zIHB5LTEgcm91bmRlZCB0ZXh0LXNtXCIsIGJsb2NrZWRMaW5rQ2xhc3MgPSBcInRleHQtZ3JheS01MDBcIiwgfSkge1xuICAgIC8vIE9ubHkgcmVxdWlyZSBkZWZhdWx0T3JpZ2luIGlmIHdlIGhhdmUgc3BlY2lmaWMgcHJlZml4ZXMgKG5vdCB3aWxkY2FyZCBvbmx5KVxuICAgIGNvbnN0IGhhc1NwZWNpZmljTGlua1ByZWZpeGVzID0gYWxsb3dlZExpbmtQcmVmaXhlcy5sZW5ndGggJiYgIWFsbG93ZWRMaW5rUHJlZml4ZXMuZXZlcnkoKHApID0+IHAgPT09IFwiKlwiKTtcbiAgICBjb25zdCBoYXNTcGVjaWZpY0ltYWdlUHJlZml4ZXMgPSBhbGxvd2VkSW1hZ2VQcmVmaXhlcy5sZW5ndGggJiZcbiAgICAgICAgIWFsbG93ZWRJbWFnZVByZWZpeGVzLmV2ZXJ5KChwKSA9PiBwID09PSBcIipcIik7XG4gICAgaWYgKCFkZWZhdWx0T3JpZ2luICYmIChoYXNTcGVjaWZpY0xpbmtQcmVmaXhlcyB8fCBoYXNTcGVjaWZpY0ltYWdlUHJlZml4ZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRPcmlnaW4gaXMgcmVxdWlyZWQgd2hlbiBhbGxvd2VkTGlua1ByZWZpeGVzIG9yIGFsbG93ZWRJbWFnZVByZWZpeGVzIGFyZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBjcmVhdGVWaXNpdG9yKGRlZmF1bHRPcmlnaW4sIGFsbG93ZWRMaW5rUHJlZml4ZXMsIGFsbG93ZWRJbWFnZVByZWZpeGVzLCBhbGxvd0RhdGFJbWFnZXMsIGFsbG93ZWRQcm90b2NvbHMsIGJsb2NrZWRJbWFnZUNsYXNzLCBibG9ja2VkTGlua0NsYXNzKTtcbiAgICAgICAgdmlzaXQodHJlZSwgdmlzaXRvcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCwgZGVmYXVsdE9yaWdpbikge1xuICAgIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgYWJzb2x1dGUgVVJMIGZpcnN0XG4gICAgICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gSWYgdGhhdCBmYWlscyBhbmQgd2UgaGF2ZSBhIGRlZmF1bHRPcmlnaW4sIHRyeSB3aXRoIGl0XG4gICAgICAgIGlmIChkZWZhdWx0T3JpZ2luKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCwgZGVmYXVsdE9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHJlbGF0aXZlIFVSTHMgd2l0aG91dCBkZWZhdWx0T3JpZ2luLCB1c2UgYSBkdW1teSBiYXNlIHRvIHBhcnNlIHRoZW1cbiAgICAgICAgLy8gVGhpcyBhbGxvd3Mgd2lsZGNhcmQgXCIqXCIgdG8gd29yayB3aXRoIHJlbGF0aXZlIFVSTHNcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKFwiL1wiKSB8fCB1cmwuc3RhcnRzV2l0aChcIi4vXCIpIHx8IHVybC5zdGFydHNXaXRoKFwiLi4vXCIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCwgXCJodHRwOi8vZXhhbXBsZS5jb21cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXRoUmVsYXRpdmVVcmwodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgoXCIvXCIpIHx8IHVybC5zdGFydHNXaXRoKFwiLi9cIikgfHwgdXJsLnN0YXJ0c1dpdGgoXCIuLi9cIik7XG59XG5jb25zdCBzYWZlUHJvdG9jb2xzID0gbmV3IFNldChbXG4gICAgXCJodHRwczpcIixcbiAgICBcImh0dHA6XCIsXG4gICAgXCJpcmM6XCIsXG4gICAgXCJpcmNzOlwiLFxuICAgIFwibWFpbHRvOlwiLFxuICAgIFwieG1wcDpcIixcbiAgICBcImJsb2I6XCIsXG5dKTtcbi8vIFByb3RvY29scyB0aGF0IHNob3VsZCBORVZFUiBiZSBhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zXG5jb25zdCBibG9ja2VkUHJvdG9jb2xzID0gbmV3IFNldChbXG4gICAgXCJqYXZhc2NyaXB0OlwiLFxuICAgIFwiZGF0YTpcIixcbiAgICBcImZpbGU6XCIsXG4gICAgXCJ2YnNjcmlwdDpcIixcbl0pO1xuZnVuY3Rpb24gdHJhbnNmb3JtVXJsKHVybCwgYWxsb3dlZFByZWZpeGVzLCBkZWZhdWx0T3JpZ2luLCBhbGxvd0RhdGFJbWFnZXMgPSBmYWxzZSwgaXNJbWFnZSA9IGZhbHNlLCBhbGxvd2VkUHJvdG9jb2xzID0gW10pIHtcbiAgICBpZiAoIXVybClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gQWxsb3cgaGFzaC1vbmx5IChmcmFnbWVudC1vbmx5KSBVUkxzIC0gdGhleSBuYXZpZ2F0ZSB3aXRoaW4gdGhlIGN1cnJlbnQgcGFnZVxuICAgIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiICYmIHVybC5zdGFydHNXaXRoKFwiI1wiKSAmJiAhaXNJbWFnZSkge1xuICAgICAgICAvLyBIYXNoLW9ubHkgVVJMcyBkb24ndCBuZWVkIGRlZmF1bHRPcmlnaW4gdmFsaWRhdGlvblxuICAgICAgICAvLyBKdXN0IHZlcmlmeSBpdCdzIGEgdmFsaWQgZnJhZ21lbnQgaWRlbnRpZmllclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNlIGEgZHVtbXkgYmFzZSB0byB2YWxpZGF0ZSB0aGUgaGFzaCBmb3JtYXRcbiAgICAgICAgICAgIGNvbnN0IHRlc3RVcmwgPSBuZXcgVVJMKHVybCwgXCJodHRwOi8vZXhhbXBsZS5jb21cIik7XG4gICAgICAgICAgICBpZiAodGVzdFVybC5oYXNoID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIEludmFsaWQgaGFzaCBmb3JtYXQsIGZhbGwgdGhyb3VnaCB0byBub3JtYWwgdmFsaWRhdGlvblxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSBkYXRhOiBVUkxzIGZvciBpbWFnZXMgaWYgYWxsb3dEYXRhSW1hZ2VzIGlzIGVuYWJsZWRcbiAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIiAmJiB1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgZGF0YTogVVJMcyBmb3IgaW1hZ2VzIHdoZW4gZXhwbGljaXRseSBlbmFibGVkXG4gICAgICAgIGlmIChpc0ltYWdlICYmIGFsbG93RGF0YUltYWdlcyAmJiB1cmwuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2UvXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgYmxvYjogVVJMcyAtIHRoZXNlIGFyZSBicm93c2VyLWdlbmVyYXRlZCBVUkxzIGZvciBsb2NhbCBvYmplY3RzXG4gICAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIgJiYgdXJsLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSkge1xuICAgICAgICAvLyBibG9iOiBVUkxzIGFyZSB2YWxpZCBhbmQgc2FmZSAtIHRoZXkgcmVmZXJlbmNlIGluLW1lbW9yeSBvYmplY3RzXG4gICAgICAgIC8vIFRoZXkgY2FuIG9ubHkgcmVmZXJlbmNlIGNvbnRlbnQgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGl0J3MgYSBwcm9wZXJseSBmb3JtYXR0ZWQgYmxvYiBVUkxcbiAgICAgICAgICAgIC8vIGJsb2I6IFVSTHMgc2hvdWxkIGhhdmUgdGhlIGZvcm1hdDogYmxvYjo8b3JpZ2luPi88dXVpZD4gb3IgYmxvYjpudWxsLzx1dWlkPlxuICAgICAgICAgICAgY29uc3QgYmxvYlVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgICAgIGlmIChibG9iVXJsLnByb3RvY29sID09PSBcImJsb2I6XCIgJiYgdXJsLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlcmUncyBhY3R1YWwgY29udGVudCBhZnRlciBcImJsb2I6XCJcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlclByb3RvY29sID0gdXJsLnN1YnN0cmluZyg1KTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXJQcm90b2NvbCAmJiBhZnRlclByb3RvY29sLmxlbmd0aCA+IDAgJiYgYWZ0ZXJQcm90b2NvbCAhPT0gXCJpbnZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRoZSBibG9iIFVSTCBpcyBtYWxmb3JtZWRcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFVybCA9IHBhcnNlVXJsKHVybCwgZGVmYXVsdE9yaWdpbik7XG4gICAgaWYgKCFwYXJzZWRVcmwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIEJsb2NrIGRhbmdlcm91cyBwcm90b2NvbHMgLSB0aGVzZSBzaG91bGQgTkVWRVIgYmUgYWxsb3dlZFxuICAgIC8vIEV4Y2VwdGlvbjogZGF0YTogaXMgYWxsb3dlZCBmb3IgaW1hZ2VzIGlmIGFsbG93RGF0YUltYWdlcyBpcyB0cnVlIChoYW5kbGVkIGFib3ZlKVxuICAgIGlmIChibG9ja2VkUHJvdG9jb2xzLmhhcyhwYXJzZWRVcmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBwcm90b2NvbCBpcyBhbGxvd2VkXG4gICAgY29uc3QgaXNQcm90b2NvbEFsbG93ZWQgPSBzYWZlUHJvdG9jb2xzLmhhcyhwYXJzZWRVcmwucHJvdG9jb2wpIHx8XG4gICAgICAgIGFsbG93ZWRQcm90b2NvbHMuaW5jbHVkZXMocGFyc2VkVXJsLnByb3RvY29sKSB8fFxuICAgICAgICBhbGxvd2VkUHJvdG9jb2xzLmluY2x1ZGVzKFwiKlwiKTtcbiAgICBpZiAoIWlzUHJvdG9jb2xBbGxvd2VkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBtYWlsdG86IGFuZCBvdGhlciBjdXN0b20gcHJvdG9jb2xzIGNhbiBqdXN0IHJldHVybiBhcy1pc1xuICAgIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwibWFpbHRvOlwiIHx8ICFwYXJzZWRVcmwucHJvdG9jb2wubWF0Y2goL15odHRwcz86JC8pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWRVcmwuaHJlZjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIHBhdGggcmVsYXRpdmUsIHdlIG91dHB1dCBhIHBhdGggcmVsYXRpdmUgVVJMIGFzIHdlbGwsXG4gICAgLy8gaG93ZXZlciwgd2UgYWx3YXlzIHJ1biB0aGUgc2FtZSBjaGVja3Mgb24gYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZVxuICAgIC8vIGFsd2F5cyByZWNvbnN0cnVjdCB0aGUgb3V0cHV0IGZyb20gdGhlIHBhcnNlZCBVUkwgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyB0aGUgb3V0cHV0IGlzIGFsd2F5cyBhIHZhbGlkIFVSTC5cbiAgICBjb25zdCBpbnB1dFdhc1JlbGF0aXZlID0gaXNQYXRoUmVsYXRpdmVVcmwodXJsKTtcbiAgICBpZiAocGFyc2VkVXJsICYmXG4gICAgICAgIGFsbG93ZWRQcmVmaXhlcy5zb21lKChwcmVmaXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFByZWZpeCA9IHBhcnNlVXJsKHByZWZpeCwgZGVmYXVsdE9yaWdpbik7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZFByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWRQcmVmaXgub3JpZ2luICE9PSBwYXJzZWRVcmwub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVybC5ocmVmLnN0YXJ0c1dpdGgocGFyc2VkUHJlZml4LmhyZWYpO1xuICAgICAgICB9KSkge1xuICAgICAgICBpZiAoaW5wdXRXYXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2ggKyBwYXJzZWRVcmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkVXJsLmhyZWY7XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciB3aWxkY2FyZCAtIGFsbG93IGFsbCBVUkxzXG4gICAgaWYgKGFsbG93ZWRQcmVmaXhlcy5pbmNsdWRlcyhcIipcIikpIHtcbiAgICAgICAgLy8gV2lsZGNhcmQgb25seSBhbGxvd3MgaHR0cCBhbmQgaHR0cHMgVVJMc1xuICAgICAgICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSBcImh0dHBzOlwiICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gXCJodHRwOlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRXYXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2ggKyBwYXJzZWRVcmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkVXJsLmhyZWY7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgU0VFTiA9IFN5bWJvbChcIm5vZGUtc2VlblwiKTtcbmNvbnN0IGNyZWF0ZVZpc2l0b3IgPSAoZGVmYXVsdE9yaWdpbiwgYWxsb3dlZExpbmtQcmVmaXhlcywgYWxsb3dlZEltYWdlUHJlZml4ZXMsIGFsbG93RGF0YUltYWdlcywgYWxsb3dlZFByb3RvY29scywgYmxvY2tlZEltYWdlQ2xhc3MsIGJsb2NrZWRMaW5rQ2xhc3MpID0+IHtcbiAgICBjb25zdCB2aXNpdG9yID0gKG5vZGUsIGluZGV4LCBwYXJlbnQpID0+IHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJlbGVtZW50XCIgfHxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIG5vZGVbU0VFTl0pIHtcbiAgICAgICAgICAgIHJldHVybiBDT05USU5VRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcImFcIikge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRVcmwgPSB0cmFuc2Zvcm1Vcmwobm9kZS5wcm9wZXJ0aWVzLmhyZWYsIGFsbG93ZWRMaW5rUHJlZml4ZXMsIGRlZmF1bHRPcmlnaW4sIGZhbHNlLCBmYWxzZSwgYWxsb3dlZFByb3RvY29scyk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZWRVcmwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgbm9kZVtTRUVOXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBlYWdlcmx5IHZpc2l0IGNoaWxkcmVuIHNvIHRoYXQgd2UgY2F0Y2ggYW55IG5lc3RlZCBuYXN0aW5lc3MgYXMgd2VsbCxcbiAgICAgICAgICAgICAgICAvLyBwcmlvciB0byBtb2RpZnlpbmcgdGhlIG5vZGUncyBwYXJlbnQuXG4gICAgICAgICAgICAgICAgdmlzaXQobm9kZSwgdmlzaXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiB0eXBlb2YgaW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQmxvY2tlZCBVUkw6IFwiICsgU3RyaW5nKG5vZGUucHJvcGVydGllcy5ocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogYmxvY2tlZExpbmtDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiIFtibG9ja2VkXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gU0tJUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5ocmVmID0gdHJhbnNmb3JtZWRVcmw7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLnRhcmdldCA9IFwiX2JsYW5rXCI7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLnJlbCA9IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBDT05USU5VRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcImltZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFVybCA9IHRyYW5zZm9ybVVybChub2RlLnByb3BlcnRpZXMuc3JjLCBhbGxvd2VkSW1hZ2VQcmVmaXhlcywgZGVmYXVsdE9yaWdpbiwgYWxsb3dEYXRhSW1hZ2VzLCB0cnVlLCBhbGxvd2VkUHJvdG9jb2xzKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lZFVybCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBub2RlW1NFRU5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2aXNpdChub2RlLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5baW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogYmxvY2tlZEltYWdlQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJbSW1hZ2UgYmxvY2tlZDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nKG5vZGUucHJvcGVydGllcy5hbHQgfHwgXCJObyBkZXNjcmlwdGlvblwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNLSVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuc3JjID0gdHJhbnNmb3JtZWRVcmw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTlRJTlVFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDT05USU5VRTtcbiAgICB9O1xuICAgIHJldHVybiB2aXNpdG9yO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rehype-harden/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rehype-harden/node_modules/unist-util-visit/lib/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rehype-harden/node_modules/unist-util-visit/lib/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTINUE: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),\n/* harmony export */   EXIT: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.EXIT),\n/* harmony export */   SKIP: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.SKIP),\n/* harmony export */   visit: () => (/* binding */ visit)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/**\n * @import {Node as UnistNode, Parent as UnistParent} from 'unist'\n * @import {VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when itâ€™s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends ReadonlyArray<any>\n *   ? MatchesOne<Value, Check[number]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnâ€™t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnâ€™t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\n\n\n\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nfunction visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.visitParents)(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVoeXBlLWhhcmRlbi9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC12aXNpdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksMENBQTBDO0FBQ3RELFlBQVksZUFBZTtBQUMzQjs7QUFFQTtBQUNBLGFBQWEsOERBQThEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGFBQWEsNENBQTRDO0FBQ3pELGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWEsc0tBQXNLO0FBQ25MO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtEQUFrRDtBQUMvRDtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxjQUFjLE1BQU07QUFDcEIsVUFBVTtBQUNWLGNBQWMsTUFBTTtBQUNwQjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxjQUFjLE1BQU07QUFDcEIsVUFBVTtBQUNWLGNBQWMsTUFBTTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsd0RBQXdEO0FBQ25FO0FBQ0EsV0FBVyw2REFBNkQ7QUFDeEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7O0FBRXFEOztBQUVROztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyw0QkFBNEI7QUFDdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyw0QkFBNEI7QUFDdkMsYUFBYTtBQUNiO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNPO0FBQ1AsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsc0VBQVk7O0FBRWQ7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2NoYWl6aGVuaHVhL0NvZGVzL3VuY2FydmUvZTJlL2V4YW1wbGVzL3RyYXZlbC11aS9ub2RlX21vZHVsZXMvcmVoeXBlLWhhcmRlbi9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC12aXNpdC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtOb2RlIGFzIFVuaXN0Tm9kZSwgUGFyZW50IGFzIFVuaXN0UGFyZW50fSBmcm9tICd1bmlzdCdcbiAqIEBpbXBvcnQge1Zpc2l0b3JSZXN1bHR9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFeGNsdWRlPGltcG9ydCgndW5pc3QtdXRpbC1pcycpLlRlc3QsIHVuZGVmaW5lZD4gfCB1bmRlZmluZWR9IFRlc3RcbiAqICAgVGVzdCBmcm9tIGB1bmlzdC11dGlsLWlzYC5cbiAqXG4gKiAgIE5vdGU6IHdlIGhhdmUgcmVtb3ZlIGFuZCBhZGQgYHVuZGVmaW5lZGAsIGJlY2F1c2Ugb3RoZXJ3aXNlIHdoZW4gZ2VuZXJhdGluZ1xuICogICBhdXRvbWF0aWMgYC5kLnRzYCBmaWxlcywgVFMgdHJpZXMgdG8gZmxhdHRlbiBwYXRocyBmcm9tIGEgbG9jYWwgcGVyc3BlY3RpdmUsXG4gKiAgIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdoZW4gcHVibGlzaGluZyBvbiBucG0uXG4gKi9cblxuLy8gVG8gZG86IHVzZSB0eXBlcyBmcm9tIGB1bmlzdC11dGlsLXZpc2l0LXBhcmVudHNgIHdoZW4gaXTigJlzIHJlbGVhc2VkLlxuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIEZuIGV4dGVuZHMgKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIGluZmVyIFRoaW5nXG4gKiAgID8gVGhpbmdcbiAqICAgOiBGYWxsYmFja1xuICogKX0gUHJlZGljYXRlXG4gKiAgIEdldCB0aGUgdmFsdWUgb2YgYSB0eXBlIGd1YXJkIGBGbmAuXG4gKiBAdGVtcGxhdGUgRm5cbiAqICAgVmFsdWU7IHR5cGljYWxseSBmdW5jdGlvbiB0aGF0IGlzIGEgdHlwZSBndWFyZCAoc3VjaCBhcyBgKHgpOiB4IGlzIFlgKS5cbiAqIEB0ZW1wbGF0ZSBGYWxsYmFja1xuICogICBWYWx1ZSB0byB5aWVsZCBpZiBgRm5gIGlzIG5vdCBhIHR5cGUgZ3VhcmQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBDaGVjayBleHRlbmRzIG51bGwgfCB1bmRlZmluZWQgLy8gTm8gdGVzdC5cbiAqICAgPyBWYWx1ZVxuICogICA6IFZhbHVlIGV4dGVuZHMge3R5cGU6IENoZWNrfSAvLyBTdHJpbmcgKHR5cGUpIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBWYWx1ZSBleHRlbmRzIENoZWNrIC8vIFBhcnRpYWwgdGVzdC5cbiAqICAgPyBWYWx1ZVxuICogICA6IENoZWNrIGV4dGVuZHMgRnVuY3Rpb24gLy8gRnVuY3Rpb24gdGVzdC5cbiAqICAgPyBQcmVkaWNhdGU8Q2hlY2ssIFZhbHVlPiBleHRlbmRzIFZhbHVlXG4gKiAgICAgPyBQcmVkaWNhdGU8Q2hlY2ssIFZhbHVlPlxuICogICAgIDogbmV2ZXJcbiAqICAgOiBuZXZlciAvLyBTb21lIG90aGVyIHRlc3Q/XG4gKiApfSBNYXRjaGVzT25lXG4gKiAgIENoZWNrIHdoZXRoZXIgYSBub2RlIG1hdGNoZXMgYSBwcmltaXRpdmUgY2hlY2sgaW4gdGhlIHR5cGUgc3lzdGVtLlxuICogQHRlbXBsYXRlIFZhbHVlXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgdW5pc3QgYE5vZGVgLlxuICogQHRlbXBsYXRlIENoZWNrXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgYHVuaXN0LXV0aWwtaXNgLWNvbXBhdGlibGUgdGVzdCwgYnV0IG5vdCBhcnJheXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBDaGVjayBleHRlbmRzIFJlYWRvbmx5QXJyYXk8YW55PlxuICogICA/IE1hdGNoZXNPbmU8VmFsdWUsIENoZWNrW251bWJlcl0+XG4gKiAgIDogTWF0Y2hlc09uZTxWYWx1ZSwgQ2hlY2s+XG4gKiApfSBNYXRjaGVzXG4gKiAgIENoZWNrIHdoZXRoZXIgYSBub2RlIG1hdGNoZXMgYSBjaGVjayBpbiB0aGUgdHlwZSBzeXN0ZW0uXG4gKiBAdGVtcGxhdGUgVmFsdWVcbiAqICAgVmFsdWU7IHR5cGljYWxseSB1bmlzdCBgTm9kZWAuXG4gKiBAdGVtcGxhdGUgQ2hlY2tcbiAqICAgVmFsdWU7IHR5cGljYWxseSBgdW5pc3QtdXRpbC1pc2AtY29tcGF0aWJsZSB0ZXN0LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgezAgfCAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMH0gVWludFxuICogICBOdW1iZXI7IGNhcHBlZCByZWFzb25hYmx5LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0kgZXh0ZW5kcyAwID8gMSA6IEkgZXh0ZW5kcyAxID8gMiA6IEkgZXh0ZW5kcyAyID8gMyA6IEkgZXh0ZW5kcyAzID8gNCA6IEkgZXh0ZW5kcyA0ID8gNSA6IEkgZXh0ZW5kcyA1ID8gNiA6IEkgZXh0ZW5kcyA2ID8gNyA6IEkgZXh0ZW5kcyA3ID8gOCA6IEkgZXh0ZW5kcyA4ID8gOSA6IDEwfSBJbmNyZW1lbnRcbiAqICAgSW5jcmVtZW50IGEgbnVtYmVyIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAqIEB0ZW1wbGF0ZSB7VWludH0gW0k9MF1cbiAqICAgSW5kZXguXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBOb2RlIGV4dGVuZHMgVW5pc3RQYXJlbnRcbiAqICAgPyBOb2RlIGV4dGVuZHMge2NoaWxkcmVuOiBBcnJheTxpbmZlciBDaGlsZHJlbj59XG4gKiAgICAgPyBDaGlsZCBleHRlbmRzIENoaWxkcmVuID8gTm9kZSA6IG5ldmVyXG4gKiAgICAgOiBuZXZlclxuICogICA6IG5ldmVyXG4gKiApfSBJbnRlcm5hbFBhcmVudFxuICogICBDb2xsZWN0IG5vZGVzIHRoYXQgY2FuIGJlIHBhcmVudHMgb2YgYENoaWxkYC5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBOb2RlXG4gKiAgIEFsbCBub2RlIHR5cGVzIGluIGEgdHJlZS5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBDaGlsZFxuICogICBOb2RlIHRvIHNlYXJjaCBmb3IuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7SW50ZXJuYWxQYXJlbnQ8SW5jbHVzaXZlRGVzY2VuZGFudDxUcmVlPiwgQ2hpbGQ+fSBQYXJlbnRcbiAqICAgQ29sbGVjdCBub2RlcyBpbiBgVHJlZWAgdGhhdCBjYW4gYmUgcGFyZW50cyBvZiBgQ2hpbGRgLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IFRyZWVcbiAqICAgQWxsIG5vZGUgdHlwZXMgaW4gYSB0cmVlLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IENoaWxkXG4gKiAgIE5vZGUgdG8gc2VhcmNoIGZvci5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIERlcHRoIGV4dGVuZHMgTWF4XG4gKiAgID8gbmV2ZXJcbiAqICAgOlxuICogICAgIHwgSW50ZXJuYWxQYXJlbnQ8Tm9kZSwgQ2hpbGQ+XG4gKiAgICAgfCBJbnRlcm5hbEFuY2VzdG9yPE5vZGUsIEludGVybmFsUGFyZW50PE5vZGUsIENoaWxkPiwgTWF4LCBJbmNyZW1lbnQ8RGVwdGg+PlxuICogKX0gSW50ZXJuYWxBbmNlc3RvclxuICogICBDb2xsZWN0IG5vZGVzIGluIGBUcmVlYCB0aGF0IGNhbiBiZSBhbmNlc3RvcnMgb2YgYENoaWxkYC5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBOb2RlXG4gKiAgIEFsbCBub2RlIHR5cGVzIGluIGEgdHJlZS5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBDaGlsZFxuICogICBOb2RlIHRvIHNlYXJjaCBmb3IuXG4gKiBAdGVtcGxhdGUge1VpbnR9IFtNYXg9MTBdXG4gKiAgIE1heDsgc2VhcmNoZXMgdXAgdG8gdGhpcyBkZXB0aC5cbiAqIEB0ZW1wbGF0ZSB7VWludH0gW0RlcHRoPTBdXG4gKiAgIEN1cnJlbnQgZGVwdGguXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBUcmVlIGV4dGVuZHMgVW5pc3RQYXJlbnRcbiAqICAgICA/IERlcHRoIGV4dGVuZHMgTWF4XG4gKiAgICAgICA/IFRyZWVcbiAqICAgICAgIDogVHJlZSB8IEluY2x1c2l2ZURlc2NlbmRhbnQ8VHJlZVsnY2hpbGRyZW4nXVtudW1iZXJdLCBNYXgsIEluY3JlbWVudDxEZXB0aD4+XG4gKiAgICAgOiBUcmVlXG4gKiApfSBJbmNsdXNpdmVEZXNjZW5kYW50XG4gKiAgIENvbGxlY3QgYWxsIChpbmNsdXNpdmUpIGRlc2NlbmRhbnRzIG9mIGBUcmVlYC5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIGZhc3Rlc3Qgd2F5IHRvXG4gKiAgID4gcmVjdXJzZSB3aXRob3V0IGFjdHVhbGx5IHJ1bm5pbmcgaW50byBhbiBpbmZpbml0ZSBsb29wLCB3aGljaCB0aGVcbiAqICAgPiBwcmV2aW91cyB2ZXJzaW9uIGRpZC5cbiAqICAgPlxuICogICA+IFByYWN0aWNhbGx5LCBhIG1heCBvZiBgMmAgaXMgdHlwaWNhbGx5IGVub3VnaCBhc3N1bWluZyBhIGBSb290YCBpc1xuICogICA+IHBhc3NlZCwgYnV0IGl0IGRvZXNu4oCZdCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICogICA+IEl0IGdldHMgaGlnaGVyIHdpdGggYExpc3QgPiBMaXN0SXRlbSA+IFRhYmxlID4gVGFibGVSb3cgPiBUYWJsZUNlbGxgLlxuICogICA+IFVzaW5nIHVwIHRvIGAxMGAgZG9lc27igJl0IGh1cnQgb3IgaGVscCBlaXRoZXIuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gVHJlZVxuICogICBUcmVlIHR5cGUuXG4gKiBAdGVtcGxhdGUge1VpbnR9IFtNYXg9MTBdXG4gKiAgIE1heDsgc2VhcmNoZXMgdXAgdG8gdGhpcyBkZXB0aC5cbiAqIEB0ZW1wbGF0ZSB7VWludH0gW0RlcHRoPTBdXG4gKiAgIEN1cnJlbnQgZGVwdGguXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgVmlzaXRvclxuICogICBIYW5kbGUgYSBub2RlIChtYXRjaGluZyBgdGVzdGAsIGlmIGdpdmVuKS5cbiAqXG4gKiAgIFZpc2l0b3JzIGFyZSBmcmVlIHRvIHRyYW5zZm9ybSBgbm9kZWAuXG4gKiAgIFRoZXkgY2FuIGFsc28gdHJhbnNmb3JtIGBwYXJlbnRgLlxuICpcbiAqICAgUmVwbGFjaW5nIGBub2RlYCBpdHNlbGYsIGlmIGBTS0lQYCBpcyBub3QgcmV0dXJuZWQsIHN0aWxsIGNhdXNlcyBpdHNcbiAqICAgZGVzY2VuZGFudHMgdG8gYmUgd2Fsa2VkICh3aGljaCBpcyBhIGJ1ZykuXG4gKlxuICogICBXaGVuIGFkZGluZyBvciByZW1vdmluZyBwcmV2aW91cyBzaWJsaW5ncyBvZiBgbm9kZWAgKG9yIG5leHQgc2libGluZ3MsIGluXG4gKiAgIGNhc2Ugb2YgcmV2ZXJzZSksIHRoZSBgVmlzaXRvcmAgc2hvdWxkIHJldHVybiBhIG5ldyBgSW5kZXhgIHRvIHNwZWNpZnkgdGhlXG4gKiAgIHNpYmxpbmcgdG8gdHJhdmVyc2UgYWZ0ZXIgYG5vZGVgIGlzIHRyYXZlcnNlZC5cbiAqICAgQWRkaW5nIG9yIHJlbW92aW5nIG5leHQgc2libGluZ3Mgb2YgYG5vZGVgIChvciBwcmV2aW91cyBzaWJsaW5ncywgaW4gY2FzZVxuICogICBvZiByZXZlcnNlKSBpcyBoYW5kbGVkIGFzIGV4cGVjdGVkIHdpdGhvdXQgbmVlZGluZyB0byByZXR1cm4gYSBuZXcgYEluZGV4YC5cbiAqXG4gKiAgIFJlbW92aW5nIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eSBvZiBgcGFyZW50YCBzdGlsbCByZXN1bHRzIGluIHRoZW0gYmVpbmdcbiAqICAgdHJhdmVyc2VkLlxuICogQHBhcmFtIHtWaXNpdGVkfSBub2RlXG4gKiAgIEZvdW5kIG5vZGUuXG4gKiBAcGFyYW0ge1Zpc2l0ZWQgZXh0ZW5kcyBVbmlzdE5vZGUgPyBudW1iZXIgfCB1bmRlZmluZWQgOiBuZXZlcn0gaW5kZXhcbiAqICAgSW5kZXggb2YgYG5vZGVgIGluIGBwYXJlbnRgLlxuICogQHBhcmFtIHtBbmNlc3RvciBleHRlbmRzIFVuaXN0UGFyZW50ID8gQW5jZXN0b3IgfCB1bmRlZmluZWQgOiBuZXZlcn0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBgbm9kZWAuXG4gKiBAcmV0dXJucyB7VmlzaXRvclJlc3VsdH1cbiAqICAgV2hhdCB0byBkbyBuZXh0LlxuICpcbiAqICAgQW4gYEluZGV4YCBpcyB0cmVhdGVkIGFzIGEgdHVwbGUgb2YgYFtDT05USU5VRSwgSW5kZXhdYC5cbiAqICAgQW4gYEFjdGlvbmAgaXMgdHJlYXRlZCBhcyBhIHR1cGxlIG9mIGBbQWN0aW9uXWAuXG4gKlxuICogICBQYXNzaW5nIGEgdHVwbGUgYmFjayBvbmx5IG1ha2VzIHNlbnNlIGlmIHRoZSBgQWN0aW9uYCBpcyBgU0tJUGAuXG4gKiAgIFdoZW4gdGhlIGBBY3Rpb25gIGlzIGBFWElUYCwgdGhhdCBhY3Rpb24gY2FuIGJlIHJldHVybmVkLlxuICogICBXaGVuIHRoZSBgQWN0aW9uYCBpcyBgQ09OVElOVUVgLCBgSW5kZXhgIGNhbiBiZSByZXR1cm5lZC5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBbVmlzaXRlZD1VbmlzdE5vZGVdXG4gKiAgIFZpc2l0ZWQgbm9kZSB0eXBlLlxuICogQHRlbXBsYXRlIHtVbmlzdFBhcmVudH0gW0FuY2VzdG9yPVVuaXN0UGFyZW50XVxuICogICBBbmNlc3RvciB0eXBlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1Zpc2l0b3I8VmlzaXRlZCwgUGFyZW50PEFuY2VzdG9yLCBWaXNpdGVkPj59IEJ1aWxkVmlzaXRvckZyb21NYXRjaFxuICogICBCdWlsZCBhIHR5cGVkIGBWaXNpdG9yYCBmdW5jdGlvbiBmcm9tIGEgbm9kZSBhbmQgYWxsIHBvc3NpYmxlIHBhcmVudHMuXG4gKlxuICogICBJdCB3aWxsIGluZmVyIHdoaWNoIHZhbHVlcyBhcmUgcGFzc2VkIGFzIGBub2RlYCBhbmQgd2hpY2ggYXMgYHBhcmVudGAuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gVmlzaXRlZFxuICogICBOb2RlIHR5cGUuXG4gKiBAdGVtcGxhdGUge1VuaXN0UGFyZW50fSBBbmNlc3RvclxuICogICBQYXJlbnQgdHlwZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIEJ1aWxkVmlzaXRvckZyb21NYXRjaDxcbiAqICAgICBNYXRjaGVzPERlc2NlbmRhbnQsIENoZWNrPixcbiAqICAgICBFeHRyYWN0PERlc2NlbmRhbnQsIFVuaXN0UGFyZW50PlxuICogICA+XG4gKiApfSBCdWlsZFZpc2l0b3JGcm9tRGVzY2VuZGFudHNcbiAqICAgQnVpbGQgYSB0eXBlZCBgVmlzaXRvcmAgZnVuY3Rpb24gZnJvbSBhIGxpc3Qgb2YgZGVzY2VuZGFudHMgYW5kIGEgdGVzdC5cbiAqXG4gKiAgIEl0IHdpbGwgaW5mZXIgd2hpY2ggdmFsdWVzIGFyZSBwYXNzZWQgYXMgYG5vZGVgIGFuZCB3aGljaCBhcyBgcGFyZW50YC5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBEZXNjZW5kYW50XG4gKiAgIE5vZGUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSB7VGVzdH0gQ2hlY2tcbiAqICAgVGVzdCB0eXBlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgQnVpbGRWaXNpdG9yRnJvbURlc2NlbmRhbnRzPFxuICogICAgIEluY2x1c2l2ZURlc2NlbmRhbnQ8VHJlZT4sXG4gKiAgICAgQ2hlY2tcbiAqICAgPlxuICogKX0gQnVpbGRWaXNpdG9yXG4gKiAgIEJ1aWxkIGEgdHlwZWQgYFZpc2l0b3JgIGZ1bmN0aW9uIGZyb20gYSB0cmVlIGFuZCBhIHRlc3QuXG4gKlxuICogICBJdCB3aWxsIGluZmVyIHdoaWNoIHZhbHVlcyBhcmUgcGFzc2VkIGFzIGBub2RlYCBhbmQgd2hpY2ggYXMgYHBhcmVudGAuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gW1RyZWU9VW5pc3ROb2RlXVxuICogICBOb2RlIHR5cGUuXG4gKiBAdGVtcGxhdGUge1Rlc3R9IFtDaGVjaz1UZXN0XVxuICogICBUZXN0IHR5cGUuXG4gKi9cblxuaW1wb3J0IHt2aXNpdFBhcmVudHN9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcblxuZXhwb3J0IHtDT05USU5VRSwgRVhJVCwgU0tJUH0gZnJvbSAndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzJ1xuXG4vKipcbiAqIFZpc2l0IG5vZGVzLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIHBlcmZvcm1zICpkZXB0aC1maXJzdCogKnRyZWUgdHJhdmVyc2FsKiBpbiAqcHJlb3JkZXIqXG4gKiAoKipOTFIqKikgb3IgaWYgYHJldmVyc2VgIGlzIGdpdmVuLCBpbiAqcmV2ZXJzZSBwcmVvcmRlciogKCoqTlJMKiopLlxuICpcbiAqIFlvdSBjYW4gY2hvb3NlIGZvciB3aGljaCBub2RlcyBgdmlzaXRvcmAgaXMgY2FsbGVkIGJ5IHBhc3NpbmcgYSBgdGVzdGAuXG4gKiBGb3IgY29tcGxleCB0ZXN0cywgeW91IHNob3VsZCB0ZXN0IHlvdXJzZWxmIGluIGB2aXNpdG9yYCwgYXMgaXQgd2lsbCBiZVxuICogZmFzdGVyIGFuZCB3aWxsIGhhdmUgaW1wcm92ZWQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBXYWxraW5nIHRoZSB0cmVlIGlzIGFuIGludGVuc2l2ZSB0YXNrLlxuICogTWFrZSB1c2Ugb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHZpc2l0b3Igd2hlbiBwb3NzaWJsZS5cbiAqIEluc3RlYWQgb2Ygd2Fsa2luZyBhIHRyZWUgbXVsdGlwbGUgdGltZXMsIHdhbGsgaXQgb25jZSwgdXNlIGB1bmlzdC11dGlsLWlzYFxuICogdG8gY2hlY2sgaWYgYSBub2RlIG1hdGNoZXMsIGFuZCB0aGVuIHBlcmZvcm0gZGlmZmVyZW50IG9wZXJhdGlvbnMuXG4gKlxuICogWW91IGNhbiBjaGFuZ2UgdGhlIHRyZWUuXG4gKiBTZWUgYFZpc2l0b3JgIGZvciBtb3JlIGluZm8uXG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWVcbiAqIEBwYXJhbSB7Q2hlY2t9IGNoZWNrXG4gKiBAcGFyYW0ge0J1aWxkVmlzaXRvcjxUcmVlLCBDaGVjaz59IHZpc2l0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtyZXZlcnNlXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7VHJlZX0gdHJlZVxuICogQHBhcmFtIHtCdWlsZFZpc2l0b3I8VHJlZT59IHZpc2l0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtyZXZlcnNlXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqXG4gKiBAcGFyYW0ge1VuaXN0Tm9kZX0gdHJlZVxuICogICBUcmVlIHRvIHRyYXZlcnNlLlxuICogQHBhcmFtIHtWaXNpdG9yIHwgVGVzdH0gdGVzdE9yVmlzaXRvclxuICogICBgdW5pc3QtdXRpbC1pc2AtY29tcGF0aWJsZSB0ZXN0IChvcHRpb25hbCwgb21pdCB0byBwYXNzIGEgdmlzaXRvcikuXG4gKiBAcGFyYW0ge1Zpc2l0b3IgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Zpc2l0b3JPclJldmVyc2VdXG4gKiAgIEhhbmRsZSBlYWNoIG5vZGUgKHdoZW4gdGVzdCBpcyBvbWl0dGVkLCBwYXNzIGByZXZlcnNlYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbbWF5YmVSZXZlcnNlPWZhbHNlXVxuICogICBUcmF2ZXJzZSBpbiByZXZlcnNlIHByZW9yZGVyIChOUkwpIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgcHJlb3JkZXIgKE5MUikuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBUcmVlXG4gKiAgIE5vZGUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSB7VGVzdH0gQ2hlY2tcbiAqICAgYHVuaXN0LXV0aWwtaXNgLWNvbXBhdGlibGUgdGVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0KHRyZWUsIHRlc3RPclZpc2l0b3IsIHZpc2l0b3JPclJldmVyc2UsIG1heWJlUmV2ZXJzZSkge1xuICAvKiogQHR5cGUge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgcmV2ZXJzZVxuICAvKiogQHR5cGUge1Rlc3R9ICovXG4gIGxldCB0ZXN0XG4gIC8qKiBAdHlwZSB7VmlzaXRvcn0gKi9cbiAgbGV0IHZpc2l0b3JcblxuICBpZiAoXG4gICAgdHlwZW9mIHRlc3RPclZpc2l0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmlzaXRvck9yUmV2ZXJzZSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICB0ZXN0ID0gdW5kZWZpbmVkXG4gICAgdmlzaXRvciA9IHRlc3RPclZpc2l0b3JcbiAgICByZXZlcnNlID0gdmlzaXRvck9yUmV2ZXJzZVxuICB9IGVsc2Uge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFzc3VtZSB0aGUgb3ZlcmxvYWQgd2l0aCB0ZXN0IHdhcyBnaXZlbi5cbiAgICB0ZXN0ID0gdGVzdE9yVmlzaXRvclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFzc3VtZSB0aGUgb3ZlcmxvYWQgd2l0aCB0ZXN0IHdhcyBnaXZlbi5cbiAgICB2aXNpdG9yID0gdmlzaXRvck9yUmV2ZXJzZVxuICAgIHJldmVyc2UgPSBtYXliZVJldmVyc2VcbiAgfVxuXG4gIHZpc2l0UGFyZW50cyh0cmVlLCB0ZXN0LCBvdmVybG9hZCwgcmV2ZXJzZSlcblxuICAvKipcbiAgICogQHBhcmFtIHtVbmlzdE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtBcnJheTxVbmlzdFBhcmVudD59IHBhcmVudHNcbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJsb2FkKG5vZGUsIHBhcmVudHMpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV1cbiAgICBjb25zdCBpbmRleCA9IHBhcmVudCA/IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpIDogdW5kZWZpbmVkXG4gICAgcmV0dXJuIHZpc2l0b3Iobm9kZSwgaW5kZXgsIHBhcmVudClcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rehype-harden/node_modules/unist-util-visit/lib/index.js\n");

/***/ })

};
;