{"version":3,"sources":["../src/hooks/use-coagent-state-render-bridge.helpers.ts"],"sourcesContent":["import { dataToUUID, parseJson } from \"@copilotkit/shared\";\n\nexport enum RenderStatus {\n  InProgress = \"inProgress\",\n  Complete = \"complete\",\n}\n\nexport enum ClaimAction {\n  Create = \"create\",\n  Override = \"override\",\n  Existing = \"existing\",\n  Block = \"block\",\n}\n\nexport interface StateRenderContext {\n  agentId: string;\n  stateRenderId: string;\n  messageId: string;\n  runId: string;\n  messageIndex?: number;\n}\n\nexport interface Claim {\n  stateRenderId: string;\n  runId?: string;\n  stateSnapshot?: any;\n  locked?: boolean;\n  messageIndex?: number;\n}\n\nexport type ClaimsByMessageId = Record<string, Claim>;\n\nexport interface ClaimResolution {\n  canRender: boolean;\n  action: ClaimAction;\n  nextClaim?: Claim;\n  lockOthers?: boolean;\n  updateRunId?: string;\n}\n\nexport interface SnapshotCaches {\n  byStateRenderAndRun: Record<string, any>;\n  byMessageId: Record<string, any>;\n}\n\nexport interface SnapshotSelectionInput {\n  messageId: string;\n  messageName?: string;\n  allowLiveState?: boolean;\n  skipLatestCache?: boolean;\n  stateRenderId?: string;\n  effectiveRunId: string;\n  stateSnapshotProp?: any;\n  agentState?: any;\n  agentMessages?: Array<{ id: string; role?: string }>;\n  existingClaim?: Claim;\n  caches: SnapshotCaches;\n}\n\nexport interface SnapshotSelectionResult {\n  snapshot?: any;\n  hasSnapshotKeys: boolean;\n  cachedSnapshot?: any;\n  allowEmptySnapshot?: boolean;\n  snapshotForClaim?: any;\n}\n\nfunction getStateWithoutConstantKeys(state: any) {\n  if (!state) return {};\n  const { messages, tools, copilotkit, ...stateWithoutConstantKeys } = state;\n  return stateWithoutConstantKeys;\n}\n\n// Function that compares states, without the constant keys\nexport function areStatesEquals(a: any, b: any) {\n  if ((a && !b) || (!a && b)) return false;\n  const { messages, tools, copilotkit, ...aWithoutConstantKeys } = a;\n  const {\n    messages: bMessages,\n    tools: bTools,\n    copilotkit: bCopilotkit,\n    ...bWithoutConstantKeys\n  } = b;\n\n  return JSON.stringify(aWithoutConstantKeys) === JSON.stringify(bWithoutConstantKeys);\n}\n\nexport function isPlaceholderMessageId(messageId: string | undefined) {\n  return !!messageId && messageId.startsWith(\"coagent-state-render-\");\n}\n\nexport function isPlaceholderMessageName(messageName: string | undefined) {\n  return messageName === \"coagent-state-render\";\n}\n\nexport function readCachedMessageEntry(entry: any): { snapshot?: any; runId?: string } {\n  if (!entry || typeof entry !== \"object\") {\n    return { snapshot: entry, runId: undefined };\n  }\n  const snapshot = \"snapshot\" in entry ? entry.snapshot : entry;\n  const runId = \"runId\" in entry ? entry.runId : undefined;\n  return { snapshot, runId };\n}\n\nexport function getEffectiveRunId({\n  existingClaimRunId,\n  cachedMessageRunId,\n  runId,\n}: {\n  existingClaimRunId?: string;\n  cachedMessageRunId?: string;\n  runId?: string;\n}) {\n  return existingClaimRunId || cachedMessageRunId || runId || \"pending\";\n}\n\n/**\n * Resolve whether a message can claim a render slot.\n * This is a pure decision function; the caller applies claim mutations.\n */\nexport function resolveClaim({\n  claims,\n  context,\n  stateSnapshot,\n}: {\n  claims: ClaimsByMessageId;\n  context: StateRenderContext;\n  stateSnapshot?: any;\n}): ClaimResolution {\n  const { messageId, stateRenderId, runId, messageIndex } = context;\n  const existing = claims[messageId];\n\n  if (existing) {\n    const canRender = existing.stateRenderId === stateRenderId;\n    const shouldUpdateRunId =\n      canRender && runId && (!existing.runId || existing.runId === \"pending\");\n    return {\n      canRender,\n      action: canRender ? ClaimAction.Existing : ClaimAction.Block,\n      updateRunId: shouldUpdateRunId ? runId : undefined,\n    };\n  }\n\n  const normalizedRunId = runId ?? \"pending\";\n  const renderClaimedByOtherMessageEntry = Object.entries(claims).find(\n    ([, claim]) =>\n      claim.stateRenderId === stateRenderId &&\n      (claim.runId ?? \"pending\") === normalizedRunId &&\n      dataToUUID(getStateWithoutConstantKeys(claim.stateSnapshot)) ===\n        dataToUUID(getStateWithoutConstantKeys(stateSnapshot)),\n  );\n\n  const renderClaimedByOtherMessage = renderClaimedByOtherMessageEntry?.[1];\n  const claimedMessageId = renderClaimedByOtherMessageEntry?.[0];\n\n  if (renderClaimedByOtherMessage) {\n    if (\n      messageIndex !== undefined &&\n      renderClaimedByOtherMessage.messageIndex !== undefined &&\n      messageIndex > renderClaimedByOtherMessage.messageIndex\n    ) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers:\n          runId === renderClaimedByOtherMessage.runId || isPlaceholderMessageId(claimedMessageId),\n      };\n    }\n\n    if (runId && renderClaimedByOtherMessage.runId && runId !== renderClaimedByOtherMessage.runId) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers: isPlaceholderMessageId(claimedMessageId),\n      };\n    }\n\n    if (isPlaceholderMessageId(claimedMessageId)) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers: true,\n      };\n    }\n\n    if (\n      stateSnapshot &&\n      renderClaimedByOtherMessage.stateSnapshot &&\n      !areStatesEquals(renderClaimedByOtherMessage.stateSnapshot, stateSnapshot)\n    ) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId },\n      };\n    }\n\n    return { canRender: false, action: ClaimAction.Block };\n  }\n\n  if (!runId) {\n    return { canRender: false, action: ClaimAction.Block };\n  }\n\n  return {\n    canRender: true,\n    action: ClaimAction.Create,\n    nextClaim: { stateRenderId, runId, messageIndex },\n  };\n}\n\n/**\n * Select the best snapshot to render for this message.\n * Priority order is:\n * 1) explicit message snapshot\n * 2) live agent state (latest assistant only)\n * 3) cached snapshot for message\n * 4) cached snapshot for stateRenderId+runId\n * 5) last cached snapshot for stateRenderId\n */\nexport function selectSnapshot({\n  messageId,\n  messageName,\n  allowLiveState,\n  skipLatestCache,\n  stateRenderId,\n  effectiveRunId,\n  stateSnapshotProp,\n  agentState,\n  agentMessages,\n  existingClaim,\n  caches,\n}: SnapshotSelectionInput): SnapshotSelectionResult {\n  const lastAssistantId = agentMessages\n    ? [...agentMessages].reverse().find((msg) => msg.role === \"assistant\")?.id\n    : undefined;\n  const latestSnapshot =\n    stateRenderId !== undefined ? caches.byStateRenderAndRun[`${stateRenderId}::latest`] : undefined;\n  const messageIndex = agentMessages\n    ? agentMessages.findIndex((msg) => msg.id === messageId)\n    : -1;\n  const messageRole =\n    messageIndex >= 0 && agentMessages ? agentMessages[messageIndex]?.role : undefined;\n  let previousUserMessageId: string | undefined;\n  if (messageIndex > 0 && agentMessages) {\n    for (let i = messageIndex - 1; i >= 0; i -= 1) {\n      if (agentMessages[i]?.role === \"user\") {\n        previousUserMessageId = agentMessages[i]?.id;\n        break;\n      }\n    }\n  }\n  const liveStateIsStale =\n    stateSnapshotProp === undefined &&\n    latestSnapshot !== undefined &&\n    agentState !== undefined &&\n    areStatesEquals(latestSnapshot, agentState);\n  const shouldUseLiveState =\n    (Boolean(allowLiveState) || !lastAssistantId || messageId === lastAssistantId) &&\n    !liveStateIsStale;\n  const snapshot = stateSnapshotProp\n    ? parseJson(stateSnapshotProp, stateSnapshotProp)\n    : shouldUseLiveState\n      ? agentState\n      : undefined;\n  const hasSnapshotKeys = !!(snapshot && Object.keys(snapshot).length > 0);\n  const allowEmptySnapshot =\n    snapshot !== undefined &&\n    !hasSnapshotKeys &&\n    (stateSnapshotProp !== undefined || shouldUseLiveState);\n\n  const messageCacheEntry = caches.byMessageId[messageId];\n  const cachedMessageSnapshot = readCachedMessageEntry(messageCacheEntry).snapshot;\n  const cacheKey =\n    stateRenderId !== undefined ? `${stateRenderId}::${effectiveRunId}` : undefined;\n  let cachedSnapshot = cachedMessageSnapshot ?? caches.byMessageId[messageId];\n  if (cachedSnapshot === undefined && cacheKey && caches.byStateRenderAndRun[cacheKey] !== undefined) {\n    cachedSnapshot = caches.byStateRenderAndRun[cacheKey];\n  }\n  if (\n    cachedSnapshot === undefined &&\n    stateRenderId &&\n    previousUserMessageId &&\n    caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`] !==\n      undefined\n  ) {\n    cachedSnapshot =\n      caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`];\n  }\n  if (\n    cachedSnapshot === undefined &&\n    !skipLatestCache &&\n    stateRenderId &&\n    messageRole !== \"assistant\" &&\n    (stateSnapshotProp !== undefined ||\n      (agentState && Object.keys(agentState).length > 0))\n  ) {\n    cachedSnapshot = caches.byStateRenderAndRun[`${stateRenderId}::latest`];\n  }\n\n  const snapshotForClaim = existingClaim?.locked\n    ? existingClaim.stateSnapshot ?? cachedSnapshot\n    : hasSnapshotKeys\n      ? snapshot\n      : existingClaim?.stateSnapshot ?? cachedSnapshot;\n\n  return { snapshot, hasSnapshotKeys, cachedSnapshot, allowEmptySnapshot, snapshotForClaim };\n}\n"],"mappings":"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","names":["RenderStatus","ClaimAction"]}