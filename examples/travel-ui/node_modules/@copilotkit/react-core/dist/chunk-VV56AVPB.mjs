import {
  useAgentNodeName
} from "./chunk-I76HKHPJ.mjs";
import {
  useCopilotContext
} from "./chunk-AFNWX62Q.mjs";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-SKC7AJIV.mjs";

// src/hooks/use-langgraph-interrupt-render.ts
import React, { useCallback, useEffect, useMemo } from "react";
import { MetaEventName } from "@copilotkit/runtime-client-gql";
import { dataToUUID, parseJson } from "@copilotkit/shared";
import { useCopilotChatConfiguration } from "@copilotkitnext/react";
var InterruptRenderer = ({ event, result, render, resolve }) => {
  return render({ event, result, resolve });
};
function useLangGraphInterruptRender(agent) {
  var _a;
  const {
    interruptActions,
    agentSession,
    threadId,
    interruptEventQueue,
    addInterruptEvent,
    resolveInterruptEvent
  } = useCopilotContext();
  const existingConfig = useCopilotChatConfiguration();
  const resolvedAgentId = (_a = existingConfig == null ? void 0 : existingConfig.agentId) != null ? _a : "default";
  const nodeName = useAgentNodeName(resolvedAgentId);
  useEffect(() => {
    if (!agent)
      return;
    let localInterrupt = null;
    const subscriber = {
      onCustomEvent: ({ event }) => {
        if (event.name === "on_interrupt") {
          const eventData = {
            name: MetaEventName.LangGraphInterruptEvent,
            type: event.type,
            value: parseJson(event.value, event.value)
          };
          const eventId = dataToUUID(eventData, "interruptEvents");
          localInterrupt = {
            eventId,
            threadId,
            event: eventData
          };
        }
      },
      onRunStartedEvent: () => {
        localInterrupt = null;
      },
      onRunFinalized: () => {
        if (localInterrupt) {
          addInterruptEvent(localInterrupt);
          localInterrupt = null;
        }
      }
    };
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agent, threadId]);
  const handleResolve = useCallback(
    (eventId, response) => {
      agent == null ? void 0 : agent.runAgent({
        forwardedProps: {
          command: {
            resume: response
          }
        }
      });
      resolveInterruptEvent(threadId, eventId, response != null ? response : "");
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [agent, threadId]
  );
  return useMemo(() => {
    const eventQueue = interruptEventQueue[threadId] || [];
    const currentQueuedEvent = eventQueue.find((qe) => !qe.event.response);
    if (!currentQueuedEvent || !agentSession)
      return null;
    const allActions = Object.values(interruptActions);
    const matchingAction = allActions.find((action) => {
      if (!action.enabled)
        return true;
      return action.enabled({
        eventValue: currentQueuedEvent.event.value,
        agentMetadata: __spreadProps(__spreadValues({}, agentSession), {
          nodeName
        })
      });
    });
    if (!matchingAction)
      return null;
    const { render, handler } = matchingAction;
    const resolveInterrupt = (response) => {
      handleResolve(currentQueuedEvent.eventId, response);
    };
    let result = null;
    if (handler) {
      result = handler({
        event: currentQueuedEvent.event,
        resolve: resolveInterrupt
      });
    }
    if (!render)
      return null;
    return React.createElement(InterruptRenderer, {
      event: currentQueuedEvent.event,
      result,
      render,
      resolve: resolveInterrupt
    });
  }, [interruptActions, interruptEventQueue, threadId, agentSession, handleResolve]);
}

export {
  useLangGraphInterruptRender
};
//# sourceMappingURL=chunk-VV56AVPB.mjs.map