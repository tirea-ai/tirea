import {
  useAgentNodeName
} from "./chunk-I76HKHPJ.mjs";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-SKC7AJIV.mjs";

// src/hooks/use-coagent.ts
import { useCallback, useEffect, useMemo, useRef } from "react";
import { useAgent, useCopilotKit } from "@copilotkitnext/react";
function useCoAgent(options) {
  const { agent } = useAgent({ agentId: options.name });
  const { copilotkit } = useCopilotKit();
  const nodeName = useAgentNodeName(options.name);
  const handleStateUpdate = useCallback(
    (newState) => {
      if (!agent)
        return;
      if (typeof newState === "function") {
        const updater = newState;
        agent.setState(updater(agent.state));
      } else {
        agent.setState(__spreadValues(__spreadValues({}, agent.state), newState));
      }
    },
    [agent == null ? void 0 : agent.state, agent == null ? void 0 : agent.setState]
  );
  useEffect(() => {
    var _a;
    if (!options.config && !options.configurable)
      return;
    let config = (_a = options.config) != null ? _a : {};
    if (options.configurable) {
      config = __spreadProps(__spreadValues({}, config), {
        configurable: __spreadValues(__spreadValues({}, options.configurable), config.configurable)
      });
    }
    copilotkit.setProperties(config);
  }, [options.config, options.configurable]);
  const externalStateStr = useMemo(
    () => isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0,
    [isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0]
  );
  useEffect(() => {
    if ((agent == null ? void 0 : agent.state) && isExternalStateManagement(options) && JSON.stringify(options.state) !== JSON.stringify(agent.state)) {
      handleStateUpdate(options.state);
    }
  }, [agent, externalStateStr, handleStateUpdate]);
  const hasStateValues = useCallback((value) => {
    return Boolean(value && Object.keys(value).length);
  }, []);
  const initialStateRef = useRef(
    isExternalStateManagement(options) ? options.state : "initialState" in options ? options.initialState : void 0
  );
  useEffect(() => {
    if (isExternalStateManagement(options)) {
      initialStateRef.current = options.state;
    } else if ("initialState" in options) {
      initialStateRef.current = options.initialState;
    }
  }, [
    isExternalStateManagement(options) ? JSON.stringify(options.state) : "initialState" in options ? JSON.stringify(options.initialState) : void 0
  ]);
  useEffect(() => {
    if (!agent)
      return;
    const subscriber = {
      onStateChanged: (args) => {
        if (isExternalStateManagement(options)) {
          options.setState(args.state);
        }
      },
      onRunInitialized: (args) => {
        const runHasState = hasStateValues(args.state);
        if (runHasState) {
          handleStateUpdate(args.state);
          return;
        }
        if (hasStateValues(agent.state)) {
          return;
        }
        if (initialStateRef.current !== void 0) {
          handleStateUpdate(initialStateRef.current);
        }
      }
    };
    const subscription = agent.subscribe(subscriber);
    return () => {
      subscription.unsubscribe();
    };
  }, [agent, handleStateUpdate, hasStateValues]);
  return useMemo(() => {
    var _a, _b, _c;
    if (!agent) {
      const noop = () => {
      };
      const noopAsync = () => __async(this, null, function* () {
      });
      const initialState = (
        // prefer externally provided state if available
        (_b = (_a = "state" in options && options.state) != null ? _a : (
          // then initialState if provided
          "initialState" in options && options.initialState
        )) != null ? _b : {}
      );
      return {
        name: options.name,
        nodeName,
        threadId: void 0,
        running: false,
        state: initialState,
        setState: noop,
        start: noop,
        stop: noop,
        run: noopAsync
      };
    }
    return {
      name: (_c = agent == null ? void 0 : agent.agentId) != null ? _c : options.name,
      nodeName,
      threadId: agent.threadId,
      running: agent.isRunning,
      state: agent.state,
      setState: handleStateUpdate,
      // TODO: start and run both have same thing. need to figure out
      start: agent.runAgent,
      stop: agent.abortRun,
      run: agent.runAgent
    };
  }, [
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.runAgent,
    agent == null ? void 0 : agent.abortRun,
    agent == null ? void 0 : agent.runAgent,
    agent == null ? void 0 : agent.threadId,
    agent == null ? void 0 : agent.isRunning,
    agent == null ? void 0 : agent.agentId,
    handleStateUpdate,
    options.name
  ]);
}
var isExternalStateManagement = (options) => {
  return "state" in options && "setState" in options;
};

export {
  useCoAgent
};
//# sourceMappingURL=chunk-ZYTXB6HH.mjs.map