"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/components/copilot-provider/index.ts
var copilot_provider_exports = {};
__export(copilot_provider_exports, {
  CopilotKit: () => CopilotKit,
  defaultCopilotContextCategories: () => defaultCopilotContextCategories
});
module.exports = __toCommonJS(copilot_provider_exports);

// src/components/copilot-provider/copilotkit.tsx
var import_react15 = require("react");
var import_react16 = require("@copilotkitnext/react");

// src/context/copilot-context.tsx
var import_react = __toESM(require("react"));
var emptyCopilotContext = {
  actions: {},
  setAction: () => {
  },
  removeAction: () => {
  },
  setRegisteredActions: () => "",
  removeRegisteredAction: () => {
  },
  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },
  getContextString: (documents, categories) => returnAndThrowInDebug(""),
  addContext: () => "",
  removeContext: () => {
  },
  getAllContext: () => [],
  getFunctionCallHandler: () => returnAndThrowInDebug(() => __async(void 0, null, function* () {
  })),
  isLoading: false,
  setIsLoading: () => returnAndThrowInDebug(false),
  chatInstructions: "",
  setChatInstructions: () => returnAndThrowInDebug(""),
  additionalInstructions: [],
  setAdditionalInstructions: () => returnAndThrowInDebug([]),
  getDocumentsContext: (categories) => returnAndThrowInDebug([]),
  addDocumentContext: () => returnAndThrowInDebug(""),
  removeDocumentContext: () => {
  },
  copilotApiConfig: new class {
    get chatApiEndpoint() {
      throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
    }
    get headers() {
      return {};
    }
    get body() {
      return {};
    }
  }(),
  chatSuggestionConfiguration: {},
  addChatSuggestionConfiguration: () => {
  },
  removeChatSuggestionConfiguration: () => {
  },
  showDevConsole: false,
  coagentStates: {},
  setCoagentStates: () => {
  },
  coagentStatesRef: { current: {} },
  setCoagentStatesWithRef: () => {
  },
  agentSession: null,
  setAgentSession: () => {
  },
  forwardedParameters: {},
  agentLock: null,
  threadId: "",
  setThreadId: () => {
  },
  runId: null,
  setRunId: () => {
  },
  chatAbortControllerRef: { current: null },
  availableAgents: [],
  extensions: {},
  setExtensions: () => {
  },
  interruptActions: {},
  setInterruptAction: () => {
  },
  removeInterruptAction: () => {
  },
  interruptEventQueue: {},
  addInterruptEvent: () => {
  },
  resolveInterruptEvent: () => {
  },
  onError: () => {
  },
  bannerError: null,
  setBannerError: () => {
  },
  internalErrorHandlers: {},
  setInternalErrorHandler: () => {
  },
  removeInternalErrorHandler: () => {
  }
};
var CopilotContext = import_react.default.createContext(emptyCopilotContext);
function useCopilotContext() {
  const context = import_react.default.useContext(CopilotContext);
  if (context === emptyCopilotContext) {
    throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
  }
  return context;
}
function returnAndThrowInDebug(_value) {
  throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
}

// src/hooks/use-tree.ts
var import_shared = require("@copilotkit/shared");
var import_react2 = require("react");
var removeNode = (nodes, id) => {
  return nodes.reduce((result, node) => {
    if (node.id !== id) {
      const newNode = __spreadProps(__spreadValues({}, node), { children: removeNode(node.children, id) });
      result.push(newNode);
    }
    return result;
  }, []);
};
var addNode = (nodes, newNode, parentId) => {
  if (!parentId) {
    return [...nodes, newNode];
  }
  return nodes.map((node) => {
    if (node.id === parentId) {
      return __spreadProps(__spreadValues({}, node), { children: [...node.children, newNode] });
    } else if (node.children.length) {
      return __spreadProps(__spreadValues({}, node), { children: addNode(node.children, newNode, parentId) });
    }
    return node;
  });
};
var treeIndentationRepresentation = (index, indentLevel) => {
  if (indentLevel === 0) {
    return (index + 1).toString();
  } else if (indentLevel === 1) {
    return String.fromCharCode(65 + index);
  } else if (indentLevel === 2) {
    return String.fromCharCode(97 + index);
  } else {
    return "-";
  }
};
var printNode = (node, prefix = "", indentLevel = 0) => {
  const indent = " ".repeat(3).repeat(indentLevel);
  const prefixPlusIndentLength = prefix.length + indent.length;
  const subsequentLinesPrefix = " ".repeat(prefixPlusIndentLength);
  const valueLines = node.value.split("\n");
  const outputFirstLine = `${indent}${prefix}${valueLines[0]}`;
  const outputSubsequentLines = valueLines.slice(1).map((line) => `${subsequentLinesPrefix}${line}`).join("\n");
  let output = `${outputFirstLine}
`;
  if (outputSubsequentLines) {
    output += `${outputSubsequentLines}
`;
  }
  const childPrePrefix = " ".repeat(prefix.length);
  node.children.forEach(
    (child, index) => output += printNode(
      child,
      `${childPrePrefix}${treeIndentationRepresentation(index, indentLevel + 1)}. `,
      indentLevel + 1
    )
  );
  return output;
};
function treeReducer(state, action) {
  switch (action.type) {
    case "ADD_NODE": {
      const { value, parentId, id: newNodeId } = action;
      const newNode = {
        id: newNodeId,
        value,
        children: [],
        categories: new Set(action.categories)
      };
      try {
        return addNode(state, newNode, parentId);
      } catch (error) {
        console.error(`Error while adding node with id ${newNodeId}: ${error}`);
        return state;
      }
    }
    case "REMOVE_NODE":
      return removeNode(state, action.id);
    default:
      return state;
  }
}
var useTree = () => {
  const [tree, dispatch] = (0, import_react2.useReducer)(treeReducer, []);
  const addElement = (0, import_react2.useCallback)(
    (value, categories, parentId) => {
      const newNodeId = (0, import_shared.randomId)();
      dispatch({
        type: "ADD_NODE",
        value,
        parentId,
        id: newNodeId,
        categories
      });
      return newNodeId;
    },
    []
  );
  const removeElement = (0, import_react2.useCallback)((id) => {
    dispatch({ type: "REMOVE_NODE", id });
  }, []);
  const getAllElements = (0, import_react2.useCallback)(() => {
    return tree;
  }, [tree]);
  const printTree = (0, import_react2.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      let output = "";
      tree.forEach((node, index) => {
        if (!setsHaveIntersection(categoriesSet, node.categories)) {
          return;
        }
        if (index !== 0) {
          output += "\n";
        }
        output += printNode(node, `${treeIndentationRepresentation(index, 0)}. `);
      });
      return output;
    },
    [tree]
  );
  return { tree, addElement, printTree, removeElement, getAllElements };
};
var use_tree_default = useTree;
function setsHaveIntersection(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// src/components/copilot-provider/copilotkit.tsx
var import_react_dom = require("react-dom");
var import_shared13 = require("@copilotkit/shared");

// src/hooks/use-flat-category-store.ts
var import_react3 = require("react");
var import_shared2 = require("@copilotkit/shared");
var useFlatCategoryStore = () => {
  const [elements, dispatch] = (0, import_react3.useReducer)(
    flatCategoryStoreReducer,
    /* @__PURE__ */ new Map()
  );
  const addElement = (0, import_react3.useCallback)((value, categories) => {
    const newId = (0, import_shared2.randomId)();
    dispatch({
      type: "ADD_ELEMENT",
      value,
      id: newId,
      categories
    });
    return newId;
  }, []);
  const removeElement = (0, import_react3.useCallback)((id) => {
    dispatch({ type: "REMOVE_ELEMENT", id });
  }, []);
  const allElements = (0, import_react3.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      const result = [];
      elements.forEach((element) => {
        if (setsHaveIntersection2(categoriesSet, element.categories)) {
          result.push(element.value);
        }
      });
      return result;
    },
    [elements]
  );
  return { addElement, removeElement, allElements };
};
var use_flat_category_store_default = useFlatCategoryStore;
function flatCategoryStoreReducer(state, action) {
  switch (action.type) {
    case "ADD_ELEMENT": {
      const { value, id, categories } = action;
      const newElement = {
        id,
        value,
        categories: new Set(categories)
      };
      const newState = new Map(state);
      newState.set(id, newElement);
      return newState;
    }
    case "REMOVE_ELEMENT": {
      const newState = new Map(state);
      newState.delete(action.id);
      return newState;
    }
    default:
      return state;
  }
}
function setsHaveIntersection2(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// src/components/copilot-provider/copilot-messages.tsx
var import_react6 = require("react");

// src/context/copilot-messages-context.tsx
var import_react4 = __toESM(require("react"));
var emptyCopilotContext2 = {
  messages: [],
  setMessages: () => [],
  // suggestions state
  suggestions: [],
  setSuggestions: () => []
};
var CopilotMessagesContext = import_react4.default.createContext(emptyCopilotContext2);

// src/components/toast/toast-provider.tsx
var import_react5 = require("react");
var import_shared3 = require("@copilotkit/shared");
var import_jsx_runtime = require("react/jsx-runtime");
var ToastContext = (0, import_react5.createContext)(void 0);
function getErrorSeverity(error) {
  if (error.severity) {
    switch (error.severity) {
      case import_shared3.Severity.CRITICAL:
        return "critical";
      case import_shared3.Severity.WARNING:
        return "warning";
      case import_shared3.Severity.INFO:
        return "info";
      default:
        return "info";
    }
  }
  const message = error.message.toLowerCase();
  if (message.includes("api key") || message.includes("401") || message.includes("unauthorized") || message.includes("authentication") || message.includes("incorrect api key")) {
    return "critical";
  }
  return "info";
}
function getErrorColors(severity) {
  switch (severity) {
    case "critical":
      return {
        background: "#fee2e2",
        border: "#dc2626",
        text: "#7f1d1d",
        icon: "#dc2626"
      };
    case "warning":
      return {
        background: "#fef3c7",
        border: "#d97706",
        text: "#78350f",
        icon: "#d97706"
      };
    case "info":
      return {
        background: "#dbeafe",
        border: "#2563eb",
        text: "#1e3a8a",
        icon: "#2563eb"
      };
  }
}
function useToast() {
  const context = (0, import_react5.useContext)(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
}
function ToastProvider({
  enabled,
  children
}) {
  const [toasts, setToasts] = (0, import_react5.useState)([]);
  const [bannerError, setBannerErrorState] = (0, import_react5.useState)(null);
  const removeToast = (0, import_react5.useCallback)((id) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);
  const addToast = (0, import_react5.useCallback)(
    (toast) => {
      var _a;
      if (!enabled) {
        return;
      }
      const id = (_a = toast.id) != null ? _a : Math.random().toString(36).substring(2, 9);
      setToasts((currentToasts) => {
        if (currentToasts.find((toast2) => toast2.id === id))
          return currentToasts;
        return [...currentToasts, __spreadProps(__spreadValues({}, toast), { id })];
      });
      if (toast.duration) {
        setTimeout(() => {
          removeToast(id);
        }, toast.duration);
      }
    },
    [enabled, removeToast]
  );
  const setBannerError = (0, import_react5.useCallback)(
    (error) => {
      if (!enabled && error !== null) {
        return;
      }
      setBannerErrorState(error);
    },
    [enabled]
  );
  const addGraphQLErrorsToast = (0, import_react5.useCallback)((errors) => {
    console.warn("addGraphQLErrorsToast is deprecated. All errors now show as banners.");
  }, []);
  const value = {
    toasts,
    addToast,
    addGraphQLErrorsToast,
    removeToast,
    enabled,
    bannerError,
    setBannerError
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ToastContext.Provider, { value, children: [
    bannerError && (() => {
      const severity = getErrorSeverity(bannerError);
      const colors = getErrorColors(severity);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "div",
        {
          style: {
            position: "fixed",
            bottom: "20px",
            left: "50%",
            transform: "translateX(-50%)",
            zIndex: 9999,
            backgroundColor: colors.background,
            border: `1px solid ${colors.border}`,
            borderLeft: `4px solid ${colors.border}`,
            borderRadius: "8px",
            padding: "12px 16px",
            fontSize: "13px",
            boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
            backdropFilter: "blur(8px)",
            maxWidth: "min(90vw, 700px)",
            width: "100%",
            boxSizing: "border-box",
            overflow: "hidden"
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                gap: "10px"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      flex: 1,
                      minWidth: 0
                    },
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                        "div",
                        {
                          style: {
                            width: "12px",
                            height: "12px",
                            borderRadius: "50%",
                            backgroundColor: colors.border,
                            flexShrink: 0
                          }
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            display: "flex",
                            alignItems: "center",
                            gap: "10px",
                            flex: 1,
                            minWidth: 0
                          },
                          children: [
                            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                              "div",
                              {
                                style: {
                                  color: colors.text,
                                  lineHeight: "1.4",
                                  fontWeight: "400",
                                  fontSize: "13px",
                                  flex: 1,
                                  wordBreak: "break-all",
                                  overflowWrap: "break-word",
                                  maxWidth: "550px",
                                  overflow: "hidden",
                                  display: "-webkit-box",
                                  WebkitLineClamp: 10,
                                  WebkitBoxOrient: "vertical"
                                },
                                children: (() => {
                                  let message = bannerError.message;
                                  const jsonMatch = message.match(/'message':\s*'([^']+)'/);
                                  if (jsonMatch) {
                                    return jsonMatch[1];
                                  }
                                  message = message.split(" - ")[0];
                                  message = message.split(": Error code")[0];
                                  message = message.replace(/:\s*\d{3}$/, "");
                                  message = message.replace(/See more:.*$/g, "");
                                  message = message.trim();
                                  return message || "Configuration error occurred.";
                                })()
                              }
                            ),
                            (() => {
                              const message = bannerError.message;
                              const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
                              const plainUrlRegex = /(https?:\/\/[^\s)]+)/g;
                              let url = null;
                              let buttonText = "See More";
                              const markdownMatch = markdownLinkRegex.exec(message);
                              if (markdownMatch) {
                                url = markdownMatch[2];
                                buttonText = "See More";
                              } else {
                                const urlMatch = plainUrlRegex.exec(message);
                                if (urlMatch) {
                                  url = urlMatch[0].replace(/[.,;:'"]*$/, "");
                                  buttonText = "See More";
                                }
                              }
                              if (!url)
                                return null;
                              return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                                "button",
                                {
                                  onClick: () => window.open(url, "_blank", "noopener,noreferrer"),
                                  style: {
                                    background: colors.border,
                                    color: "white",
                                    border: "none",
                                    borderRadius: "5px",
                                    padding: "4px 10px",
                                    fontSize: "11px",
                                    fontWeight: "500",
                                    cursor: "pointer",
                                    transition: "all 0.2s ease",
                                    flexShrink: 0
                                  },
                                  onMouseEnter: (e) => {
                                    e.currentTarget.style.opacity = "0.9";
                                    e.currentTarget.style.transform = "translateY(-1px)";
                                  },
                                  onMouseLeave: (e) => {
                                    e.currentTarget.style.opacity = "1";
                                    e.currentTarget.style.transform = "translateY(0)";
                                  },
                                  children: buttonText
                                }
                              );
                            })()
                          ]
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "button",
                  {
                    onClick: () => setBannerError(null),
                    style: {
                      background: "transparent",
                      border: "none",
                      color: colors.text,
                      cursor: "pointer",
                      padding: "2px",
                      borderRadius: "3px",
                      fontSize: "14px",
                      lineHeight: "1",
                      opacity: 0.6,
                      transition: "all 0.2s ease",
                      flexShrink: 0
                    },
                    title: "Dismiss",
                    onMouseEnter: (e) => {
                      e.currentTarget.style.opacity = "1";
                      e.currentTarget.style.background = "rgba(0, 0, 0, 0.05)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.opacity = "0.6";
                      e.currentTarget.style.background = "transparent";
                    },
                    children: "\xD7"
                  }
                )
              ]
            }
          )
        }
      );
    })(),
    children
  ] });
}

// src/utils/dev-console.ts
function isLocalhost() {
  if (typeof window === "undefined")
    return false;
  return window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname === "0.0.0.0";
}
function shouldShowDevConsole(showDevConsole) {
  if (showDevConsole !== void 0) {
    return showDevConsole;
  }
  return isLocalhost();
}

// src/components/copilot-provider/copilot-messages.tsx
var import_shared4 = require("@copilotkit/shared");
var import_jsx_runtime2 = require("react/jsx-runtime");
var MessagesTapContext = (0, import_react6.createContext)(null);
function useMessagesTap() {
  const tap = (0, import_react6.useContext)(MessagesTapContext);
  if (!tap)
    throw new Error("useMessagesTap must be used inside <MessagesTapProvider>");
  return tap;
}
function MessagesTapProvider({ children }) {
  const messagesRef = (0, import_react6.useRef)([]);
  const tapRef = (0, import_react6.useRef)({
    getMessagesFromTap: () => messagesRef.current,
    updateTapMessages: (messages) => {
      messagesRef.current = messages;
    }
  });
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MessagesTapContext.Provider, { value: tapRef.current, children });
}
function CopilotMessages({ children }) {
  const [messages, setMessages] = (0, import_react6.useState)([]);
  const lastLoadedThreadId = (0, import_react6.useRef)(void 0);
  const lastLoadedAgentName = (0, import_react6.useRef)(void 0);
  const lastLoadedMessages = (0, import_react6.useRef)(void 0);
  const { updateTapMessages } = useMessagesTap();
  const { threadId, agentSession, showDevConsole, onError, copilotApiConfig } = useCopilotContext();
  const { setBannerError } = useToast();
  const traceUIError = (0, import_react6.useCallback)(
    (error, originalError) => __async(this, null, function* () {
      if (!onError || !copilotApiConfig.publicApiKey)
        return;
      try {
        const traceEvent = {
          type: "error",
          timestamp: Date.now(),
          context: {
            source: "ui",
            request: {
              operation: "loadAgentState",
              url: copilotApiConfig.chatApiEndpoint,
              startTime: Date.now()
            },
            technical: {
              environment: "browser",
              userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
              stackTrace: originalError instanceof Error ? originalError.stack : void 0
            }
          },
          error
        };
        yield onError(traceEvent);
      } catch (traceError) {
        console.error("Error in CopilotMessages onError handler:", traceError);
      }
    }),
    [onError, copilotApiConfig.publicApiKey, copilotApiConfig.chatApiEndpoint]
  );
  const createStructuredError = (gqlError) => {
    const extensions = gqlError.extensions;
    const originalError = extensions == null ? void 0 : extensions.originalError;
    if (originalError == null ? void 0 : originalError.stack) {
      if (originalError.stack.includes("CopilotApiDiscoveryError")) {
        return new import_shared4.CopilotKitApiDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitRemoteEndpointDiscoveryError")) {
        return new import_shared4.CopilotKitRemoteEndpointDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitAgentDiscoveryError")) {
        return new import_shared4.CopilotKitAgentDiscoveryError({
          agentName: "",
          availableAgents: []
        });
      }
    }
    const message = (originalError == null ? void 0 : originalError.message) || gqlError.message;
    const code = extensions == null ? void 0 : extensions.code;
    if (code) {
      return new import_shared4.CopilotKitError({ message, code });
    }
    return null;
  };
  const handleGraphQLErrors = (0, import_react6.useCallback)(
    (error) => {
      var _a;
      if ((_a = error.graphQLErrors) == null ? void 0 : _a.length) {
        const graphQLErrors = error.graphQLErrors;
        const routeError = (gqlError) => {
          const extensions = gqlError.extensions;
          const visibility = extensions == null ? void 0 : extensions.visibility;
          const isDev = shouldShowDevConsole(showDevConsole);
          if (!isDev) {
            console.error("CopilotKit Error (hidden in production):", gqlError.message);
            return;
          }
          if (visibility === import_shared4.ErrorVisibility.SILENT) {
            console.error("CopilotKit Silent Error:", gqlError.message);
            return;
          }
          const ckError = createStructuredError(gqlError);
          if (ckError) {
            setBannerError(ckError);
            traceUIError(ckError, gqlError);
          } else {
            const fallbackError = new import_shared4.CopilotKitError({
              message: gqlError.message,
              code: import_shared4.CopilotKitErrorCode.UNKNOWN
            });
            setBannerError(fallbackError);
            traceUIError(fallbackError, gqlError);
          }
        };
        graphQLErrors.forEach(routeError);
      } else {
        const isDev = shouldShowDevConsole(showDevConsole);
        if (!isDev) {
          console.error("CopilotKit Error (hidden in production):", error);
        } else {
          const fallbackError = new import_shared4.CopilotKitError({
            message: (error == null ? void 0 : error.message) || String(error),
            code: import_shared4.CopilotKitErrorCode.UNKNOWN
          });
          setBannerError(fallbackError);
          traceUIError(fallbackError, error);
        }
      }
    },
    [setBannerError, showDevConsole, traceUIError]
  );
  (0, import_react6.useEffect)(() => {
    updateTapMessages(messages);
  }, [messages, updateTapMessages]);
  const memoizedChildren = (0, import_react6.useMemo)(() => children, [children]);
  const [suggestions, setSuggestions] = (0, import_react6.useState)([]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    CopilotMessagesContext.Provider,
    {
      value: {
        messages,
        setMessages,
        suggestions,
        setSuggestions
      },
      children: memoizedChildren
    }
  );
}

// src/components/usage-banner.tsx
var import_shared5 = require("@copilotkit/shared");
var import_jsx_runtime3 = require("react/jsx-runtime");
function UsageBanner({
  severity = import_shared5.Severity.CRITICAL,
  message = "",
  onClose,
  actions
}) {
  if (!message || !severity) {
    return null;
  }
  const themes = {
    [import_shared5.Severity.INFO]: {
      bg: "#f8fafc",
      border: "#e2e8f0",
      text: "#475569",
      accent: "#3b82f6"
    },
    [import_shared5.Severity.WARNING]: {
      bg: "#fffbeb",
      border: "#fbbf24",
      text: "#92400e",
      accent: "#f59e0b"
    },
    [import_shared5.Severity.CRITICAL]: {
      bg: "#fef2f2",
      border: "#fecaca",
      text: "#dc2626",
      accent: "#ef4444"
    }
  };
  const theme = themes[severity];
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("style", { children: `
          @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(8px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
          }
          
          .usage-banner {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: min(600px, calc(100vw - 32px));
            z-index: 10000;
            animation: slideUp 0.2s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          .banner-content {
            background: linear-gradient(135deg, ${theme.bg} 0%, ${theme.bg}f5 100%);
            border: 1px solid ${theme.border};
            border-radius: 12px;
            padding: 18px 20px;
            box-shadow: 
              0 4px 24px rgba(0, 0, 0, 0.08),
              0 2px 8px rgba(0, 0, 0, 0.04),
              inset 0 1px 0 rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            gap: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            backdrop-filter: blur(12px);
            position: relative;
            overflow: hidden;
          }
          
          .banner-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, ${theme.accent}40, transparent);
          }
          
          .banner-message {
            color: ${theme.text};
            font-size: 14px;
            line-height: 1.5;
            font-weight: 500;
            flex: 1;
            letter-spacing: -0.01em;
          }
          
          .close-btn {
            background: rgba(0, 0, 0, 0.05);
            border: none;
            color: ${theme.text};
            cursor: pointer;
            padding: 0;
            border-radius: 6px;
            opacity: 0.6;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-size: 14px;
            line-height: 1;
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          
          .close-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.08);
            transform: scale(1.05);
          }
          
          .btn-primary {
            background: linear-gradient(135deg, ${theme.accent} 0%, ${theme.accent}e6 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-family: inherit;
            flex-shrink: 0;
            box-shadow: 
              0 2px 8px ${theme.accent}30,
              inset 0 1px 0 rgba(255, 255, 255, 0.2);
            letter-spacing: -0.01em;
          }
          
          .btn-primary:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 
              0 4px 12px ${theme.accent}40,
              inset 0 1px 0 rgba(255, 255, 255, 0.25);
          }
          
          .btn-primary:active {
            transform: translateY(0) scale(0.98);
            transition: all 0.08s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          @media (max-width: 640px) {
            .usage-banner {
              width: calc(100vw - 24px);
            }
            
            .banner-content {
              padding: 16px;
              gap: 12px;
            }
            
            .banner-message {
              font-size: 13px;
              line-height: 1.45;
            }
            
            .btn-primary {
              padding: 8px 14px;
              font-size: 12px;
            }
            
            .close-btn {
              width: 22px;
              height: 22px;
              font-size: 12px;
            }
          }
        ` }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "usage-banner", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "banner-content", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "banner-message", children: message }),
      (actions == null ? void 0 : actions.primary) && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("button", { className: "btn-primary", onClick: actions.primary.onClick, children: actions.primary.label }),
      onClose && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("button", { className: "close-btn", onClick: onClose, title: "Close", children: "\xD7" })
    ] }) })
  ] });
}
var getErrorActions = (error) => {
  switch (error.code) {
    case import_shared5.CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR:
      return {
        primary: {
          label: "Show me how",
          onClick: () => window.open(
            "https://docs.copilotkit.ai/premium#how-do-i-get-access-to-premium-features",
            "_blank",
            "noopener,noreferrer"
          )
        }
      };
    case import_shared5.CopilotKitErrorCode.UPGRADE_REQUIRED_ERROR:
      return {
        primary: {
          label: "Upgrade",
          onClick: () => window.open("https://cloud.copilotkit.ai", "_blank", "noopener,noreferrer")
        }
      };
    default:
      return void 0;
  }
};

// src/components/error-boundary/error-boundary.tsx
var import_react7 = __toESM(require("react"));
var import_shared7 = require("@copilotkit/shared");

// src/lib/status-checker.ts
var import_shared6 = require("@copilotkit/shared");
var STATUS_CHECK_INTERVAL = 1e3 * 60 * 5;
var StatusChecker = class {
  constructor() {
    this.activeKey = null;
    this.intervalId = null;
    this.instanceCount = 0;
    this.lastResponse = null;
  }
  start(publicApiKey, onUpdate) {
    return __async(this, null, function* () {
      this.instanceCount++;
      if (this.activeKey === publicApiKey)
        return;
      if (this.intervalId)
        clearInterval(this.intervalId);
      const checkStatus = () => __async(this, null, function* () {
        try {
          const response = yield fetch(`${import_shared6.COPILOT_CLOUD_API_URL}/ciu`, {
            method: "GET",
            headers: {
              [import_shared6.COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey
            }
          }).then((response2) => response2.json());
          this.lastResponse = response;
          onUpdate == null ? void 0 : onUpdate(response);
          return response;
        } catch (error) {
          return null;
        }
      });
      const initialResponse = yield checkStatus();
      this.intervalId = setInterval(checkStatus, STATUS_CHECK_INTERVAL);
      this.activeKey = publicApiKey;
      return initialResponse;
    });
  }
  getLastResponse() {
    return this.lastResponse;
  }
  stop() {
    this.instanceCount--;
    if (this.instanceCount === 0) {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
        this.activeKey = null;
        this.lastResponse = null;
      }
    }
  }
};

// src/components/error-boundary/error-boundary.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var statusChecker = new StatusChecker();
var CopilotErrorBoundary = class extends import_react7.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidMount() {
    if (this.props.publicApiKey) {
      statusChecker.start(this.props.publicApiKey, (newStatus) => {
        this.setState((prevState) => {
          var _a;
          if ((newStatus == null ? void 0 : newStatus.severity) !== ((_a = prevState.status) == null ? void 0 : _a.severity)) {
            return { status: newStatus != null ? newStatus : void 0 };
          }
          return null;
        });
      });
    }
  }
  componentWillUnmount() {
    statusChecker.stop();
  }
  componentDidCatch(error, errorInfo) {
    console.error("CopilotKit Error:", error, errorInfo);
  }
  render() {
    var _a, _b, _c, _d;
    if (this.state.hasError) {
      if (this.state.error instanceof import_shared7.CopilotKitError) {
        return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
          this.props.children,
          this.props.showUsageBanner && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            UsageBanner,
            {
              severity: (_b = (_a = this.state.status) == null ? void 0 : _a.severity) != null ? _b : this.state.error.severity,
              message: (_d = (_c = this.state.status) == null ? void 0 : _c.message) != null ? _d : this.state.error.message,
              actions: getErrorActions(this.state.error)
            }
          )
        ] });
      }
      throw this.state.error;
    }
    return this.props.children;
  }
};

// src/context/coagent-state-renders-context.tsx
var import_react8 = require("react");
var import_jsx_runtime5 = require("react/jsx-runtime");
var CoAgentStateRendersContext = (0, import_react8.createContext)(
  void 0
);
function CoAgentStateRendersProvider({ children }) {
  const [coAgentStateRenders, setCoAgentStateRenders] = (0, import_react8.useState)({});
  const setCoAgentStateRender = (0, import_react8.useCallback)((id, stateRender) => {
    setCoAgentStateRenders((prevPoints) => __spreadProps(__spreadValues({}, prevPoints), {
      [id]: stateRender
    }));
  }, []);
  const removeCoAgentStateRender = (0, import_react8.useCallback)((id) => {
    setCoAgentStateRenders((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const claimsRef = (0, import_react8.useRef)({});
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    CoAgentStateRendersContext.Provider,
    {
      value: {
        coAgentStateRenders,
        setCoAgentStateRender,
        removeCoAgentStateRender,
        claimsRef
      },
      children
    }
  );
}
function useCoAgentStateRenders() {
  const context = (0, import_react8.useContext)(CoAgentStateRendersContext);
  if (!context) {
    throw new Error("useCoAgentStateRenders must be used within CoAgentStateRendersProvider");
  }
  return context;
}

// src/hooks/use-coagent-state-render-bridge.tsx
var import_react11 = require("@copilotkitnext/react");
var import_react12 = require("react");

// src/context/threads-context.tsx
var import_react9 = require("react");
var import_shared8 = require("@copilotkit/shared");
var import_jsx_runtime6 = require("react/jsx-runtime");
var ThreadsContext = (0, import_react9.createContext)(void 0);
function ThreadsProvider({ children, threadId: explicitThreadId }) {
  const [internalThreadId, setThreadId] = (0, import_react9.useState)(() => (0, import_shared8.randomUUID)());
  const threadId = explicitThreadId != null ? explicitThreadId : internalThreadId;
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    ThreadsContext.Provider,
    {
      value: {
        threadId,
        setThreadId
      },
      children
    }
  );
}
function useThreads() {
  const context = (0, import_react9.useContext)(ThreadsContext);
  if (!context) {
    throw new Error("useThreads must be used within ThreadsProvider");
  }
  return context;
}

// src/hooks/use-coagent-state-render-bridge.tsx
var import_shared10 = require("@copilotkit/shared");

// src/hooks/use-coagent-state-render-bridge.helpers.ts
var import_shared9 = require("@copilotkit/shared");
function getStateWithoutConstantKeys(state) {
  if (!state)
    return {};
  const _a = state, { messages, tools, copilotkit } = _a, stateWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  return stateWithoutConstantKeys;
}
function areStatesEquals(a, b) {
  if (a && !b || !a && b)
    return false;
  const _a = a, { messages, tools, copilotkit } = _a, aWithoutConstantKeys = __objRest(_a, ["messages", "tools", "copilotkit"]);
  const _b = b, {
    messages: bMessages,
    tools: bTools,
    copilotkit: bCopilotkit
  } = _b, bWithoutConstantKeys = __objRest(_b, [
    "messages",
    "tools",
    "copilotkit"
  ]);
  return JSON.stringify(aWithoutConstantKeys) === JSON.stringify(bWithoutConstantKeys);
}
function isPlaceholderMessageId(messageId) {
  return !!messageId && messageId.startsWith("coagent-state-render-");
}
function isPlaceholderMessageName(messageName) {
  return messageName === "coagent-state-render";
}
function readCachedMessageEntry(entry) {
  if (!entry || typeof entry !== "object") {
    return { snapshot: entry, runId: void 0 };
  }
  const snapshot = "snapshot" in entry ? entry.snapshot : entry;
  const runId = "runId" in entry ? entry.runId : void 0;
  return { snapshot, runId };
}
function getEffectiveRunId({
  existingClaimRunId,
  cachedMessageRunId,
  runId
}) {
  return existingClaimRunId || cachedMessageRunId || runId || "pending";
}
function resolveClaim({
  claims,
  context,
  stateSnapshot
}) {
  const { messageId, stateRenderId, runId, messageIndex } = context;
  const existing = claims[messageId];
  if (existing) {
    const canRender = existing.stateRenderId === stateRenderId;
    const shouldUpdateRunId = canRender && runId && (!existing.runId || existing.runId === "pending");
    return {
      canRender,
      action: canRender ? "existing" /* Existing */ : "block" /* Block */,
      updateRunId: shouldUpdateRunId ? runId : void 0
    };
  }
  const normalizedRunId = runId != null ? runId : "pending";
  const renderClaimedByOtherMessageEntry = Object.entries(claims).find(
    ([, claim]) => {
      var _a;
      return claim.stateRenderId === stateRenderId && ((_a = claim.runId) != null ? _a : "pending") === normalizedRunId && (0, import_shared9.dataToUUID)(getStateWithoutConstantKeys(claim.stateSnapshot)) === (0, import_shared9.dataToUUID)(getStateWithoutConstantKeys(stateSnapshot));
    }
  );
  const renderClaimedByOtherMessage = renderClaimedByOtherMessageEntry == null ? void 0 : renderClaimedByOtherMessageEntry[1];
  const claimedMessageId = renderClaimedByOtherMessageEntry == null ? void 0 : renderClaimedByOtherMessageEntry[0];
  if (renderClaimedByOtherMessage) {
    if (messageIndex !== void 0 && renderClaimedByOtherMessage.messageIndex !== void 0 && messageIndex > renderClaimedByOtherMessage.messageIndex) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId, messageIndex },
        lockOthers: runId === renderClaimedByOtherMessage.runId || isPlaceholderMessageId(claimedMessageId)
      };
    }
    if (runId && renderClaimedByOtherMessage.runId && runId !== renderClaimedByOtherMessage.runId) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId, messageIndex },
        lockOthers: isPlaceholderMessageId(claimedMessageId)
      };
    }
    if (isPlaceholderMessageId(claimedMessageId)) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId, messageIndex },
        lockOthers: true
      };
    }
    if (stateSnapshot && renderClaimedByOtherMessage.stateSnapshot && !areStatesEquals(renderClaimedByOtherMessage.stateSnapshot, stateSnapshot)) {
      return {
        canRender: true,
        action: "override" /* Override */,
        nextClaim: { stateRenderId, runId }
      };
    }
    return { canRender: false, action: "block" /* Block */ };
  }
  if (!runId) {
    return { canRender: false, action: "block" /* Block */ };
  }
  return {
    canRender: true,
    action: "create" /* Create */,
    nextClaim: { stateRenderId, runId, messageIndex }
  };
}
function selectSnapshot({
  messageId,
  messageName,
  allowLiveState,
  skipLatestCache,
  stateRenderId,
  effectiveRunId,
  stateSnapshotProp,
  agentState,
  agentMessages,
  existingClaim,
  caches
}) {
  var _a, _b, _c, _d, _e, _f;
  const lastAssistantId = agentMessages ? (_a = [...agentMessages].reverse().find((msg) => msg.role === "assistant")) == null ? void 0 : _a.id : void 0;
  const latestSnapshot = stateRenderId !== void 0 ? caches.byStateRenderAndRun[`${stateRenderId}::latest`] : void 0;
  const messageIndex = agentMessages ? agentMessages.findIndex((msg) => msg.id === messageId) : -1;
  const messageRole = messageIndex >= 0 && agentMessages ? (_b = agentMessages[messageIndex]) == null ? void 0 : _b.role : void 0;
  let previousUserMessageId;
  if (messageIndex > 0 && agentMessages) {
    for (let i = messageIndex - 1; i >= 0; i -= 1) {
      if (((_c = agentMessages[i]) == null ? void 0 : _c.role) === "user") {
        previousUserMessageId = (_d = agentMessages[i]) == null ? void 0 : _d.id;
        break;
      }
    }
  }
  const liveStateIsStale = stateSnapshotProp === void 0 && latestSnapshot !== void 0 && agentState !== void 0 && areStatesEquals(latestSnapshot, agentState);
  const shouldUseLiveState = (Boolean(allowLiveState) || !lastAssistantId || messageId === lastAssistantId) && !liveStateIsStale;
  const snapshot = stateSnapshotProp ? (0, import_shared9.parseJson)(stateSnapshotProp, stateSnapshotProp) : shouldUseLiveState ? agentState : void 0;
  const hasSnapshotKeys = !!(snapshot && Object.keys(snapshot).length > 0);
  const allowEmptySnapshot = snapshot !== void 0 && !hasSnapshotKeys && (stateSnapshotProp !== void 0 || shouldUseLiveState);
  const messageCacheEntry = caches.byMessageId[messageId];
  const cachedMessageSnapshot = readCachedMessageEntry(messageCacheEntry).snapshot;
  const cacheKey = stateRenderId !== void 0 ? `${stateRenderId}::${effectiveRunId}` : void 0;
  let cachedSnapshot = cachedMessageSnapshot != null ? cachedMessageSnapshot : caches.byMessageId[messageId];
  if (cachedSnapshot === void 0 && cacheKey && caches.byStateRenderAndRun[cacheKey] !== void 0) {
    cachedSnapshot = caches.byStateRenderAndRun[cacheKey];
  }
  if (cachedSnapshot === void 0 && stateRenderId && previousUserMessageId && caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`] !== void 0) {
    cachedSnapshot = caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`];
  }
  if (cachedSnapshot === void 0 && !skipLatestCache && stateRenderId && messageRole !== "assistant" && (stateSnapshotProp !== void 0 || agentState && Object.keys(agentState).length > 0)) {
    cachedSnapshot = caches.byStateRenderAndRun[`${stateRenderId}::latest`];
  }
  const snapshotForClaim = (existingClaim == null ? void 0 : existingClaim.locked) ? (_e = existingClaim.stateSnapshot) != null ? _e : cachedSnapshot : hasSnapshotKeys ? snapshot : (_f = existingClaim == null ? void 0 : existingClaim.stateSnapshot) != null ? _f : cachedSnapshot;
  return { snapshot, hasSnapshotKeys, cachedSnapshot, allowEmptySnapshot, snapshotForClaim };
}

// src/hooks/use-coagent-state-render-registry.ts
var import_react10 = require("react");
var LAST_SNAPSHOTS_BY_RENDER_AND_RUN = "__lastSnapshotsByStateRenderIdAndRun";
var LAST_SNAPSHOTS_BY_MESSAGE = "__lastSnapshotsByMessageId";
function getClaimsStore(claimsRef) {
  return claimsRef.current;
}
function getSnapshotCaches(claimsRef) {
  var _a, _b;
  const store = getClaimsStore(claimsRef);
  return {
    byStateRenderAndRun: (_a = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _a : {},
    byMessageId: (_b = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _b : {}
  };
}
function useStateRenderRegistry({
  agentId,
  stateRenderId,
  message,
  messageIndex,
  stateSnapshot,
  agentState,
  agentMessages,
  claimsRef
}) {
  var _a, _b, _c, _d, _e, _f;
  const store = getClaimsStore(claimsRef);
  const runId = message.runId;
  const cachedMessageEntry = (_a = store[LAST_SNAPSHOTS_BY_MESSAGE]) == null ? void 0 : _a[message.id];
  const { runId: cachedMessageRunId } = readCachedMessageEntry(cachedMessageEntry);
  const existingClaimRunId = (_b = claimsRef.current[message.id]) == null ? void 0 : _b.runId;
  const effectiveRunId = getEffectiveRunId({
    existingClaimRunId,
    cachedMessageRunId,
    runId
  });
  (0, import_react10.useEffect)(() => {
    return () => {
      var _a2, _b2, _c2, _d2;
      const existingClaim2 = claimsRef.current[message.id];
      if ((existingClaim2 == null ? void 0 : existingClaim2.stateSnapshot) && Object.keys(existingClaim2.stateSnapshot).length > 0) {
        const snapshotCache = __spreadValues({}, (_a2 = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _a2 : {});
        const cacheKey = `${existingClaim2.stateRenderId}::${(_b2 = existingClaim2.runId) != null ? _b2 : "pending"}`;
        snapshotCache[cacheKey] = existingClaim2.stateSnapshot;
        snapshotCache[`${existingClaim2.stateRenderId}::latest`] = existingClaim2.stateSnapshot;
        store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;
        const messageCache = __spreadValues({}, (_c2 = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _c2 : {});
        messageCache[message.id] = {
          snapshot: existingClaim2.stateSnapshot,
          runId: (_d2 = existingClaim2.runId) != null ? _d2 : effectiveRunId
        };
        store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;
      }
      delete claimsRef.current[message.id];
    };
  }, [claimsRef, effectiveRunId, message.id]);
  if (!stateRenderId) {
    return { canRender: false };
  }
  const caches = getSnapshotCaches(claimsRef);
  const existingClaim = claimsRef.current[message.id];
  const { snapshot, hasSnapshotKeys, allowEmptySnapshot, snapshotForClaim } = selectSnapshot({
    messageId: message.id,
    messageName: message.name,
    allowLiveState: isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),
    skipLatestCache: isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),
    stateRenderId,
    effectiveRunId,
    stateSnapshotProp: stateSnapshot,
    agentState,
    agentMessages,
    existingClaim,
    caches
  });
  const resolution = resolveClaim({
    claims: claimsRef.current,
    context: {
      agentId,
      messageId: message.id,
      stateRenderId,
      runId: effectiveRunId,
      messageIndex
    },
    stateSnapshot: snapshotForClaim
  });
  if (resolution.action === "block" /* Block */) {
    return { canRender: false };
  }
  if (resolution.updateRunId && claimsRef.current[message.id]) {
    claimsRef.current[message.id].runId = resolution.updateRunId;
  }
  if (resolution.nextClaim) {
    claimsRef.current[message.id] = resolution.nextClaim;
  }
  if (resolution.lockOthers) {
    Object.entries(claimsRef.current).forEach(([id, claim]) => {
      if (id !== message.id && claim.stateRenderId === stateRenderId) {
        claim.locked = true;
      }
    });
  }
  if (existingClaim && !existingClaim.locked && (agentMessages == null ? void 0 : agentMessages.length)) {
    const indexInAgentMessages = agentMessages.findIndex((msg) => msg.id === message.id);
    if (indexInAgentMessages >= 0 && indexInAgentMessages < agentMessages.length - 1) {
      existingClaim.locked = true;
    }
  }
  const existingSnapshot = claimsRef.current[message.id].stateSnapshot;
  const snapshotChanged = stateSnapshot && existingSnapshot !== void 0 && !areStatesEquals(existingSnapshot, snapshot);
  if (snapshot && (stateSnapshot || hasSnapshotKeys || allowEmptySnapshot) && (!claimsRef.current[message.id].locked || snapshotChanged)) {
    if (!claimsRef.current[message.id].locked || snapshotChanged) {
      claimsRef.current[message.id].stateSnapshot = snapshot;
      const snapshotCache = __spreadValues({}, (_c = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _c : {});
      const cacheKey = `${stateRenderId}::${effectiveRunId}`;
      snapshotCache[cacheKey] = snapshot;
      snapshotCache[`${stateRenderId}::latest`] = snapshot;
      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;
      const messageCache = __spreadValues({}, (_d = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _d : {});
      messageCache[message.id] = { snapshot, runId: effectiveRunId };
      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;
      if (stateSnapshot) {
        claimsRef.current[message.id].locked = true;
      }
    }
  } else if (snapshotForClaim) {
    const existingSnapshot2 = claimsRef.current[message.id].stateSnapshot;
    if (!existingSnapshot2) {
      claimsRef.current[message.id].stateSnapshot = snapshotForClaim;
      const snapshotCache = __spreadValues({}, (_e = store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN]) != null ? _e : {});
      const cacheKey = `${stateRenderId}::${effectiveRunId}`;
      snapshotCache[cacheKey] = snapshotForClaim;
      snapshotCache[`${stateRenderId}::latest`] = snapshotForClaim;
      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;
      const messageCache = __spreadValues({}, (_f = store[LAST_SNAPSHOTS_BY_MESSAGE]) != null ? _f : {});
      messageCache[message.id] = { snapshot: snapshotForClaim, runId: effectiveRunId };
      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;
    }
  }
  return { canRender: true };
}

// src/hooks/use-coagent-state-render-bridge.tsx
function useCoagentStateRenderBridge(agentId, props) {
  var _a;
  const { stateSnapshot, message } = props;
  const { coAgentStateRenders, claimsRef } = useCoAgentStateRenders();
  const { agent } = (0, import_react11.useAgent)({ agentId });
  const [nodeName, setNodeName] = (0, import_react12.useState)(void 0);
  const [, forceUpdate] = (0, import_react12.useState)(0);
  (0, import_react12.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = {
      onStateChanged: () => {
        forceUpdate((value) => value + 1);
      },
      onStepStartedEvent: ({ event }) => {
        if (event.stepName !== nodeName) {
          setNodeName(event.stepName);
        }
      },
      onStepFinishedEvent: ({ event }) => {
        if (event.stepName === nodeName) {
          setNodeName(void 0);
        }
      }
    };
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agentId, nodeName]);
  const getStateRender = (0, import_react12.useCallback)(
    (messageId) => {
      return Object.entries(coAgentStateRenders).find(([stateRenderId2, stateRender2]) => {
        if (claimsRef.current[messageId]) {
          return stateRenderId2 === claimsRef.current[messageId].stateRenderId;
        }
        const matchingAgentName = stateRender2.name === agentId;
        const matchesNodeContext = stateRender2.nodeName ? stateRender2.nodeName === nodeName : true;
        return matchingAgentName && matchesNodeContext;
      });
    },
    [coAgentStateRenders, nodeName, agentId]
  );
  const stateRenderEntry = (0, import_react12.useMemo)(() => getStateRender(message.id), [getStateRender, message.id]);
  const stateRenderId = stateRenderEntry == null ? void 0 : stateRenderEntry[0];
  const stateRender = stateRenderEntry == null ? void 0 : stateRenderEntry[1];
  const registryMessage = __spreadProps(__spreadValues({}, message), {
    runId: (_a = props.runId) != null ? _a : message.runId
  });
  const { canRender } = useStateRenderRegistry({
    agentId,
    stateRenderId,
    message: registryMessage,
    messageIndex: props.messageIndex,
    stateSnapshot,
    agentState: agent == null ? void 0 : agent.state,
    agentMessages: agent == null ? void 0 : agent.messages,
    claimsRef
  });
  return (0, import_react12.useMemo)(() => {
    var _a2, _b;
    if (!stateRender || !stateRenderId) {
      return null;
    }
    if (!canRender) {
      return null;
    }
    if (stateRender.handler) {
      stateRender.handler({
        state: stateSnapshot ? (0, import_shared10.parseJson)(stateSnapshot, stateSnapshot) : (_a2 = agent == null ? void 0 : agent.state) != null ? _a2 : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
    if (stateRender.render) {
      const status = (agent == null ? void 0 : agent.isRunning) ? "inProgress" /* InProgress */ : "complete" /* Complete */;
      if (typeof stateRender.render === "string")
        return stateRender.render;
      return stateRender.render({
        status,
        // Always use state from claim, to make sure the state does not seem "wiped" for a fraction of a second
        state: (_b = claimsRef.current[message.id].stateSnapshot) != null ? _b : {},
        nodeName: nodeName != null ? nodeName : ""
      });
    }
  }, [
    stateRender,
    stateRenderId,
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.isRunning,
    nodeName,
    message.id,
    stateSnapshot,
    canRender
  ]);
}
function CoAgentStateRenderBridge(props) {
  return useCoagentStateRenderBridge(props.agentId, props);
}

// src/components/CopilotListeners.tsx
var import_react13 = require("react");
var import_react14 = require("@copilotkitnext/react");
var import_shared11 = require("@copilotkit/shared");
var import_shared12 = require("@copilotkit/shared");
var usePredictStateSubscription = (agent) => {
  const predictStateToolsRef = (0, import_react13.useRef)([]);
  const getSubscriber = (0, import_react13.useCallback)(
    (agent2) => ({
      onCustomEvent: ({ event }) => {
        if (event.name === "PredictState") {
          predictStateToolsRef.current = event.value;
        }
      },
      onToolCallArgsEvent: ({ partialToolCallArgs, toolCallName }) => {
        predictStateToolsRef.current.forEach((t) => {
          if ((t == null ? void 0 : t.tool) !== toolCallName)
            return;
          const emittedState = typeof partialToolCallArgs === "string" ? (0, import_shared11.parseJson)(partialToolCallArgs, partialToolCallArgs) : partialToolCallArgs;
          agent2.setState({
            [t.state_key]: emittedState[t.state_key]
          });
        });
      }
    }),
    []
  );
  (0, import_react13.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = getSubscriber(agent);
    const { unsubscribe } = agent.subscribe(subscriber);
    return () => {
      unsubscribe();
    };
  }, [agent, getSubscriber]);
};
function CopilotListeners() {
  const { copilotkit } = (0, import_react14.useCopilotKit)();
  const existingConfig = (0, import_react14.useCopilotChatConfiguration)();
  const resolvedAgentId = existingConfig == null ? void 0 : existingConfig.agentId;
  const { setBannerError } = useToast();
  const { agent } = (0, import_react14.useAgent)({ agentId: resolvedAgentId });
  usePredictStateSubscription(agent);
  (0, import_react13.useEffect)(() => {
    const subscriber = {
      onError: ({ error }) => {
        setBannerError(new import_shared12.CopilotKitLowLevelError({ error, message: error.message }));
      }
    };
    const subscription = copilotkit.subscribe(subscriber);
    return () => {
      subscription.unsubscribe();
    };
  }, [copilotkit == null ? void 0 : copilotkit.subscribe]);
  return null;
}

// src/components/copilot-provider/copilotkit.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
function CopilotKit(_a) {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const enabled = shouldShowDevConsole(props.showDevConsole);
  const showInspector = shouldShowDevConsole(props.enableInspector);
  const publicApiKey = props.publicApiKey || props.publicLicenseKey;
  const renderArr = (0, import_react15.useMemo)(() => [{ render: CoAgentStateRenderBridge }], []);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ToastProvider, { enabled, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CopilotErrorBoundary, { publicApiKey, showUsageBanner: enabled, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ThreadsProvider, { threadId: props.threadId, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    import_react16.CopilotKitProvider,
    __spreadProps(__spreadValues({}, props), {
      showDevConsole: showInspector,
      renderCustomMessages: renderArr,
      useSingleEndpoint: true,
      children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CopilotKitInternal, __spreadProps(__spreadValues({}, props), { children }))
    })
  ) }) }) });
}
function CopilotKitErrorBridge() {
  const { copilotkit } = (0, import_react16.useCopilotKit)();
  const { onError, copilotApiConfig } = useCopilotContext();
  (0, import_react15.useEffect)(() => {
    if (!copilotkit)
      return;
    const subscription = copilotkit.subscribe({
      onError: (event) => __async(this, null, function* () {
        const errorEvent = {
          type: "error",
          timestamp: Date.now(),
          context: __spreadValues({
            source: "agent",
            request: {
              operation: event.code || "unknown",
              url: copilotApiConfig == null ? void 0 : copilotApiConfig.chatApiEndpoint,
              startTime: Date.now()
            },
            technical: {
              environment: "browser",
              userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
              stackTrace: event.error.stack
            }
          }, event.context),
          error: event.error
        };
        try {
          yield onError(errorEvent);
        } catch (handlerError) {
          console.error("Error in onError handler:", handlerError);
        }
      })
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [copilotkit, onError, copilotApiConfig]);
  return null;
}
function CopilotKitInternal(cpkProps) {
  var _b;
  const _a = cpkProps, { children } = _a, props = __objRest(_a, ["children"]);
  validateProps(cpkProps);
  const publicApiKey = props.publicLicenseKey || props.publicApiKey;
  const chatApiEndpoint = props.runtimeUrl || import_shared13.COPILOT_CLOUD_CHAT_URL;
  const [actions, setActions] = (0, import_react15.useState)({});
  const [registeredActionConfigs, setRegisteredActionConfigs] = (0, import_react15.useState)(/* @__PURE__ */ new Map());
  const chatComponentsCache = (0, import_react15.useRef)({
    actions: {},
    coAgentStateRenders: {}
  });
  const { addElement, removeElement, printTree, getAllElements } = use_tree_default();
  const [isLoading, setIsLoading] = (0, import_react15.useState)(false);
  const [chatInstructions, setChatInstructions] = (0, import_react15.useState)("");
  const [authStates, setAuthStates] = (0, import_react15.useState)({});
  const [extensions, setExtensions] = (0, import_react15.useState)({});
  const [additionalInstructions, setAdditionalInstructions] = (0, import_react15.useState)([]);
  const {
    addElement: addDocument,
    removeElement: removeDocument,
    allElements: allDocuments
  } = use_flat_category_store_default();
  const setAction = (0, import_react15.useCallback)((id, action) => {
    setActions((prevPoints) => {
      return __spreadProps(__spreadValues({}, prevPoints), {
        [id]: action
      });
    });
  }, []);
  const removeAction = (0, import_react15.useCallback)((id) => {
    setActions((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const getContextString = (0, import_react15.useCallback)(
    (documents, categories) => {
      const documentsString = documents.map((document) => {
        return `${document.name} (${document.sourceApplication}):
${document.getContents()}`;
      }).join("\n\n");
      const nonDocumentStrings = printTree(categories);
      return `${documentsString}

${nonDocumentStrings}`;
    },
    [printTree]
  );
  const addContext = (0, import_react15.useCallback)(
    (context, parentId, categories = defaultCopilotContextCategories) => {
      return addElement(context, categories, parentId);
    },
    [addElement]
  );
  const removeContext = (0, import_react15.useCallback)(
    (id) => {
      removeElement(id);
    },
    [removeElement]
  );
  const getAllContext = (0, import_react15.useCallback)(() => {
    return getAllElements();
  }, [getAllElements]);
  const getFunctionCallHandler = (0, import_react15.useCallback)(
    (customEntryPoints) => {
      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));
    },
    [actions]
  );
  const getDocumentsContext = (0, import_react15.useCallback)(
    (categories) => {
      return allDocuments(categories);
    },
    [allDocuments]
  );
  const addDocumentContext = (0, import_react15.useCallback)(
    (documentPointer, categories = defaultCopilotContextCategories) => {
      return addDocument(documentPointer, categories);
    },
    [addDocument]
  );
  const removeDocumentContext = (0, import_react15.useCallback)(
    (documentId) => {
      removeDocument(documentId);
    },
    [removeDocument]
  );
  const copilotApiConfig = (0, import_react15.useMemo)(() => {
    var _a2, _b2;
    let cloud = void 0;
    if (publicApiKey) {
      cloud = {
        guardrails: {
          input: {
            restrictToTopic: {
              enabled: Boolean(props.guardrails_c),
              validTopics: ((_a2 = props.guardrails_c) == null ? void 0 : _a2.validTopics) || [],
              invalidTopics: ((_b2 = props.guardrails_c) == null ? void 0 : _b2.invalidTopics) || []
            }
          }
        }
      };
    }
    return __spreadProps(__spreadValues({
      publicApiKey
    }, cloud ? { cloud } : {}), {
      chatApiEndpoint,
      headers: props.headers || {},
      properties: props.properties || {},
      transcribeAudioUrl: props.transcribeAudioUrl,
      textToSpeechUrl: props.textToSpeechUrl,
      credentials: props.credentials
    });
  }, [
    publicApiKey,
    props.headers,
    props.properties,
    props.transcribeAudioUrl,
    props.textToSpeechUrl,
    props.credentials,
    props.cloudRestrictToTopic,
    props.guardrails_c
  ]);
  const headers = (0, import_react15.useMemo)(() => {
    const authHeaders = Object.values(authStates || {}).reduce((acc, state) => {
      if (state.status === "authenticated" && state.authHeaders) {
        return __spreadValues(__spreadValues({}, acc), Object.entries(state.authHeaders).reduce(
          (headers2, [key, value]) => __spreadProps(__spreadValues({}, headers2), {
            [key.startsWith("X-Custom-") ? key : `X-Custom-${key}`]: value
          }),
          {}
        ));
      }
      return acc;
    }, {});
    return __spreadValues(__spreadValues(__spreadValues({}, copilotApiConfig.headers || {}), copilotApiConfig.publicApiKey ? { [import_shared13.COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: copilotApiConfig.publicApiKey } : {}), authHeaders);
  }, [copilotApiConfig.headers, copilotApiConfig.publicApiKey, authStates]);
  const [internalErrorHandlers, _setInternalErrorHandler] = (0, import_react15.useState)({});
  const setInternalErrorHandler = (0, import_react15.useCallback)((handler) => {
    _setInternalErrorHandler((prev) => __spreadValues(__spreadValues({}, prev), handler));
  }, []);
  const removeInternalErrorHandler = (0, import_react15.useCallback)((key) => {
    _setInternalErrorHandler((prev) => {
      const _a2 = prev, { [key]: _removed } = _a2, rest = __objRest(_a2, [__restKey(key)]);
      return rest;
    });
  }, []);
  const onErrorRef = (0, import_react15.useRef)(props.onError);
  (0, import_react15.useEffect)(() => {
    onErrorRef.current = props.onError;
  }, [props.onError]);
  const internalHandlersRef = (0, import_react15.useRef)({});
  (0, import_react15.useEffect)(() => {
    internalHandlersRef.current = internalErrorHandlers;
  }, [internalErrorHandlers]);
  const handleErrors = (0, import_react15.useCallback)(
    (error) => __async(this, null, function* () {
      if (copilotApiConfig.publicApiKey && onErrorRef.current) {
        try {
          yield onErrorRef.current(error);
        } catch (e) {
          console.error("Error in public onError handler:", e);
        }
      }
      const handlers = Object.values(internalHandlersRef.current);
      yield Promise.all(
        handlers.map(
          (h) => Promise.resolve(h(error)).catch(
            (e) => console.error("Error in internal error handler:", e)
          )
        )
      );
    }),
    [copilotApiConfig.publicApiKey]
  );
  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = (0, import_react15.useState)({});
  const addChatSuggestionConfiguration = (0, import_react15.useCallback)(
    (id, suggestion) => {
      setChatSuggestionConfiguration((prev) => __spreadProps(__spreadValues({}, prev), { [id]: suggestion }));
    },
    [setChatSuggestionConfiguration]
  );
  const removeChatSuggestionConfiguration = (0, import_react15.useCallback)(
    (id) => {
      setChatSuggestionConfiguration((prev) => {
        const _a2 = prev, { [id]: _ } = _a2, rest = __objRest(_a2, [__restKey(id)]);
        return rest;
      });
    },
    [setChatSuggestionConfiguration]
  );
  const [availableAgents, setAvailableAgents] = (0, import_react15.useState)([]);
  const [coagentStates, setCoagentStates] = (0, import_react15.useState)({});
  const coagentStatesRef = (0, import_react15.useRef)({});
  const setCoagentStatesWithRef = (0, import_react15.useCallback)(
    (value) => {
      const newValue = typeof value === "function" ? value(coagentStatesRef.current) : value;
      coagentStatesRef.current = newValue;
      setCoagentStates((prev) => {
        return newValue;
      });
    },
    []
  );
  let initialAgentSession = null;
  if (props.agent) {
    initialAgentSession = {
      agentName: props.agent
    };
  }
  const [agentSession, setAgentSession] = (0, import_react15.useState)(initialAgentSession);
  (0, import_react15.useEffect)(() => {
    if (props.agent) {
      setAgentSession({
        agentName: props.agent
      });
    } else {
      setAgentSession(null);
    }
  }, [props.agent]);
  const { threadId, setThreadId: setInternalThreadId } = useThreads();
  const setThreadId = (0, import_react15.useCallback)(
    (value) => {
      if (props.threadId) {
        throw new Error("Cannot call setThreadId() when threadId is provided via props.");
      }
      setInternalThreadId(value);
    },
    [props.threadId]
  );
  const [runId, setRunId] = (0, import_react15.useState)(null);
  const chatAbortControllerRef = (0, import_react15.useRef)(null);
  const showDevConsole = shouldShowDevConsole(props.showDevConsole);
  const [interruptActions, _setInterruptActions] = (0, import_react15.useState)({});
  const setInterruptAction = (0, import_react15.useCallback)((action) => {
    _setInterruptActions((prev) => {
      var _a2;
      if (action == null || !action.id) {
        return prev;
      }
      return __spreadProps(__spreadValues({}, prev), {
        [action.id]: __spreadValues(__spreadValues({}, (_a2 = prev[action.id]) != null ? _a2 : {}), action)
      });
    });
  }, []);
  const removeInterruptAction = (0, import_react15.useCallback)((actionId) => {
    _setInterruptActions((prev) => {
      const _a2 = prev, { [actionId]: _ } = _a2, rest = __objRest(_a2, [__restKey(actionId)]);
      return rest;
    });
  }, []);
  const [interruptEventQueue, setInterruptEventQueue] = (0, import_react15.useState)({});
  const addInterruptEvent = (0, import_react15.useCallback)((queuedEvent) => {
    setInterruptEventQueue((prev) => {
      const threadQueue = prev[queuedEvent.threadId] || [];
      return __spreadProps(__spreadValues({}, prev), {
        [queuedEvent.threadId]: [...threadQueue, queuedEvent]
      });
    });
  }, []);
  const resolveInterruptEvent = (0, import_react15.useCallback)(
    (threadId2, eventId, response) => {
      setInterruptEventQueue((prev) => {
        const threadQueue = prev[threadId2] || [];
        return __spreadProps(__spreadValues({}, prev), {
          [threadId2]: threadQueue.map(
            (queuedEvent) => queuedEvent.eventId === eventId ? __spreadProps(__spreadValues({}, queuedEvent), { event: __spreadProps(__spreadValues({}, queuedEvent.event), { response }) }) : queuedEvent
          )
        });
      });
    },
    []
  );
  const memoizedChildren = (0, import_react15.useMemo)(() => children, [children]);
  const [bannerError, setBannerError] = (0, import_react15.useState)(null);
  const agentLock = (0, import_react15.useMemo)(() => {
    var _a2;
    return (_a2 = props.agent) != null ? _a2 : null;
  }, [props.agent]);
  const forwardedParameters = (0, import_react15.useMemo)(
    () => {
      var _a2;
      return (_a2 = props.forwardedParameters) != null ? _a2 : {};
    },
    [props.forwardedParameters]
  );
  const updateExtensions = (0, import_react15.useCallback)(
    (newExtensions) => {
      setExtensions((prev) => {
        const resolved = typeof newExtensions === "function" ? newExtensions(prev) : newExtensions;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value]) => prev[key] === value);
        return isEqual ? prev : resolved;
      });
    },
    [setExtensions]
  );
  const updateAuthStates = (0, import_react15.useCallback)(
    (newAuthStates) => {
      setAuthStates((prev) => {
        const resolved = typeof newAuthStates === "function" ? newAuthStates(prev) : newAuthStates;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value]) => prev[key] === value);
        return isEqual ? prev : resolved;
      });
    },
    [setAuthStates]
  );
  const handleSetRegisteredActions = (0, import_react15.useCallback)((actionConfig) => {
    const key = actionConfig.action.name || (0, import_shared13.randomUUID)();
    setRegisteredActionConfigs((prev) => {
      const newMap = new Map(prev);
      newMap.set(key, actionConfig);
      return newMap;
    });
    return key;
  }, []);
  const handleRemoveRegisteredAction = (0, import_react15.useCallback)((actionKey) => {
    setRegisteredActionConfigs((prev) => {
      const newMap = new Map(prev);
      newMap.delete(actionKey);
      return newMap;
    });
  }, []);
  const RegisteredActionsRenderer = (0, import_react15.useMemo)(() => {
    return () => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: Array.from(registeredActionConfigs.entries()).map(([key, config]) => {
      const Component = config.component;
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Component, { action: config.action }, key);
    }) });
  }, [registeredActionConfigs]);
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    import_react16.CopilotChatConfigurationProvider,
    {
      agentId: (_b = props.agent) != null ? _b : "default",
      threadId,
      children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
        CopilotContext.Provider,
        {
          value: {
            actions,
            chatComponentsCache,
            getFunctionCallHandler,
            setAction,
            removeAction,
            setRegisteredActions: handleSetRegisteredActions,
            removeRegisteredAction: handleRemoveRegisteredAction,
            getContextString,
            addContext,
            removeContext,
            getAllContext,
            getDocumentsContext,
            addDocumentContext,
            removeDocumentContext,
            copilotApiConfig,
            isLoading,
            setIsLoading,
            chatSuggestionConfiguration,
            addChatSuggestionConfiguration,
            removeChatSuggestionConfiguration,
            chatInstructions,
            setChatInstructions,
            additionalInstructions,
            setAdditionalInstructions,
            showDevConsole,
            coagentStates,
            setCoagentStates,
            coagentStatesRef,
            setCoagentStatesWithRef,
            agentSession,
            setAgentSession,
            forwardedParameters,
            agentLock,
            threadId,
            setThreadId,
            runId,
            setRunId,
            chatAbortControllerRef,
            availableAgents,
            authConfig_c: props.authConfig_c,
            authStates_c: authStates,
            setAuthStates_c: updateAuthStates,
            extensions,
            setExtensions: updateExtensions,
            interruptActions,
            setInterruptAction,
            removeInterruptAction,
            interruptEventQueue,
            addInterruptEvent,
            resolveInterruptEvent,
            bannerError,
            setBannerError,
            onError: handleErrors,
            internalErrorHandlers,
            setInternalErrorHandler,
            removeInternalErrorHandler
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CopilotListeners, {}),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(CopilotKitErrorBridge, {}),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(CoAgentStateRendersProvider, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(MessagesTapProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(CopilotMessages, { children: [
                memoizedChildren,
                /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(RegisteredActionsRenderer, {})
              ] }) }),
              bannerError && showDevConsole && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                UsageBanner,
                {
                  severity: bannerError.severity,
                  message: bannerError.message,
                  onClose: () => setBannerError(null),
                  actions: getErrorActions(bannerError)
                }
              )
            ] })
          ]
        }
      )
    }
  );
}
var defaultCopilotContextCategories = ["global"];
function entryPointsToFunctionCallHandler(actions) {
  return (_0) => __async(this, [_0], function* ({ name, args }) {
    let actionsByFunctionName = {};
    for (let action2 of actions) {
      actionsByFunctionName[action2.name] = action2;
    }
    const action = actionsByFunctionName[name];
    let result = void 0;
    if (action) {
      yield new Promise((resolve, reject) => {
        (0, import_react_dom.flushSync)(() => __async(this, null, function* () {
          var _a;
          try {
            result = yield (_a = action.handler) == null ? void 0 : _a.call(action, args);
            resolve();
          } catch (error) {
            reject(error);
          }
        }));
      });
      yield new Promise((resolve) => setTimeout(resolve, 20));
    }
    return result;
  });
}
function formatFeatureName(featureName) {
  return featureName.replace(/_c$/, "").split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
}
function validateProps(props) {
  const cloudFeatures = Object.keys(props).filter((key) => key.endsWith("_c"));
  const hasApiKey = props.publicApiKey || props.publicLicenseKey;
  if (!props.runtimeUrl && !hasApiKey) {
    throw new import_shared13.ConfigurationError(
      "Missing required prop: 'runtimeUrl' or 'publicApiKey' or 'publicLicenseKey'"
    );
  }
  if (cloudFeatures.length > 0 && !hasApiKey) {
    throw new import_shared13.MissingPublicApiKeyError(
      `Missing required prop: 'publicApiKey' or 'publicLicenseKey' to use cloud features: ${cloudFeatures.map(formatFeatureName).join(", ")}`
    );
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CopilotKit,
  defaultCopilotContextCategories
});
//# sourceMappingURL=index.js.map