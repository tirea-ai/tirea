declare enum RenderStatus {
    InProgress = "inProgress",
    Complete = "complete"
}
declare enum ClaimAction {
    Create = "create",
    Override = "override",
    Existing = "existing",
    Block = "block"
}
interface StateRenderContext {
    agentId: string;
    stateRenderId: string;
    messageId: string;
    runId: string;
    messageIndex?: number;
}
interface Claim {
    stateRenderId: string;
    runId?: string;
    stateSnapshot?: any;
    locked?: boolean;
    messageIndex?: number;
}
type ClaimsByMessageId = Record<string, Claim>;
interface ClaimResolution {
    canRender: boolean;
    action: ClaimAction;
    nextClaim?: Claim;
    lockOthers?: boolean;
    updateRunId?: string;
}
interface SnapshotCaches {
    byStateRenderAndRun: Record<string, any>;
    byMessageId: Record<string, any>;
}
interface SnapshotSelectionInput {
    messageId: string;
    messageName?: string;
    allowLiveState?: boolean;
    skipLatestCache?: boolean;
    stateRenderId?: string;
    effectiveRunId: string;
    stateSnapshotProp?: any;
    agentState?: any;
    agentMessages?: Array<{
        id: string;
        role?: string;
    }>;
    existingClaim?: Claim;
    caches: SnapshotCaches;
}
interface SnapshotSelectionResult {
    snapshot?: any;
    hasSnapshotKeys: boolean;
    cachedSnapshot?: any;
    allowEmptySnapshot?: boolean;
    snapshotForClaim?: any;
}
declare function areStatesEquals(a: any, b: any): boolean;
declare function isPlaceholderMessageId(messageId: string | undefined): boolean;
declare function isPlaceholderMessageName(messageName: string | undefined): messageName is "coagent-state-render";
declare function readCachedMessageEntry(entry: any): {
    snapshot?: any;
    runId?: string;
};
declare function getEffectiveRunId({ existingClaimRunId, cachedMessageRunId, runId, }: {
    existingClaimRunId?: string;
    cachedMessageRunId?: string;
    runId?: string;
}): string;
/**
 * Resolve whether a message can claim a render slot.
 * This is a pure decision function; the caller applies claim mutations.
 */
declare function resolveClaim({ claims, context, stateSnapshot, }: {
    claims: ClaimsByMessageId;
    context: StateRenderContext;
    stateSnapshot?: any;
}): ClaimResolution;
/**
 * Select the best snapshot to render for this message.
 * Priority order is:
 * 1) explicit message snapshot
 * 2) live agent state (latest assistant only)
 * 3) cached snapshot for message
 * 4) cached snapshot for stateRenderId+runId
 * 5) last cached snapshot for stateRenderId
 */
declare function selectSnapshot({ messageId, messageName, allowLiveState, skipLatestCache, stateRenderId, effectiveRunId, stateSnapshotProp, agentState, agentMessages, existingClaim, caches, }: SnapshotSelectionInput): SnapshotSelectionResult;

export { Claim, ClaimAction, ClaimResolution, ClaimsByMessageId, RenderStatus, SnapshotCaches, SnapshotSelectionInput, SnapshotSelectionResult, StateRenderContext, areStatesEquals, getEffectiveRunId, isPlaceholderMessageId, isPlaceholderMessageName, readCachedMessageEntry, resolveClaim, selectSnapshot };
