"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/hooks/use-coagent.ts
var use_coagent_exports = {};
__export(use_coagent_exports, {
  useCoAgent: () => useCoAgent
});
module.exports = __toCommonJS(use_coagent_exports);
var import_react3 = require("react");
var import_react4 = require("@copilotkitnext/react");

// src/hooks/use-agent-nodename.ts
var import_react = require("react");
var import_react2 = require("@copilotkitnext/react");
function useAgentNodeName(agentName) {
  const { agent } = (0, import_react2.useAgent)({ agentId: agentName });
  const nodeNameRef = (0, import_react.useRef)("start");
  (0, import_react.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = {
      onStepStartedEvent: ({ event }) => {
        nodeNameRef.current = event.stepName;
      },
      onRunStartedEvent: () => {
        nodeNameRef.current = "start";
      },
      onRunFinishedEvent: () => {
        nodeNameRef.current = "end";
      }
    };
    const subscription = agent.subscribe(subscriber);
    return () => {
      subscription.unsubscribe();
    };
  }, [agent]);
  return nodeNameRef.current;
}

// src/hooks/use-coagent.ts
function useCoAgent(options) {
  const { agent } = (0, import_react4.useAgent)({ agentId: options.name });
  const { copilotkit } = (0, import_react4.useCopilotKit)();
  const nodeName = useAgentNodeName(options.name);
  const handleStateUpdate = (0, import_react3.useCallback)(
    (newState) => {
      if (!agent)
        return;
      if (typeof newState === "function") {
        const updater = newState;
        agent.setState(updater(agent.state));
      } else {
        agent.setState(__spreadValues(__spreadValues({}, agent.state), newState));
      }
    },
    [agent == null ? void 0 : agent.state, agent == null ? void 0 : agent.setState]
  );
  (0, import_react3.useEffect)(() => {
    var _a;
    if (!options.config && !options.configurable)
      return;
    let config = (_a = options.config) != null ? _a : {};
    if (options.configurable) {
      config = __spreadProps(__spreadValues({}, config), {
        configurable: __spreadValues(__spreadValues({}, options.configurable), config.configurable)
      });
    }
    copilotkit.setProperties(config);
  }, [options.config, options.configurable]);
  const externalStateStr = (0, import_react3.useMemo)(
    () => isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0,
    [isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0]
  );
  (0, import_react3.useEffect)(() => {
    if ((agent == null ? void 0 : agent.state) && isExternalStateManagement(options) && JSON.stringify(options.state) !== JSON.stringify(agent.state)) {
      handleStateUpdate(options.state);
    }
  }, [agent, externalStateStr, handleStateUpdate]);
  const hasStateValues = (0, import_react3.useCallback)((value) => {
    return Boolean(value && Object.keys(value).length);
  }, []);
  const initialStateRef = (0, import_react3.useRef)(
    isExternalStateManagement(options) ? options.state : "initialState" in options ? options.initialState : void 0
  );
  (0, import_react3.useEffect)(() => {
    if (isExternalStateManagement(options)) {
      initialStateRef.current = options.state;
    } else if ("initialState" in options) {
      initialStateRef.current = options.initialState;
    }
  }, [
    isExternalStateManagement(options) ? JSON.stringify(options.state) : "initialState" in options ? JSON.stringify(options.initialState) : void 0
  ]);
  (0, import_react3.useEffect)(() => {
    if (!agent)
      return;
    const subscriber = {
      onStateChanged: (args) => {
        if (isExternalStateManagement(options)) {
          options.setState(args.state);
        }
      },
      onRunInitialized: (args) => {
        const runHasState = hasStateValues(args.state);
        if (runHasState) {
          handleStateUpdate(args.state);
          return;
        }
        if (hasStateValues(agent.state)) {
          return;
        }
        if (initialStateRef.current !== void 0) {
          handleStateUpdate(initialStateRef.current);
        }
      }
    };
    const subscription = agent.subscribe(subscriber);
    return () => {
      subscription.unsubscribe();
    };
  }, [agent, handleStateUpdate, hasStateValues]);
  return (0, import_react3.useMemo)(() => {
    var _a, _b, _c;
    if (!agent) {
      const noop = () => {
      };
      const noopAsync = () => __async(this, null, function* () {
      });
      const initialState = (
        // prefer externally provided state if available
        (_b = (_a = "state" in options && options.state) != null ? _a : (
          // then initialState if provided
          "initialState" in options && options.initialState
        )) != null ? _b : {}
      );
      return {
        name: options.name,
        nodeName,
        threadId: void 0,
        running: false,
        state: initialState,
        setState: noop,
        start: noop,
        stop: noop,
        run: noopAsync
      };
    }
    return {
      name: (_c = agent == null ? void 0 : agent.agentId) != null ? _c : options.name,
      nodeName,
      threadId: agent.threadId,
      running: agent.isRunning,
      state: agent.state,
      setState: handleStateUpdate,
      // TODO: start and run both have same thing. need to figure out
      start: agent.runAgent,
      stop: agent.abortRun,
      run: agent.runAgent
    };
  }, [
    agent == null ? void 0 : agent.state,
    agent == null ? void 0 : agent.runAgent,
    agent == null ? void 0 : agent.abortRun,
    agent == null ? void 0 : agent.runAgent,
    agent == null ? void 0 : agent.threadId,
    agent == null ? void 0 : agent.isRunning,
    agent == null ? void 0 : agent.agentId,
    handleStateUpdate,
    options.name
  ]);
}
var isExternalStateManagement = (options) => {
  return "state" in options && "setState" in options;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useCoAgent
});
//# sourceMappingURL=use-coagent.js.map