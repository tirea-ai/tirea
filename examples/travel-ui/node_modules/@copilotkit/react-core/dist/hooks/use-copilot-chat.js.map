{"version":3,"sources":["../../src/hooks/use-copilot-chat.ts","../../src/hooks/use-copilot-chat_internal.ts","../../src/context/copilot-context.tsx","../../src/components/error-boundary/error-utils.tsx","../../src/components/toast/toast-provider.tsx","../../src/components/toast/exclamation-mark-icon.tsx","../../src/context/coagent-state-renders-context.tsx","../../src/hooks/use-langgraph-interrupt-render.ts","../../src/hooks/use-agent-nodename.ts","../../src/hooks/use-lazy-tool-renderer.tsx","../../src/hooks/use-coagent-state-render-bridge.tsx","../../src/hooks/use-coagent-state-render-bridge.helpers.ts","../../src/hooks/use-coagent-state-render-registry.ts"],"sourcesContent":["/**\n * `useCopilotChat` is a lightweight React hook for headless chat interactions.\n * Perfect for controlling the prebuilt chat components programmatically.\n *\n * **Open Source Friendly** - Works without requiring a free public license key.\n *\n * <Callout title=\"Looking for fully headless UI?\">\n * Get started with [useCopilotChatHeadless_c](https://docs.copilotkit.ai/reference/hooks/useCopilotChatHeadless_c).\n * </Callout>\n *\n * ## Use Cases\n *\n * - **Programmatic Messaging**: Send messages without displaying chat UI\n * - **Programmatic control**: Control prebuilt component programmatically\n * - **Background Operations**: Trigger AI interactions in the background\n * - **Fire-and-Forget**: Send messages without needing to read responses\n *\n * ## Usage\n *\n * ```tsx\n * import { TextMessage, MessageRole } from \"@copilotkit/runtime-client-gql\";\n *\n * const { appendMessage } = useCopilotChat();\n *\n * // Example usage without naming conflicts\n * const handleSendMessage = async (content: string) => {\n *   await appendMessage(\n *     new TextMessage({\n *       role: MessageRole.User,\n *       content,\n *     })\n *   );\n * };\n * ```\n *\n * ## Return Values\n * The following properties are returned from the hook:\n *\n * <PropertyReference name=\"visibleMessages\" type=\"DeprecatedGqlMessage[]\" deprecated>\n * Array of messages in old non-AG-UI format, use for compatibility only\n * </PropertyReference>\n *\n * <PropertyReference name=\"appendMessage\" type=\"(message: DeprecatedGqlMessage, options?) => Promise<void>\" deprecated>\n * Append message using old format, use `sendMessage` instead\n * </PropertyReference>\n *\n * <PropertyReference name=\"reloadMessages\" type=\"(messageId: string) => Promise<void>\">\n * Regenerate the response for a specific message by ID\n * </PropertyReference>\n *\n * <PropertyReference name=\"stopGeneration\" type=\"() => void\">\n * Stop the current message generation process\n * </PropertyReference>\n *\n * <PropertyReference name=\"reset\" type=\"() => void\">\n * Clear all messages and reset chat state completely\n * </PropertyReference>\n *\n * <PropertyReference name=\"isLoading\" type=\"boolean\">\n * Whether the chat is currently generating a response\n * </PropertyReference>\n *\n * <PropertyReference name=\"runChatCompletion\" type=\"() => Promise<Message[]>\">\n * Manually trigger chat completion for advanced usage\n * </PropertyReference>\n *\n * <PropertyReference name=\"mcpServers\" type=\"MCPServerConfig[]\">\n * Array of Model Context Protocol server configurations\n * </PropertyReference>\n *\n * <PropertyReference name=\"setMcpServers\" type=\"(servers: MCPServerConfig[]) => void\">\n * Update MCP server configurations for enhanced context\n * </PropertyReference>\n */\n\nimport {\n  UseCopilotChatOptions,\n  useCopilotChatInternal,\n  UseCopilotChatReturn as UseCopilotChatReturnInternal,\n} from \"./use-copilot-chat_internal\";\n\n// Create a type that excludes message-related properties from the internal type\nexport type UseCopilotChatReturn = Omit<\n  UseCopilotChatReturnInternal,\n  | \"messages\"\n  | \"sendMessage\"\n  | \"suggestions\"\n  | \"setSuggestions\"\n  | \"generateSuggestions\"\n  | \"isLoadingSuggestions\"\n  | \"resetSuggestions\"\n  | \"interrupt\"\n  | \"setMessages\"\n  | \"deleteMessage\"\n>;\n\n/**\n * A lightweight React hook for headless chat interactions.\n * Perfect for programmatic messaging, background operations, and custom UI implementations.\n *\n * **Open Source Friendly** - Works without requiring a `publicApiKey`.\n */\n// TODO: Do we need this? If so, does it work properly? test.\nexport function useCopilotChat(options: UseCopilotChatOptions = {}): UseCopilotChatReturn {\n  const {\n    visibleMessages,\n    appendMessage,\n    reloadMessages,\n    stopGeneration,\n    reset,\n    isLoading,\n    isAvailable,\n    runChatCompletion,\n    mcpServers,\n    setMcpServers,\n  } = useCopilotChatInternal(options);\n\n  return {\n    visibleMessages,\n    appendMessage,\n    reloadMessages,\n    stopGeneration,\n    reset,\n    isLoading,\n    isAvailable,\n    runChatCompletion,\n    mcpServers,\n    setMcpServers,\n  };\n}\n","import { useRef, useEffect, useCallback, useMemo, useState, createElement } from \"react\";\nimport { useCopilotContext } from \"../context/copilot-context\";\nimport { SystemMessageFunction } from \"../types\";\nimport { useAsyncCallback } from \"../components/error-boundary/error-utils\";\nimport { Message } from \"@copilotkit/shared\";\nimport { gqlToAGUI, Message as DeprecatedGqlMessage } from \"@copilotkit/runtime-client-gql\";\nimport { useLangGraphInterruptRender } from \"./use-langgraph-interrupt-render\";\nimport {\n  useAgent,\n  useCopilotChatConfiguration,\n  useCopilotKit,\n  useRenderCustomMessages,\n  useSuggestions,\n} from \"@copilotkitnext/react\";\nimport { Suggestion } from \"@copilotkitnext/core\";\nimport { useLazyToolRenderer } from \"./use-lazy-tool-renderer\";\nimport { AbstractAgent, AGUIConnectNotImplementedError } from \"@ag-ui/client\";\nimport {\n  CoAgentStateRenderBridge,\n  type CoAgentStateRenderBridgeProps,\n} from \"./use-coagent-state-render-bridge\";\n\n/**\n * The type of suggestions to use in the chat.\n *\n * `auto` - Suggestions are generated automatically.\n * `manual` - Suggestions are controlled programmatically.\n * `SuggestionItem[]` - Static suggestions array.\n */\nexport type ChatSuggestions = \"auto\" | \"manual\" | Omit<Suggestion, \"isLoading\">[];\n\nexport interface AppendMessageOptions {\n  /**\n   * Whether to run the chat completion after appending the message. Defaults to `true`.\n   */\n  followUp?: boolean;\n  /**\n   * Whether to clear the suggestions after appending the message. Defaults to `true`.\n   */\n  clearSuggestions?: boolean;\n}\n\nexport interface OnStopGenerationArguments {\n  /**\n   * The name of the currently executing agent.\n   */\n  currentAgentName: string | undefined;\n\n  /**\n   * The messages in the chat.\n   */\n  messages: Message[];\n}\n\nexport type OnReloadMessagesArguments = OnStopGenerationArguments & {\n  /**\n   * The message on which \"regenerate\" was pressed\n   */\n  messageId: string;\n};\n\nexport type OnStopGeneration = (args: OnStopGenerationArguments) => void;\n\nexport type OnReloadMessages = (args: OnReloadMessagesArguments) => void;\n\nexport interface UseCopilotChatOptions {\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated. When provided, the `useChat` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n\n  /**\n   * Initial messages to populate the chat with.\n   */\n  initialMessages?: Message[];\n\n  /**\n   * A function to generate the system message. Defaults to `defaultSystemMessage`.\n   */\n  makeSystemMessage?: SystemMessageFunction;\n\n  /**\n   * Disables inclusion of CopilotKitâ€™s default system message. When true, no system message is sent (this also suppresses any custom message from <code>makeSystemMessage</code>).\n   */\n  disableSystemMessage?: boolean;\n  /**\n   * Controls the behavior of suggestions in the chat interface.\n   *\n   * `auto` (default) - Suggestions are generated automatically:\n   *   - When the chat is first opened (empty state)\n   *   - After each message exchange completes\n   *   - Uses configuration from `useCopilotChatSuggestions` hooks\n   *\n   * `manual` - Suggestions are controlled programmatically:\n   *   - Use `setSuggestions()` to set custom suggestions\n   *   - Use `generateSuggestions()` to trigger AI generation\n   *   - Access via `useCopilotChat` hook\n   *\n   * `SuggestionItem[]` - Static suggestions array:\n   *   - Always shows the same suggestions\n   *   - No AI generation involved\n   */\n  suggestions?: ChatSuggestions;\n\n  onInProgress?: (isLoading: boolean) => void;\n  onSubmitMessage?: (messageContent: string) => Promise<void> | void;\n  onStopGeneration?: OnStopGeneration;\n  onReloadMessages?: OnReloadMessages;\n}\n\nexport interface MCPServerConfig {\n  endpoint: string;\n  apiKey?: string;\n}\n\n// Old suggestion item interface, for returning from useCopilotChatInternal\ninterface SuggestionItem {\n  title: string;\n  message: string;\n  partial?: boolean;\n  className?: string;\n}\n\nexport interface UseCopilotChatReturn {\n  /**\n   * @deprecated use `messages` instead, this is an old non ag-ui version of the messages\n   * Array of messages currently visible in the chat interface\n   *\n   * This is the visible messages, not the raw messages from the runtime client.\n   */\n  visibleMessages: DeprecatedGqlMessage[];\n\n  /**\n   * The messages that are currently in the chat in AG-UI format.\n   */\n  messages: Message[];\n\n  /** @deprecated use `sendMessage` in `useCopilotChatHeadless_c` instead. This will be removed in a future major version. */\n  appendMessage: (message: DeprecatedGqlMessage, options?: AppendMessageOptions) => Promise<void>;\n\n  /**\n   * Send a new message to the chat\n   *\n   * ```tsx\n   * await sendMessage({\n   *   id: \"123\",\n   *   role: \"user\",\n   *   content: \"Hello, process this request\",\n   * });\n   * ```\n   */\n  sendMessage: (message: Message, options?: AppendMessageOptions) => Promise<void>;\n\n  /**\n   * Replace all messages in the chat\n   *\n   * ```tsx\n   * setMessages([\n   *   { id: \"123\", role: \"user\", content: \"Hello, process this request\" },\n   *   { id: \"456\", role: \"assistant\", content: \"Hello, I'm the assistant\" },\n   * ]);\n   * ```\n   *\n   * **Deprecated** non-ag-ui version:\n   *\n   * ```tsx\n   * setMessages([\n   *   new TextMessage({\n   *     content: \"Hello, process this request\",\n   *     role: gqlRole.User,\n   *   }),\n   *   new TextMessage({\n   *     content: \"Hello, I'm the assistant\",\n   *     role: gqlRole.Assistant,\n   * ]);\n   * ```\n   *\n   */\n  setMessages: (messages: Message[] | DeprecatedGqlMessage[]) => void;\n\n  /**\n   * Remove a specific message by ID\n   *\n   * ```tsx\n   * deleteMessage(\"123\");\n   * ```\n   */\n  deleteMessage: (messageId: string) => void;\n\n  /**\n   * Regenerate the response for a specific message\n   *\n   * ```tsx\n   * reloadMessages(\"123\");\n   * ```\n   */\n  reloadMessages: (messageId: string) => Promise<void>;\n\n  /**\n   * Stop the current message generation\n   *\n   * ```tsx\n   * if (isLoading) {\n   *   stopGeneration();\n   * }\n   * ```\n   */\n  stopGeneration: () => void;\n\n  /**\n   * Clear all messages and reset chat state\n   *\n   * ```tsx\n   * reset();\n   * console.log(messages); // []\n   * ```\n   */\n  reset: () => void;\n\n  /**\n   * Whether the chat is currently generating a response\n   *\n   * ```tsx\n   * if (isLoading) {\n   *   console.log(\"Loading...\");\n   * } else {\n   *   console.log(\"Not loading\");\n   * }\n   */\n  isLoading: boolean;\n\n  /**\n   * Whether the chat agent is available to generate responses\n   *\n   * ```tsx\n   * if (isAvailable) {\n   *   console.log(\"Loading...\");\n   * } else {\n   *   console.log(\"Not loading\");\n   * }\n   */\n  isAvailable: boolean;\n\n  /** Manually trigger chat completion (advanced usage) */\n  runChatCompletion: () => Promise<Message[]>;\n\n  /** MCP (Model Context Protocol) server configurations */\n  mcpServers: MCPServerConfig[];\n\n  /** Update MCP server configurations */\n  setMcpServers: (mcpServers: MCPServerConfig[]) => void;\n\n  /**\n   * Current suggestions array\n   * Use this to read the current suggestions or in conjunction with setSuggestions for manual control\n   */\n  suggestions: Suggestion[];\n\n  /**\n   * Manually set suggestions\n   * Useful for manual mode or custom suggestion workflows\n   */\n  setSuggestions: (suggestions: Omit<Suggestion, \"isLoading\">[]) => void;\n\n  /**\n   * Trigger AI-powered suggestion generation\n   * Uses configurations from useCopilotChatSuggestions hooks\n   * Respects global debouncing - only one generation can run at a time\n   *\n   * ```tsx\n   * generateSuggestions();\n   * console.log(suggestions); // [suggestion1, suggestion2, suggestion3]\n   * ```\n   */\n  generateSuggestions: () => Promise<void>;\n\n  /**\n   * Clear all current suggestions\n   * Also resets suggestion generation state\n   */\n  resetSuggestions: () => void;\n\n  /** Whether suggestions are currently being generated */\n  isLoadingSuggestions: boolean;\n\n  /** Interrupt content for human-in-the-loop workflows */\n  interrupt: string | React.ReactElement | null;\n\n  agent?: ReturnType<typeof useAgent>[\"agent\"];\n\n  threadId?: string;\n}\n\nexport function useCopilotChatInternal({\n  suggestions,\n  onInProgress,\n  onSubmitMessage,\n  onStopGeneration,\n  onReloadMessages,\n}: UseCopilotChatOptions = {}): UseCopilotChatReturn {\n  const { copilotkit } = useCopilotKit();\n  const { threadId, agentSession } = useCopilotContext();\n  const existingConfig = useCopilotChatConfiguration();\n  const [agentAvailable, setAgentAvailable] = useState(false);\n\n  // Apply priority: props > existing config > defaults\n  const resolvedAgentId = existingConfig?.agentId ?? \"default\";\n  const { agent } = useAgent({ agentId: resolvedAgentId });\n\n  useEffect(() => {\n    const connect = async (agent: AbstractAgent) => {\n      setAgentAvailable(false);\n      try {\n        await copilotkit.connectAgent({ agent });\n        setAgentAvailable(true);\n      } catch (error) {\n        if (error instanceof AGUIConnectNotImplementedError) {\n          // connect not implemented, ignore\n        } else {\n          console.error(\"CopilotChat: connectAgent failed\", error);\n          // Error will be reported through subscription\n        }\n      }\n    };\n    if (agent && existingConfig?.threadId && agent.threadId !== existingConfig.threadId) {\n      agent.threadId = existingConfig.threadId;\n      connect(agent);\n    }\n    return () => {};\n  }, [existingConfig?.threadId, agent, copilotkit, resolvedAgentId]);\n\n  useEffect(() => {\n    onInProgress?.(Boolean(agent?.isRunning));\n  }, [agent?.isRunning, onInProgress]);\n\n  const interrupt = useLangGraphInterruptRender(agent);\n\n  const reset = () => {\n    agent?.setMessages([]);\n    agent?.setState(null);\n  };\n\n  const deleteMessage = useCallback(\n    (messageId: string) => {\n      const filteredMessages = (agent?.messages ?? []).filter(\n        (message) => message.id !== messageId,\n      );\n      agent?.setMessages(filteredMessages);\n    },\n    [agent?.setMessages, agent?.messages],\n  );\n\n  const latestDelete = useUpdatedRef(deleteMessage);\n  const latestDeleteFunc = useCallback(\n    (messageId: string) => {\n      return latestDelete.current(messageId);\n    },\n    [latestDelete],\n  );\n\n  const currentSuggestions = useSuggestions({ agentId: resolvedAgentId });\n\n  const reload = useAsyncCallback(\n    async (reloadMessageId: string): Promise<void> => {\n      const messages = agent?.messages ?? [];\n      // TODO: get isLoading\n      const isLoading = false;\n      if (isLoading || messages.length === 0) {\n        return;\n      }\n\n      const reloadMessageIndex = messages.findIndex((msg) => msg.id === reloadMessageId);\n      if (reloadMessageIndex === -1) {\n        console.warn(`Message with id ${reloadMessageId} not found`);\n        return;\n      }\n\n      const reloadMessageRole = messages[reloadMessageIndex].role;\n      if (reloadMessageRole !== \"assistant\") {\n        console.warn(`Regenerate cannot be performed on ${reloadMessageRole} role`);\n        return;\n      }\n      let historyCutoff: Message[] = [messages[0]];\n\n      if (messages.length > 2 && reloadMessageIndex !== 0) {\n        // message to regenerate from is now first.\n        // Work backwards to find the first the closest user message\n        const lastUserMessageBeforeRegenerate = messages\n          .slice(0, reloadMessageIndex)\n          .reverse()\n          .find((msg) => msg.role === \"user\");\n\n        if (!lastUserMessageBeforeRegenerate) {\n          historyCutoff = [messages[0]];\n        } else {\n          const indexOfLastUserMessageBeforeRegenerate = messages.findIndex(\n            (msg) => msg.id === lastUserMessageBeforeRegenerate.id,\n          );\n          // Include the user message, remove everything after it\n          historyCutoff = messages.slice(0, indexOfLastUserMessageBeforeRegenerate + 1);\n        }\n      } else if (messages.length > 2 && reloadMessageIndex === 0) {\n        historyCutoff = [messages[0], messages[1]];\n      }\n\n      agent?.setMessages(historyCutoff);\n\n      if (agent) {\n        try {\n          await copilotkit.runAgent({ agent });\n        } catch (error) {\n          console.error(\"CopilotChat: runAgent failed during reload\", error);\n          // Error will be reported through subscription\n        }\n      }\n      return;\n    },\n    [agent?.setMessages, copilotkit?.runAgent],\n  );\n\n  const latestSendMessageFunc = useAsyncCallback(\n    async (message: Message, options?: AppendMessageOptions) => {\n      if (!agent) return;\n      const followUp = options?.followUp ?? true;\n      if (options?.clearSuggestions) {\n        copilotkit.clearSuggestions(resolvedAgentId);\n      }\n\n      // Call onSubmitMessage BEFORE adding message and running agent\n      // This allows users to perform actions (e.g., open chat window) before agent starts processing\n      if (onSubmitMessage) {\n        const content =\n          typeof message.content === \"string\"\n            ? message.content\n            : message.content && \"text\" in message.content\n              ? message.content.text\n              : message.content && \"filename\" in message.content\n                ? message.content.filename\n                : \"\";\n        try {\n          await onSubmitMessage(content);\n        } catch (error) {\n          console.error(\"Error in onSubmitMessage:\", error);\n        }\n      }\n\n      agent?.addMessage(message);\n      if (followUp) {\n        try {\n          await copilotkit.runAgent({ agent });\n        } catch (error) {\n          console.error(\"CopilotChat: runAgent failed\", error);\n          // Error will be reported through subscription\n        }\n      }\n    },\n    [agent, copilotkit, resolvedAgentId, onSubmitMessage],\n  );\n\n  const latestAppendFunc = useAsyncCallback(\n    async (message: DeprecatedGqlMessage, options?: AppendMessageOptions) => {\n      return latestSendMessageFunc(gqlToAGUI([message])[0], options);\n    },\n    [latestSendMessageFunc],\n  );\n\n  const latestSetMessagesFunc = useCallback(\n    (messages: Message[] | DeprecatedGqlMessage[]) => {\n      if (messages.every((message) => message instanceof DeprecatedGqlMessage)) {\n        return agent?.setMessages?.(gqlToAGUI(messages));\n      }\n      return agent?.setMessages?.(messages);\n    },\n    [agent?.setMessages, agent],\n  );\n\n  const latestReload = useUpdatedRef(reload);\n  const latestReloadFunc = useAsyncCallback(\n    async (messageId: string) => {\n      onReloadMessages?.({\n        messageId,\n        currentAgentName: agent?.agentId,\n        messages: agent?.messages ?? [],\n      });\n      return await latestReload.current(messageId);\n    },\n    [latestReload, agent, onReloadMessages],\n  );\n\n  const latestStopFunc = useCallback(() => {\n    onStopGeneration?.({\n      currentAgentName: agent?.agentId,\n      messages: agent?.messages ?? [],\n    });\n    return agent?.abortRun?.();\n  }, [onStopGeneration, agent]);\n\n  const latestReset = useUpdatedRef(reset);\n  const latestResetFunc = useCallback(() => {\n    return latestReset.current();\n  }, [latestReset]);\n\n  const lazyToolRendered = useLazyToolRenderer();\n  const renderCustomMessage = useRenderCustomMessages();\n  const legacyCustomMessageRenderer = useLegacyCoagentRenderer({\n    copilotkit,\n    agent,\n    agentId: resolvedAgentId,\n    threadId: existingConfig?.threadId ?? threadId,\n  });\n  const allMessages = agent?.messages ?? [];\n  const resolvedMessages = useMemo(() => {\n    let processedMessages = allMessages.map((message) => {\n      if (message.role !== \"assistant\") {\n        return message;\n      }\n\n      const lazyRendered = lazyToolRendered(message, allMessages);\n      if (lazyRendered) {\n        const renderedGenUi = lazyRendered();\n        if (renderedGenUi) {\n          return { ...message, generativeUI: () => renderedGenUi };\n        }\n      }\n\n      const bridgeRenderer =\n        legacyCustomMessageRenderer || renderCustomMessage\n          ? () => {\n              if (legacyCustomMessageRenderer) {\n                return legacyCustomMessageRenderer({ message, position: \"before\" });\n              }\n              try {\n                return renderCustomMessage?.({ message, position: \"before\" }) ?? null;\n              } catch (error) {\n                console.warn(\n                  \"[CopilotKit] renderCustomMessages failed, falling back to legacy renderer\",\n                  error,\n                );\n                return null;\n              }\n            }\n          : null;\n\n      if (bridgeRenderer) {\n        // Attach a position so react-ui can render the custom UI above the assistant content.\n        return {\n          ...message,\n          generativeUI: bridgeRenderer,\n          generativeUIPosition: \"before\" as const,\n        };\n      }\n      return message;\n    });\n\n    const hasAssistantMessages = processedMessages.some((msg) => msg.role === \"assistant\");\n    const canUseCustomRenderer = Boolean(\n      renderCustomMessage && copilotkit?.getAgent?.(resolvedAgentId),\n    );\n    const placeholderRenderer = legacyCustomMessageRenderer\n      ? legacyCustomMessageRenderer\n      : canUseCustomRenderer\n        ? renderCustomMessage\n        : null;\n\n    const shouldRenderPlaceholder =\n      Boolean(agent?.isRunning) || Boolean(agent?.state && Object.keys(agent.state).length);\n\n    const effectiveThreadId = threadId ?? agent?.threadId ?? \"default\";\n    let latestUserIndex = -1;\n    for (let i = processedMessages.length - 1; i >= 0; i -= 1) {\n      if (processedMessages[i].role === \"user\") {\n        latestUserIndex = i;\n        break;\n      }\n    }\n    const latestUserMessageId =\n      latestUserIndex >= 0 ? processedMessages[latestUserIndex].id : undefined;\n    const currentRunId = latestUserMessageId\n      ? copilotkit.getRunIdForMessage(resolvedAgentId, effectiveThreadId, latestUserMessageId) ||\n        `pending:${latestUserMessageId}`\n      : undefined;\n    const hasAssistantForCurrentRun =\n      latestUserIndex >= 0\n        ? processedMessages\n            .slice(latestUserIndex + 1)\n            .some((msg) => msg.role === \"assistant\")\n        : hasAssistantMessages;\n\n    // Insert a placeholder assistant message so state snapshots can render before any\n    // assistant text exists for the current run.\n    if (placeholderRenderer && shouldRenderPlaceholder && !hasAssistantForCurrentRun) {\n      const placeholderId = currentRunId\n        ? `coagent-state-render-${resolvedAgentId}-${currentRunId}`\n        : `coagent-state-render-${resolvedAgentId}`;\n      const placeholderMessage: Message = {\n        id: placeholderId,\n        role: \"assistant\",\n        content: \"\",\n        name: \"coagent-state-render\",\n        runId: currentRunId,\n      };\n      processedMessages = [\n        ...processedMessages,\n        {\n          ...placeholderMessage,\n          generativeUIPosition: \"before\" as const,\n          generativeUI: () =>\n            placeholderRenderer({\n              message: placeholderMessage,\n              position: \"before\",\n            }),\n        } as Message,\n      ];\n    }\n\n    return processedMessages;\n  }, [\n    agent?.messages,\n    lazyToolRendered,\n    allMessages,\n    renderCustomMessage,\n    legacyCustomMessageRenderer,\n    resolvedAgentId,\n    copilotkit,\n    agent?.isRunning,\n    agent?.state,\n  ]);\n\n  const renderedSuggestions = useMemo(() => {\n    if (Array.isArray(suggestions)) {\n      return {\n        suggestions: suggestions.map((s) => ({ ...s, isLoading: false })),\n        isLoading: false,\n      };\n    }\n    return currentSuggestions;\n  }, [suggestions, currentSuggestions]);\n\n  // @ts-ignore\n  return {\n    messages: resolvedMessages,\n    sendMessage: latestSendMessageFunc,\n    appendMessage: latestAppendFunc,\n    setMessages: latestSetMessagesFunc,\n    reloadMessages: latestReloadFunc,\n    stopGeneration: latestStopFunc,\n    reset: latestResetFunc,\n    deleteMessage: latestDeleteFunc,\n    isAvailable: agentAvailable,\n    isLoading: Boolean(agent?.isRunning),\n    // mcpServers,\n    // setMcpServers,\n    suggestions: renderedSuggestions.suggestions,\n    setSuggestions: (suggestions: Omit<Suggestion, \"isLoading\">[]) =>\n      copilotkit.addSuggestionsConfig({ suggestions }),\n    generateSuggestions: async () => copilotkit.reloadSuggestions(resolvedAgentId),\n    resetSuggestions: () => copilotkit.clearSuggestions(resolvedAgentId),\n    isLoadingSuggestions: renderedSuggestions.isLoading,\n    interrupt,\n    agent,\n    threadId,\n  };\n}\n\n// store `value` in a ref and update\n// it whenever it changes.\nfunction useUpdatedRef<T>(value: T) {\n  const ref = useRef(value);\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref;\n}\n\ntype LegacyRenderParams = {\n  message: Message;\n  position: \"before\" | \"after\";\n};\n\ntype LegacyRenderer = ((args: LegacyRenderParams) => any) | null;\n\nfunction useLegacyCoagentRenderer({\n  copilotkit,\n  agent,\n  agentId,\n  threadId,\n}: {\n  copilotkit: ReturnType<typeof useCopilotKit>[\"copilotkit\"];\n  agent?: AbstractAgent;\n  agentId: string;\n  threadId?: string;\n}): LegacyRenderer {\n  return useMemo(() => {\n    if (!copilotkit || !agent) {\n      return null;\n    }\n\n    return ({ message, position }: LegacyRenderParams) => {\n      const effectiveThreadId = threadId ?? agent.threadId ?? \"default\";\n      const providedRunId = (message as any).runId as string | undefined;\n      const existingRunId = providedRunId\n        ? providedRunId\n        : copilotkit.getRunIdForMessage(agentId, effectiveThreadId, message.id);\n      const runId = existingRunId || `pending:${message.id}`;\n      const messageIndex = Math.max(\n        agent.messages.findIndex((msg) => msg.id === message.id),\n        0,\n      );\n\n      const bridgeProps: CoAgentStateRenderBridgeProps = {\n        message: message as any,\n        position,\n        runId,\n        messageIndex,\n        messageIndexInRun: 0,\n        numberOfMessagesInRun: 1,\n        agentId,\n        stateSnapshot: (message as any).state,\n      };\n\n      return createElement(CoAgentStateRenderBridge, bridgeProps) as any;\n    };\n  }, [agent, agentId, copilotkit, threadId]);\n}\n\nexport function defaultSystemMessage(\n  contextString: string,\n  additionalInstructions?: string,\n): string {\n  return (\n    `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\nIn case of a function error:\n- If this error stems from incorrect function parameters or syntax, you may retry with corrected arguments.\n- If the error's source is unclear or seems unrelated to your input, do not attempt further retries.\n` + (additionalInstructions ? `\\n\\n${additionalInstructions}` : \"\")\n  );\n}\n","import {\n  CopilotCloudConfig,\n  FunctionCallHandler,\n  CopilotErrorHandler,\n  CopilotKitError,\n} from \"@copilotkit/shared\";\nimport {\n  ActionRenderProps,\n  CatchAllActionRenderProps,\n  FrontendAction,\n} from \"../types/frontend-action\";\nimport React from \"react\";\nimport { TreeNodeId, Tree } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\nimport { CopilotChatSuggestionConfiguration } from \"../types/chat-suggestion-configuration\";\nimport { CoAgentStateRender, CoAgentStateRenderProps } from \"../types/coagent-action\";\nimport { CoagentState } from \"../types/coagent-state\";\nimport {\n  CopilotRuntimeClient,\n  ExtensionsInput,\n  ForwardedParametersInput,\n} from \"@copilotkit/runtime-client-gql\";\nimport { Agent } from \"@copilotkit/runtime-client-gql\";\nimport {\n  LangGraphInterruptRender,\n  LangGraphInterruptActionSetter,\n  QueuedInterruptEvent,\n} from \"../types/interrupt-action\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The public API key for Copilot Cloud.\n   */\n  publicApiKey?: string;\n\n  /**\n   * The configuration for Copilot Cloud.\n   */\n  cloud?: CopilotCloudConfig;\n\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the Copilot transcribe audio service.\n   */\n  transcribeAudioUrl?: string;\n\n  /**\n   * The endpoint for the Copilot text to speech service.\n   */\n  textToSpeechUrl?: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Custom properties to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  properties?: Record<string, any>;\n\n  /**\n   * Indicates whether the user agent should send or receive cookies from the other domain\n   * in the case of cross-origin requests.\n   */\n  credentials?: RequestCredentials;\n\n  /**\n   * Optional configuration for connecting to Model Context Protocol (MCP) servers.\n   * This is typically derived from the CopilotKitProps and used internally.\n   * @experimental\n   */\n  mcpServers?: Array<{ endpoint: string; apiKey?: string }>;\n}\n\nexport type InChatRenderFunction<TProps = ActionRenderProps<any> | CatchAllActionRenderProps<any>> =\n  (props: TProps) => string | React.JSX.Element;\nexport type CoagentInChatRenderFunction = (\n  props: CoAgentStateRenderProps<any>,\n) => string | React.JSX.Element | undefined | null;\n\nexport interface ChatComponentsCache {\n  actions: Record<string, InChatRenderFunction | string>;\n  coAgentStateRenders: Record<string, CoagentInChatRenderFunction | string>;\n}\n\nexport interface AgentSession {\n  agentName: string;\n  threadId?: string;\n  nodeName?: string;\n}\n\nexport interface AuthState {\n  status: \"authenticated\" | \"unauthenticated\";\n  authHeaders: Record<string, string>;\n  userId?: string;\n  metadata?: Record<string, any>;\n}\n\nexport type ActionName = string;\nexport type ContextTree = Tree;\n\nexport interface CopilotContextParams {\n  // function-calling\n  actions: Record<string, FrontendAction<any>>;\n  setAction: (id: string, action: FrontendAction<any>) => void;\n  removeAction: (id: string) => void;\n\n  // registered actions for component-based rendering\n  setRegisteredActions: (actionConfig: any) => string;\n  removeRegisteredAction: (actionKey: string) => void;\n\n  chatComponentsCache: React.RefObject<ChatComponentsCache>;\n\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, FrontendAction<any>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getAllContext: () => Tree;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  isLoading: boolean;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration };\n  addChatSuggestionConfiguration: (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => void;\n  removeChatSuggestionConfiguration: (id: string) => void;\n\n  chatInstructions: string;\n  setChatInstructions: React.Dispatch<React.SetStateAction<string>>;\n\n  additionalInstructions?: string[];\n  setAdditionalInstructions: React.Dispatch<React.SetStateAction<string[]>>;\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n\n  showDevConsole: boolean;\n\n  // agents\n  coagentStates: Record<string, CoagentState>;\n  setCoagentStates: React.Dispatch<React.SetStateAction<Record<string, CoagentState>>>;\n  coagentStatesRef: React.RefObject<Record<string, CoagentState>>;\n  setCoagentStatesWithRef: (\n    value:\n      | Record<string, CoagentState>\n      | ((prev: Record<string, CoagentState>) => Record<string, CoagentState>),\n  ) => void;\n\n  agentSession: AgentSession | null;\n  setAgentSession: React.Dispatch<React.SetStateAction<AgentSession | null>>;\n\n  agentLock: string | null;\n\n  threadId: string;\n  setThreadId: React.Dispatch<React.SetStateAction<string>>;\n\n  runId: string | null;\n  setRunId: React.Dispatch<React.SetStateAction<string | null>>;\n\n  // The chat abort controller can be used to stop generation globally,\n  // i.e. when using `stop()` from `useChat`\n  chatAbortControllerRef: React.MutableRefObject<AbortController | null>;\n\n  /**\n   * The forwarded parameters to use for the task.\n   */\n  forwardedParameters?: Partial<Pick<ForwardedParametersInput, \"temperature\">>;\n  availableAgents: Agent[];\n\n  /**\n   * The auth states for the CopilotKit.\n   */\n  authStates_c?: Record<ActionName, AuthState>;\n  setAuthStates_c?: React.Dispatch<React.SetStateAction<Record<ActionName, AuthState>>>;\n\n  /**\n   * The auth config for the CopilotKit.\n   */\n  authConfig_c?: {\n    SignInComponent: React.ComponentType<{\n      onSignInComplete: (authState: AuthState) => void;\n    }>;\n  };\n\n  extensions: ExtensionsInput;\n  setExtensions: React.Dispatch<React.SetStateAction<ExtensionsInput>>;\n  interruptActions: Record<string, LangGraphInterruptRender>;\n  setInterruptAction: LangGraphInterruptActionSetter;\n  removeInterruptAction: (actionId: string) => void;\n  interruptEventQueue: Record<string, QueuedInterruptEvent[]>;\n  addInterruptEvent: (queuedEvent: QueuedInterruptEvent) => void;\n  resolveInterruptEvent: (threadId: string, eventId: string, response: string) => void;\n\n  /**\n   * Optional trace handler for comprehensive debugging and observability.\n   */\n  onError: CopilotErrorHandler;\n\n  // banner error state\n  bannerError: CopilotKitError | null;\n  setBannerError: React.Dispatch<React.SetStateAction<CopilotKitError | null>>;\n  // Internal error handlers\n  // These are used to handle errors that occur during the execution of the chat.\n  // They are not intended for use by the developer. A component can register itself an error listener to be activated somewhere else as needed\n  internalErrorHandlers: Record<string, CopilotErrorHandler>;\n  setInternalErrorHandler: (handler: Record<string, CopilotErrorHandler>) => void;\n  removeInternalErrorHandler: (id: string) => void;\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  actions: {},\n  setAction: () => {},\n  removeAction: () => {},\n\n  setRegisteredActions: () => \"\",\n  removeRegisteredAction: () => {},\n\n  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n  getAllContext: () => [],\n\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  isLoading: false,\n  setIsLoading: () => returnAndThrowInDebug(false),\n\n  chatInstructions: \"\",\n  setChatInstructions: () => returnAndThrowInDebug(\"\"),\n\n  additionalInstructions: [],\n  setAdditionalInstructions: () => returnAndThrowInDebug([]),\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n\n  chatSuggestionConfiguration: {},\n  addChatSuggestionConfiguration: () => {},\n  removeChatSuggestionConfiguration: () => {},\n  showDevConsole: false,\n  coagentStates: {},\n  setCoagentStates: () => {},\n  coagentStatesRef: { current: {} },\n  setCoagentStatesWithRef: () => {},\n  agentSession: null,\n  setAgentSession: () => {},\n  forwardedParameters: {},\n  agentLock: null,\n  threadId: \"\",\n  setThreadId: () => {},\n  runId: null,\n  setRunId: () => {},\n  chatAbortControllerRef: { current: null },\n  availableAgents: [],\n  extensions: {},\n  setExtensions: () => {},\n  interruptActions: {},\n  setInterruptAction: () => {},\n  removeInterruptAction: () => {},\n  interruptEventQueue: {},\n  addInterruptEvent: () => {},\n  resolveInterruptEvent: () => {},\n  onError: () => {},\n  bannerError: null,\n  setBannerError: () => {},\n  internalErrorHandlers: {},\n  setInternalErrorHandler: () => {},\n  removeInternalErrorHandler: () => {},\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  const context = React.useContext(CopilotContext);\n  if (context === emptyCopilotContext) {\n    throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  }\n  return context;\n}\n\nfunction returnAndThrowInDebug<T>(_value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n}\n","import React, { useCallback } from \"react\";\nimport { GraphQLError } from \"@copilotkit/runtime-client-gql\";\nimport { useToast } from \"../toast/toast-provider\";\nimport { ExclamationMarkIcon } from \"../toast/exclamation-mark-icon\";\nimport ReactMarkdown from \"react-markdown\";\n\ninterface OriginalError {\n  message?: string;\n  stack?: string;\n}\n\nexport function ErrorToast({ errors }: { errors: (Error | GraphQLError)[] }) {\n  const errorsToRender = errors.map((error, idx) => {\n    const originalError =\n      \"extensions\" in error ? (error.extensions?.originalError as undefined | OriginalError) : {};\n    const message = originalError?.message ?? error.message;\n    const code = \"extensions\" in error ? (error.extensions?.code as string) : null;\n\n    return (\n      <div\n        key={idx}\n        style={{\n          marginTop: idx === 0 ? 0 : 10,\n          marginBottom: 14,\n        }}\n      >\n        <ExclamationMarkIcon style={{ marginBottom: 4 }} />\n\n        {code && (\n          <div\n            style={{\n              fontWeight: \"600\",\n              marginBottom: 4,\n            }}\n          >\n            Copilot Runtime Error:{\" \"}\n            <span style={{ fontFamily: \"monospace\", fontWeight: \"normal\" }}>{code}</span>\n          </div>\n        )}\n        <ReactMarkdown>{message}</ReactMarkdown>\n      </div>\n    );\n  });\n  return (\n    <div\n      style={{\n        fontSize: \"13px\",\n        maxWidth: \"600px\",\n      }}\n    >\n      {errorsToRender}\n      <div style={{ fontSize: \"11px\", opacity: 0.75 }}>\n        NOTE: This error only displays during local development.\n      </div>\n    </div>\n  );\n}\n\nexport function useErrorToast() {\n  const { addToast } = useToast();\n\n  return useCallback(\n    (errors: (Error | GraphQLError)[]) => {\n      const errorId = errors\n        .map((err) => {\n          const message =\n            \"extensions\" in err\n              ? (err.extensions?.originalError as any)?.message || err.message\n              : err.message;\n          const stack = err.stack || \"\";\n          return btoa(message + stack).slice(0, 32); // Create hash from message + stack\n        })\n        .join(\"|\");\n\n      addToast({\n        type: \"error\",\n        id: errorId, // Toast libraries typically dedupe by id\n        message: <ErrorToast errors={errors} />,\n      });\n    },\n    [addToast],\n  );\n}\n\nexport function useAsyncCallback<T extends (...args: any[]) => Promise<any>>(\n  callback: T,\n  deps: Parameters<typeof useCallback>[1],\n) {\n  const addErrorToast = useErrorToast();\n  return useCallback(async (...args: Parameters<T>) => {\n    try {\n      return await callback(...args);\n    } catch (error) {\n      console.error(\"Error in async callback:\", error);\n      // @ts-ignore\n      addErrorToast([error]);\n      throw error;\n    }\n  }, deps);\n}\n","import { GraphQLError } from \"@copilotkit/runtime-client-gql\";\nimport React, { createContext, useContext, useState, useCallback } from \"react\";\nimport { PartialBy, CopilotKitError, Severity } from \"@copilotkit/shared\";\n\ninterface Toast {\n  id: string;\n  message: string | React.ReactNode;\n  type: \"info\" | \"success\" | \"warning\" | \"error\";\n  duration?: number;\n}\n\ninterface ToastContextValue {\n  toasts: Toast[];\n  addToast: (toast: PartialBy<Toast, \"id\">) => void;\n  addGraphQLErrorsToast: (errors: GraphQLError[]) => void;\n  removeToast: (id: string) => void;\n  enabled: boolean;\n  // Banner management\n  bannerError: CopilotKitError | null;\n  setBannerError: (error: CopilotKitError | null) => void;\n}\n\nconst ToastContext = createContext<ToastContextValue | undefined>(undefined);\n\n// Helper functions for error banner styling\ntype ErrorSeverity = \"critical\" | \"warning\" | \"info\";\n\ninterface ErrorColors {\n  background: string;\n  border: string;\n  text: string;\n  icon: string;\n}\n\nfunction getErrorSeverity(error: CopilotKitError): ErrorSeverity {\n  // Use structured error severity if available\n  if (error.severity) {\n    switch (error.severity) {\n      case Severity.CRITICAL:\n        return \"critical\";\n      case Severity.WARNING:\n        return \"warning\";\n      case Severity.INFO:\n        return \"info\";\n      default:\n        return \"info\";\n    }\n  }\n\n  // Fallback: Check for API key errors which should always be critical\n  const message = error.message.toLowerCase();\n  if (\n    message.includes(\"api key\") ||\n    message.includes(\"401\") ||\n    message.includes(\"unauthorized\") ||\n    message.includes(\"authentication\") ||\n    message.includes(\"incorrect api key\")\n  ) {\n    return \"critical\";\n  }\n\n  // Default to info level\n  return \"info\";\n}\n\nfunction getErrorColors(severity: ErrorSeverity): ErrorColors {\n  switch (severity) {\n    case \"critical\":\n      return {\n        background: \"#fee2e2\",\n        border: \"#dc2626\",\n        text: \"#7f1d1d\",\n        icon: \"#dc2626\",\n      };\n    case \"warning\":\n      return {\n        background: \"#fef3c7\",\n        border: \"#d97706\",\n        text: \"#78350f\",\n        icon: \"#d97706\",\n      };\n    case \"info\":\n      return {\n        background: \"#dbeafe\",\n        border: \"#2563eb\",\n        text: \"#1e3a8a\",\n        icon: \"#2563eb\",\n      };\n  }\n}\n\nexport function useToast() {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error(\"useToast must be used within a ToastProvider\");\n  }\n  return context;\n}\n\nexport function ToastProvider({\n  enabled,\n  children,\n}: {\n  enabled: boolean;\n  children: React.ReactNode;\n}) {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n  const [bannerError, setBannerErrorState] = useState<CopilotKitError | null>(null);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts((prev) => prev.filter((toast) => toast.id !== id));\n  }, []);\n\n  const addToast = useCallback(\n    (toast: PartialBy<Toast, \"id\">) => {\n      // Respect the enabled flag for ALL toasts\n      if (!enabled) {\n        return;\n      }\n\n      const id = toast.id ?? Math.random().toString(36).substring(2, 9);\n\n      setToasts((currentToasts) => {\n        if (currentToasts.find((toast) => toast.id === id)) return currentToasts;\n        return [...currentToasts, { ...toast, id }];\n      });\n\n      if (toast.duration) {\n        setTimeout(() => {\n          removeToast(id);\n        }, toast.duration);\n      }\n    },\n    [enabled, removeToast],\n  );\n\n  const setBannerError = useCallback(\n    (error: CopilotKitError | null) => {\n      // Respect the enabled flag for ALL errors\n      if (!enabled && error !== null) {\n        return;\n      }\n      setBannerErrorState(error);\n    },\n    [enabled],\n  );\n\n  const addGraphQLErrorsToast = useCallback((errors: GraphQLError[]) => {\n    // DEPRECATED: All errors now route to banners for consistency\n    console.warn(\"addGraphQLErrorsToast is deprecated. All errors now show as banners.\");\n    // Function kept for backward compatibility - does nothing\n  }, []);\n\n  const value = {\n    toasts,\n    addToast,\n    addGraphQLErrorsToast,\n    removeToast,\n    enabled,\n    bannerError,\n    setBannerError,\n  };\n\n  return (\n    <ToastContext.Provider value={value}>\n      {/* Banner Error Display */}\n      {bannerError &&\n        (() => {\n          const severity = getErrorSeverity(bannerError);\n          const colors = getErrorColors(severity);\n\n          return (\n            <div\n              style={{\n                position: \"fixed\",\n                bottom: \"20px\",\n                left: \"50%\",\n                transform: \"translateX(-50%)\",\n                zIndex: 9999,\n                backgroundColor: colors.background,\n                border: `1px solid ${colors.border}`,\n                borderLeft: `4px solid ${colors.border}`,\n                borderRadius: \"8px\",\n                padding: \"12px 16px\",\n                fontSize: \"13px\",\n                boxShadow: \"0 4px 12px rgba(0, 0, 0, 0.15)\",\n                backdropFilter: \"blur(8px)\",\n                maxWidth: \"min(90vw, 700px)\",\n                width: \"100%\",\n                boxSizing: \"border-box\",\n                overflow: \"hidden\",\n              }}\n            >\n              <div\n                style={{\n                  display: \"flex\",\n                  justifyContent: \"space-between\",\n                  alignItems: \"center\",\n                  gap: \"10px\",\n                }}\n              >\n                <div\n                  style={{\n                    display: \"flex\",\n                    alignItems: \"center\",\n                    gap: \"8px\",\n                    flex: 1,\n                    minWidth: 0,\n                  }}\n                >\n                  <div\n                    style={{\n                      width: \"12px\",\n                      height: \"12px\",\n                      borderRadius: \"50%\",\n                      backgroundColor: colors.border,\n                      flexShrink: 0,\n                    }}\n                  />\n                  <div\n                    style={{\n                      display: \"flex\",\n                      alignItems: \"center\",\n                      gap: \"10px\",\n                      flex: 1,\n                      minWidth: 0,\n                    }}\n                  >\n                    <div\n                      style={{\n                        color: colors.text,\n                        lineHeight: \"1.4\",\n                        fontWeight: \"400\",\n                        fontSize: \"13px\",\n                        flex: 1,\n                        wordBreak: \"break-all\",\n                        overflowWrap: \"break-word\",\n                        maxWidth: \"550px\",\n                        overflow: \"hidden\",\n                        display: \"-webkit-box\",\n                        WebkitLineClamp: 10,\n                        WebkitBoxOrient: \"vertical\",\n                      }}\n                    >\n                      {(() => {\n                        let message = bannerError.message;\n\n                        // Try to extract the useful message from JSON first\n                        const jsonMatch = message.match(/'message':\\s*'([^']+)'/);\n                        if (jsonMatch) {\n                          return jsonMatch[1]; // Return the actual error message\n                        }\n\n                        // Strip technical garbage but keep the meaningful message\n                        message = message.split(\" - \")[0]; // Remove everything after \" - {\"\n                        message = message.split(\": Error code\")[0]; // Remove \": Error code: 401\"\n                        message = message.replace(/:\\s*\\d{3}$/, \"\"); // Remove trailing \": 401\"\n                        message = message.replace(/See more:.*$/g, \"\"); // Remove \"See more\" links\n                        message = message.trim();\n\n                        // If it's still garbage (contains { or '), use fallback\n                        // if (message.includes(\"{\") || message.includes(\"'\")) {\n                        //   return \"Configuration error.... Please check your setup.\";\n                        // }\n\n                        return message || \"Configuration error occurred.\";\n                      })()}\n                    </div>\n\n                    {(() => {\n                      const message = bannerError.message;\n                      const markdownLinkRegex = /\\[([^\\]]+)\\]\\(([^)]+)\\)/g;\n                      const plainUrlRegex = /(https?:\\/\\/[^\\s)]+)/g;\n\n                      // Extract the first URL found\n                      let url = null;\n                      let buttonText = \"See More\";\n\n                      // Check for markdown links first\n                      const markdownMatch = markdownLinkRegex.exec(message);\n                      if (markdownMatch) {\n                        url = markdownMatch[2];\n                        buttonText = \"See More\";\n                      } else {\n                        // Check for plain URLs\n                        const urlMatch = plainUrlRegex.exec(message);\n                        if (urlMatch) {\n                          url = urlMatch[0].replace(/[.,;:'\"]*$/, \"\"); // Remove trailing punctuation\n                          buttonText = \"See More\";\n                        }\n                      }\n\n                      if (!url) return null;\n\n                      return (\n                        <button\n                          onClick={() => window.open(url, \"_blank\", \"noopener,noreferrer\")}\n                          style={{\n                            background: colors.border,\n                            color: \"white\",\n                            border: \"none\",\n                            borderRadius: \"5px\",\n                            padding: \"4px 10px\",\n                            fontSize: \"11px\",\n                            fontWeight: \"500\",\n                            cursor: \"pointer\",\n                            transition: \"all 0.2s ease\",\n                            flexShrink: 0,\n                          }}\n                          onMouseEnter={(e) => {\n                            e.currentTarget.style.opacity = \"0.9\";\n                            e.currentTarget.style.transform = \"translateY(-1px)\";\n                          }}\n                          onMouseLeave={(e) => {\n                            e.currentTarget.style.opacity = \"1\";\n                            e.currentTarget.style.transform = \"translateY(0)\";\n                          }}\n                        >\n                          {buttonText}\n                        </button>\n                      );\n                    })()}\n                  </div>\n                </div>\n                <button\n                  onClick={() => setBannerError(null)}\n                  style={{\n                    background: \"transparent\",\n                    border: \"none\",\n                    color: colors.text,\n                    cursor: \"pointer\",\n                    padding: \"2px\",\n                    borderRadius: \"3px\",\n                    fontSize: \"14px\",\n                    lineHeight: \"1\",\n                    opacity: 0.6,\n                    transition: \"all 0.2s ease\",\n                    flexShrink: 0,\n                  }}\n                  title=\"Dismiss\"\n                  onMouseEnter={(e) => {\n                    e.currentTarget.style.opacity = \"1\";\n                    e.currentTarget.style.background = \"rgba(0, 0, 0, 0.05)\";\n                  }}\n                  onMouseLeave={(e) => {\n                    e.currentTarget.style.opacity = \"0.6\";\n                    e.currentTarget.style.background = \"transparent\";\n                  }}\n                >\n                  Ã—\n                </button>\n              </div>\n            </div>\n          );\n        })()}\n\n      {/* Toast Display - Deprecated: All errors now show as banners */}\n      {children}\n    </ToastContext.Provider>\n  );\n}\n\n// Toast component removed - all errors now show as banners for consistency\n","import React from \"react\";\n\nexport const ExclamationMarkIcon = ({\n  className,\n  style,\n}: {\n  className?: string;\n  style?: React.CSSProperties;\n}) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"24\"\n    height=\"24\"\n    viewBox=\"0 0 24 24\"\n    fill=\"none\"\n    stroke=\"currentColor\"\n    strokeWidth=\"2\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    className={`lucide lucide-circle-alert ${className ? className : \"\"}`}\n    style={style}\n  >\n    <circle cx=\"12\" cy=\"12\" r=\"10\" />\n    <line x1=\"12\" x2=\"12\" y1=\"8\" y2=\"12\" />\n    <line x1=\"12\" x2=\"12.01\" y1=\"16\" y2=\"16\" />\n  </svg>\n);\n","import React, {\n  createContext,\n  useContext,\n  useCallback,\n  useState,\n  useRef,\n  ReactNode,\n  RefObject,\n} from \"react\";\nimport { CoAgentStateRender } from \"../types/coagent-action\";\n\ninterface StateRenderClaim {\n  stateRenderId: string;\n  stateSnapshot?: any;\n  runId?: string;\n  messageIndex?: number;\n  locked?: boolean;\n}\n\ntype ClaimsRef = Record<string, StateRenderClaim>;\n\nexport interface CoAgentStateRendersContextValue {\n  coAgentStateRenders: Record<string, CoAgentStateRender<any>>;\n  setCoAgentStateRender: (id: string, stateRender: CoAgentStateRender<any>) => void;\n  removeCoAgentStateRender: (id: string) => void;\n  claimsRef: RefObject<ClaimsRef>;\n}\n\nconst CoAgentStateRendersContext = createContext<CoAgentStateRendersContextValue | undefined>(\n  undefined,\n);\n\nexport function CoAgentStateRendersProvider({ children }: { children: ReactNode }) {\n  const [coAgentStateRenders, setCoAgentStateRenders] = useState<\n    Record<string, CoAgentStateRender<any>>\n  >({});\n\n  const setCoAgentStateRender = useCallback((id: string, stateRender: CoAgentStateRender<any>) => {\n    setCoAgentStateRenders((prevPoints) => ({\n      ...prevPoints,\n      [id]: stateRender,\n    }));\n  }, []);\n\n  const removeCoAgentStateRender = useCallback((id: string) => {\n    setCoAgentStateRenders((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const claimsRef = useRef<ClaimsRef>({});\n\n  return (\n    <CoAgentStateRendersContext.Provider\n      value={{\n        coAgentStateRenders,\n        setCoAgentStateRender,\n        removeCoAgentStateRender,\n        claimsRef,\n      }}\n    >\n      {children}\n    </CoAgentStateRendersContext.Provider>\n  );\n}\n\nexport function useCoAgentStateRenders() {\n  const context = useContext(CoAgentStateRendersContext);\n  if (!context) {\n    throw new Error(\"useCoAgentStateRenders must be used within CoAgentStateRendersProvider\");\n  }\n  return context;\n}\n\nexport { CoAgentStateRendersContext };\n","import { useCopilotContext } from \"../context\";\nimport React, { useCallback, useEffect, useMemo } from \"react\";\nimport type { AbstractAgent, AgentSubscriber } from \"@ag-ui/client\";\nimport { MetaEventName } from \"@copilotkit/runtime-client-gql\";\nimport { dataToUUID, parseJson } from \"@copilotkit/shared\";\nimport { useAgentNodeName } from \"./use-agent-nodename\";\nimport { useCopilotChatConfiguration } from \"@copilotkitnext/react\";\n\ntype InterruptProps = {\n  event: any;\n  result: any;\n  render: (props: {\n    event: any;\n    result: any;\n    resolve: (response: string) => void;\n  }) => string | React.ReactElement;\n  resolve: (response: string) => void;\n};\n\nconst InterruptRenderer: React.FC<InterruptProps> = ({ event, result, render, resolve }) => {\n  return render({ event, result, resolve });\n};\n\nexport function useLangGraphInterruptRender(\n  agent: AbstractAgent,\n): string | React.ReactElement | null {\n  const {\n    interruptActions,\n    agentSession,\n    threadId,\n    interruptEventQueue,\n    addInterruptEvent,\n    resolveInterruptEvent,\n  } = useCopilotContext();\n  const existingConfig = useCopilotChatConfiguration();\n  const resolvedAgentId = existingConfig?.agentId ?? \"default\";\n  const nodeName = useAgentNodeName(resolvedAgentId);\n\n  useEffect(() => {\n    if (!agent) return;\n    let localInterrupt: any = null;\n    const subscriber: AgentSubscriber = {\n      onCustomEvent: ({ event }) => {\n        if (event.name === \"on_interrupt\") {\n          const eventData = {\n            name: MetaEventName.LangGraphInterruptEvent,\n            type: event.type,\n            value: parseJson(event.value, event.value),\n          };\n          const eventId = dataToUUID(eventData, \"interruptEvents\");\n          localInterrupt = {\n            eventId,\n            threadId,\n            event: eventData,\n          };\n        }\n      },\n      onRunStartedEvent: () => {\n        localInterrupt = null;\n      },\n      onRunFinalized: () => {\n        if (localInterrupt) {\n          addInterruptEvent(localInterrupt);\n          localInterrupt = null;\n        }\n      },\n    };\n\n    const { unsubscribe } = agent.subscribe(subscriber);\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [agent, threadId]);\n\n  const handleResolve = useCallback(\n    (eventId: string, response?: string) => {\n      agent?.runAgent({\n        forwardedProps: {\n          command: {\n            resume: response,\n          },\n        },\n      });\n      resolveInterruptEvent(threadId, eventId, response ?? \"\");\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [agent, threadId],\n  );\n\n  return useMemo(() => {\n    // Get the queue for this thread and find the first unresponded event\n    const eventQueue = interruptEventQueue[threadId] || [];\n    const currentQueuedEvent = eventQueue.find((qe) => !qe.event.response);\n\n    if (!currentQueuedEvent || !agentSession) return null;\n\n    // Find the first matching action from all registered actions\n    const allActions = Object.values(interruptActions);\n    const matchingAction = allActions.find((action) => {\n      if (!action.enabled) return true; // No filter = match all\n      return action.enabled({\n        eventValue: currentQueuedEvent.event.value,\n        agentMetadata: {\n          ...agentSession,\n          nodeName,\n        },\n      });\n    });\n\n    if (!matchingAction) return null;\n\n    const { render, handler } = matchingAction;\n\n    const resolveInterrupt = (response: string) => {\n      handleResolve(currentQueuedEvent.eventId, response);\n    };\n\n    let result = null;\n    if (handler) {\n      result = handler({\n        event: currentQueuedEvent.event,\n        resolve: resolveInterrupt,\n      });\n    }\n\n    if (!render) return null;\n\n    return React.createElement(InterruptRenderer, {\n      event: currentQueuedEvent.event,\n      result,\n      render,\n      resolve: resolveInterrupt,\n    });\n  }, [interruptActions, interruptEventQueue, threadId, agentSession, handleResolve]);\n}\n","import { useEffect, useRef } from \"react\";\nimport type { AgentSubscriber } from \"@ag-ui/client\";\nimport { useAgent } from \"@copilotkitnext/react\";\n\nexport function useAgentNodeName(agentName?: string) {\n  const { agent } = useAgent({ agentId: agentName });\n  const nodeNameRef = useRef<string>(\"start\");\n\n  useEffect(() => {\n    if (!agent) return;\n    const subscriber: AgentSubscriber = {\n      onStepStartedEvent: ({ event }) => {\n        nodeNameRef.current = event.stepName;\n      },\n      onRunStartedEvent: () => {\n        nodeNameRef.current = \"start\";\n      },\n      onRunFinishedEvent: () => {\n        nodeNameRef.current = \"end\";\n      },\n    };\n\n    const subscription = agent.subscribe(subscriber);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [agent]);\n\n  return nodeNameRef.current;\n}\n","import { useRenderToolCall } from \"@copilotkitnext/react\";\nimport { AIMessage, Message, ToolResult } from \"@copilotkit/shared\";\nimport React, { useCallback } from \"react\";\n\nexport function useLazyToolRenderer(): (\n  message?: AIMessage,\n  messages?: Message[],\n) => null | (() => ReturnType<ReturnType<typeof useRenderToolCall>> | null) {\n  const renderToolCall = useRenderToolCall();\n\n  return useCallback(\n    (message?: AIMessage, messages?: Message[]) => {\n      if (!message?.toolCalls?.length) return null;\n\n      const toolCall = message.toolCalls[0];\n      if (!toolCall) return null;\n\n      const toolMessage = messages?.find(\n        (m) => m.role === \"tool\" && m.toolCallId === toolCall.id,\n      ) as ToolResult;\n\n      return () =>\n        renderToolCall({\n          toolCall,\n          toolMessage,\n        });\n    },\n    [renderToolCall],\n  );\n}\n","import { ReactCustomMessageRendererPosition, useAgent } from \"@copilotkitnext/react\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport type { AgentSubscriber } from \"@ag-ui/client\";\nimport { useCoAgentStateRenders } from \"../context\";\nimport { parseJson } from \"@copilotkit/shared\";\nimport { RenderStatus } from \"./use-coagent-state-render-bridge.helpers\";\nimport { useStateRenderRegistry } from \"./use-coagent-state-render-registry\";\n\n/**\n * Bridge hook that connects agent state renders to chat messages.\n *\n * ## Purpose\n * This hook finds matching state render configurations (registered via useCoAgentStateRender)\n * and returns UI to render in chat.\n * It ensures each state render appears bound to a specific message, preventing duplicates while\n * allowing re-binding when the underlying state changes significantly.\n *\n * ## Message-ID-Based Claiming System\n *\n * ### The Problem\n * Multiple bridge component instances render simultaneously (one per message). Without coordination,\n * they would all try to render the same state render, causing duplicates.\n *\n * ### The Solution: Message-ID Claims with State Comparison\n * Each state render is \"claimed\" by exactly one **message ID** (not runId):\n *\n * **Claim Structure**: `claimsRef.current[messageId] = { stateRenderId, runId, stateSnapshot, locked }`\n *\n * **Primary binding is by messageId because**:\n * - runId is not always available immediately (starts as \"pending\")\n * - messageId is the stable identifier throughout the message lifecycle\n * - Claims persist across component remounts via context ref\n *\n * ### Claiming Logic Flow\n *\n * 1. **Message already has a claim**:\n *    - Check if the claim matches the current stateRenderId\n *    - If yes â†’ render (this message owns this render)\n *    - Update runId if it was \"pending\" and now available\n *\n * 2. **State render claimed by another message**:\n *    - Compare state snapshots (ignoring constant keys: messages, tools, copilotkit)\n *    - If states are identical â†’ block rendering (duplicate)\n *    - **If states are different â†’ allow claiming** (new data, new message)\n *    - This handles cases where the same render type shows different states in different messages\n *\n * 3. **Unclaimed state render**:\n *    - Only allow claiming if runId is \"pending\" (initial render)\n *    - If runId is real but no claim exists â†’ block (edge case protection)\n *    - Create new claim: `claimsRef.current[messageId] = { stateRenderId, runId }`\n *\n * ### State Snapshot Locking\n *\n * Once a state snapshot is captured and locked for a message:\n * - The UI always renders with the locked snapshot (not live agent.state)\n * - Prevents UI from appearing \"wiped\" during state transitions\n * - Locked when: stateSnapshot prop is available (from message persistence)\n * - Unlocked state: can still update from live agent.state\n *\n * ### Synchronous Claiming (Ref-based)\n *\n * Claims are stored in a context-level ref (not React state):\n * - Multiple bridges render in the same tick\n * - State updates are async - would allow duplicates before update completes\n * - Ref provides immediate, synchronous claim checking\n * - Survives component remounts (stored in context, not component)\n *\n * ## Flow Example\n *\n * ```\n * Time 1: Message A renders, runId=undefined, state={progress: 50%}\n *   â†’ effectiveRunId = \"pending\"\n *   â†’ Claims: claimsRef[\"msgA\"] = { stateRenderId: \"tasks\", runId: \"pending\", stateSnapshot: {progress: 50%} }\n *   â†’ Renders UI with 50% progress\n *\n * Time 2: Message B renders, runId=undefined, same state\n *   â†’ Checks: \"tasks\" already claimed by msgA with same state\n *   â†’ Returns null (blocked - duplicate)\n *\n * Time 3: Real runId appears (e.g., \"run-123\")\n *   â†’ Updates claim: claimsRef[\"msgA\"].runId = \"run-123\"\n *   â†’ Message A continues rendering\n *\n * Time 4: Agent processes more, state={progress: 100%}\n *   â†’ Message A: locked to 50% (stateSnapshot locked)\n *   â†’ Message C renders with state={progress: 100%}\n *   â†’ Checks: \"tasks\" claimed by msgA but state is DIFFERENT (50% vs 100%)\n *   â†’ Allows new claim: claimsRef[\"msgC\"] = { stateRenderId: \"tasks\", runId: \"run-123\", stateSnapshot: {progress: 100%} }\n *   â†’ Both messages render independently with their own snapshots\n * ```\n */\nexport interface CoAgentStateRenderBridgeProps {\n  message: any;\n  position: ReactCustomMessageRendererPosition;\n  runId: string;\n  messageIndex: number;\n  messageIndexInRun: number;\n  numberOfMessagesInRun: number;\n  agentId: string;\n  stateSnapshot: any;\n}\n\nexport function useCoagentStateRenderBridge(agentId: string, props: CoAgentStateRenderBridgeProps) {\n  const { stateSnapshot, message } = props;\n  const { coAgentStateRenders, claimsRef } = useCoAgentStateRenders();\n  const { agent } = useAgent({ agentId });\n  const [nodeName, setNodeName] = useState<string | undefined>(undefined);\n  const [, forceUpdate] = useState(0);\n\n  useEffect(() => {\n    if (!agent) return;\n    const subscriber: AgentSubscriber = {\n      onStateChanged: () => {\n        forceUpdate((value) => value + 1);\n      },\n      onStepStartedEvent: ({ event }) => {\n        if (event.stepName !== nodeName) {\n          setNodeName(event.stepName);\n        }\n      },\n      onStepFinishedEvent: ({ event }) => {\n        if (event.stepName === nodeName) {\n          setNodeName(undefined);\n        }\n      },\n    };\n\n    const { unsubscribe } = agent.subscribe(subscriber);\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [agentId, nodeName]);\n\n  const getStateRender = useCallback(\n    (messageId: string) => {\n      return Object.entries(coAgentStateRenders).find(([stateRenderId, stateRender]) => {\n        if (claimsRef.current[messageId]) {\n          return stateRenderId === claimsRef.current[messageId].stateRenderId;\n        }\n        const matchingAgentName = stateRender.name === agentId;\n        const matchesNodeContext = stateRender.nodeName ? stateRender.nodeName === nodeName : true;\n        return matchingAgentName && matchesNodeContext;\n      });\n    },\n    [coAgentStateRenders, nodeName, agentId],\n  );\n  const stateRenderEntry = useMemo(() => getStateRender(message.id), [getStateRender, message.id]);\n  const stateRenderId = stateRenderEntry?.[0];\n  const stateRender = stateRenderEntry?.[1];\n\n  const registryMessage = {\n    ...message,\n    runId: props.runId ?? message.runId,\n  };\n  const { canRender } = useStateRenderRegistry({\n    agentId,\n    stateRenderId,\n    message: registryMessage,\n    messageIndex: props.messageIndex,\n    stateSnapshot,\n    agentState: agent?.state,\n    agentMessages: agent?.messages,\n    claimsRef,\n  });\n\n  return useMemo(() => {\n    if (!stateRender || !stateRenderId) {\n      return null;\n    }\n    if (!canRender) {\n      return null;\n    }\n\n    if (stateRender.handler) {\n      stateRender.handler({\n        state: stateSnapshot ? parseJson(stateSnapshot, stateSnapshot) : (agent?.state ?? {}),\n        nodeName: nodeName ?? \"\",\n      });\n    }\n\n    if (stateRender.render) {\n      const status = agent?.isRunning ? RenderStatus.InProgress : RenderStatus.Complete;\n\n      if (typeof stateRender.render === \"string\") return stateRender.render;\n\n      return stateRender.render({\n        status,\n        // Always use state from claim, to make sure the state does not seem \"wiped\" for a fraction of a second\n        state: claimsRef.current[message.id].stateSnapshot ?? {},\n        nodeName: nodeName ?? \"\",\n      });\n    }\n  }, [\n    stateRender,\n    stateRenderId,\n    agent?.state,\n    agent?.isRunning,\n    nodeName,\n    message.id,\n    stateSnapshot,\n    canRender,\n  ]);\n}\n\nexport function CoAgentStateRenderBridge(props: CoAgentStateRenderBridgeProps) {\n  return useCoagentStateRenderBridge(props.agentId, props);\n}\n","import { dataToUUID, parseJson } from \"@copilotkit/shared\";\n\nexport enum RenderStatus {\n  InProgress = \"inProgress\",\n  Complete = \"complete\",\n}\n\nexport enum ClaimAction {\n  Create = \"create\",\n  Override = \"override\",\n  Existing = \"existing\",\n  Block = \"block\",\n}\n\nexport interface StateRenderContext {\n  agentId: string;\n  stateRenderId: string;\n  messageId: string;\n  runId: string;\n  messageIndex?: number;\n}\n\nexport interface Claim {\n  stateRenderId: string;\n  runId?: string;\n  stateSnapshot?: any;\n  locked?: boolean;\n  messageIndex?: number;\n}\n\nexport type ClaimsByMessageId = Record<string, Claim>;\n\nexport interface ClaimResolution {\n  canRender: boolean;\n  action: ClaimAction;\n  nextClaim?: Claim;\n  lockOthers?: boolean;\n  updateRunId?: string;\n}\n\nexport interface SnapshotCaches {\n  byStateRenderAndRun: Record<string, any>;\n  byMessageId: Record<string, any>;\n}\n\nexport interface SnapshotSelectionInput {\n  messageId: string;\n  messageName?: string;\n  allowLiveState?: boolean;\n  skipLatestCache?: boolean;\n  stateRenderId?: string;\n  effectiveRunId: string;\n  stateSnapshotProp?: any;\n  agentState?: any;\n  agentMessages?: Array<{ id: string; role?: string }>;\n  existingClaim?: Claim;\n  caches: SnapshotCaches;\n}\n\nexport interface SnapshotSelectionResult {\n  snapshot?: any;\n  hasSnapshotKeys: boolean;\n  cachedSnapshot?: any;\n  allowEmptySnapshot?: boolean;\n  snapshotForClaim?: any;\n}\n\nfunction getStateWithoutConstantKeys(state: any) {\n  if (!state) return {};\n  const { messages, tools, copilotkit, ...stateWithoutConstantKeys } = state;\n  return stateWithoutConstantKeys;\n}\n\n// Function that compares states, without the constant keys\nexport function areStatesEquals(a: any, b: any) {\n  if ((a && !b) || (!a && b)) return false;\n  const { messages, tools, copilotkit, ...aWithoutConstantKeys } = a;\n  const {\n    messages: bMessages,\n    tools: bTools,\n    copilotkit: bCopilotkit,\n    ...bWithoutConstantKeys\n  } = b;\n\n  return JSON.stringify(aWithoutConstantKeys) === JSON.stringify(bWithoutConstantKeys);\n}\n\nexport function isPlaceholderMessageId(messageId: string | undefined) {\n  return !!messageId && messageId.startsWith(\"coagent-state-render-\");\n}\n\nexport function isPlaceholderMessageName(messageName: string | undefined) {\n  return messageName === \"coagent-state-render\";\n}\n\nexport function readCachedMessageEntry(entry: any): { snapshot?: any; runId?: string } {\n  if (!entry || typeof entry !== \"object\") {\n    return { snapshot: entry, runId: undefined };\n  }\n  const snapshot = \"snapshot\" in entry ? entry.snapshot : entry;\n  const runId = \"runId\" in entry ? entry.runId : undefined;\n  return { snapshot, runId };\n}\n\nexport function getEffectiveRunId({\n  existingClaimRunId,\n  cachedMessageRunId,\n  runId,\n}: {\n  existingClaimRunId?: string;\n  cachedMessageRunId?: string;\n  runId?: string;\n}) {\n  return existingClaimRunId || cachedMessageRunId || runId || \"pending\";\n}\n\n/**\n * Resolve whether a message can claim a render slot.\n * This is a pure decision function; the caller applies claim mutations.\n */\nexport function resolveClaim({\n  claims,\n  context,\n  stateSnapshot,\n}: {\n  claims: ClaimsByMessageId;\n  context: StateRenderContext;\n  stateSnapshot?: any;\n}): ClaimResolution {\n  const { messageId, stateRenderId, runId, messageIndex } = context;\n  const existing = claims[messageId];\n\n  if (existing) {\n    const canRender = existing.stateRenderId === stateRenderId;\n    const shouldUpdateRunId =\n      canRender && runId && (!existing.runId || existing.runId === \"pending\");\n    return {\n      canRender,\n      action: canRender ? ClaimAction.Existing : ClaimAction.Block,\n      updateRunId: shouldUpdateRunId ? runId : undefined,\n    };\n  }\n\n  const normalizedRunId = runId ?? \"pending\";\n  const renderClaimedByOtherMessageEntry = Object.entries(claims).find(\n    ([, claim]) =>\n      claim.stateRenderId === stateRenderId &&\n      (claim.runId ?? \"pending\") === normalizedRunId &&\n      dataToUUID(getStateWithoutConstantKeys(claim.stateSnapshot)) ===\n        dataToUUID(getStateWithoutConstantKeys(stateSnapshot)),\n  );\n\n  const renderClaimedByOtherMessage = renderClaimedByOtherMessageEntry?.[1];\n  const claimedMessageId = renderClaimedByOtherMessageEntry?.[0];\n\n  if (renderClaimedByOtherMessage) {\n    if (\n      messageIndex !== undefined &&\n      renderClaimedByOtherMessage.messageIndex !== undefined &&\n      messageIndex > renderClaimedByOtherMessage.messageIndex\n    ) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers:\n          runId === renderClaimedByOtherMessage.runId || isPlaceholderMessageId(claimedMessageId),\n      };\n    }\n\n    if (runId && renderClaimedByOtherMessage.runId && runId !== renderClaimedByOtherMessage.runId) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers: isPlaceholderMessageId(claimedMessageId),\n      };\n    }\n\n    if (isPlaceholderMessageId(claimedMessageId)) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId, messageIndex },\n        lockOthers: true,\n      };\n    }\n\n    if (\n      stateSnapshot &&\n      renderClaimedByOtherMessage.stateSnapshot &&\n      !areStatesEquals(renderClaimedByOtherMessage.stateSnapshot, stateSnapshot)\n    ) {\n      return {\n        canRender: true,\n        action: ClaimAction.Override,\n        nextClaim: { stateRenderId, runId },\n      };\n    }\n\n    return { canRender: false, action: ClaimAction.Block };\n  }\n\n  if (!runId) {\n    return { canRender: false, action: ClaimAction.Block };\n  }\n\n  return {\n    canRender: true,\n    action: ClaimAction.Create,\n    nextClaim: { stateRenderId, runId, messageIndex },\n  };\n}\n\n/**\n * Select the best snapshot to render for this message.\n * Priority order is:\n * 1) explicit message snapshot\n * 2) live agent state (latest assistant only)\n * 3) cached snapshot for message\n * 4) cached snapshot for stateRenderId+runId\n * 5) last cached snapshot for stateRenderId\n */\nexport function selectSnapshot({\n  messageId,\n  messageName,\n  allowLiveState,\n  skipLatestCache,\n  stateRenderId,\n  effectiveRunId,\n  stateSnapshotProp,\n  agentState,\n  agentMessages,\n  existingClaim,\n  caches,\n}: SnapshotSelectionInput): SnapshotSelectionResult {\n  const lastAssistantId = agentMessages\n    ? [...agentMessages].reverse().find((msg) => msg.role === \"assistant\")?.id\n    : undefined;\n  const latestSnapshot =\n    stateRenderId !== undefined ? caches.byStateRenderAndRun[`${stateRenderId}::latest`] : undefined;\n  const messageIndex = agentMessages\n    ? agentMessages.findIndex((msg) => msg.id === messageId)\n    : -1;\n  const messageRole =\n    messageIndex >= 0 && agentMessages ? agentMessages[messageIndex]?.role : undefined;\n  let previousUserMessageId: string | undefined;\n  if (messageIndex > 0 && agentMessages) {\n    for (let i = messageIndex - 1; i >= 0; i -= 1) {\n      if (agentMessages[i]?.role === \"user\") {\n        previousUserMessageId = agentMessages[i]?.id;\n        break;\n      }\n    }\n  }\n  const liveStateIsStale =\n    stateSnapshotProp === undefined &&\n    latestSnapshot !== undefined &&\n    agentState !== undefined &&\n    areStatesEquals(latestSnapshot, agentState);\n  const shouldUseLiveState =\n    (Boolean(allowLiveState) || !lastAssistantId || messageId === lastAssistantId) &&\n    !liveStateIsStale;\n  const snapshot = stateSnapshotProp\n    ? parseJson(stateSnapshotProp, stateSnapshotProp)\n    : shouldUseLiveState\n      ? agentState\n      : undefined;\n  const hasSnapshotKeys = !!(snapshot && Object.keys(snapshot).length > 0);\n  const allowEmptySnapshot =\n    snapshot !== undefined &&\n    !hasSnapshotKeys &&\n    (stateSnapshotProp !== undefined || shouldUseLiveState);\n\n  const messageCacheEntry = caches.byMessageId[messageId];\n  const cachedMessageSnapshot = readCachedMessageEntry(messageCacheEntry).snapshot;\n  const cacheKey =\n    stateRenderId !== undefined ? `${stateRenderId}::${effectiveRunId}` : undefined;\n  let cachedSnapshot = cachedMessageSnapshot ?? caches.byMessageId[messageId];\n  if (cachedSnapshot === undefined && cacheKey && caches.byStateRenderAndRun[cacheKey] !== undefined) {\n    cachedSnapshot = caches.byStateRenderAndRun[cacheKey];\n  }\n  if (\n    cachedSnapshot === undefined &&\n    stateRenderId &&\n    previousUserMessageId &&\n    caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`] !==\n      undefined\n  ) {\n    cachedSnapshot =\n      caches.byStateRenderAndRun[`${stateRenderId}::pending:${previousUserMessageId}`];\n  }\n  if (\n    cachedSnapshot === undefined &&\n    !skipLatestCache &&\n    stateRenderId &&\n    messageRole !== \"assistant\" &&\n    (stateSnapshotProp !== undefined ||\n      (agentState && Object.keys(agentState).length > 0))\n  ) {\n    cachedSnapshot = caches.byStateRenderAndRun[`${stateRenderId}::latest`];\n  }\n\n  const snapshotForClaim = existingClaim?.locked\n    ? existingClaim.stateSnapshot ?? cachedSnapshot\n    : hasSnapshotKeys\n      ? snapshot\n      : existingClaim?.stateSnapshot ?? cachedSnapshot;\n\n  return { snapshot, hasSnapshotKeys, cachedSnapshot, allowEmptySnapshot, snapshotForClaim };\n}\n","import { useEffect } from \"react\";\nimport {\n  areStatesEquals,\n  ClaimAction,\n  getEffectiveRunId,\n  isPlaceholderMessageId,\n  isPlaceholderMessageName,\n  readCachedMessageEntry,\n  resolveClaim,\n  selectSnapshot,\n  type Claim,\n  type ClaimsByMessageId,\n  type SnapshotCaches,\n  type StateRenderContext,\n} from \"./use-coagent-state-render-bridge.helpers\";\n\nexport interface StateRenderRegistryInput {\n  agentId: string;\n  stateRenderId?: string;\n  message: { id: string; runId?: string; name?: string };\n  messageIndex?: number;\n  stateSnapshot?: any;\n  agentState?: any;\n  agentMessages?: Array<{ id: string; role?: string }>;\n  claimsRef: React.MutableRefObject<Record<string, Claim>>;\n}\n\nexport interface StateRenderRegistryResult {\n  canRender: boolean;\n}\n\nconst LAST_SNAPSHOTS_BY_RENDER_AND_RUN = \"__lastSnapshotsByStateRenderIdAndRun\";\nconst LAST_SNAPSHOTS_BY_MESSAGE = \"__lastSnapshotsByMessageId\";\n\ntype SnapshotByMessageEntry = { snapshot: any; runId?: string } | any;\ntype ClaimsStore = Record<string, Claim> & {\n  [LAST_SNAPSHOTS_BY_RENDER_AND_RUN]?: Record<string, any>;\n  [LAST_SNAPSHOTS_BY_MESSAGE]?: Record<string, SnapshotByMessageEntry>;\n};\n\nfunction getClaimsStore(\n  claimsRef: React.MutableRefObject<Record<string, Claim>>,\n): ClaimsStore {\n  return claimsRef.current as ClaimsStore;\n}\n\nfunction getSnapshotCaches(claimsRef: React.MutableRefObject<Record<string, Claim>>): SnapshotCaches {\n  const store = getClaimsStore(claimsRef);\n  return {\n    byStateRenderAndRun: store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {},\n    byMessageId: store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {},\n  };\n}\n\nexport function useStateRenderRegistry({\n  agentId,\n  stateRenderId,\n  message,\n  messageIndex,\n  stateSnapshot,\n  agentState,\n  agentMessages,\n  claimsRef,\n}: StateRenderRegistryInput): StateRenderRegistryResult {\n  const store = getClaimsStore(claimsRef);\n  const runId = message.runId;\n  const cachedMessageEntry = store[LAST_SNAPSHOTS_BY_MESSAGE]?.[message.id];\n  const { runId: cachedMessageRunId } = readCachedMessageEntry(cachedMessageEntry);\n  const existingClaimRunId = claimsRef.current[message.id]?.runId;\n  const effectiveRunId = getEffectiveRunId({\n    existingClaimRunId,\n    cachedMessageRunId,\n    runId,\n  });\n\n  useEffect(() => {\n    return () => {\n      const existingClaim = claimsRef.current[message.id];\n      if (\n        existingClaim?.stateSnapshot &&\n        Object.keys(existingClaim.stateSnapshot).length > 0\n      ) {\n        const snapshotCache = {\n          ...(store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {}),\n        };\n        const cacheKey = `${existingClaim.stateRenderId}::${existingClaim.runId ?? \"pending\"}`;\n        snapshotCache[cacheKey] = existingClaim.stateSnapshot;\n        snapshotCache[`${existingClaim.stateRenderId}::latest`] = existingClaim.stateSnapshot;\n        store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;\n\n        const messageCache = {\n          ...(store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {}),\n        };\n        messageCache[message.id] = {\n          snapshot: existingClaim.stateSnapshot,\n          runId: existingClaim.runId ?? effectiveRunId,\n        };\n        store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;\n      }\n      delete claimsRef.current[message.id];\n    };\n  }, [claimsRef, effectiveRunId, message.id]);\n\n  if (!stateRenderId) {\n    return { canRender: false };\n  }\n\n  const caches = getSnapshotCaches(claimsRef);\n  const existingClaim = claimsRef.current[message.id] as Claim | undefined;\n\n  const { snapshot, hasSnapshotKeys, allowEmptySnapshot, snapshotForClaim } = selectSnapshot({\n    messageId: message.id,\n    messageName: message.name,\n    allowLiveState:\n      isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),\n    skipLatestCache:\n      isPlaceholderMessageName(message.name) || isPlaceholderMessageId(message.id),\n    stateRenderId,\n    effectiveRunId,\n    stateSnapshotProp: stateSnapshot,\n    agentState,\n    agentMessages,\n    existingClaim,\n    caches,\n  });\n\n  const resolution = resolveClaim({\n    claims: claimsRef.current as ClaimsByMessageId,\n    context: {\n      agentId,\n      messageId: message.id,\n      stateRenderId,\n      runId: effectiveRunId,\n      messageIndex,\n    } satisfies StateRenderContext,\n    stateSnapshot: snapshotForClaim,\n  });\n\n  if (resolution.action === ClaimAction.Block) {\n    return { canRender: false };\n  }\n\n  if (resolution.updateRunId && claimsRef.current[message.id]) {\n    claimsRef.current[message.id].runId = resolution.updateRunId;\n  }\n\n  if (resolution.nextClaim) {\n    claimsRef.current[message.id] = resolution.nextClaim;\n  }\n\n  if (resolution.lockOthers) {\n    Object.entries(claimsRef.current).forEach(([id, claim]) => {\n      if (id !== message.id && claim.stateRenderId === stateRenderId) {\n        claim.locked = true;\n      }\n    });\n  }\n\n  if (existingClaim && !existingClaim.locked && agentMessages?.length) {\n    const indexInAgentMessages = agentMessages.findIndex((msg: any) => msg.id === message.id);\n    if (indexInAgentMessages >= 0 && indexInAgentMessages < agentMessages.length - 1) {\n      existingClaim.locked = true;\n    }\n  }\n\n  const existingSnapshot = claimsRef.current[message.id].stateSnapshot;\n  const snapshotChanged =\n    stateSnapshot &&\n    existingSnapshot !== undefined &&\n    !areStatesEquals(existingSnapshot, snapshot);\n\n  if (\n    snapshot &&\n    (stateSnapshot || hasSnapshotKeys || allowEmptySnapshot) &&\n    (!claimsRef.current[message.id].locked || snapshotChanged)\n  ) {\n    if (!claimsRef.current[message.id].locked || snapshotChanged) {\n      claimsRef.current[message.id].stateSnapshot = snapshot;\n      const snapshotCache = {\n        ...(store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {}),\n      };\n      const cacheKey = `${stateRenderId}::${effectiveRunId}`;\n      snapshotCache[cacheKey] = snapshot;\n      snapshotCache[`${stateRenderId}::latest`] = snapshot;\n      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;\n      const messageCache = {\n        ...(store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {}),\n      };\n      messageCache[message.id] = { snapshot, runId: effectiveRunId };\n      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;\n      if (stateSnapshot) {\n        claimsRef.current[message.id].locked = true;\n      }\n    }\n  } else if (snapshotForClaim) {\n    const existingSnapshot = claimsRef.current[message.id].stateSnapshot;\n    if (!existingSnapshot) {\n      claimsRef.current[message.id].stateSnapshot = snapshotForClaim;\n      const snapshotCache = {\n        ...(store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] ?? {}),\n      };\n      const cacheKey = `${stateRenderId}::${effectiveRunId}`;\n      snapshotCache[cacheKey] = snapshotForClaim;\n      snapshotCache[`${stateRenderId}::latest`] = snapshotForClaim;\n      store[LAST_SNAPSHOTS_BY_RENDER_AND_RUN] = snapshotCache;\n      const messageCache = {\n        ...(store[LAST_SNAPSHOTS_BY_MESSAGE] ?? {}),\n      };\n      messageCache[message.id] = { snapshot: snapshotForClaim, runId: effectiveRunId };\n      store[LAST_SNAPSHOTS_BY_MESSAGE] = messageCache;\n    }\n  }\n\n  return { canRender: true };\n}\n"],"mappings":"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","names":["import_react","React","import_react","import_react","import_jsx_runtime","import_jsx_runtime","ReactMarkdown","import_runtime_client_gql","import_react","import_jsx_runtime","import_react","import_shared","import_react","import_react","React","import_react","import_react","import_react","import_shared","import_shared","import_react","_a","_b","_c","_d","existingClaim","existingSnapshot","stateRenderId","stateRender","_a","agent","_a","_b","DeprecatedGqlMessage","suggestions"]}