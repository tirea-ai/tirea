"use client";

// src/index.ts
export * from "@ag-ui/client";

// src/components/chat/CopilotChatInput.tsx
import {
  useState as useState3,
  useRef as useRef2,
  useEffect as useEffect2,
  useLayoutEffect,
  forwardRef as forwardRef2,
  useImperativeHandle as useImperativeHandle2,
  useCallback as useCallback2,
  useMemo as useMemo2
} from "react";
import { twMerge as twMerge3 } from "tailwind-merge";
import { Plus, Mic, ArrowUp, X, Check, Square, Loader2 } from "lucide-react";

// src/providers/CopilotChatConfigurationProvider.tsx
import { createContext, useContext, useMemo, useState } from "react";
import { DEFAULT_AGENT_ID, randomUUID } from "@copilotkitnext/shared";
import { jsx } from "react/jsx-runtime";
var CopilotChatDefaultLabels = {
  chatInputPlaceholder: "Type a message...",
  chatInputToolbarStartTranscribeButtonLabel: "Transcribe",
  chatInputToolbarCancelTranscribeButtonLabel: "Cancel",
  chatInputToolbarFinishTranscribeButtonLabel: "Finish",
  chatInputToolbarAddButtonLabel: "Add photos or files",
  chatInputToolbarToolsButtonLabel: "Tools",
  assistantMessageToolbarCopyCodeLabel: "Copy",
  assistantMessageToolbarCopyCodeCopiedLabel: "Copied",
  assistantMessageToolbarCopyMessageLabel: "Copy",
  assistantMessageToolbarThumbsUpLabel: "Good response",
  assistantMessageToolbarThumbsDownLabel: "Bad response",
  assistantMessageToolbarReadAloudLabel: "Read aloud",
  assistantMessageToolbarRegenerateLabel: "Regenerate",
  userMessageToolbarCopyMessageLabel: "Copy",
  userMessageToolbarEditMessageLabel: "Edit",
  chatDisclaimerText: "AI can make mistakes. Please verify important information.",
  chatToggleOpenLabel: "Open chat",
  chatToggleCloseLabel: "Close chat",
  modalHeaderTitle: "CopilotKit Chat",
  welcomeMessageText: "How can I help you today?"
};
var CopilotChatConfiguration = createContext(null);
var CopilotChatConfigurationProvider = ({ children, labels, agentId, threadId, isModalDefaultOpen }) => {
  const parentConfig = useContext(CopilotChatConfiguration);
  const mergedLabels = useMemo(
    () => ({
      ...CopilotChatDefaultLabels,
      ...parentConfig?.labels ?? {},
      ...labels ?? {}
    }),
    [labels, parentConfig?.labels]
  );
  const resolvedAgentId = agentId ?? parentConfig?.agentId ?? DEFAULT_AGENT_ID;
  const resolvedThreadId = useMemo(() => {
    if (threadId) {
      return threadId;
    }
    if (parentConfig?.threadId) {
      return parentConfig.threadId;
    }
    return randomUUID();
  }, [threadId, parentConfig?.threadId]);
  const resolvedDefaultOpen = isModalDefaultOpen ?? parentConfig?.isModalDefaultOpen ?? true;
  const [internalModalOpen, setInternalModalOpen] = useState(
    parentConfig?.isModalOpen ?? resolvedDefaultOpen
  );
  const resolvedIsModalOpen = parentConfig?.isModalOpen ?? internalModalOpen;
  const resolvedSetModalOpen = parentConfig?.setModalOpen ?? setInternalModalOpen;
  const configurationValue = useMemo(
    () => ({
      labels: mergedLabels,
      agentId: resolvedAgentId,
      threadId: resolvedThreadId,
      isModalOpen: resolvedIsModalOpen,
      setModalOpen: resolvedSetModalOpen,
      isModalDefaultOpen: resolvedDefaultOpen
    }),
    [
      mergedLabels,
      resolvedAgentId,
      resolvedThreadId,
      resolvedIsModalOpen,
      resolvedSetModalOpen,
      resolvedDefaultOpen
    ]
  );
  return /* @__PURE__ */ jsx(CopilotChatConfiguration.Provider, { value: configurationValue, children });
};
var useCopilotChatConfiguration = () => {
  const configuration = useContext(CopilotChatConfiguration);
  return configuration;
};

// src/components/ui/button.tsx
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";

// src/lib/utils.ts
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";
function cn(...inputs) {
  return twMerge(clsx(inputs));
}

// src/components/ui/button.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 cursor-pointer",
        link: "text-primary underline-offset-4 hover:underline",
        assistantMessageToolbarButton: [
          "cursor-pointer",
          // Background and text
          "p-0 text-[rgb(93,93,93)] hover:bg-[#E8E8E8]",
          // Dark mode - lighter gray for better contrast
          "dark:text-[rgb(243,243,243)] dark:hover:bg-[#303030]",
          // Shape and sizing
          "h-8 w-8",
          // Interactions
          "transition-colors",
          // Hover states
          "hover:text-[rgb(93,93,93)]",
          "dark:hover:text-[rgb(243,243,243)]"
        ],
        chatInputToolbarPrimary: [
          "cursor-pointer",
          // Background and text
          "bg-black text-white",
          // Dark mode
          "dark:bg-white dark:text-black dark:focus-visible:outline-white",
          // Shape and sizing
          "rounded-full",
          // Interactions
          "transition-colors",
          // Focus states
          "focus:outline-none",
          // Hover states
          "hover:opacity-70 disabled:hover:opacity-100",
          // Disabled states
          "disabled:cursor-not-allowed disabled:bg-[#00000014] disabled:text-[rgb(13,13,13)]",
          "dark:disabled:bg-[#454545] dark:disabled:text-white "
        ],
        chatInputToolbarSecondary: [
          "cursor-pointer",
          // Background and text
          "bg-transparent text-[#444444]",
          // Dark mode
          "dark:text-white dark:border-[#404040]",
          // Shape and sizing
          "rounded-full",
          // Interactions
          "transition-colors",
          // Focus states
          "focus:outline-none",
          // Hover states
          "hover:bg-[#f8f8f8] hover:text-[#333333]",
          "dark:hover:bg-[#404040] dark:hover:text-[#FFFFFF]",
          // Disabled states
          "disabled:cursor-not-allowed disabled:opacity-50",
          "disabled:hover:bg-transparent disabled:hover:text-[#444444]",
          "dark:disabled:hover:bg-transparent dark:disabled:hover:text-[#CCCCCC]"
        ]
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        chatInputToolbarIcon: [
          // Shape and sizing
          "h-9 w-9 rounded-full"
        ],
        chatInputToolbarIconLabel: [
          // Shape and sizing
          "h-9 px-3 rounded-full",
          // Layout
          "gap-2",
          // Typography
          "font-normal"
        ]
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button";
  return /* @__PURE__ */ jsx2(
    Comp,
    {
      "data-slot": "button",
      className: cn(buttonVariants({ variant, size, className })),
      ...props
    }
  );
}

// src/components/ui/tooltip.tsx
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { jsx as jsx3, jsxs } from "react/jsx-runtime";
function TooltipProvider({
  delayDuration = 0,
  ...props
}) {
  return /* @__PURE__ */ jsx3(
    TooltipPrimitive.Provider,
    {
      "data-slot": "tooltip-provider",
      delayDuration,
      ...props
    }
  );
}
function Tooltip({
  ...props
}) {
  return /* @__PURE__ */ jsx3(TooltipProvider, { children: /* @__PURE__ */ jsx3(TooltipPrimitive.Root, { "data-slot": "tooltip", ...props }) });
}
function TooltipTrigger({
  ...props
}) {
  return /* @__PURE__ */ jsx3(TooltipPrimitive.Trigger, { "data-slot": "tooltip-trigger", ...props });
}
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsx3(TooltipPrimitive.Portal, { children: /* @__PURE__ */ jsxs(
    TooltipPrimitive.Content,
    {
      "data-slot": "tooltip-content",
      sideOffset,
      className: cn(
        "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx3(TooltipPrimitive.Arrow, { className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" })
      ]
    }
  ) });
}

// src/components/ui/dropdown-menu.tsx
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import { jsx as jsx4, jsxs as jsxs2 } from "react/jsx-runtime";
function DropdownMenu({
  ...props
}) {
  return /* @__PURE__ */ jsx4(DropdownMenuPrimitive.Root, { "data-slot": "dropdown-menu", ...props });
}
function DropdownMenuTrigger({
  ...props
}) {
  return /* @__PURE__ */ jsx4(
    DropdownMenuPrimitive.Trigger,
    {
      "data-slot": "dropdown-menu-trigger",
      ...props
    }
  );
}
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}) {
  return /* @__PURE__ */ jsx4(DropdownMenuPrimitive.Portal, { children: /* @__PURE__ */ jsx4(
    DropdownMenuPrimitive.Content,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset,
      className: cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        className
      ),
      ...props
    }
  ) });
}
function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}) {
  return /* @__PURE__ */ jsx4(
    DropdownMenuPrimitive.Item,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": inset,
      "data-variant": variant,
      className: cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      ),
      ...props
    }
  );
}
function DropdownMenuSeparator({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx4(
    DropdownMenuPrimitive.Separator,
    {
      "data-slot": "dropdown-menu-separator",
      className: cn("bg-border -mx-1 my-1 h-px", className),
      ...props
    }
  );
}
function DropdownMenuSub({
  ...props
}) {
  return /* @__PURE__ */ jsx4(DropdownMenuPrimitive.Sub, { "data-slot": "dropdown-menu-sub", ...props });
}
function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs2(
    DropdownMenuPrimitive.SubTrigger,
    {
      "data-slot": "dropdown-menu-sub-trigger",
      "data-inset": inset,
      className: cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx4(ChevronRightIcon, { className: "ml-auto size-4" })
      ]
    }
  );
}
function DropdownMenuSubContent({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx4(
    DropdownMenuPrimitive.SubContent,
    {
      "data-slot": "dropdown-menu-sub-content",
      className: cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      ),
      ...props
    }
  );
}

// src/components/chat/CopilotChatAudioRecorder.tsx
import { useRef, useEffect, useImperativeHandle, forwardRef, useCallback, useState as useState2 } from "react";
import { twMerge as twMerge2 } from "tailwind-merge";
import { jsx as jsx5 } from "react/jsx-runtime";
var AudioRecorderError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AudioRecorderError";
  }
};
var CopilotChatAudioRecorder = forwardRef((props, ref) => {
  const { className, ...divProps } = props;
  const canvasRef = useRef(null);
  const [recorderState, setRecorderState] = useState2("idle");
  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);
  const streamRef = useRef(null);
  const analyserRef = useRef(null);
  const audioContextRef = useRef(null);
  const animationIdRef = useRef(null);
  const amplitudeHistoryRef = useRef([]);
  const frameCountRef = useRef(0);
  const scrollOffsetRef = useRef(0);
  const smoothedAmplitudeRef = useRef(0);
  const fadeOpacityRef = useRef(0);
  const cleanup = useCallback(() => {
    if (animationIdRef.current) {
      cancelAnimationFrame(animationIdRef.current);
      animationIdRef.current = null;
    }
    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== "inactive") {
      try {
        mediaRecorderRef.current.stop();
      } catch {
      }
    }
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }
    if (audioContextRef.current && audioContextRef.current.state !== "closed") {
      audioContextRef.current.close().catch(() => {
      });
      audioContextRef.current = null;
    }
    mediaRecorderRef.current = null;
    analyserRef.current = null;
    audioChunksRef.current = [];
    amplitudeHistoryRef.current = [];
    frameCountRef.current = 0;
    scrollOffsetRef.current = 0;
    smoothedAmplitudeRef.current = 0;
    fadeOpacityRef.current = 0;
  }, []);
  const start = useCallback(async () => {
    if (recorderState !== "idle") {
      throw new AudioRecorderError("Recorder is already active");
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      const audioContext = new AudioContext();
      audioContextRef.current = audioContext;
      const source = audioContext.createMediaStreamSource(stream);
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);
      analyserRef.current = analyser;
      const mimeType = MediaRecorder.isTypeSupported("audio/webm;codecs=opus") ? "audio/webm;codecs=opus" : MediaRecorder.isTypeSupported("audio/webm") ? "audio/webm" : MediaRecorder.isTypeSupported("audio/mp4") ? "audio/mp4" : "";
      const options = mimeType ? { mimeType } : {};
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorderRef.current = mediaRecorder;
      audioChunksRef.current = [];
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunksRef.current.push(event.data);
        }
      };
      mediaRecorder.start(100);
      setRecorderState("recording");
    } catch (error) {
      cleanup();
      if (error instanceof Error && error.name === "NotAllowedError") {
        throw new AudioRecorderError("Microphone permission denied");
      }
      if (error instanceof Error && error.name === "NotFoundError") {
        throw new AudioRecorderError("No microphone found");
      }
      throw new AudioRecorderError(
        error instanceof Error ? error.message : "Failed to start recording"
      );
    }
  }, [recorderState, cleanup]);
  const stop = useCallback(() => {
    return new Promise((resolve, reject) => {
      const mediaRecorder = mediaRecorderRef.current;
      if (!mediaRecorder || recorderState !== "recording") {
        reject(new AudioRecorderError("No active recording"));
        return;
      }
      setRecorderState("processing");
      mediaRecorder.onstop = () => {
        const mimeType = mediaRecorder.mimeType || "audio/webm";
        const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });
        cleanup();
        setRecorderState("idle");
        resolve(audioBlob);
      };
      mediaRecorder.onerror = () => {
        cleanup();
        setRecorderState("idle");
        reject(new AudioRecorderError("Recording failed"));
      };
      mediaRecorder.stop();
    });
  }, [recorderState, cleanup]);
  const calculateAmplitude = (dataArray) => {
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const sample = (dataArray[i] ?? 128) / 128 - 1;
      sum += sample * sample;
    }
    return Math.sqrt(sum / dataArray.length);
  };
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const barWidth = 2;
    const barGap = 1;
    const barSpacing = barWidth + barGap;
    const scrollSpeed = 1 / 3;
    const draw = () => {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
      }
      const maxBars = Math.floor(rect.width / barSpacing) + 2;
      if (analyserRef.current && recorderState === "recording") {
        if (amplitudeHistoryRef.current.length === 0) {
          amplitudeHistoryRef.current = new Array(maxBars).fill(0);
        }
        if (fadeOpacityRef.current < 1) {
          fadeOpacityRef.current = Math.min(1, fadeOpacityRef.current + 0.03);
        }
        scrollOffsetRef.current += scrollSpeed;
        const bufferLength = analyserRef.current.fftSize;
        const dataArray = new Uint8Array(bufferLength);
        analyserRef.current.getByteTimeDomainData(dataArray);
        const rawAmplitude = calculateAmplitude(dataArray);
        const attackSpeed = 0.12;
        const decaySpeed = 0.08;
        const speed = rawAmplitude > smoothedAmplitudeRef.current ? attackSpeed : decaySpeed;
        smoothedAmplitudeRef.current += (rawAmplitude - smoothedAmplitudeRef.current) * speed;
        if (scrollOffsetRef.current >= barSpacing) {
          scrollOffsetRef.current -= barSpacing;
          amplitudeHistoryRef.current.push(smoothedAmplitudeRef.current);
          if (amplitudeHistoryRef.current.length > maxBars) {
            amplitudeHistoryRef.current = amplitudeHistoryRef.current.slice(-maxBars);
          }
        }
      }
      ctx.clearRect(0, 0, rect.width, rect.height);
      const computedStyle = getComputedStyle(canvas);
      ctx.fillStyle = computedStyle.color;
      ctx.globalAlpha = fadeOpacityRef.current;
      const centerY = rect.height / 2;
      const maxAmplitude = rect.height / 2 - 2;
      const history = amplitudeHistoryRef.current;
      if (history.length > 0) {
        const offset = scrollOffsetRef.current;
        const edgeFadeWidth = 12;
        for (let i = 0; i < history.length; i++) {
          const amplitude = history[i] ?? 0;
          const scaledAmplitude = Math.min(amplitude * 4, 1);
          const barHeight = Math.max(2, scaledAmplitude * maxAmplitude * 2);
          const x = rect.width - (history.length - i) * barSpacing - offset;
          const y = centerY - barHeight / 2;
          if (x + barWidth > 0 && x < rect.width) {
            let edgeOpacity = 1;
            if (x < edgeFadeWidth) {
              edgeOpacity = Math.max(0, x / edgeFadeWidth);
            } else if (x > rect.width - edgeFadeWidth) {
              edgeOpacity = Math.max(0, (rect.width - x) / edgeFadeWidth);
            }
            ctx.globalAlpha = fadeOpacityRef.current * edgeOpacity;
            ctx.fillRect(x, y, barWidth, barHeight);
          }
        }
      }
      animationIdRef.current = requestAnimationFrame(draw);
    };
    draw();
    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
    };
  }, [recorderState]);
  useEffect(() => {
    return cleanup;
  }, [cleanup]);
  useImperativeHandle(
    ref,
    () => ({
      get state() {
        return recorderState;
      },
      start,
      stop,
      dispose: cleanup
    }),
    [recorderState, start, stop, cleanup]
  );
  return /* @__PURE__ */ jsx5("div", { className: twMerge2("w-full py-3 px-5", className), ...divProps, children: /* @__PURE__ */ jsx5("canvas", { ref: canvasRef, className: "block w-full h-[26px]" }) });
});
CopilotChatAudioRecorder.displayName = "CopilotChatAudioRecorder";

// src/lib/slots.tsx
import React2 from "react";
function shallowEqual(obj1, obj2) {
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;
  for (const key of keys1) {
    if (obj1[key] !== obj2[key]) return false;
  }
  return true;
}
function renderSlotElement(slot, DefaultComponent, props) {
  if (typeof slot === "string") {
    return React2.createElement(DefaultComponent, {
      ...props,
      className: slot
    });
  }
  if (typeof slot === "function") {
    return React2.createElement(slot, props);
  }
  if (slot && typeof slot === "object" && !React2.isValidElement(slot)) {
    return React2.createElement(DefaultComponent, {
      ...props,
      ...slot
    });
  }
  return React2.createElement(DefaultComponent, props);
}
var MemoizedSlotWrapper = React2.memo(
  React2.forwardRef(function MemoizedSlotWrapper2(props, ref) {
    const { $slot, $component, ...rest } = props;
    const propsWithRef = ref !== null ? { ...rest, ref } : rest;
    return renderSlotElement($slot, $component, propsWithRef);
  }),
  (prev, next) => {
    if (prev.$slot !== next.$slot) return false;
    if (prev.$component !== next.$component) return false;
    const { $slot: _ps, $component: _pc, ...prevRest } = prev;
    const { $slot: _ns, $component: _nc, ...nextRest } = next;
    return shallowEqual(
      prevRest,
      nextRest
    );
  }
);
function renderSlot(slot, DefaultComponent, props) {
  return React2.createElement(MemoizedSlotWrapper, {
    ...props,
    $slot: slot,
    $component: DefaultComponent
  });
}

// src/components/chat/CopilotChatInput.tsx
import { Fragment, jsx as jsx6, jsxs as jsxs3 } from "react/jsx-runtime";
var SLASH_MENU_MAX_VISIBLE_ITEMS = 5;
var SLASH_MENU_ITEM_HEIGHT_PX = 40;
function CopilotChatInput({
  mode = "input",
  onSubmitMessage,
  onStop,
  isRunning = false,
  onStartTranscribe,
  onCancelTranscribe,
  onFinishTranscribe,
  onFinishTranscribeWithAudio,
  onAddFile,
  onChange,
  value,
  toolsMenu,
  autoFocus = true,
  textArea,
  sendButton,
  startTranscribeButton,
  cancelTranscribeButton,
  finishTranscribeButton,
  addMenuButton,
  audioRecorder,
  children,
  className,
  ...props
}) {
  const isControlled = value !== void 0;
  const [internalValue, setInternalValue] = useState3(() => value ?? "");
  useEffect2(() => {
    if (!isControlled && value !== void 0) {
      setInternalValue(value);
    }
  }, [isControlled, value]);
  const resolvedValue = isControlled ? value ?? "" : internalValue;
  const [layout, setLayout] = useState3("compact");
  const ignoreResizeRef = useRef2(false);
  const resizeEvaluationRafRef = useRef2(null);
  const isExpanded = mode === "input" && layout === "expanded";
  const [commandQuery, setCommandQuery] = useState3(null);
  const [slashHighlightIndex, setSlashHighlightIndex] = useState3(0);
  const inputRef = useRef2(null);
  const gridRef = useRef2(null);
  const addButtonContainerRef = useRef2(null);
  const actionsContainerRef = useRef2(null);
  const audioRecorderRef = useRef2(null);
  const slashMenuRef = useRef2(null);
  const config = useCopilotChatConfiguration();
  const labels = config?.labels ?? CopilotChatDefaultLabels;
  const previousModalStateRef = useRef2(void 0);
  const measurementCanvasRef = useRef2(null);
  const measurementsRef = useRef2({
    singleLineHeight: 0,
    maxHeight: 0,
    paddingLeft: 0,
    paddingRight: 0
  });
  const commandItems = useMemo2(() => {
    const entries = [];
    const seen = /* @__PURE__ */ new Set();
    const pushItem = (item) => {
      if (item === "-") {
        return;
      }
      if (item.items && item.items.length > 0) {
        for (const nested of item.items) {
          pushItem(nested);
        }
        return;
      }
      if (!seen.has(item.label)) {
        seen.add(item.label);
        entries.push(item);
      }
    };
    if (onAddFile) {
      pushItem({
        label: labels.chatInputToolbarAddButtonLabel,
        action: onAddFile
      });
    }
    if (toolsMenu && toolsMenu.length > 0) {
      for (const item of toolsMenu) {
        pushItem(item);
      }
    }
    return entries;
  }, [labels.chatInputToolbarAddButtonLabel, onAddFile, toolsMenu]);
  const filteredCommands = useMemo2(() => {
    if (commandQuery === null) {
      return [];
    }
    if (commandItems.length === 0) {
      return [];
    }
    const query = commandQuery.trim().toLowerCase();
    if (query.length === 0) {
      return commandItems;
    }
    const startsWith = [];
    const contains = [];
    for (const item of commandItems) {
      const label = item.label.toLowerCase();
      if (label.startsWith(query)) {
        startsWith.push(item);
      } else if (label.includes(query)) {
        contains.push(item);
      }
    }
    return [...startsWith, ...contains];
  }, [commandItems, commandQuery]);
  useEffect2(() => {
    if (!autoFocus) {
      previousModalStateRef.current = config?.isModalOpen;
      return;
    }
    if (config?.isModalOpen && !previousModalStateRef.current) {
      inputRef.current?.focus();
    }
    previousModalStateRef.current = config?.isModalOpen;
  }, [config?.isModalOpen, autoFocus]);
  useEffect2(() => {
    if (commandItems.length === 0 && commandQuery !== null) {
      setCommandQuery(null);
    }
  }, [commandItems.length, commandQuery]);
  const previousCommandQueryRef = useRef2(null);
  useEffect2(() => {
    if (commandQuery !== null && commandQuery !== previousCommandQueryRef.current && filteredCommands.length > 0) {
      setSlashHighlightIndex(0);
    }
    previousCommandQueryRef.current = commandQuery;
  }, [commandQuery, filteredCommands.length]);
  useEffect2(() => {
    if (commandQuery === null) {
      setSlashHighlightIndex(0);
      return;
    }
    if (filteredCommands.length === 0) {
      setSlashHighlightIndex(-1);
    } else if (slashHighlightIndex < 0 || slashHighlightIndex >= filteredCommands.length) {
      setSlashHighlightIndex(0);
    }
  }, [commandQuery, filteredCommands, slashHighlightIndex]);
  useEffect2(() => {
    const recorder = audioRecorderRef.current;
    if (!recorder) {
      return;
    }
    if (mode === "transcribe") {
      recorder.start().catch(console.error);
    } else {
      if (recorder.state === "recording") {
        recorder.stop().catch(console.error);
      }
    }
  }, [mode]);
  useEffect2(() => {
    if (mode !== "input") {
      setLayout("compact");
      setCommandQuery(null);
    }
  }, [mode]);
  const updateSlashState = useCallback2(
    (value2) => {
      if (commandItems.length === 0) {
        setCommandQuery((prev) => prev === null ? prev : null);
        return;
      }
      if (value2.startsWith("/")) {
        const firstLine = value2.split(/\r?\n/, 1)[0] ?? "";
        const query = firstLine.slice(1);
        setCommandQuery((prev) => prev === query ? prev : query);
      } else {
        setCommandQuery((prev) => prev === null ? prev : null);
      }
    },
    [commandItems.length]
  );
  useEffect2(() => {
    updateSlashState(resolvedValue);
  }, [resolvedValue, updateSlashState]);
  const handleChange = (e) => {
    const nextValue = e.target.value;
    if (!isControlled) {
      setInternalValue(nextValue);
    }
    onChange?.(nextValue);
    updateSlashState(nextValue);
  };
  const clearInputValue = useCallback2(() => {
    if (!isControlled) {
      setInternalValue("");
    }
    if (onChange) {
      onChange("");
    }
  }, [isControlled, onChange]);
  const runCommand = useCallback2(
    (item) => {
      clearInputValue();
      item.action?.();
      setCommandQuery(null);
      setSlashHighlightIndex(0);
      requestAnimationFrame(() => {
        inputRef.current?.focus();
      });
    },
    [clearInputValue]
  );
  const handleKeyDown = (e) => {
    if (commandQuery !== null && mode === "input") {
      if (e.key === "ArrowDown") {
        if (filteredCommands.length > 0) {
          e.preventDefault();
          setSlashHighlightIndex((prev) => {
            if (filteredCommands.length === 0) {
              return prev;
            }
            const next = prev === -1 ? 0 : (prev + 1) % filteredCommands.length;
            return next;
          });
        }
        return;
      }
      if (e.key === "ArrowUp") {
        if (filteredCommands.length > 0) {
          e.preventDefault();
          setSlashHighlightIndex((prev) => {
            if (filteredCommands.length === 0) {
              return prev;
            }
            if (prev === -1) {
              return filteredCommands.length - 1;
            }
            return prev <= 0 ? filteredCommands.length - 1 : prev - 1;
          });
        }
        return;
      }
      if (e.key === "Enter") {
        const selected = slashHighlightIndex >= 0 ? filteredCommands[slashHighlightIndex] : void 0;
        if (selected) {
          e.preventDefault();
          runCommand(selected);
          return;
        }
      }
      if (e.key === "Escape") {
        e.preventDefault();
        setCommandQuery(null);
        return;
      }
    }
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      if (isProcessing) {
        onStop?.();
      } else {
        send();
      }
    }
  };
  const send = () => {
    if (!onSubmitMessage) {
      return;
    }
    const trimmed = resolvedValue.trim();
    if (!trimmed) {
      return;
    }
    onSubmitMessage(trimmed);
    if (!isControlled) {
      setInternalValue("");
      onChange?.("");
    }
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  const BoundTextArea = renderSlot(textArea, CopilotChatInput.TextArea, {
    ref: inputRef,
    value: resolvedValue,
    onChange: handleChange,
    onKeyDown: handleKeyDown,
    autoFocus,
    className: twMerge3(
      "w-full py-3",
      isExpanded ? "px-5" : "pr-5"
    )
  });
  const isProcessing = mode !== "transcribe" && isRunning;
  const canSend = resolvedValue.trim().length > 0 && !!onSubmitMessage;
  const canStop = !!onStop;
  const handleSendButtonClick = () => {
    if (isProcessing) {
      onStop?.();
      return;
    }
    send();
  };
  const BoundAudioRecorder = renderSlot(audioRecorder, CopilotChatAudioRecorder, {
    ref: audioRecorderRef
  });
  const BoundSendButton = renderSlot(sendButton, CopilotChatInput.SendButton, {
    onClick: handleSendButtonClick,
    disabled: isProcessing ? !canStop : !canSend,
    children: isProcessing && canStop ? /* @__PURE__ */ jsx6(Square, { className: "size-[18px] fill-current" }) : void 0
  });
  const BoundStartTranscribeButton = renderSlot(startTranscribeButton, CopilotChatInput.StartTranscribeButton, {
    onClick: onStartTranscribe
  });
  const BoundCancelTranscribeButton = renderSlot(cancelTranscribeButton, CopilotChatInput.CancelTranscribeButton, {
    onClick: onCancelTranscribe
  });
  const handleFinishTranscribe = useCallback2(async () => {
    const recorder = audioRecorderRef.current;
    if (recorder && recorder.state === "recording") {
      try {
        const audioBlob = await recorder.stop();
        if (onFinishTranscribeWithAudio) {
          await onFinishTranscribeWithAudio(audioBlob);
        }
      } catch (error) {
        console.error("Failed to stop recording:", error);
      }
    }
    onFinishTranscribe?.();
  }, [onFinishTranscribe, onFinishTranscribeWithAudio]);
  const BoundFinishTranscribeButton = renderSlot(finishTranscribeButton, CopilotChatInput.FinishTranscribeButton, {
    onClick: handleFinishTranscribe
  });
  const BoundAddMenuButton = renderSlot(addMenuButton, CopilotChatInput.AddMenuButton, {
    disabled: mode === "transcribe",
    onAddFile,
    toolsMenu
  });
  if (children) {
    const childProps = {
      textArea: BoundTextArea,
      audioRecorder: BoundAudioRecorder,
      sendButton: BoundSendButton,
      startTranscribeButton: BoundStartTranscribeButton,
      cancelTranscribeButton: BoundCancelTranscribeButton,
      finishTranscribeButton: BoundFinishTranscribeButton,
      addMenuButton: BoundAddMenuButton,
      onSubmitMessage,
      onStop,
      isRunning,
      onStartTranscribe,
      onCancelTranscribe,
      onFinishTranscribe,
      onAddFile,
      mode,
      toolsMenu,
      autoFocus
    };
    return /* @__PURE__ */ jsx6(Fragment, { children: children(childProps) });
  }
  const handleContainerClick = (e) => {
    const target = e.target;
    if (target.tagName !== "BUTTON" && !target.closest("button") && inputRef.current && mode === "input") {
      inputRef.current.focus();
    }
  };
  const ensureMeasurements = useCallback2(() => {
    const textarea = inputRef.current;
    if (!textarea) {
      return;
    }
    const previousValue = textarea.value;
    const previousHeight = textarea.style.height;
    textarea.style.height = "auto";
    const computedStyle = window.getComputedStyle(textarea);
    const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
    const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
    const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
    const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
    textarea.value = "";
    const singleLineHeight = textarea.scrollHeight;
    textarea.value = previousValue;
    const contentHeight = singleLineHeight - paddingTop - paddingBottom;
    const maxHeight = contentHeight * 5 + paddingTop + paddingBottom;
    measurementsRef.current = {
      singleLineHeight,
      maxHeight,
      paddingLeft,
      paddingRight
    };
    textarea.style.height = previousHeight;
    textarea.style.maxHeight = `${maxHeight}px`;
  }, []);
  const adjustTextareaHeight = useCallback2(() => {
    const textarea = inputRef.current;
    if (!textarea) {
      return 0;
    }
    if (measurementsRef.current.singleLineHeight === 0) {
      ensureMeasurements();
    }
    const { maxHeight } = measurementsRef.current;
    if (maxHeight) {
      textarea.style.maxHeight = `${maxHeight}px`;
    }
    textarea.style.height = "auto";
    const scrollHeight = textarea.scrollHeight;
    if (maxHeight) {
      textarea.style.height = `${Math.min(scrollHeight, maxHeight)}px`;
    } else {
      textarea.style.height = `${scrollHeight}px`;
    }
    return scrollHeight;
  }, [ensureMeasurements]);
  const updateLayout = useCallback2((nextLayout) => {
    setLayout((prev) => {
      if (prev === nextLayout) {
        return prev;
      }
      ignoreResizeRef.current = true;
      return nextLayout;
    });
  }, []);
  const evaluateLayout = useCallback2(() => {
    if (mode !== "input") {
      updateLayout("compact");
      return;
    }
    if (typeof window !== "undefined" && typeof window.matchMedia === "function") {
      const isMobileViewport = window.matchMedia("(max-width: 767px)").matches;
      if (isMobileViewport) {
        ensureMeasurements();
        adjustTextareaHeight();
        updateLayout("expanded");
        return;
      }
    }
    const textarea = inputRef.current;
    const grid = gridRef.current;
    const addContainer = addButtonContainerRef.current;
    const actionsContainer = actionsContainerRef.current;
    if (!textarea || !grid || !addContainer || !actionsContainer) {
      return;
    }
    if (measurementsRef.current.singleLineHeight === 0) {
      ensureMeasurements();
    }
    const scrollHeight = adjustTextareaHeight();
    const baseline = measurementsRef.current.singleLineHeight;
    const hasExplicitBreak = resolvedValue.includes("\n");
    const renderedMultiline = baseline > 0 ? scrollHeight > baseline + 1 : false;
    let shouldExpand = hasExplicitBreak || renderedMultiline;
    if (!shouldExpand) {
      const gridStyles = window.getComputedStyle(grid);
      const paddingLeft = parseFloat(gridStyles.paddingLeft) || 0;
      const paddingRight = parseFloat(gridStyles.paddingRight) || 0;
      const columnGap = parseFloat(gridStyles.columnGap) || 0;
      const gridAvailableWidth = grid.clientWidth - paddingLeft - paddingRight;
      if (gridAvailableWidth > 0) {
        const addWidth = addContainer.getBoundingClientRect().width;
        const actionsWidth = actionsContainer.getBoundingClientRect().width;
        const compactWidth = Math.max(gridAvailableWidth - addWidth - actionsWidth - columnGap * 2, 0);
        const canvas = measurementCanvasRef.current ?? document.createElement("canvas");
        if (!measurementCanvasRef.current) {
          measurementCanvasRef.current = canvas;
        }
        const context = canvas.getContext("2d");
        if (context) {
          const textareaStyles = window.getComputedStyle(textarea);
          const font = textareaStyles.font || `${textareaStyles.fontStyle} ${textareaStyles.fontVariant} ${textareaStyles.fontWeight} ${textareaStyles.fontSize}/${textareaStyles.lineHeight} ${textareaStyles.fontFamily}`;
          context.font = font;
          const compactInnerWidth = Math.max(
            compactWidth - (measurementsRef.current.paddingLeft || 0) - (measurementsRef.current.paddingRight || 0),
            0
          );
          if (compactInnerWidth > 0) {
            const lines = resolvedValue.length > 0 ? resolvedValue.split("\n") : [""];
            let longestWidth = 0;
            for (const line of lines) {
              const metrics = context.measureText(line || " ");
              if (metrics.width > longestWidth) {
                longestWidth = metrics.width;
              }
            }
            if (longestWidth > compactInnerWidth) {
              shouldExpand = true;
            }
          }
        }
      }
    }
    const nextLayout = shouldExpand ? "expanded" : "compact";
    updateLayout(nextLayout);
  }, [adjustTextareaHeight, ensureMeasurements, mode, resolvedValue, updateLayout]);
  useLayoutEffect(() => {
    evaluateLayout();
  }, [evaluateLayout]);
  useEffect2(() => {
    if (typeof ResizeObserver === "undefined") {
      return;
    }
    const textarea = inputRef.current;
    const grid = gridRef.current;
    const addContainer = addButtonContainerRef.current;
    const actionsContainer = actionsContainerRef.current;
    if (!textarea || !grid || !addContainer || !actionsContainer) {
      return;
    }
    const scheduleEvaluation = () => {
      if (ignoreResizeRef.current) {
        ignoreResizeRef.current = false;
        return;
      }
      if (typeof window === "undefined") {
        evaluateLayout();
        return;
      }
      if (resizeEvaluationRafRef.current !== null) {
        cancelAnimationFrame(resizeEvaluationRafRef.current);
      }
      resizeEvaluationRafRef.current = window.requestAnimationFrame(() => {
        resizeEvaluationRafRef.current = null;
        evaluateLayout();
      });
    };
    const observer = new ResizeObserver(() => {
      scheduleEvaluation();
    });
    observer.observe(grid);
    observer.observe(addContainer);
    observer.observe(actionsContainer);
    observer.observe(textarea);
    return () => {
      observer.disconnect();
      if (typeof window !== "undefined" && resizeEvaluationRafRef.current !== null) {
        cancelAnimationFrame(resizeEvaluationRafRef.current);
        resizeEvaluationRafRef.current = null;
      }
    };
  }, [evaluateLayout]);
  const slashMenuVisible = commandQuery !== null && commandItems.length > 0;
  useEffect2(() => {
    if (!slashMenuVisible || slashHighlightIndex < 0) {
      return;
    }
    const active = slashMenuRef.current?.querySelector(
      `[data-slash-index="${slashHighlightIndex}"]`
    );
    active?.scrollIntoView({ block: "nearest" });
  }, [slashMenuVisible, slashHighlightIndex]);
  const slashMenu = slashMenuVisible ? /* @__PURE__ */ jsx6(
    "div",
    {
      "data-testid": "copilot-slash-menu",
      role: "listbox",
      "aria-label": "Slash commands",
      ref: slashMenuRef,
      className: "absolute bottom-full left-0 right-0 z-30 mb-2 max-h-64 overflow-y-auto rounded-lg border border-border bg-white shadow-lg dark:border-[#3a3a3a] dark:bg-[#1f1f1f]",
      style: { maxHeight: `${SLASH_MENU_MAX_VISIBLE_ITEMS * SLASH_MENU_ITEM_HEIGHT_PX}px` },
      children: filteredCommands.length === 0 ? /* @__PURE__ */ jsx6("div", { className: "px-3 py-2 text-sm text-muted-foreground", children: "No commands found" }) : filteredCommands.map((item, index) => {
        const isActive = index === slashHighlightIndex;
        return /* @__PURE__ */ jsx6(
          "button",
          {
            type: "button",
            role: "option",
            "aria-selected": isActive,
            "data-active": isActive ? "true" : void 0,
            "data-slash-index": index,
            className: twMerge3(
              "w-full px-3 py-2 text-left text-sm transition-colors",
              "hover:bg-muted dark:hover:bg-[#2f2f2f]",
              isActive ? "bg-muted dark:bg-[#2f2f2f]" : "bg-transparent"
            ),
            onMouseEnter: () => setSlashHighlightIndex(index),
            onMouseDown: (event) => {
              event.preventDefault();
              runCommand(item);
            },
            children: item.label
          },
          `${item.label}-${index}`
        );
      })
    }
  ) : null;
  return /* @__PURE__ */ jsx6(
    "div",
    {
      className: twMerge3(
        // Layout
        "flex w-full flex-col items-center justify-center",
        // Interaction
        "cursor-text",
        // Overflow and clipping
        "overflow-visible bg-clip-padding contain-inline-size",
        // Background
        "bg-white dark:bg-[#303030]",
        // Visual effects
        "shadow-[0_4px_4px_0_#0000000a,0_0_1px_0_#0000009e] rounded-[28px]",
        className
      ),
      onClick: handleContainerClick,
      ...props,
      "data-layout": isExpanded ? "expanded" : "compact",
      children: /* @__PURE__ */ jsxs3(
        "div",
        {
          ref: gridRef,
          className: twMerge3(
            "grid w-full gap-x-3 gap-y-3 px-3 py-2",
            isExpanded ? "grid-cols-[auto_minmax(0,1fr)_auto] grid-rows-[auto_auto]" : "grid-cols-[auto_minmax(0,1fr)_auto] items-center"
          ),
          "data-layout": isExpanded ? "expanded" : "compact",
          children: [
            /* @__PURE__ */ jsx6(
              "div",
              {
                ref: addButtonContainerRef,
                className: twMerge3(
                  "flex items-center",
                  isExpanded ? "row-start-2" : "row-start-1",
                  "col-start-1"
                ),
                children: BoundAddMenuButton
              }
            ),
            /* @__PURE__ */ jsx6(
              "div",
              {
                className: twMerge3(
                  "relative flex min-w-0 flex-col min-h-[50px] justify-center",
                  isExpanded ? "col-span-3 row-start-1" : "col-start-2 row-start-1"
                ),
                children: mode === "transcribe" ? BoundAudioRecorder : mode === "processing" ? /* @__PURE__ */ jsx6("div", { className: "flex w-full items-center justify-center py-3 px-5", children: /* @__PURE__ */ jsx6(Loader2, { className: "size-[26px] animate-spin text-muted-foreground" }) }) : /* @__PURE__ */ jsxs3(Fragment, { children: [
                  BoundTextArea,
                  slashMenu
                ] })
              }
            ),
            /* @__PURE__ */ jsx6(
              "div",
              {
                ref: actionsContainerRef,
                className: twMerge3(
                  "flex items-center justify-end gap-2",
                  isExpanded ? "col-start-3 row-start-2" : "col-start-3 row-start-1"
                ),
                children: mode === "transcribe" ? /* @__PURE__ */ jsxs3(Fragment, { children: [
                  onCancelTranscribe && BoundCancelTranscribeButton,
                  onFinishTranscribe && BoundFinishTranscribeButton
                ] }) : /* @__PURE__ */ jsxs3(Fragment, { children: [
                  onStartTranscribe && BoundStartTranscribeButton,
                  BoundSendButton
                ] })
              }
            )
          ]
        }
      )
    }
  );
}
((CopilotChatInput2) => {
  CopilotChatInput2.SendButton = ({ className, children, ...props }) => /* @__PURE__ */ jsx6("div", { className: "mr-[10px]", children: /* @__PURE__ */ jsx6(
    Button,
    {
      type: "button",
      variant: "chatInputToolbarPrimary",
      size: "chatInputToolbarIcon",
      className,
      ...props,
      children: children ?? /* @__PURE__ */ jsx6(ArrowUp, { className: "size-[18px]" })
    }
  ) });
  CopilotChatInput2.ToolbarButton = ({ icon, labelKey, defaultClassName, className, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsxs3(Tooltip, { children: [
      /* @__PURE__ */ jsx6(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsx6(
        Button,
        {
          type: "button",
          variant: "chatInputToolbarSecondary",
          size: "chatInputToolbarIcon",
          className: twMerge3(defaultClassName, className),
          ...props,
          children: icon
        }
      ) }),
      /* @__PURE__ */ jsx6(TooltipContent, { side: "bottom", children: /* @__PURE__ */ jsx6("p", { children: labels[labelKey] }) })
    ] });
  };
  CopilotChatInput2.StartTranscribeButton = (props) => /* @__PURE__ */ jsx6(
    CopilotChatInput2.ToolbarButton,
    {
      icon: /* @__PURE__ */ jsx6(Mic, { className: "size-[18px]" }),
      labelKey: "chatInputToolbarStartTranscribeButtonLabel",
      defaultClassName: "mr-2",
      ...props
    }
  );
  CopilotChatInput2.CancelTranscribeButton = (props) => /* @__PURE__ */ jsx6(
    CopilotChatInput2.ToolbarButton,
    {
      icon: /* @__PURE__ */ jsx6(X, { className: "size-[18px]" }),
      labelKey: "chatInputToolbarCancelTranscribeButtonLabel",
      defaultClassName: "mr-2",
      ...props
    }
  );
  CopilotChatInput2.FinishTranscribeButton = (props) => /* @__PURE__ */ jsx6(
    CopilotChatInput2.ToolbarButton,
    {
      icon: /* @__PURE__ */ jsx6(Check, { className: "size-[18px]" }),
      labelKey: "chatInputToolbarFinishTranscribeButtonLabel",
      defaultClassName: "mr-[10px]",
      ...props
    }
  );
  CopilotChatInput2.AddMenuButton = ({ className, toolsMenu, onAddFile, disabled, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    const menuItems = useMemo2(() => {
      const items = [];
      if (onAddFile) {
        items.push({
          label: labels.chatInputToolbarAddButtonLabel,
          action: onAddFile
        });
      }
      if (toolsMenu && toolsMenu.length > 0) {
        if (items.length > 0) {
          items.push("-");
        }
        for (const item of toolsMenu) {
          if (item === "-") {
            if (items.length === 0 || items[items.length - 1] === "-") {
              continue;
            }
            items.push(item);
          } else {
            items.push(item);
          }
        }
        while (items.length > 0 && items[items.length - 1] === "-") {
          items.pop();
        }
      }
      return items;
    }, [onAddFile, toolsMenu, labels.chatInputToolbarAddButtonLabel]);
    const renderMenuItems = useCallback2(
      (items) => items.map((item, index) => {
        if (item === "-") {
          return /* @__PURE__ */ jsx6(DropdownMenuSeparator, {}, `separator-${index}`);
        }
        if (item.items && item.items.length > 0) {
          return /* @__PURE__ */ jsxs3(DropdownMenuSub, { children: [
            /* @__PURE__ */ jsx6(DropdownMenuSubTrigger, { children: item.label }),
            /* @__PURE__ */ jsx6(DropdownMenuSubContent, { children: renderMenuItems(item.items) })
          ] }, `group-${index}`);
        }
        return /* @__PURE__ */ jsx6(DropdownMenuItem, { onClick: item.action, children: item.label }, `item-${index}`);
      }),
      []
    );
    const hasMenuItems = menuItems.length > 0;
    const isDisabled = disabled || !hasMenuItems;
    return /* @__PURE__ */ jsxs3(DropdownMenu, { children: [
      /* @__PURE__ */ jsxs3(Tooltip, { children: [
        /* @__PURE__ */ jsx6(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsx6(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsx6(
          Button,
          {
            type: "button",
            variant: "chatInputToolbarSecondary",
            size: "chatInputToolbarIcon",
            className: twMerge3("ml-1", className),
            disabled: isDisabled,
            ...props,
            children: /* @__PURE__ */ jsx6(Plus, { className: "size-[20px]" })
          }
        ) }) }),
        /* @__PURE__ */ jsx6(TooltipContent, { side: "bottom", children: /* @__PURE__ */ jsxs3("p", { className: "flex items-center gap-1 text-xs font-medium", children: [
          /* @__PURE__ */ jsx6("span", { children: "Add files and more" }),
          /* @__PURE__ */ jsx6("code", { className: "rounded bg-[#4a4a4a] px-1 py-[1px] font-mono text-[11px] text-white dark:bg-[#e0e0e0] dark:text-black", children: "/" })
        ] }) })
      ] }),
      hasMenuItems && /* @__PURE__ */ jsx6(DropdownMenuContent, { side: "top", align: "start", children: renderMenuItems(menuItems) })
    ] });
  };
  CopilotChatInput2.TextArea = forwardRef2(function TextArea2({ style, className, autoFocus, ...props }, ref) {
    const internalTextareaRef = useRef2(null);
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    useImperativeHandle2(ref, () => internalTextareaRef.current);
    useEffect2(() => {
      const textarea = internalTextareaRef.current;
      if (!textarea) return;
      const handleFocus = () => {
        setTimeout(() => {
          textarea.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }, 300);
      };
      textarea.addEventListener("focus", handleFocus);
      return () => textarea.removeEventListener("focus", handleFocus);
    }, []);
    useEffect2(() => {
      if (autoFocus) {
        internalTextareaRef.current?.focus();
      }
    }, [autoFocus]);
    return /* @__PURE__ */ jsx6(
      "textarea",
      {
        ref: internalTextareaRef,
        ...props,
        style: {
          overflow: "auto",
          resize: "none",
          ...style
        },
        placeholder: labels.chatInputPlaceholder,
        className: twMerge3(
          "bg-transparent outline-none antialiased font-regular leading-relaxed text-[16px] placeholder:text-[#00000077] dark:placeholder:text-[#fffc]",
          className
        ),
        rows: 1
      }
    );
  });
  CopilotChatInput2.AudioRecorder = CopilotChatAudioRecorder;
})(CopilotChatInput || (CopilotChatInput = {}));
CopilotChatInput.TextArea.displayName = "CopilotChatInput.TextArea";
CopilotChatInput.SendButton.displayName = "CopilotChatInput.SendButton";
CopilotChatInput.ToolbarButton.displayName = "CopilotChatInput.ToolbarButton";
CopilotChatInput.StartTranscribeButton.displayName = "CopilotChatInput.StartTranscribeButton";
CopilotChatInput.CancelTranscribeButton.displayName = "CopilotChatInput.CancelTranscribeButton";
CopilotChatInput.FinishTranscribeButton.displayName = "CopilotChatInput.FinishTranscribeButton";
CopilotChatInput.AddMenuButton.displayName = "CopilotChatInput.AddMenuButton";
var CopilotChatInput_default = CopilotChatInput;

// src/components/chat/CopilotChatAssistantMessage.tsx
import { useState as useState8 } from "react";
import {
  Copy,
  Check as Check2,
  ThumbsUp,
  ThumbsDown,
  Volume2,
  RefreshCw
} from "lucide-react";
import { twMerge as twMerge4 } from "tailwind-merge";
import "katex/dist/katex.min.css";
import { Streamdown } from "streamdown";

// src/hooks/use-render-tool-call.tsx
import React7, { useCallback as useCallback4, useMemo as useMemo4, useSyncExternalStore } from "react";
import { ToolCallStatus } from "@copilotkitnext/core";

// src/providers/CopilotKitProvider.tsx
import { createContext as createContext2, useContext as useContext2, useMemo as useMemo3, useEffect as useEffect5, useReducer, useRef as useRef4, useState as useState6 } from "react";
import { z as z2 } from "zod";

// src/lib/react-core.ts
import {
  CopilotKitCore
} from "@copilotkitnext/core";
var CopilotKitCoreReact = class extends CopilotKitCore {
  _renderToolCalls = [];
  _renderCustomMessages = [];
  _renderActivityMessages = [];
  constructor(config) {
    super(config);
    this._renderToolCalls = config.renderToolCalls ?? [];
    this._renderCustomMessages = config.renderCustomMessages ?? [];
    this._renderActivityMessages = config.renderActivityMessages ?? [];
  }
  get renderCustomMessages() {
    return this._renderCustomMessages;
  }
  get renderActivityMessages() {
    return this._renderActivityMessages;
  }
  get renderToolCalls() {
    return this._renderToolCalls;
  }
  setRenderToolCalls(renderToolCalls) {
    this._renderToolCalls = renderToolCalls;
    void this.notifySubscribers(
      (subscriber) => {
        const reactSubscriber = subscriber;
        if (reactSubscriber.onRenderToolCallsChanged) {
          reactSubscriber.onRenderToolCallsChanged({
            copilotkit: this,
            renderToolCalls: this.renderToolCalls
          });
        }
      },
      "Subscriber onRenderToolCallsChanged error:"
    );
  }
  // Override to accept React-specific subscriber type
  subscribe(subscriber) {
    return super.subscribe(subscriber);
  }
};

// src/components/CopilotKitInspector.tsx
import * as React4 from "react";
import { createComponent } from "@lit-labs/react";
import { jsx as jsx7 } from "react/jsx-runtime";
var CopilotKitInspector = ({ core, ...rest }) => {
  const [InspectorComponent, setInspectorComponent] = React4.useState(null);
  React4.useEffect(() => {
    let mounted = true;
    import("@copilotkitnext/web-inspector").then((mod) => {
      mod.defineWebInspector?.();
      const Component = createComponent({
        tagName: mod.WEB_INSPECTOR_TAG,
        elementClass: mod.WebInspectorElement,
        react: React4
      });
      if (mounted) {
        setInspectorComponent(() => Component);
      }
    });
    return () => {
      mounted = false;
    };
  }, []);
  if (!InspectorComponent) return null;
  return /* @__PURE__ */ jsx7(InspectorComponent, { ...rest, core: core ?? null });
};
CopilotKitInspector.displayName = "CopilotKitInspector";

// src/components/MCPAppsActivityRenderer.tsx
import { useEffect as useEffect4, useRef as useRef3, useState as useState5, useCallback as useCallback3 } from "react";
import { z } from "zod";
import { jsx as jsx8, jsxs as jsxs4 } from "react/jsx-runtime";
var PROTOCOL_VERSION = "2025-06-18";
var SANDBOX_HTML = `<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src * data: blob: 'unsafe-inline'; media-src * blob: data:; font-src * blob: data:; script-src 'self' 'wasm-unsafe-eval' 'unsafe-inline' 'unsafe-eval' blob: data: http://localhost:* https://localhost:*; style-src * blob: data: 'unsafe-inline'; connect-src *; frame-src * blob: data: http://localhost:* https://localhost:*; base-uri 'self';" />
<style>html,body{margin:0;padding:0;height:100%;width:100%;overflow:hidden}*{box-sizing:border-box}iframe{background-color:transparent;border:none;padding:0;overflow:hidden;width:100%;height:100%}</style>
</head>
<body>
<script>
if(window.self===window.top){throw new Error("This file must be used in an iframe.")}
const inner=document.createElement("iframe");
inner.style="width:100%;height:100%;border:none;";
inner.setAttribute("sandbox","allow-scripts allow-same-origin allow-forms");
document.body.appendChild(inner);
window.addEventListener("message",async(event)=>{
if(event.source===window.parent){
if(event.data&&event.data.method==="ui/notifications/sandbox-resource-ready"){
const{html,sandbox}=event.data.params;
if(typeof sandbox==="string")inner.setAttribute("sandbox",sandbox);
if(typeof html==="string")inner.srcdoc=html;
}else if(inner&&inner.contentWindow){
inner.contentWindow.postMessage(event.data,"*");
}
}else if(event.source===inner.contentWindow){
window.parent.postMessage(event.data,"*");
}
});
window.parent.postMessage({jsonrpc:"2.0",method:"ui/notifications/sandbox-proxy-ready",params:{}},"*");
</script>
</body>
</html>`;
var MCPAppsRequestQueue = class {
  queues = /* @__PURE__ */ new Map();
  processing = /* @__PURE__ */ new Map();
  /**
   * Add a request to the queue for a specific agent thread.
   * Returns a promise that resolves when the request completes.
   */
  async enqueue(agent, request) {
    const threadId = agent.threadId || "default";
    return new Promise((resolve, reject) => {
      let queue = this.queues.get(threadId);
      if (!queue) {
        queue = [];
        this.queues.set(threadId, queue);
      }
      queue.push({ execute: request, resolve, reject });
      this.processQueue(threadId, agent);
    });
  }
  async processQueue(threadId, agent) {
    if (this.processing.get(threadId)) {
      return;
    }
    this.processing.set(threadId, true);
    try {
      const queue = this.queues.get(threadId);
      if (!queue) return;
      while (queue.length > 0) {
        const item = queue[0];
        try {
          await this.waitForAgentIdle(agent);
          const result = await item.execute();
          item.resolve(result);
        } catch (error) {
          item.reject(error instanceof Error ? error : new Error(String(error)));
        }
        queue.shift();
      }
    } finally {
      this.processing.set(threadId, false);
    }
  }
  waitForAgentIdle(agent) {
    return new Promise((resolve) => {
      if (!agent.isRunning) {
        resolve();
        return;
      }
      let done = false;
      const finish = () => {
        if (done) return;
        done = true;
        clearInterval(checkInterval);
        sub.unsubscribe();
        resolve();
      };
      const sub = agent.subscribe({
        onRunFinalized: finish,
        onRunFailed: finish
      });
      const checkInterval = setInterval(() => {
        if (!agent.isRunning) finish();
      }, 500);
    });
  }
};
var mcpAppsRequestQueue = new MCPAppsRequestQueue();
var MCPAppsActivityType = "mcp-apps";
var MCPAppsActivityContentSchema = z.object({
  result: z.object({
    content: z.array(z.any()).optional(),
    structuredContent: z.any().optional(),
    isError: z.boolean().optional()
  }),
  // Resource URI to fetch (e.g., "ui://server/dashboard")
  resourceUri: z.string(),
  // MD5 hash of server config (renamed from serverId in 0.0.1)
  serverHash: z.string(),
  // Optional stable server ID from config (takes precedence over serverHash)
  serverId: z.string().optional(),
  // Original tool input arguments
  toolInput: z.record(z.unknown()).optional()
});
function isRequest(msg) {
  return "id" in msg && "method" in msg;
}
function isNotification(msg) {
  return !("id" in msg) && "method" in msg;
}
var MCPAppsActivityRenderer = function MCPAppsActivityRenderer2({ content, agent }) {
  const containerRef = useRef3(null);
  const iframeRef = useRef3(null);
  const [iframeReady, setIframeReady] = useState5(false);
  const [error, setError] = useState5(null);
  const [isLoading, setIsLoading] = useState5(true);
  const [iframeSize, setIframeSize] = useState5({});
  const [fetchedResource, setFetchedResource] = useState5(null);
  const contentRef = useRef3(content);
  contentRef.current = content;
  const agentRef = useRef3(agent);
  agentRef.current = agent;
  const fetchStateRef = useRef3({ inProgress: false, promise: null, resourceUri: null });
  const sendToIframe = useCallback3((msg) => {
    if (iframeRef.current?.contentWindow) {
      console.log("[MCPAppsRenderer] Sending to iframe:", msg);
      iframeRef.current.contentWindow.postMessage(msg, "*");
    }
  }, []);
  const sendResponse = useCallback3((id, result) => {
    sendToIframe({
      jsonrpc: "2.0",
      id,
      result
    });
  }, [sendToIframe]);
  const sendErrorResponse = useCallback3((id, code, message) => {
    sendToIframe({
      jsonrpc: "2.0",
      id,
      error: { code, message }
    });
  }, [sendToIframe]);
  const sendNotification = useCallback3((method, params) => {
    sendToIframe({
      jsonrpc: "2.0",
      method,
      params: params || {}
    });
  }, [sendToIframe]);
  useEffect4(() => {
    const { resourceUri, serverHash, serverId } = content;
    if (fetchStateRef.current.inProgress && fetchStateRef.current.resourceUri === resourceUri) {
      fetchStateRef.current.promise?.then((resource) => {
        if (resource) {
          setFetchedResource(resource);
          setIsLoading(false);
        }
      }).catch((err) => {
        setError(err instanceof Error ? err : new Error(String(err)));
        setIsLoading(false);
      });
      return;
    }
    if (!agent) {
      setError(new Error("No agent available to fetch resource"));
      setIsLoading(false);
      return;
    }
    fetchStateRef.current.inProgress = true;
    fetchStateRef.current.resourceUri = resourceUri;
    const fetchPromise = (async () => {
      try {
        const runResult = await mcpAppsRequestQueue.enqueue(
          agent,
          () => agent.runAgent({
            forwardedProps: {
              __proxiedMCPRequest: {
                serverHash,
                serverId,
                // optional, takes precedence if provided
                method: "resources/read",
                params: { uri: resourceUri }
              }
            }
          })
        );
        const resultData = runResult.result;
        const resource = resultData?.contents?.[0];
        if (!resource) {
          throw new Error("No resource content in response");
        }
        return resource;
      } catch (err) {
        console.error("[MCPAppsRenderer] Failed to fetch resource:", err);
        throw err;
      } finally {
        fetchStateRef.current.inProgress = false;
      }
    })();
    fetchStateRef.current.promise = fetchPromise;
    fetchPromise.then((resource) => {
      if (resource) {
        setFetchedResource(resource);
        setIsLoading(false);
      }
    }).catch((err) => {
      setError(err instanceof Error ? err : new Error(String(err)));
      setIsLoading(false);
    });
  }, [agent, content]);
  useEffect4(() => {
    if (isLoading || !fetchedResource) {
      return;
    }
    const container = containerRef.current;
    if (!container) {
      return;
    }
    let mounted = true;
    let messageHandler = null;
    let initialListener = null;
    let createdIframe = null;
    const setup = async () => {
      try {
        const iframe = document.createElement("iframe");
        createdIframe = iframe;
        iframe.style.width = "100%";
        iframe.style.height = "100px";
        iframe.style.border = "none";
        iframe.style.backgroundColor = "transparent";
        iframe.style.display = "block";
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
        const sandboxReady = new Promise((resolve) => {
          initialListener = (event) => {
            if (event.source === iframe.contentWindow) {
              if (event.data?.method === "ui/notifications/sandbox-proxy-ready") {
                if (initialListener) {
                  window.removeEventListener("message", initialListener);
                  initialListener = null;
                }
                resolve();
              }
            }
          };
          window.addEventListener("message", initialListener);
        });
        if (!mounted) {
          if (initialListener) {
            window.removeEventListener("message", initialListener);
            initialListener = null;
          }
          return;
        }
        iframe.srcdoc = SANDBOX_HTML;
        iframeRef.current = iframe;
        container.appendChild(iframe);
        await sandboxReady;
        if (!mounted) return;
        console.log("[MCPAppsRenderer] Sandbox proxy ready");
        messageHandler = async (event) => {
          if (event.source !== iframe.contentWindow) return;
          const msg = event.data;
          if (!msg || typeof msg !== "object" || msg.jsonrpc !== "2.0") return;
          console.log("[MCPAppsRenderer] Received from iframe:", msg);
          if (isRequest(msg)) {
            switch (msg.method) {
              case "ui/initialize": {
                sendResponse(msg.id, {
                  protocolVersion: PROTOCOL_VERSION,
                  hostInfo: {
                    name: "CopilotKit MCP Apps Host",
                    version: "1.0.0"
                  },
                  hostCapabilities: {
                    openLinks: {},
                    logging: {}
                  },
                  hostContext: {
                    theme: "light",
                    platform: "web"
                  }
                });
                break;
              }
              case "ui/message": {
                const currentAgent = agentRef.current;
                if (!currentAgent) {
                  console.warn("[MCPAppsRenderer] ui/message: No agent available");
                  sendResponse(msg.id, { isError: false });
                  break;
                }
                try {
                  const params = msg.params;
                  const textContent = params.content?.filter((c) => c.type === "text" && c.text).map((c) => c.text).join("\n") || "";
                  if (textContent) {
                    currentAgent.addMessage({
                      id: crypto.randomUUID(),
                      role: params.role || "user",
                      content: textContent
                    });
                  }
                  sendResponse(msg.id, { isError: false });
                } catch (err) {
                  console.error("[MCPAppsRenderer] ui/message error:", err);
                  sendResponse(msg.id, { isError: true });
                }
                break;
              }
              case "ui/open-link": {
                const url = msg.params?.url;
                if (url) {
                  window.open(url, "_blank", "noopener,noreferrer");
                  sendResponse(msg.id, { isError: false });
                } else {
                  sendErrorResponse(msg.id, -32602, "Missing url parameter");
                }
                break;
              }
              case "tools/call": {
                const { serverHash, serverId } = contentRef.current;
                const currentAgent = agentRef.current;
                if (!serverHash) {
                  sendErrorResponse(msg.id, -32603, "No server hash available for proxying");
                  break;
                }
                if (!currentAgent) {
                  sendErrorResponse(msg.id, -32603, "No agent available for proxying");
                  break;
                }
                try {
                  const runResult = await mcpAppsRequestQueue.enqueue(
                    currentAgent,
                    () => currentAgent.runAgent({
                      forwardedProps: {
                        __proxiedMCPRequest: {
                          serverHash,
                          serverId,
                          // optional, takes precedence if provided
                          method: "tools/call",
                          params: msg.params
                        }
                      }
                    })
                  );
                  sendResponse(msg.id, runResult.result || {});
                } catch (err) {
                  console.error("[MCPAppsRenderer] tools/call error:", err);
                  sendErrorResponse(msg.id, -32603, String(err));
                }
                break;
              }
              default:
                sendErrorResponse(msg.id, -32601, `Method not found: ${msg.method}`);
            }
          }
          if (isNotification(msg)) {
            switch (msg.method) {
              case "ui/notifications/initialized": {
                console.log("[MCPAppsRenderer] Inner iframe initialized");
                if (mounted) {
                  setIframeReady(true);
                }
                break;
              }
              case "ui/notifications/size-changed": {
                const { width, height } = msg.params || {};
                console.log("[MCPAppsRenderer] Size change:", { width, height });
                if (mounted) {
                  setIframeSize({
                    width: typeof width === "number" ? width : void 0,
                    height: typeof height === "number" ? height : void 0
                  });
                }
                break;
              }
              case "notifications/message": {
                console.log("[MCPAppsRenderer] App log:", msg.params);
                break;
              }
            }
          }
        };
        window.addEventListener("message", messageHandler);
        let html;
        if (fetchedResource.text) {
          html = fetchedResource.text;
        } else if (fetchedResource.blob) {
          html = atob(fetchedResource.blob);
        } else {
          throw new Error("Resource has no text or blob content");
        }
        sendNotification("ui/notifications/sandbox-resource-ready", { html });
      } catch (err) {
        console.error("[MCPAppsRenderer] Setup error:", err);
        if (mounted) {
          setError(err instanceof Error ? err : new Error(String(err)));
        }
      }
    };
    setup();
    return () => {
      mounted = false;
      if (initialListener) {
        window.removeEventListener("message", initialListener);
        initialListener = null;
      }
      if (messageHandler) {
        window.removeEventListener("message", messageHandler);
      }
      if (createdIframe) {
        createdIframe.remove();
        createdIframe = null;
      }
      iframeRef.current = null;
    };
  }, [isLoading, fetchedResource, sendNotification, sendResponse, sendErrorResponse]);
  useEffect4(() => {
    if (iframeRef.current) {
      if (iframeSize.width !== void 0) {
        iframeRef.current.style.minWidth = `min(${iframeSize.width}px, 100%)`;
        iframeRef.current.style.width = "100%";
      }
      if (iframeSize.height !== void 0) {
        iframeRef.current.style.height = `${iframeSize.height}px`;
      }
    }
  }, [iframeSize]);
  useEffect4(() => {
    if (iframeReady && content.toolInput) {
      console.log("[MCPAppsRenderer] Sending tool input:", content.toolInput);
      sendNotification("ui/notifications/tool-input", {
        arguments: content.toolInput
      });
    }
  }, [iframeReady, content.toolInput, sendNotification]);
  useEffect4(() => {
    if (iframeReady && content.result) {
      console.log("[MCPAppsRenderer] Sending tool result:", content.result);
      sendNotification("ui/notifications/tool-result", content.result);
    }
  }, [iframeReady, content.result, sendNotification]);
  const prefersBorder = fetchedResource?._meta?.ui?.prefersBorder;
  const borderStyle = prefersBorder === true ? {
    borderRadius: "8px",
    backgroundColor: "#f9f9f9",
    border: "1px solid #e0e0e0"
  } : {};
  return /* @__PURE__ */ jsxs4(
    "div",
    {
      ref: containerRef,
      style: {
        width: "100%",
        height: iframeSize.height ? `${iframeSize.height}px` : "auto",
        minHeight: "100px",
        overflow: "hidden",
        position: "relative",
        ...borderStyle
      },
      children: [
        isLoading && /* @__PURE__ */ jsx8("div", { style: { padding: "1rem", color: "#666" }, children: "Loading..." }),
        error && /* @__PURE__ */ jsxs4("div", { style: { color: "red", padding: "1rem" }, children: [
          "Error: ",
          error.message
        ] })
      ]
    }
  );
};

// src/providers/CopilotKitProvider.tsx
import { jsx as jsx9, jsxs as jsxs5 } from "react/jsx-runtime";
var HEADER_NAME = "X-CopilotCloud-Public-Api-Key";
var COPILOT_CLOUD_CHAT_URL = "https://api.cloud.copilotkit.ai/copilotkit/v1";
var EMPTY_SET = /* @__PURE__ */ new Set();
var CopilotKitContext = createContext2({
  copilotkit: null,
  executingToolCallIds: EMPTY_SET
});
function useStableArrayProp(prop, warningMessage, isMeaningfulChange) {
  const empty = useMemo3(() => [], []);
  const value = prop ?? empty;
  const initial = useRef4(value);
  useEffect5(() => {
    if (warningMessage && value !== initial.current && (isMeaningfulChange ? isMeaningfulChange(initial.current, value) : true)) {
      console.error(warningMessage);
    }
  }, [value, warningMessage]);
  return value;
}
var CopilotKitProvider = ({
  children,
  runtimeUrl,
  headers = {},
  credentials,
  publicApiKey,
  publicLicenseKey,
  properties = {},
  agents__unsafe_dev_only: agents = {},
  renderToolCalls,
  renderActivityMessages,
  renderCustomMessages,
  frontendTools,
  humanInTheLoop,
  showDevConsole = false,
  useSingleEndpoint = false
}) => {
  const [shouldRenderInspector, setShouldRenderInspector] = useState6(false);
  useEffect5(() => {
    if (typeof window === "undefined") {
      return;
    }
    if (showDevConsole === true) {
      setShouldRenderInspector(true);
    } else if (showDevConsole === "auto") {
      const localhostHosts = /* @__PURE__ */ new Set(["localhost", "127.0.0.1"]);
      if (localhostHosts.has(window.location.hostname)) {
        setShouldRenderInspector(true);
      } else {
        setShouldRenderInspector(false);
      }
    } else {
      setShouldRenderInspector(false);
    }
  }, [showDevConsole]);
  const renderToolCallsList = useStableArrayProp(
    renderToolCalls,
    "renderToolCalls must be a stable array. If you want to dynamically add or remove tools, use `useFrontendTool` instead.",
    (initial, next) => {
      const key = (rc) => `${rc?.agentId ?? ""}:${rc?.name ?? ""}`;
      const setFrom = (arr) => new Set(arr.map(key));
      const a = setFrom(initial);
      const b = setFrom(next);
      if (a.size !== b.size) return true;
      for (const k of a) if (!b.has(k)) return true;
      return false;
    }
  );
  const renderCustomMessagesList = useStableArrayProp(
    renderCustomMessages,
    "renderCustomMessages must be a stable array."
  );
  const renderActivityMessagesList = useStableArrayProp(
    renderActivityMessages,
    "renderActivityMessages must be a stable array."
  );
  const builtInActivityRenderers = useMemo3(() => [
    {
      activityType: MCPAppsActivityType,
      content: MCPAppsActivityContentSchema,
      render: MCPAppsActivityRenderer
    }
  ], []);
  const allActivityRenderers = useMemo3(() => {
    return [...renderActivityMessagesList, ...builtInActivityRenderers];
  }, [renderActivityMessagesList, builtInActivityRenderers]);
  const resolvedPublicKey = publicApiKey ?? publicLicenseKey;
  const hasLocalAgents = agents && Object.keys(agents).length > 0;
  const mergedHeaders = useMemo3(() => {
    if (!resolvedPublicKey) return headers;
    if (headers[HEADER_NAME]) return headers;
    return {
      ...headers,
      [HEADER_NAME]: resolvedPublicKey
    };
  }, [headers, resolvedPublicKey]);
  if (!runtimeUrl && !resolvedPublicKey && !hasLocalAgents) {
    const message = "Missing required prop: 'runtimeUrl' or 'publicApiKey' or 'publicLicenseKey'";
    if (process.env.NODE_ENV === "production") {
      throw new Error(message);
    } else {
      console.warn(message);
    }
  }
  const chatApiEndpoint = runtimeUrl ?? (resolvedPublicKey ? COPILOT_CLOUD_CHAT_URL : void 0);
  const frontendToolsList = useStableArrayProp(
    frontendTools,
    "frontendTools must be a stable array. If you want to dynamically add or remove tools, use `useFrontendTool` instead."
  );
  const humanInTheLoopList = useStableArrayProp(
    humanInTheLoop,
    "humanInTheLoop must be a stable array. If you want to dynamically add or remove human-in-the-loop tools, use `useHumanInTheLoop` instead."
  );
  const processedHumanInTheLoopTools = useMemo3(() => {
    const processedTools = [];
    const processedRenderToolCalls = [];
    humanInTheLoopList.forEach((tool) => {
      const frontendTool = {
        name: tool.name,
        description: tool.description,
        parameters: tool.parameters,
        followUp: tool.followUp,
        ...tool.agentId && { agentId: tool.agentId },
        handler: async () => {
          return new Promise((resolve) => {
            console.warn(`Human-in-the-loop tool '${tool.name}' called but no interactive handler is set up.`);
            resolve(void 0);
          });
        }
      };
      processedTools.push(frontendTool);
      if (tool.render) {
        processedRenderToolCalls.push({
          name: tool.name,
          args: tool.parameters,
          render: tool.render,
          ...tool.agentId && { agentId: tool.agentId }
        });
      }
    });
    return { tools: processedTools, renderToolCalls: processedRenderToolCalls };
  }, [humanInTheLoopList]);
  const allTools = useMemo3(() => {
    const tools = [];
    tools.push(...frontendToolsList);
    tools.push(...processedHumanInTheLoopTools.tools);
    return tools;
  }, [frontendToolsList, processedHumanInTheLoopTools]);
  const allRenderToolCalls = useMemo3(() => {
    const combined = [...renderToolCallsList];
    frontendToolsList.forEach((tool) => {
      if (tool.render) {
        const args = tool.parameters || (tool.name === "*" ? z2.any() : void 0);
        if (args) {
          combined.push({
            name: tool.name,
            args,
            render: tool.render
          });
        }
      }
    });
    combined.push(...processedHumanInTheLoopTools.renderToolCalls);
    return combined;
  }, [renderToolCallsList, frontendToolsList, processedHumanInTheLoopTools]);
  const copilotkit = useMemo3(() => {
    const copilotkit2 = new CopilotKitCoreReact({
      runtimeUrl: chatApiEndpoint,
      runtimeTransport: useSingleEndpoint ? "single" : "rest",
      headers: mergedHeaders,
      credentials,
      properties,
      agents__unsafe_dev_only: agents,
      tools: allTools,
      renderToolCalls: allRenderToolCalls,
      renderActivityMessages: allActivityRenderers,
      renderCustomMessages: renderCustomMessagesList
    });
    return copilotkit2;
  }, [allTools, allRenderToolCalls, allActivityRenderers, renderCustomMessagesList, useSingleEndpoint]);
  const [, forceUpdate] = useReducer((x) => x + 1, 0);
  useEffect5(() => {
    const subscription = copilotkit.subscribe({
      onRenderToolCallsChanged: () => {
        forceUpdate();
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [copilotkit]);
  const [executingToolCallIds, setExecutingToolCallIds] = useState6(() => /* @__PURE__ */ new Set());
  useEffect5(() => {
    const subscription = copilotkit.subscribe({
      onToolExecutionStart: ({ toolCallId }) => {
        setExecutingToolCallIds((prev) => {
          if (prev.has(toolCallId)) return prev;
          const next = new Set(prev);
          next.add(toolCallId);
          return next;
        });
      },
      onToolExecutionEnd: ({ toolCallId }) => {
        setExecutingToolCallIds((prev) => {
          if (!prev.has(toolCallId)) return prev;
          const next = new Set(prev);
          next.delete(toolCallId);
          return next;
        });
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [copilotkit]);
  useEffect5(() => {
    copilotkit.setRuntimeUrl(chatApiEndpoint);
    copilotkit.setRuntimeTransport(useSingleEndpoint ? "single" : "rest");
    copilotkit.setHeaders(mergedHeaders);
    copilotkit.setCredentials(credentials);
    copilotkit.setProperties(properties);
    copilotkit.setAgents__unsafe_dev_only(agents);
  }, [chatApiEndpoint, mergedHeaders, credentials, properties, agents, useSingleEndpoint]);
  return /* @__PURE__ */ jsxs5(
    CopilotKitContext.Provider,
    {
      value: {
        copilotkit,
        executingToolCallIds
      },
      children: [
        children,
        shouldRenderInspector ? /* @__PURE__ */ jsx9(CopilotKitInspector, { core: copilotkit }) : null
      ]
    }
  );
};
var useCopilotKit = () => {
  const context = useContext2(CopilotKitContext);
  const [, forceUpdate] = useReducer((x) => x + 1, 0);
  if (!context) {
    throw new Error("useCopilotKit must be used within CopilotKitProvider");
  }
  useEffect5(() => {
    const subscription = context.copilotkit.subscribe({
      onRuntimeConnectionStatusChanged: () => {
        forceUpdate();
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  return context;
};

// src/hooks/use-render-tool-call.tsx
import { DEFAULT_AGENT_ID as DEFAULT_AGENT_ID2 } from "@copilotkitnext/shared";
import { partialJSONParse } from "@copilotkitnext/shared";
import { jsx as jsx10 } from "react/jsx-runtime";
var ToolCallRenderer = React7.memo(
  function ToolCallRenderer2({
    toolCall,
    toolMessage,
    RenderComponent,
    isExecuting
  }) {
    const args = useMemo4(
      () => partialJSONParse(toolCall.function.arguments),
      [toolCall.function.arguments]
    );
    const toolName = toolCall.function.name;
    if (toolMessage) {
      return /* @__PURE__ */ jsx10(
        RenderComponent,
        {
          name: toolName,
          args,
          status: ToolCallStatus.Complete,
          result: toolMessage.content
        }
      );
    } else if (isExecuting) {
      return /* @__PURE__ */ jsx10(
        RenderComponent,
        {
          name: toolName,
          args,
          status: ToolCallStatus.Executing,
          result: void 0
        }
      );
    } else {
      return /* @__PURE__ */ jsx10(
        RenderComponent,
        {
          name: toolName,
          args,
          status: ToolCallStatus.InProgress,
          result: void 0
        }
      );
    }
  },
  // Custom comparison function to prevent re-renders when tool call data hasn't changed
  (prevProps, nextProps) => {
    if (prevProps.toolCall.id !== nextProps.toolCall.id) return false;
    if (prevProps.toolCall.function.name !== nextProps.toolCall.function.name) return false;
    if (prevProps.toolCall.function.arguments !== nextProps.toolCall.function.arguments) return false;
    const prevResult = prevProps.toolMessage?.content;
    const nextResult = nextProps.toolMessage?.content;
    if (prevResult !== nextResult) return false;
    if (prevProps.isExecuting !== nextProps.isExecuting) return false;
    if (prevProps.RenderComponent !== nextProps.RenderComponent) return false;
    return true;
  }
);
function useRenderToolCall() {
  const { copilotkit, executingToolCallIds } = useCopilotKit();
  const config = useCopilotChatConfiguration();
  const agentId = config?.agentId ?? DEFAULT_AGENT_ID2;
  const renderToolCalls = useSyncExternalStore(
    (callback) => {
      return copilotkit.subscribe({
        onRenderToolCallsChanged: callback
      }).unsubscribe;
    },
    () => copilotkit.renderToolCalls,
    () => copilotkit.renderToolCalls
  );
  const renderToolCall = useCallback4(
    ({
      toolCall,
      toolMessage
    }) => {
      const exactMatches = renderToolCalls.filter(
        (rc) => rc.name === toolCall.function.name
      );
      const renderConfig = exactMatches.find((rc) => rc.agentId === agentId) || exactMatches.find((rc) => !rc.agentId) || exactMatches[0] || renderToolCalls.find((rc) => rc.name === "*");
      if (!renderConfig) {
        return null;
      }
      const RenderComponent = renderConfig.render;
      const isExecuting = executingToolCallIds.has(toolCall.id);
      return /* @__PURE__ */ jsx10(
        ToolCallRenderer,
        {
          toolCall,
          toolMessage,
          RenderComponent,
          isExecuting
        },
        toolCall.id
      );
    },
    [renderToolCalls, executingToolCallIds, agentId]
  );
  return renderToolCall;
}

// src/hooks/use-render-custom-messages.tsx
import { jsx as jsx11 } from "react/jsx-runtime";
function useRenderCustomMessages() {
  const { copilotkit } = useCopilotKit();
  const config = useCopilotChatConfiguration();
  if (!config) {
    return null;
  }
  const { agentId, threadId } = config;
  const customMessageRenderers = copilotkit.renderCustomMessages.filter((renderer) => renderer.agentId === void 0 || renderer.agentId === agentId).sort((a, b) => {
    const aHasAgent = a.agentId !== void 0;
    const bHasAgent = b.agentId !== void 0;
    if (aHasAgent === bHasAgent) return 0;
    return aHasAgent ? -1 : 1;
  });
  return function(params) {
    if (!customMessageRenderers.length) {
      return null;
    }
    const { message, position } = params;
    const resolvedRunId = copilotkit.getRunIdForMessage(agentId, threadId, message.id) ?? copilotkit.getRunIdsForThread(agentId, threadId).slice(-1)[0];
    const runId = resolvedRunId ?? `missing-run-id:${message.id}`;
    const agent = copilotkit.getAgent(agentId);
    if (!agent) {
      throw new Error("Agent not found");
    }
    const messagesIdsInRun = resolvedRunId ? agent.messages.filter((msg) => copilotkit.getRunIdForMessage(agentId, threadId, msg.id) === resolvedRunId).map((msg) => msg.id) : [message.id];
    const rawMessageIndex = agent.messages.findIndex((msg) => msg.id === message.id);
    const messageIndex = rawMessageIndex >= 0 ? rawMessageIndex : 0;
    const messageIndexInRun = resolvedRunId ? Math.max(messagesIdsInRun.indexOf(message.id), 0) : 0;
    const numberOfMessagesInRun = resolvedRunId ? messagesIdsInRun.length : 1;
    const stateSnapshot = resolvedRunId ? copilotkit.getStateByRun(agentId, threadId, resolvedRunId) : void 0;
    let result = null;
    for (const renderer of customMessageRenderers) {
      if (!renderer.render) {
        continue;
      }
      const Component = renderer.render;
      result = /* @__PURE__ */ jsx11(
        Component,
        {
          message,
          position,
          runId,
          messageIndex,
          messageIndexInRun,
          numberOfMessagesInRun,
          agentId,
          stateSnapshot
        },
        `${runId}-${message.id}-${position}`
      );
      if (result) {
        break;
      }
    }
    return result;
  };
}

// src/hooks/use-render-activity-message.tsx
import { DEFAULT_AGENT_ID as DEFAULT_AGENT_ID3 } from "@copilotkitnext/shared";
import { useCallback as useCallback5, useMemo as useMemo5 } from "react";
import { jsx as jsx12 } from "react/jsx-runtime";
function useRenderActivityMessage() {
  const { copilotkit } = useCopilotKit();
  const config = useCopilotChatConfiguration();
  const agentId = config?.agentId ?? DEFAULT_AGENT_ID3;
  const renderers = copilotkit.renderActivityMessages;
  const findRenderer = useCallback5(
    (activityType) => {
      if (!renderers.length) {
        return null;
      }
      const matches = renderers.filter(
        (renderer) => renderer.activityType === activityType
      );
      return matches.find((candidate) => candidate.agentId === agentId) ?? matches.find((candidate) => candidate.agentId === void 0) ?? renderers.find((candidate) => candidate.activityType === "*") ?? null;
    },
    [agentId, renderers]
  );
  const renderActivityMessage = useCallback5(
    (message) => {
      const renderer = findRenderer(message.activityType);
      if (!renderer) {
        return null;
      }
      const parseResult = renderer.content.safeParse(message.content);
      if (!parseResult.success) {
        console.warn(
          `Failed to parse content for activity message '${message.activityType}':`,
          parseResult.error
        );
        return null;
      }
      const Component = renderer.render;
      const agent = copilotkit.getAgent(agentId);
      return /* @__PURE__ */ jsx12(
        Component,
        {
          activityType: message.activityType,
          content: parseResult.data,
          message,
          agent
        },
        message.id
      );
    },
    [agentId, copilotkit, findRenderer]
  );
  return useMemo5(
    () => ({ renderActivityMessage, findRenderer }),
    [renderActivityMessage, findRenderer]
  );
}

// src/hooks/use-frontend-tool.tsx
import { useEffect as useEffect6 } from "react";
var EMPTY_DEPS = [];
function useFrontendTool(tool, deps) {
  const { copilotkit } = useCopilotKit();
  const extraDeps = deps ?? EMPTY_DEPS;
  useEffect6(() => {
    const name = tool.name;
    if (copilotkit.getTool({ toolName: name, agentId: tool.agentId })) {
      console.warn(
        `Tool '${name}' already exists for agent '${tool.agentId || "global"}'. Overriding with latest registration.`
      );
      copilotkit.removeTool(name, tool.agentId);
    }
    copilotkit.addTool(tool);
    if (tool.render) {
      const keyOf = (rc) => `${rc.agentId ?? ""}:${rc.name}`;
      const currentRenderToolCalls = copilotkit.renderToolCalls;
      const mergedMap = /* @__PURE__ */ new Map();
      for (const rc of currentRenderToolCalls) {
        mergedMap.set(keyOf(rc), rc);
      }
      const newEntry = {
        name,
        args: tool.parameters,
        agentId: tool.agentId,
        render: tool.render
      };
      mergedMap.set(keyOf(newEntry), newEntry);
      copilotkit.setRenderToolCalls(Array.from(mergedMap.values()));
    }
    return () => {
      copilotkit.removeTool(name, tool.agentId);
    };
  }, [tool.name, copilotkit, extraDeps.length, ...extraDeps]);
}

// src/hooks/use-human-in-the-loop.tsx
import { useCallback as useCallback6, useRef as useRef5, useEffect as useEffect7 } from "react";
import React8 from "react";
function useHumanInTheLoop(tool, deps) {
  const { copilotkit } = useCopilotKit();
  const resolvePromiseRef = useRef5(null);
  const respond = useCallback6(async (result) => {
    if (resolvePromiseRef.current) {
      resolvePromiseRef.current(result);
      resolvePromiseRef.current = null;
    }
  }, []);
  const handler = useCallback6(async () => {
    return new Promise((resolve) => {
      resolvePromiseRef.current = resolve;
    });
  }, []);
  const RenderComponent = useCallback6(
    (props) => {
      const ToolComponent = tool.render;
      if (props.status === "inProgress") {
        const enhancedProps = {
          ...props,
          name: tool.name,
          description: tool.description || "",
          respond: void 0
        };
        return React8.createElement(ToolComponent, enhancedProps);
      } else if (props.status === "executing") {
        const enhancedProps = {
          ...props,
          name: tool.name,
          description: tool.description || "",
          respond
        };
        return React8.createElement(ToolComponent, enhancedProps);
      } else if (props.status === "complete") {
        const enhancedProps = {
          ...props,
          name: tool.name,
          description: tool.description || "",
          respond: void 0
        };
        return React8.createElement(ToolComponent, enhancedProps);
      }
      return React8.createElement(ToolComponent, props);
    },
    [tool.render, tool.name, tool.description, respond]
  );
  const frontendTool = {
    ...tool,
    handler,
    render: RenderComponent
  };
  useFrontendTool(frontendTool, deps);
  useEffect7(() => {
    return () => {
      const keyOf = (rc) => `${rc.agentId ?? ""}:${rc.name}`;
      const currentRenderToolCalls = copilotkit.renderToolCalls;
      const filtered = currentRenderToolCalls.filter(
        (rc) => keyOf(rc) !== keyOf({ name: tool.name, agentId: tool.agentId })
      );
      copilotkit.setRenderToolCalls(filtered);
    };
  }, [copilotkit, tool.name, tool.agentId]);
}

// src/hooks/use-agent.tsx
import { useMemo as useMemo6, useEffect as useEffect8, useReducer as useReducer2 } from "react";
import { DEFAULT_AGENT_ID as DEFAULT_AGENT_ID4 } from "@copilotkitnext/shared";
import { ProxiedCopilotRuntimeAgent, CopilotKitCoreRuntimeConnectionStatus } from "@copilotkitnext/core";
var UseAgentUpdate = /* @__PURE__ */ ((UseAgentUpdate2) => {
  UseAgentUpdate2["OnMessagesChanged"] = "OnMessagesChanged";
  UseAgentUpdate2["OnStateChanged"] = "OnStateChanged";
  UseAgentUpdate2["OnRunStatusChanged"] = "OnRunStatusChanged";
  return UseAgentUpdate2;
})(UseAgentUpdate || {});
var ALL_UPDATES = [
  "OnMessagesChanged" /* OnMessagesChanged */,
  "OnStateChanged" /* OnStateChanged */,
  "OnRunStatusChanged" /* OnRunStatusChanged */
];
function useAgent({ agentId, updates } = {}) {
  agentId ??= DEFAULT_AGENT_ID4;
  const { copilotkit } = useCopilotKit();
  const [, forceUpdate] = useReducer2((x) => x + 1, 0);
  const updateFlags = useMemo6(
    () => updates ?? ALL_UPDATES,
    [JSON.stringify(updates)]
  );
  const agent = useMemo6(() => {
    const existing = copilotkit.getAgent(agentId);
    if (existing) {
      return existing;
    }
    const isRuntimeConfigured = copilotkit.runtimeUrl !== void 0;
    const status = copilotkit.runtimeConnectionStatus;
    if (isRuntimeConfigured && (status === CopilotKitCoreRuntimeConnectionStatus.Disconnected || status === CopilotKitCoreRuntimeConnectionStatus.Connecting)) {
      const provisional = new ProxiedCopilotRuntimeAgent({
        runtimeUrl: copilotkit.runtimeUrl,
        agentId,
        transport: copilotkit.runtimeTransport
      });
      provisional.headers = { ...copilotkit.headers };
      return provisional;
    }
    const knownAgents = Object.keys(copilotkit.agents ?? {});
    const runtimePart = isRuntimeConfigured ? `runtimeUrl=${copilotkit.runtimeUrl}` : "no runtimeUrl";
    throw new Error(
      `useAgent: Agent '${agentId}' not found after runtime sync (${runtimePart}). ` + (knownAgents.length ? `Known agents: [${knownAgents.join(", ")}]` : "No agents registered.") + " Verify your runtime /info and/or agents__unsafe_dev_only."
    );
  }, [
    agentId,
    copilotkit.agents,
    copilotkit.runtimeConnectionStatus,
    copilotkit.runtimeUrl,
    copilotkit.runtimeTransport,
    JSON.stringify(copilotkit.headers),
    copilotkit
  ]);
  useEffect8(() => {
    if (updateFlags.length === 0) {
      return;
    }
    const handlers = {};
    if (updateFlags.includes("OnMessagesChanged" /* OnMessagesChanged */)) {
      handlers.onMessagesChanged = () => {
        forceUpdate();
      };
    }
    if (updateFlags.includes("OnStateChanged" /* OnStateChanged */)) {
      handlers.onStateChanged = forceUpdate;
    }
    if (updateFlags.includes("OnRunStatusChanged" /* OnRunStatusChanged */)) {
      handlers.onRunInitialized = forceUpdate;
      handlers.onRunFinalized = forceUpdate;
      handlers.onRunFailed = forceUpdate;
    }
    const subscription = agent.subscribe(handlers);
    return () => subscription.unsubscribe();
  }, [agent, forceUpdate, JSON.stringify(updateFlags)]);
  return {
    agent
  };
}

// src/hooks/use-agent-context.tsx
import { useEffect as useEffect9, useMemo as useMemo7 } from "react";
function useAgentContext(context) {
  const { description, value } = context;
  const { copilotkit } = useCopilotKit();
  const stringValue = useMemo7(() => {
    if (typeof value === "string") {
      return value;
    }
    return JSON.stringify(value);
  }, [value]);
  useEffect9(() => {
    if (!copilotkit) return;
    const id = copilotkit.addContext({ description, value: stringValue });
    return () => {
      copilotkit.removeContext(id);
    };
  }, [description, stringValue, copilotkit]);
}

// src/hooks/use-suggestions.tsx
import { useCallback as useCallback7, useEffect as useEffect10, useMemo as useMemo8, useState as useState7 } from "react";
import { DEFAULT_AGENT_ID as DEFAULT_AGENT_ID5 } from "@copilotkitnext/shared";
function useSuggestions({ agentId } = {}) {
  const { copilotkit } = useCopilotKit();
  const config = useCopilotChatConfiguration();
  const resolvedAgentId = useMemo8(() => agentId ?? config?.agentId ?? DEFAULT_AGENT_ID5, [agentId, config?.agentId]);
  const [suggestions, setSuggestions] = useState7(() => {
    const result = copilotkit.getSuggestions(resolvedAgentId);
    return result.suggestions;
  });
  const [isLoading, setIsLoading] = useState7(() => {
    const result = copilotkit.getSuggestions(resolvedAgentId);
    return result.isLoading;
  });
  useEffect10(() => {
    const result = copilotkit.getSuggestions(resolvedAgentId);
    setSuggestions(result.suggestions);
    setIsLoading(result.isLoading);
  }, [copilotkit, resolvedAgentId]);
  useEffect10(() => {
    const subscription = copilotkit.subscribe({
      onSuggestionsChanged: ({ agentId: changedAgentId, suggestions: suggestions2 }) => {
        if (changedAgentId !== resolvedAgentId) {
          return;
        }
        setSuggestions(suggestions2);
      },
      onSuggestionsStartedLoading: ({ agentId: changedAgentId }) => {
        if (changedAgentId !== resolvedAgentId) {
          return;
        }
        setIsLoading(true);
      },
      onSuggestionsFinishedLoading: ({ agentId: changedAgentId }) => {
        if (changedAgentId !== resolvedAgentId) {
          return;
        }
        setIsLoading(false);
      },
      onSuggestionsConfigChanged: () => {
        const result = copilotkit.getSuggestions(resolvedAgentId);
        setSuggestions(result.suggestions);
        setIsLoading(result.isLoading);
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [copilotkit, resolvedAgentId]);
  const reloadSuggestions = useCallback7(() => {
    copilotkit.reloadSuggestions(resolvedAgentId);
  }, [copilotkit, resolvedAgentId]);
  const clearSuggestions = useCallback7(() => {
    copilotkit.clearSuggestions(resolvedAgentId);
  }, [copilotkit, resolvedAgentId]);
  return {
    suggestions,
    reloadSuggestions,
    clearSuggestions,
    isLoading
  };
}

// src/hooks/use-configure-suggestions.tsx
import { useCallback as useCallback8, useEffect as useEffect11, useMemo as useMemo9, useRef as useRef6 } from "react";
import { DEFAULT_AGENT_ID as DEFAULT_AGENT_ID6 } from "@copilotkitnext/shared";
function useConfigureSuggestions(config, deps) {
  const { copilotkit } = useCopilotKit();
  const chatConfig = useCopilotChatConfiguration();
  const extraDeps = deps ?? [];
  const resolvedConsumerAgentId = useMemo9(() => chatConfig?.agentId ?? DEFAULT_AGENT_ID6, [chatConfig?.agentId]);
  const rawConsumerAgentId = useMemo9(() => config ? config.consumerAgentId : void 0, [config]);
  const normalizationCacheRef = useRef6({
    serialized: null,
    config: null
  });
  const { normalizedConfig, serializedConfig } = useMemo9(() => {
    if (!config) {
      normalizationCacheRef.current = { serialized: null, config: null };
      return { normalizedConfig: null, serializedConfig: null };
    }
    if (config.available === "disabled") {
      normalizationCacheRef.current = { serialized: null, config: null };
      return { normalizedConfig: null, serializedConfig: null };
    }
    let built;
    if (isDynamicConfig(config)) {
      built = {
        ...config
      };
    } else {
      const normalizedSuggestions = normalizeStaticSuggestions(config.suggestions);
      const baseConfig = {
        ...config,
        suggestions: normalizedSuggestions
      };
      built = baseConfig;
    }
    const serialized = JSON.stringify(built);
    const cache = normalizationCacheRef.current;
    if (cache.serialized === serialized && cache.config) {
      return { normalizedConfig: cache.config, serializedConfig: serialized };
    }
    normalizationCacheRef.current = { serialized, config: built };
    return { normalizedConfig: built, serializedConfig: serialized };
  }, [config, resolvedConsumerAgentId, ...extraDeps]);
  const latestConfigRef = useRef6(null);
  latestConfigRef.current = normalizedConfig;
  const previousSerializedConfigRef = useRef6(null);
  const targetAgentId = useMemo9(() => {
    if (!normalizedConfig) {
      return resolvedConsumerAgentId;
    }
    const consumer = normalizedConfig.consumerAgentId;
    if (!consumer || consumer === "*") {
      return resolvedConsumerAgentId;
    }
    return consumer;
  }, [normalizedConfig, resolvedConsumerAgentId]);
  const isGlobalConfig = rawConsumerAgentId === void 0 || rawConsumerAgentId === "*";
  const requestReload = useCallback8(() => {
    if (!normalizedConfig) {
      return;
    }
    if (isGlobalConfig) {
      const agents = Object.values(copilotkit.agents ?? {});
      for (const entry of agents) {
        const agentId = entry.agentId;
        if (!agentId) {
          continue;
        }
        if (!entry.isRunning) {
          copilotkit.reloadSuggestions(agentId);
        }
      }
      return;
    }
    if (!targetAgentId) {
      return;
    }
    copilotkit.reloadSuggestions(targetAgentId);
  }, [copilotkit, isGlobalConfig, normalizedConfig, targetAgentId]);
  useEffect11(() => {
    if (!serializedConfig || !latestConfigRef.current) {
      return;
    }
    const id = copilotkit.addSuggestionsConfig(latestConfigRef.current);
    requestReload();
    return () => {
      copilotkit.removeSuggestionsConfig(id);
    };
  }, [copilotkit, serializedConfig, requestReload]);
  useEffect11(() => {
    if (!normalizedConfig) {
      previousSerializedConfigRef.current = null;
      return;
    }
    if (serializedConfig && previousSerializedConfigRef.current === serializedConfig) {
      return;
    }
    if (serializedConfig) {
      previousSerializedConfigRef.current = serializedConfig;
    }
    requestReload();
  }, [normalizedConfig, requestReload, serializedConfig]);
  useEffect11(() => {
    if (!normalizedConfig || extraDeps.length === 0) {
      return;
    }
    requestReload();
  }, [extraDeps.length, normalizedConfig, requestReload, ...extraDeps]);
}
function isDynamicConfig(config) {
  return "instructions" in config;
}
function normalizeStaticSuggestions(suggestions) {
  return suggestions.map((suggestion) => ({
    ...suggestion,
    isLoading: suggestion.isLoading ?? false
  }));
}

// src/components/chat/CopilotChatToolCallsView.tsx
import React9 from "react";
import { Fragment as Fragment2, jsx as jsx13 } from "react/jsx-runtime";
function CopilotChatToolCallsView({
  message,
  messages = []
}) {
  const renderToolCall = useRenderToolCall();
  if (!message.toolCalls || message.toolCalls.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsx13(Fragment2, { children: message.toolCalls.map((toolCall) => {
    const toolMessage = messages.find(
      (m) => m.role === "tool" && m.toolCallId === toolCall.id
    );
    return /* @__PURE__ */ jsx13(React9.Fragment, { children: renderToolCall({
      toolCall,
      toolMessage
    }) }, toolCall.id);
  }) });
}
var CopilotChatToolCallsView_default = CopilotChatToolCallsView;

// src/components/chat/CopilotChatAssistantMessage.tsx
import { Fragment as Fragment3, jsx as jsx14, jsxs as jsxs6 } from "react/jsx-runtime";
function CopilotChatAssistantMessage({
  message,
  messages,
  isRunning,
  onThumbsUp,
  onThumbsDown,
  onReadAloud,
  onRegenerate,
  additionalToolbarItems,
  toolbarVisible = true,
  markdownRenderer,
  toolbar,
  copyButton,
  thumbsUpButton,
  thumbsDownButton,
  readAloudButton,
  regenerateButton,
  toolCallsView,
  children,
  className,
  ...props
}) {
  const boundMarkdownRenderer = renderSlot(
    markdownRenderer,
    CopilotChatAssistantMessage.MarkdownRenderer,
    {
      content: message.content || ""
    }
  );
  const boundCopyButton = renderSlot(
    copyButton,
    CopilotChatAssistantMessage.CopyButton,
    {
      onClick: async () => {
        if (message.content) {
          try {
            await navigator.clipboard.writeText(message.content);
          } catch (err) {
            console.error("Failed to copy message:", err);
          }
        }
      }
    }
  );
  const boundThumbsUpButton = renderSlot(
    thumbsUpButton,
    CopilotChatAssistantMessage.ThumbsUpButton,
    {
      onClick: onThumbsUp
    }
  );
  const boundThumbsDownButton = renderSlot(
    thumbsDownButton,
    CopilotChatAssistantMessage.ThumbsDownButton,
    {
      onClick: onThumbsDown
    }
  );
  const boundReadAloudButton = renderSlot(
    readAloudButton,
    CopilotChatAssistantMessage.ReadAloudButton,
    {
      onClick: onReadAloud
    }
  );
  const boundRegenerateButton = renderSlot(
    regenerateButton,
    CopilotChatAssistantMessage.RegenerateButton,
    {
      onClick: onRegenerate
    }
  );
  const boundToolbar = renderSlot(
    toolbar,
    CopilotChatAssistantMessage.Toolbar,
    {
      children: /* @__PURE__ */ jsxs6("div", { className: "flex items-center gap-1", children: [
        boundCopyButton,
        (onThumbsUp || thumbsUpButton) && boundThumbsUpButton,
        (onThumbsDown || thumbsDownButton) && boundThumbsDownButton,
        (onReadAloud || readAloudButton) && boundReadAloudButton,
        (onRegenerate || regenerateButton) && boundRegenerateButton,
        additionalToolbarItems
      ] })
    }
  );
  const boundToolCallsView = renderSlot(
    toolCallsView,
    CopilotChatToolCallsView_default,
    {
      message,
      messages
    }
  );
  const hasContent = !!(message.content && message.content.trim().length > 0);
  const isLatestAssistantMessage = message.role === "assistant" && messages?.[messages.length - 1]?.id === message.id;
  const shouldShowToolbar = toolbarVisible && hasContent && !(isRunning && isLatestAssistantMessage);
  if (children) {
    return /* @__PURE__ */ jsx14(Fragment3, { children: children({
      markdownRenderer: boundMarkdownRenderer,
      toolbar: boundToolbar,
      toolCallsView: boundToolCallsView,
      copyButton: boundCopyButton,
      thumbsUpButton: boundThumbsUpButton,
      thumbsDownButton: boundThumbsDownButton,
      readAloudButton: boundReadAloudButton,
      regenerateButton: boundRegenerateButton,
      message,
      messages,
      isRunning,
      onThumbsUp,
      onThumbsDown,
      onReadAloud,
      onRegenerate,
      additionalToolbarItems,
      toolbarVisible: shouldShowToolbar
    }) });
  }
  return /* @__PURE__ */ jsxs6(
    "div",
    {
      className: twMerge4(
        "prose max-w-full break-words dark:prose-invert",
        className
      ),
      ...props,
      "data-message-id": message.id,
      children: [
        boundMarkdownRenderer,
        boundToolCallsView,
        shouldShowToolbar && boundToolbar
      ]
    }
  );
}
((CopilotChatAssistantMessage2) => {
  CopilotChatAssistantMessage2.MarkdownRenderer = ({ content, className, ...props }) => /* @__PURE__ */ jsx14(Streamdown, { className, ...props, children: content ?? "" });
  CopilotChatAssistantMessage2.Toolbar = ({
    className,
    ...props
  }) => /* @__PURE__ */ jsx14(
    "div",
    {
      className: twMerge4(
        "w-full bg-transparent flex items-center -ml-[5px] -mt-[0px]",
        className
      ),
      ...props
    }
  );
  CopilotChatAssistantMessage2.ToolbarButton = ({ title, children, ...props }) => {
    return /* @__PURE__ */ jsxs6(Tooltip, { children: [
      /* @__PURE__ */ jsx14(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsx14(
        Button,
        {
          type: "button",
          variant: "assistantMessageToolbarButton",
          "aria-label": title,
          ...props,
          children
        }
      ) }),
      /* @__PURE__ */ jsx14(TooltipContent, { side: "bottom", children: /* @__PURE__ */ jsx14("p", { children: title }) })
    ] });
  };
  CopilotChatAssistantMessage2.CopyButton = ({ className, title, onClick, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    const [copied, setCopied] = useState8(false);
    const handleClick = (event) => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
      if (onClick) {
        onClick(event);
      }
    };
    return /* @__PURE__ */ jsx14(
      CopilotChatAssistantMessage2.ToolbarButton,
      {
        title: title || labels.assistantMessageToolbarCopyMessageLabel,
        onClick: handleClick,
        className,
        ...props,
        children: copied ? /* @__PURE__ */ jsx14(Check2, { className: "size-[18px]" }) : /* @__PURE__ */ jsx14(Copy, { className: "size-[18px]" })
      }
    );
  };
  CopilotChatAssistantMessage2.ThumbsUpButton = ({ title, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsx14(
      CopilotChatAssistantMessage2.ToolbarButton,
      {
        title: title || labels.assistantMessageToolbarThumbsUpLabel,
        ...props,
        children: /* @__PURE__ */ jsx14(ThumbsUp, { className: "size-[18px]" })
      }
    );
  };
  CopilotChatAssistantMessage2.ThumbsDownButton = ({ title, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsx14(
      CopilotChatAssistantMessage2.ToolbarButton,
      {
        title: title || labels.assistantMessageToolbarThumbsDownLabel,
        ...props,
        children: /* @__PURE__ */ jsx14(ThumbsDown, { className: "size-[18px]" })
      }
    );
  };
  CopilotChatAssistantMessage2.ReadAloudButton = ({ title, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsx14(
      CopilotChatAssistantMessage2.ToolbarButton,
      {
        title: title || labels.assistantMessageToolbarReadAloudLabel,
        ...props,
        children: /* @__PURE__ */ jsx14(Volume2, { className: "size-[20px]" })
      }
    );
  };
  CopilotChatAssistantMessage2.RegenerateButton = ({ title, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsx14(
      CopilotChatAssistantMessage2.ToolbarButton,
      {
        title: title || labels.assistantMessageToolbarRegenerateLabel,
        ...props,
        children: /* @__PURE__ */ jsx14(RefreshCw, { className: "size-[18px]" })
      }
    );
  };
})(CopilotChatAssistantMessage || (CopilotChatAssistantMessage = {}));
CopilotChatAssistantMessage.MarkdownRenderer.displayName = "CopilotChatAssistantMessage.MarkdownRenderer";
CopilotChatAssistantMessage.Toolbar.displayName = "CopilotChatAssistantMessage.Toolbar";
CopilotChatAssistantMessage.CopyButton.displayName = "CopilotChatAssistantMessage.CopyButton";
CopilotChatAssistantMessage.ThumbsUpButton.displayName = "CopilotChatAssistantMessage.ThumbsUpButton";
CopilotChatAssistantMessage.ThumbsDownButton.displayName = "CopilotChatAssistantMessage.ThumbsDownButton";
CopilotChatAssistantMessage.ReadAloudButton.displayName = "CopilotChatAssistantMessage.ReadAloudButton";
CopilotChatAssistantMessage.RegenerateButton.displayName = "CopilotChatAssistantMessage.RegenerateButton";
var CopilotChatAssistantMessage_default = CopilotChatAssistantMessage;

// src/components/chat/CopilotChatUserMessage.tsx
import { useMemo as useMemo10, useState as useState9 } from "react";
import { Copy as Copy2, Check as Check3, Edit, ChevronLeft, ChevronRight } from "lucide-react";
import { twMerge as twMerge5 } from "tailwind-merge";
import { Fragment as Fragment4, jsx as jsx15, jsxs as jsxs7 } from "react/jsx-runtime";
function flattenUserMessageContent(content) {
  if (!content) {
    return "";
  }
  if (typeof content === "string") {
    return content;
  }
  return content.map((part) => {
    if (part && typeof part === "object" && "type" in part && part.type === "text" && typeof part.text === "string") {
      return part.text;
    }
    return "";
  }).filter((text) => text.length > 0).join("\n");
}
function CopilotChatUserMessage({
  message,
  onEditMessage,
  branchIndex,
  numberOfBranches,
  onSwitchToBranch,
  additionalToolbarItems,
  messageRenderer,
  toolbar,
  copyButton,
  editButton,
  branchNavigation,
  children,
  className,
  ...props
}) {
  const flattenedContent = useMemo10(
    () => flattenUserMessageContent(message.content),
    [message.content]
  );
  const BoundMessageRenderer = renderSlot(
    messageRenderer,
    CopilotChatUserMessage.MessageRenderer,
    {
      content: flattenedContent
    }
  );
  const BoundCopyButton = renderSlot(
    copyButton,
    CopilotChatUserMessage.CopyButton,
    {
      onClick: async () => {
        if (flattenedContent) {
          try {
            await navigator.clipboard.writeText(flattenedContent);
          } catch (err) {
            console.error("Failed to copy message:", err);
          }
        }
      }
    }
  );
  const BoundEditButton = renderSlot(
    editButton,
    CopilotChatUserMessage.EditButton,
    {
      onClick: () => onEditMessage?.({ message })
    }
  );
  const BoundBranchNavigation = renderSlot(
    branchNavigation,
    CopilotChatUserMessage.BranchNavigation,
    {
      currentBranch: branchIndex,
      numberOfBranches,
      onSwitchToBranch,
      message
    }
  );
  const showBranchNavigation = numberOfBranches && numberOfBranches > 1 && onSwitchToBranch;
  const BoundToolbar = renderSlot(toolbar, CopilotChatUserMessage.Toolbar, {
    children: /* @__PURE__ */ jsxs7("div", { className: "flex items-center gap-1 justify-end", children: [
      additionalToolbarItems,
      BoundCopyButton,
      onEditMessage && BoundEditButton,
      showBranchNavigation && BoundBranchNavigation
    ] })
  });
  if (children) {
    return /* @__PURE__ */ jsx15(Fragment4, { children: children({
      messageRenderer: BoundMessageRenderer,
      toolbar: BoundToolbar,
      copyButton: BoundCopyButton,
      editButton: BoundEditButton,
      branchNavigation: BoundBranchNavigation,
      message,
      branchIndex,
      numberOfBranches,
      additionalToolbarItems
    }) });
  }
  return /* @__PURE__ */ jsxs7(
    "div",
    {
      className: twMerge5("flex flex-col items-end group pt-10", className),
      "data-message-id": message.id,
      ...props,
      children: [
        BoundMessageRenderer,
        BoundToolbar
      ]
    }
  );
}
((CopilotChatUserMessage2) => {
  CopilotChatUserMessage2.Container = ({ children, className, ...props }) => /* @__PURE__ */ jsx15(
    "div",
    {
      className: twMerge5("flex flex-col items-end group", className),
      ...props,
      children
    }
  );
  CopilotChatUserMessage2.MessageRenderer = ({ content, className }) => /* @__PURE__ */ jsx15(
    "div",
    {
      className: twMerge5(
        "prose dark:prose-invert bg-muted relative max-w-[80%] rounded-[18px] px-4 py-1.5 data-[multiline]:py-3 inline-block whitespace-pre-wrap",
        className
      ),
      children: content
    }
  );
  CopilotChatUserMessage2.Toolbar = ({
    className,
    ...props
  }) => /* @__PURE__ */ jsx15(
    "div",
    {
      className: twMerge5(
        "w-full bg-transparent flex items-center justify-end -mr-[5px] mt-[4px] invisible group-hover:visible",
        className
      ),
      ...props
    }
  );
  CopilotChatUserMessage2.ToolbarButton = ({ title, children, className, ...props }) => {
    return /* @__PURE__ */ jsxs7(Tooltip, { children: [
      /* @__PURE__ */ jsx15(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsx15(
        Button,
        {
          type: "button",
          variant: "assistantMessageToolbarButton",
          "aria-label": title,
          className: twMerge5(className),
          ...props,
          children
        }
      ) }),
      /* @__PURE__ */ jsx15(TooltipContent, { side: "bottom", children: /* @__PURE__ */ jsx15("p", { children: title }) })
    ] });
  };
  CopilotChatUserMessage2.CopyButton = ({ className, title, onClick, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    const [copied, setCopied] = useState9(false);
    const handleClick = (event) => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
      if (onClick) {
        onClick(event);
      }
    };
    return /* @__PURE__ */ jsx15(
      CopilotChatUserMessage2.ToolbarButton,
      {
        title: title || labels.userMessageToolbarCopyMessageLabel,
        onClick: handleClick,
        className,
        ...props,
        children: copied ? /* @__PURE__ */ jsx15(Check3, { className: "size-[18px]" }) : /* @__PURE__ */ jsx15(Copy2, { className: "size-[18px]" })
      }
    );
  };
  CopilotChatUserMessage2.EditButton = ({ className, title, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsx15(
      CopilotChatUserMessage2.ToolbarButton,
      {
        title: title || labels.userMessageToolbarEditMessageLabel,
        className,
        ...props,
        children: /* @__PURE__ */ jsx15(Edit, { className: "size-[18px]" })
      }
    );
  };
  CopilotChatUserMessage2.BranchNavigation = ({
    className,
    currentBranch = 0,
    numberOfBranches = 1,
    onSwitchToBranch,
    message,
    ...props
  }) => {
    if (!numberOfBranches || numberOfBranches <= 1 || !onSwitchToBranch) {
      return null;
    }
    const canGoPrev = currentBranch > 0;
    const canGoNext = currentBranch < numberOfBranches - 1;
    return /* @__PURE__ */ jsxs7("div", { className: twMerge5("flex items-center gap-1", className), ...props, children: [
      /* @__PURE__ */ jsx15(
        Button,
        {
          type: "button",
          variant: "assistantMessageToolbarButton",
          onClick: () => onSwitchToBranch?.({
            branchIndex: currentBranch - 1,
            numberOfBranches,
            message
          }),
          disabled: !canGoPrev,
          className: "h-6 w-6 p-0",
          children: /* @__PURE__ */ jsx15(ChevronLeft, { className: "size-[20px]" })
        }
      ),
      /* @__PURE__ */ jsxs7("span", { className: "text-sm text-muted-foreground px-0 font-medium", children: [
        currentBranch + 1,
        "/",
        numberOfBranches
      ] }),
      /* @__PURE__ */ jsx15(
        Button,
        {
          type: "button",
          variant: "assistantMessageToolbarButton",
          onClick: () => onSwitchToBranch?.({
            branchIndex: currentBranch + 1,
            numberOfBranches,
            message
          }),
          disabled: !canGoNext,
          className: "h-6 w-6 p-0",
          children: /* @__PURE__ */ jsx15(ChevronRight, { className: "size-[20px]" })
        }
      )
    ] });
  };
})(CopilotChatUserMessage || (CopilotChatUserMessage = {}));
CopilotChatUserMessage.Container.displayName = "CopilotChatUserMessage.Container";
CopilotChatUserMessage.MessageRenderer.displayName = "CopilotChatUserMessage.MessageRenderer";
CopilotChatUserMessage.Toolbar.displayName = "CopilotChatUserMessage.Toolbar";
CopilotChatUserMessage.ToolbarButton.displayName = "CopilotChatUserMessage.ToolbarButton";
CopilotChatUserMessage.CopyButton.displayName = "CopilotChatUserMessage.CopyButton";
CopilotChatUserMessage.EditButton.displayName = "CopilotChatUserMessage.EditButton";
CopilotChatUserMessage.BranchNavigation.displayName = "CopilotChatUserMessage.BranchNavigation";
var CopilotChatUserMessage_default = CopilotChatUserMessage;

// src/components/chat/CopilotChatSuggestionPill.tsx
import React10 from "react";
import { Loader2 as Loader22 } from "lucide-react";
import { jsx as jsx16, jsxs as jsxs8 } from "react/jsx-runtime";
var baseClasses = "group inline-flex h-7 sm:h-8 items-center gap-1 sm:gap-1.5 rounded-full border border-border/60 bg-background px-2.5 sm:px-3 text-[11px] sm:text-xs leading-none text-foreground transition-colors cursor-pointer hover:bg-accent/60 hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:text-muted-foreground disabled:hover:bg-background disabled:hover:text-muted-foreground pointer-events-auto";
var labelClasses = "whitespace-nowrap font-medium leading-none";
var CopilotChatSuggestionPill = React10.forwardRef(function CopilotChatSuggestionPill2({ className, children, icon, isLoading, type, ...props }, ref) {
  const showIcon = !isLoading && icon;
  return /* @__PURE__ */ jsxs8(
    "button",
    {
      ref,
      "data-slot": "suggestion-pill",
      className: cn(baseClasses, className),
      type: type ?? "button",
      "aria-busy": isLoading || void 0,
      disabled: isLoading || props.disabled,
      ...props,
      children: [
        isLoading ? /* @__PURE__ */ jsx16("span", { className: "flex h-3.5 sm:h-4 w-3.5 sm:w-4 items-center justify-center text-muted-foreground", children: /* @__PURE__ */ jsx16(Loader22, { className: "h-3.5 sm:h-4 w-3.5 sm:w-4 animate-spin", "aria-hidden": "true" }) }) : showIcon && /* @__PURE__ */ jsx16("span", { className: "flex h-3.5 sm:h-4 w-3.5 sm:w-4 items-center justify-center text-muted-foreground", children: icon }),
        /* @__PURE__ */ jsx16("span", { className: labelClasses, children })
      ]
    }
  );
});
CopilotChatSuggestionPill.displayName = "CopilotChatSuggestionPill";
var CopilotChatSuggestionPill_default = CopilotChatSuggestionPill;

// src/components/chat/CopilotChatSuggestionView.tsx
import React11 from "react";
import { Fragment as Fragment5, jsx as jsx17, jsxs as jsxs9 } from "react/jsx-runtime";
var DefaultContainer = React11.forwardRef(function DefaultContainer2({ className, ...props }, ref) {
  return /* @__PURE__ */ jsx17(
    "div",
    {
      ref,
      className: cn(
        "flex flex-wrap items-center gap-1.5 sm:gap-2 pl-0 pr-4 sm:px-0 pointer-events-none",
        className
      ),
      ...props
    }
  );
});
var CopilotChatSuggestionView = React11.forwardRef(function CopilotChatSuggestionView2({
  suggestions,
  onSelectSuggestion,
  loadingIndexes,
  container,
  suggestion: suggestionSlot,
  className,
  children,
  ...restProps
}, ref) {
  const loadingSet = React11.useMemo(() => {
    if (!loadingIndexes || loadingIndexes.length === 0) {
      return /* @__PURE__ */ new Set();
    }
    return new Set(loadingIndexes);
  }, [loadingIndexes]);
  const ContainerElement = renderSlot(container, DefaultContainer, {
    ref,
    className,
    ...restProps
  });
  const suggestionElements = suggestions.map((suggestion, index) => {
    const isLoading = loadingSet.has(index) || suggestion.isLoading === true;
    const pill = renderSlot(suggestionSlot, CopilotChatSuggestionPill_default, {
      children: suggestion.title,
      isLoading,
      type: "button",
      onClick: () => onSelectSuggestion?.(suggestion, index)
    });
    return React11.cloneElement(pill, {
      key: `${suggestion.title}-${index}`
    });
  });
  const boundContainer = React11.cloneElement(
    ContainerElement,
    void 0,
    suggestionElements
  );
  if (typeof children === "function") {
    const sampleSuggestion = renderSlot(suggestionSlot, CopilotChatSuggestionPill_default, {
      children: suggestions[0]?.title ?? "",
      isLoading: suggestions.length > 0 ? loadingSet.has(0) || suggestions[0]?.isLoading === true : false,
      type: "button"
    });
    return /* @__PURE__ */ jsx17(Fragment5, { children: children({
      container: boundContainer,
      suggestion: sampleSuggestion,
      suggestions,
      onSelectSuggestion,
      loadingIndexes,
      className,
      ...restProps
    }) });
  }
  if (children) {
    return /* @__PURE__ */ jsxs9(Fragment5, { children: [
      boundContainer,
      children
    ] });
  }
  return boundContainer;
});
CopilotChatSuggestionView.displayName = "CopilotChatSuggestionView";
var CopilotChatSuggestionView_default = CopilotChatSuggestionView;

// src/components/chat/CopilotChatMessageView.tsx
import React12, { useEffect as useEffect12, useReducer as useReducer3 } from "react";
import { twMerge as twMerge6 } from "tailwind-merge";
import { jsx as jsx18, jsxs as jsxs10 } from "react/jsx-runtime";
var MemoizedAssistantMessage = React12.memo(
  function MemoizedAssistantMessage2({
    message,
    messages,
    isRunning,
    AssistantMessageComponent
  }) {
    return /* @__PURE__ */ jsx18(
      AssistantMessageComponent,
      {
        message,
        messages,
        isRunning
      }
    );
  },
  (prevProps, nextProps) => {
    if (prevProps.message.id !== nextProps.message.id) return false;
    if (prevProps.message.content !== nextProps.message.content) return false;
    const prevToolCalls = prevProps.message.toolCalls;
    const nextToolCalls = nextProps.message.toolCalls;
    if (prevToolCalls?.length !== nextToolCalls?.length) return false;
    if (prevToolCalls && nextToolCalls) {
      for (let i = 0; i < prevToolCalls.length; i++) {
        const prevTc = prevToolCalls[i];
        const nextTc = nextToolCalls[i];
        if (!prevTc || !nextTc) return false;
        if (prevTc.id !== nextTc.id) return false;
        if (prevTc.function.arguments !== nextTc.function.arguments) return false;
      }
    }
    if (prevToolCalls && prevToolCalls.length > 0) {
      const toolCallIds = new Set(prevToolCalls.map((tc) => tc.id));
      const prevToolResults = prevProps.messages.filter(
        (m) => m.role === "tool" && toolCallIds.has(m.toolCallId)
      );
      const nextToolResults = nextProps.messages.filter(
        (m) => m.role === "tool" && toolCallIds.has(m.toolCallId)
      );
      if (prevToolResults.length !== nextToolResults.length) return false;
      for (let i = 0; i < prevToolResults.length; i++) {
        if (prevToolResults[i].content !== nextToolResults[i].content) return false;
      }
    }
    const nextIsLatest = nextProps.messages[nextProps.messages.length - 1]?.id === nextProps.message.id;
    if (nextIsLatest && prevProps.isRunning !== nextProps.isRunning) return false;
    if (prevProps.AssistantMessageComponent !== nextProps.AssistantMessageComponent) return false;
    return true;
  }
);
var MemoizedUserMessage = React12.memo(
  function MemoizedUserMessage2({
    message,
    UserMessageComponent
  }) {
    return /* @__PURE__ */ jsx18(UserMessageComponent, { message });
  },
  (prevProps, nextProps) => {
    if (prevProps.message.id !== nextProps.message.id) return false;
    if (prevProps.message.content !== nextProps.message.content) return false;
    if (prevProps.UserMessageComponent !== nextProps.UserMessageComponent) return false;
    return true;
  }
);
var MemoizedActivityMessage = React12.memo(
  function MemoizedActivityMessage2({
    message,
    renderActivityMessage
  }) {
    return renderActivityMessage(message);
  },
  (prevProps, nextProps) => {
    if (prevProps.message.id !== nextProps.message.id) return false;
    if (prevProps.message.activityType !== nextProps.message.activityType) return false;
    if (JSON.stringify(prevProps.message.content) !== JSON.stringify(nextProps.message.content)) return false;
    return true;
  }
);
var MemoizedCustomMessage = React12.memo(
  function MemoizedCustomMessage2({
    message,
    position,
    renderCustomMessage
  }) {
    return renderCustomMessage({ message, position });
  },
  (prevProps, nextProps) => {
    if (prevProps.message.id !== nextProps.message.id) return false;
    if (prevProps.position !== nextProps.position) return false;
    if (prevProps.message.content !== nextProps.message.content) return false;
    if (prevProps.message.role !== nextProps.message.role) return false;
    if (JSON.stringify(prevProps.stateSnapshot) !== JSON.stringify(nextProps.stateSnapshot)) return false;
    return true;
  }
);
function CopilotChatMessageView({
  messages = [],
  assistantMessage,
  userMessage,
  cursor,
  isRunning = false,
  children,
  className,
  ...props
}) {
  const renderCustomMessage = useRenderCustomMessages();
  const { renderActivityMessage } = useRenderActivityMessage();
  const { copilotkit } = useCopilotKit();
  const config = useCopilotChatConfiguration();
  const [, forceUpdate] = useReducer3((x) => x + 1, 0);
  useEffect12(() => {
    if (!config?.agentId) return;
    const agent = copilotkit.getAgent(config.agentId);
    if (!agent) return;
    const subscription = agent.subscribe({
      onStateChanged: forceUpdate
    });
    return () => subscription.unsubscribe();
  }, [config?.agentId, copilotkit, forceUpdate]);
  const getStateSnapshotForMessage = (messageId) => {
    if (!config) return void 0;
    const resolvedRunId = copilotkit.getRunIdForMessage(config.agentId, config.threadId, messageId) ?? copilotkit.getRunIdsForThread(config.agentId, config.threadId).slice(-1)[0];
    if (!resolvedRunId) return void 0;
    return copilotkit.getStateByRun(config.agentId, config.threadId, resolvedRunId);
  };
  const messageElements = messages.flatMap((message) => {
    const elements = [];
    const stateSnapshot = getStateSnapshotForMessage(message.id);
    if (renderCustomMessage) {
      elements.push(
        /* @__PURE__ */ jsx18(
          MemoizedCustomMessage,
          {
            message,
            position: "before",
            renderCustomMessage,
            stateSnapshot
          },
          `${message.id}-custom-before`
        )
      );
    }
    if (message.role === "assistant") {
      const AssistantComponent = typeof assistantMessage === "function" ? assistantMessage : CopilotChatAssistantMessage_default;
      elements.push(
        /* @__PURE__ */ jsx18(
          MemoizedAssistantMessage,
          {
            message,
            messages,
            isRunning,
            AssistantMessageComponent: AssistantComponent
          },
          message.id
        )
      );
    } else if (message.role === "user") {
      const UserComponent = typeof userMessage === "function" ? userMessage : CopilotChatUserMessage_default;
      elements.push(
        /* @__PURE__ */ jsx18(
          MemoizedUserMessage,
          {
            message,
            UserMessageComponent: UserComponent
          },
          message.id
        )
      );
    } else if (message.role === "activity") {
      const activityMsg = message;
      elements.push(
        /* @__PURE__ */ jsx18(
          MemoizedActivityMessage,
          {
            message: activityMsg,
            renderActivityMessage
          },
          message.id
        )
      );
    }
    if (renderCustomMessage) {
      elements.push(
        /* @__PURE__ */ jsx18(
          MemoizedCustomMessage,
          {
            message,
            position: "after",
            renderCustomMessage,
            stateSnapshot
          },
          `${message.id}-custom-after`
        )
      );
    }
    return elements;
  }).filter(Boolean);
  if (children) {
    return children({ messageElements, messages, isRunning });
  }
  return /* @__PURE__ */ jsxs10("div", { className: twMerge6("flex flex-col", className), ...props, children: [
    messageElements,
    isRunning && renderSlot(cursor, CopilotChatMessageView.Cursor, {})
  ] });
}
CopilotChatMessageView.Cursor = function Cursor({ className, ...props }) {
  return /* @__PURE__ */ jsx18(
    "div",
    {
      className: twMerge6("w-[11px] h-[11px] rounded-full bg-foreground animate-pulse-cursor ml-1", className),
      ...props
    }
  );
};
var CopilotChatMessageView_default = CopilotChatMessageView;

// src/components/chat/CopilotChatView.tsx
import React13, { useRef as useRef7, useState as useState11, useEffect as useEffect14 } from "react";
import { twMerge as twMerge7 } from "tailwind-merge";
import { StickToBottom, useStickToBottom, useStickToBottomContext } from "use-stick-to-bottom";
import { ChevronDown } from "lucide-react";

// src/hooks/use-keyboard-height.tsx
import { useState as useState10, useEffect as useEffect13 } from "react";
function useKeyboardHeight() {
  const [keyboardState, setKeyboardState] = useState10({
    isKeyboardOpen: false,
    keyboardHeight: 0,
    availableHeight: typeof window !== "undefined" ? window.innerHeight : 0,
    viewportHeight: typeof window !== "undefined" ? window.innerHeight : 0
  });
  useEffect13(() => {
    if (typeof window === "undefined") {
      return;
    }
    const visualViewport = window.visualViewport;
    if (!visualViewport) {
      return;
    }
    const updateKeyboardState = () => {
      const layoutHeight = window.innerHeight;
      const visualHeight = visualViewport.height;
      const keyboardHeight = Math.max(0, layoutHeight - visualHeight);
      const isKeyboardOpen = keyboardHeight > 150;
      setKeyboardState({
        isKeyboardOpen,
        keyboardHeight,
        availableHeight: visualHeight,
        viewportHeight: layoutHeight
      });
    };
    updateKeyboardState();
    visualViewport.addEventListener("resize", updateKeyboardState);
    visualViewport.addEventListener("scroll", updateKeyboardState);
    return () => {
      visualViewport.removeEventListener("resize", updateKeyboardState);
      visualViewport.removeEventListener("scroll", updateKeyboardState);
    };
  }, []);
  return keyboardState;
}

// src/components/chat/CopilotChatView.tsx
import { Fragment as Fragment6, jsx as jsx19, jsxs as jsxs11 } from "react/jsx-runtime";
function CopilotChatView({
  messageView,
  input,
  scrollView,
  scrollToBottomButton,
  feather,
  inputContainer,
  disclaimer,
  suggestionView,
  welcomeScreen,
  messages = [],
  autoScroll = true,
  inputProps,
  isRunning = false,
  suggestions,
  suggestionLoadingIndexes,
  onSelectSuggestion,
  children,
  className,
  ...props
}) {
  const inputContainerRef = useRef7(null);
  const [inputContainerHeight, setInputContainerHeight] = useState11(0);
  const [isResizing, setIsResizing] = useState11(false);
  const resizeTimeoutRef = useRef7(null);
  const { isKeyboardOpen, keyboardHeight, availableHeight } = useKeyboardHeight();
  useEffect14(() => {
    const element = inputContainerRef.current;
    if (!element) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const newHeight = entry.contentRect.height;
        setInputContainerHeight((prevHeight) => {
          if (newHeight !== prevHeight) {
            setIsResizing(true);
            if (resizeTimeoutRef.current) {
              clearTimeout(resizeTimeoutRef.current);
            }
            resizeTimeoutRef.current = setTimeout(() => {
              setIsResizing(false);
            }, 250);
            return newHeight;
          }
          return prevHeight;
        });
      }
    });
    resizeObserver.observe(element);
    setInputContainerHeight(element.offsetHeight);
    return () => {
      resizeObserver.disconnect();
      if (resizeTimeoutRef.current) {
        clearTimeout(resizeTimeoutRef.current);
      }
    };
  }, []);
  const BoundMessageView = renderSlot(messageView, CopilotChatMessageView_default, {
    messages,
    isRunning
  });
  const BoundInput = renderSlot(input, CopilotChatInput_default, inputProps ?? {});
  const hasSuggestions = Array.isArray(suggestions) && suggestions.length > 0;
  const BoundSuggestionView = hasSuggestions ? renderSlot(suggestionView, CopilotChatSuggestionView_default, {
    suggestions,
    loadingIndexes: suggestionLoadingIndexes,
    onSelectSuggestion,
    className: "mb-3 lg:ml-4 lg:mr-4 ml-0 mr-0"
  }) : null;
  const BoundFeather = renderSlot(feather, CopilotChatView.Feather, {});
  const BoundScrollView = renderSlot(scrollView, CopilotChatView.ScrollView, {
    autoScroll,
    scrollToBottomButton,
    inputContainerHeight,
    isResizing,
    children: /* @__PURE__ */ jsx19("div", { style: { paddingBottom: `${inputContainerHeight + (hasSuggestions ? 4 : 32)}px` }, children: /* @__PURE__ */ jsxs11("div", { className: "max-w-3xl mx-auto", children: [
      BoundMessageView,
      hasSuggestions ? /* @__PURE__ */ jsx19("div", { className: "pl-0 pr-4 sm:px-0 mt-4", children: BoundSuggestionView }) : null
    ] }) })
  });
  const BoundScrollToBottomButton = renderSlot(scrollToBottomButton, CopilotChatView.ScrollToBottomButton, {});
  const BoundDisclaimer = renderSlot(disclaimer, CopilotChatView.Disclaimer, {});
  const BoundInputContainer = renderSlot(inputContainer, CopilotChatView.InputContainer, {
    ref: inputContainerRef,
    keyboardHeight: isKeyboardOpen ? keyboardHeight : 0,
    children: /* @__PURE__ */ jsxs11(Fragment6, { children: [
      /* @__PURE__ */ jsx19("div", { className: "max-w-3xl mx-auto py-0 px-4 sm:px-0 [div[data-sidebar-chat]_&]:px-8 [div[data-popup-chat]_&]:px-6 pointer-events-auto", children: BoundInput }),
      BoundDisclaimer
    ] })
  });
  const isEmpty = messages.length === 0;
  const welcomeScreenDisabled = welcomeScreen === false;
  const shouldShowWelcomeScreen = isEmpty && !welcomeScreenDisabled;
  if (shouldShowWelcomeScreen) {
    const welcomeScreenSlot = welcomeScreen === true ? void 0 : welcomeScreen;
    const BoundWelcomeScreen = renderSlot(
      welcomeScreenSlot,
      CopilotChatView.WelcomeScreen,
      {
        input: BoundInput,
        suggestionView: BoundSuggestionView ?? /* @__PURE__ */ jsx19(Fragment6, {})
      }
    );
    return /* @__PURE__ */ jsx19("div", { className: twMerge7("relative h-full flex flex-col", className), ...props, children: BoundWelcomeScreen });
  }
  if (children) {
    return children({
      messageView: BoundMessageView,
      input: BoundInput,
      scrollView: BoundScrollView,
      scrollToBottomButton: BoundScrollToBottomButton,
      feather: BoundFeather,
      inputContainer: BoundInputContainer,
      disclaimer: BoundDisclaimer,
      suggestionView: BoundSuggestionView ?? /* @__PURE__ */ jsx19(Fragment6, {})
    });
  }
  return /* @__PURE__ */ jsxs11("div", { className: twMerge7("relative h-full", className), ...props, children: [
    BoundScrollView,
    BoundFeather,
    BoundInputContainer
  ] });
}
((CopilotChatView2) => {
  const ScrollContent = ({ children, scrollToBottomButton, inputContainerHeight, isResizing }) => {
    const { isAtBottom, scrollToBottom } = useStickToBottomContext();
    return /* @__PURE__ */ jsxs11(Fragment6, { children: [
      /* @__PURE__ */ jsx19(StickToBottom.Content, { className: "overflow-y-scroll overflow-x-hidden", children: /* @__PURE__ */ jsx19("div", { className: "px-4 sm:px-0 [div[data-sidebar-chat]_&]:px-8 [div[data-popup-chat]_&]:px-6", children }) }),
      !isAtBottom && !isResizing && /* @__PURE__ */ jsx19(
        "div",
        {
          className: "absolute inset-x-0 flex justify-center z-10 pointer-events-none",
          style: {
            bottom: `${inputContainerHeight + 16}px`
          },
          children: renderSlot(scrollToBottomButton, CopilotChatView2.ScrollToBottomButton, {
            onClick: () => scrollToBottom()
          })
        }
      )
    ] });
  };
  CopilotChatView2.ScrollView = ({
    children,
    autoScroll = true,
    scrollToBottomButton,
    inputContainerHeight = 0,
    isResizing = false,
    className,
    ...props
  }) => {
    const [hasMounted, setHasMounted] = useState11(false);
    const { scrollRef, contentRef, scrollToBottom } = useStickToBottom();
    const [showScrollButton, setShowScrollButton] = useState11(false);
    useEffect14(() => {
      setHasMounted(true);
    }, []);
    useEffect14(() => {
      if (autoScroll) return;
      const scrollElement = scrollRef.current;
      if (!scrollElement) return;
      const checkScroll = () => {
        const atBottom = scrollElement.scrollHeight - scrollElement.scrollTop - scrollElement.clientHeight < 10;
        setShowScrollButton(!atBottom);
      };
      checkScroll();
      scrollElement.addEventListener("scroll", checkScroll);
      const resizeObserver = new ResizeObserver(checkScroll);
      resizeObserver.observe(scrollElement);
      return () => {
        scrollElement.removeEventListener("scroll", checkScroll);
        resizeObserver.disconnect();
      };
    }, [scrollRef, autoScroll]);
    if (!hasMounted) {
      return /* @__PURE__ */ jsx19("div", { className: "h-full max-h-full flex flex-col min-h-0 overflow-y-scroll overflow-x-hidden", children: /* @__PURE__ */ jsx19("div", { className: "px-4 sm:px-0 [div[data-sidebar-chat]_&]:px-8 [div[data-popup-chat]_&]:px-6", children }) });
    }
    if (!autoScroll) {
      return /* @__PURE__ */ jsxs11(
        "div",
        {
          ref: scrollRef,
          className: cn(
            "h-full max-h-full flex flex-col min-h-0 overflow-y-scroll overflow-x-hidden relative",
            className
          ),
          ...props,
          children: [
            /* @__PURE__ */ jsx19("div", { ref: contentRef, className: "px-4 sm:px-0 [div[data-sidebar-chat]_&]:px-8 [div[data-popup-chat]_&]:px-6", children }),
            showScrollButton && !isResizing && /* @__PURE__ */ jsx19(
              "div",
              {
                className: "absolute inset-x-0 flex justify-center z-10 pointer-events-none",
                style: {
                  bottom: `${inputContainerHeight + 16}px`
                },
                children: renderSlot(scrollToBottomButton, CopilotChatView2.ScrollToBottomButton, {
                  onClick: () => scrollToBottom()
                })
              }
            )
          ]
        }
      );
    }
    return /* @__PURE__ */ jsx19(
      StickToBottom,
      {
        className: cn("h-full max-h-full flex flex-col min-h-0 relative", className),
        resize: "smooth",
        initial: "smooth",
        ...props,
        children: /* @__PURE__ */ jsx19(
          ScrollContent,
          {
            scrollToBottomButton,
            inputContainerHeight,
            isResizing,
            children
          }
        )
      }
    );
  };
  CopilotChatView2.ScrollToBottomButton = ({
    className,
    ...props
  }) => /* @__PURE__ */ jsx19(
    Button,
    {
      variant: "outline",
      size: "sm",
      className: twMerge7(
        "rounded-full w-10 h-10 p-0 pointer-events-auto",
        "bg-white dark:bg-gray-900",
        "shadow-lg border border-gray-200 dark:border-gray-700",
        "hover:bg-gray-50 dark:hover:bg-gray-800",
        "flex items-center justify-center cursor-pointer",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsx19(ChevronDown, { className: "w-4 h-4 text-gray-600 dark:text-white" })
    }
  );
  CopilotChatView2.Feather = ({ className, style, ...props }) => /* @__PURE__ */ jsx19(
    "div",
    {
      className: cn(
        "absolute bottom-0 left-0 right-4 h-24 pointer-events-none z-10 bg-gradient-to-t",
        "from-white via-white to-transparent",
        "dark:from-[rgb(33,33,33)] dark:via-[rgb(33,33,33)]",
        className
      ),
      style,
      ...props
    }
  );
  CopilotChatView2.InputContainer = React13.forwardRef(({ children, className, keyboardHeight = 0, ...props }, ref) => /* @__PURE__ */ jsx19(
    "div",
    {
      ref,
      className: cn("absolute bottom-0 left-0 right-0 z-20 pointer-events-none", className),
      style: {
        // Adjust position when keyboard is open to keep input visible
        transform: keyboardHeight > 0 ? `translateY(-${keyboardHeight}px)` : void 0,
        transition: "transform 0.2s ease-out"
      },
      ...props,
      children
    }
  ));
  CopilotChatView2.InputContainer.displayName = "CopilotChatView.InputContainer";
  CopilotChatView2.Disclaimer = ({ className, ...props }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsx19(
      "div",
      {
        className: cn("text-center text-xs text-muted-foreground py-3 px-4 max-w-3xl mx-auto", className),
        ...props,
        children: labels.chatDisclaimerText
      }
    );
  };
  CopilotChatView2.WelcomeMessage = ({
    className,
    ...props
  }) => {
    const config = useCopilotChatConfiguration();
    const labels = config?.labels ?? CopilotChatDefaultLabels;
    return /* @__PURE__ */ jsx19(
      "h1",
      {
        className: cn(
          "text-xl sm:text-2xl font-medium text-foreground text-center",
          className
        ),
        ...props,
        children: labels.welcomeMessageText
      }
    );
  };
  CopilotChatView2.WelcomeScreen = ({
    welcomeMessage,
    input,
    suggestionView,
    className,
    children,
    ...props
  }) => {
    const BoundWelcomeMessage = renderSlot(
      welcomeMessage,
      CopilotChatView2.WelcomeMessage,
      {}
    );
    if (children) {
      return /* @__PURE__ */ jsx19(Fragment6, { children: children({
        welcomeMessage: BoundWelcomeMessage,
        input,
        suggestionView,
        className,
        ...props
      }) });
    }
    return /* @__PURE__ */ jsx19(
      "div",
      {
        className: cn(
          "flex-1 flex flex-col items-center justify-center px-4",
          className
        ),
        ...props,
        children: /* @__PURE__ */ jsxs11("div", { className: "w-full max-w-3xl flex flex-col items-center", children: [
          /* @__PURE__ */ jsx19("div", { className: "mb-6", children: BoundWelcomeMessage }),
          /* @__PURE__ */ jsx19("div", { className: "w-full", children: input }),
          /* @__PURE__ */ jsx19("div", { className: "mt-4 flex justify-center", children: suggestionView })
        ] })
      }
    );
  };
})(CopilotChatView || (CopilotChatView = {}));
var CopilotChatView_default = CopilotChatView;

// src/components/chat/CopilotChat.tsx
import { DEFAULT_AGENT_ID as DEFAULT_AGENT_ID7, randomUUID as randomUUID2, TranscriptionErrorCode as TranscriptionErrorCode2 } from "@copilotkitnext/shared";
import { useCallback as useCallback9, useEffect as useEffect15, useMemo as useMemo11, useState as useState12 } from "react";
import { merge } from "ts-deepmerge";
import { AGUIConnectNotImplementedError } from "@ag-ui/client";

// src/lib/transcription-client.ts
import {
  TranscriptionErrorCode
} from "@copilotkitnext/shared";
async function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const result = reader.result;
      const base64 = result.split(",")[1];
      resolve(base64 ?? "");
    };
    reader.onerror = () => reject(new Error("Failed to read audio data"));
    reader.readAsDataURL(blob);
  });
}
function isTranscriptionErrorResponse(data) {
  return typeof data === "object" && data !== null && "error" in data && "message" in data && typeof data.error === "string" && typeof data.message === "string";
}
function parseTranscriptionError(response) {
  return {
    code: response.error,
    message: response.message,
    retryable: response.retryable ?? false
  };
}
var TranscriptionError = class extends Error {
  info;
  constructor(info) {
    super(info.message);
    this.name = "TranscriptionError";
    this.info = info;
  }
};
async function transcribeAudio(core, audioBlob, filename = "recording.webm") {
  const runtimeUrl = core.runtimeUrl;
  if (!runtimeUrl) {
    throw new TranscriptionError({
      code: TranscriptionErrorCode.INVALID_REQUEST,
      message: "Runtime URL is not configured",
      retryable: false
    });
  }
  const headers = { ...core.headers };
  let response;
  try {
    if (core.runtimeTransport === "single") {
      const base64Audio = await blobToBase64(audioBlob);
      headers["Content-Type"] = "application/json";
      response = await fetch(runtimeUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          method: "transcribe",
          body: {
            audio: base64Audio,
            mimeType: audioBlob.type || "audio/webm",
            filename
          }
        })
      });
    } else {
      delete headers["Content-Type"];
      const formData = new FormData();
      formData.append("audio", audioBlob, filename);
      response = await fetch(`${runtimeUrl}/transcribe`, {
        method: "POST",
        headers,
        body: formData
      });
    }
  } catch (error) {
    throw new TranscriptionError({
      code: TranscriptionErrorCode.NETWORK_ERROR,
      message: error instanceof Error ? error.message : "Network request failed",
      retryable: true
    });
  }
  if (!response.ok) {
    let errorData;
    try {
      errorData = await response.json();
    } catch {
      throw new TranscriptionError({
        code: TranscriptionErrorCode.PROVIDER_ERROR,
        message: `HTTP ${response.status}: ${response.statusText}`,
        retryable: response.status >= 500
      });
    }
    if (isTranscriptionErrorResponse(errorData)) {
      throw new TranscriptionError(parseTranscriptionError(errorData));
    }
    throw new TranscriptionError({
      code: TranscriptionErrorCode.PROVIDER_ERROR,
      message: typeof errorData === "object" && errorData !== null && "message" in errorData ? String(errorData.message) : "Transcription failed",
      retryable: response.status >= 500
    });
  }
  return await response.json();
}

// src/components/chat/CopilotChat.tsx
import { jsx as jsx20, jsxs as jsxs12 } from "react/jsx-runtime";
function CopilotChat({ agentId, threadId, labels, chatView, isModalDefaultOpen, ...props }) {
  const existingConfig = useCopilotChatConfiguration();
  const resolvedAgentId = agentId ?? existingConfig?.agentId ?? DEFAULT_AGENT_ID7;
  const resolvedThreadId = useMemo11(
    () => threadId ?? existingConfig?.threadId ?? randomUUID2(),
    [threadId, existingConfig?.threadId]
  );
  const { agent } = useAgent({ agentId: resolvedAgentId });
  const { copilotkit } = useCopilotKit();
  const { suggestions: autoSuggestions } = useSuggestions({ agentId: resolvedAgentId });
  const [transcribeMode, setTranscribeMode] = useState12("input");
  const [inputValue, setInputValue] = useState12("");
  const [transcriptionError, setTranscriptionError] = useState12(null);
  const [isTranscribing, setIsTranscribing] = useState12(false);
  const isTranscriptionEnabled = copilotkit.audioFileTranscriptionEnabled;
  const isMediaRecorderSupported = typeof window !== "undefined" && typeof MediaRecorder !== "undefined";
  const {
    inputProps: providedInputProps,
    messageView: providedMessageView,
    suggestionView: providedSuggestionView,
    ...restProps
  } = props;
  useEffect15(() => {
    const connect = async (agent2) => {
      try {
        await copilotkit.connectAgent({ agent: agent2 });
      } catch (error) {
        if (error instanceof AGUIConnectNotImplementedError) {
        } else {
          throw error;
        }
      }
    };
    agent.threadId = resolvedThreadId;
    connect(agent);
    return () => {
    };
  }, [resolvedThreadId, agent, copilotkit, resolvedAgentId]);
  const onSubmitInput = useCallback9(
    async (value) => {
      agent.addMessage({
        id: randomUUID2(),
        role: "user",
        content: value
      });
      setInputValue("");
      try {
        await copilotkit.runAgent({ agent });
      } catch (error) {
        console.error("CopilotChat: runAgent failed", error);
      }
    },
    [agent, copilotkit]
  );
  const handleSelectSuggestion = useCallback9(
    async (suggestion) => {
      agent.addMessage({
        id: randomUUID2(),
        role: "user",
        content: suggestion.message
      });
      try {
        await copilotkit.runAgent({ agent });
      } catch (error) {
        console.error("CopilotChat: runAgent failed after selecting suggestion", error);
      }
    },
    [agent, copilotkit]
  );
  const stopCurrentRun = useCallback9(() => {
    try {
      copilotkit.stopAgent({ agent });
    } catch (error) {
      console.error("CopilotChat: stopAgent failed", error);
      try {
        agent.abortRun();
      } catch (abortError) {
        console.error("CopilotChat: abortRun fallback failed", abortError);
      }
    }
  }, [agent, copilotkit]);
  const handleStartTranscribe = useCallback9(() => {
    setTranscriptionError(null);
    setTranscribeMode("transcribe");
  }, []);
  const handleCancelTranscribe = useCallback9(() => {
    setTranscriptionError(null);
    setTranscribeMode("input");
  }, []);
  const handleFinishTranscribe = useCallback9(() => {
    setTranscribeMode("input");
  }, []);
  const handleFinishTranscribeWithAudio = useCallback9(async (audioBlob) => {
    setIsTranscribing(true);
    try {
      setTranscriptionError(null);
      const result = await transcribeAudio(copilotkit, audioBlob);
      setInputValue((prev) => {
        const trimmedPrev = prev.trim();
        if (trimmedPrev) {
          return `${trimmedPrev} ${result.text}`;
        }
        return result.text;
      });
    } catch (error) {
      console.error("CopilotChat: Transcription failed", error);
      if (error instanceof TranscriptionError) {
        const { code, retryable, message } = error.info;
        switch (code) {
          case TranscriptionErrorCode2.RATE_LIMITED:
            setTranscriptionError("Too many requests. Please wait a moment.");
            break;
          case TranscriptionErrorCode2.AUTH_FAILED:
            setTranscriptionError("Authentication error. Please check your configuration.");
            break;
          case TranscriptionErrorCode2.AUDIO_TOO_LONG:
            setTranscriptionError("Recording is too long. Please try a shorter recording.");
            break;
          case TranscriptionErrorCode2.AUDIO_TOO_SHORT:
            setTranscriptionError("Recording is too short. Please try again.");
            break;
          case TranscriptionErrorCode2.INVALID_AUDIO_FORMAT:
            setTranscriptionError("Audio format not supported.");
            break;
          case TranscriptionErrorCode2.SERVICE_NOT_CONFIGURED:
            setTranscriptionError("Transcription service is not available.");
            break;
          case TranscriptionErrorCode2.NETWORK_ERROR:
            setTranscriptionError("Network error. Please check your connection.");
            break;
          default:
            setTranscriptionError(
              retryable ? "Transcription failed. Please try again." : message
            );
        }
      } else {
        setTranscriptionError("Transcription failed. Please try again.");
      }
    } finally {
      setIsTranscribing(false);
    }
  }, [copilotkit]);
  useEffect15(() => {
    if (transcriptionError) {
      const timer = setTimeout(() => {
        setTranscriptionError(null);
      }, 5e3);
      return () => clearTimeout(timer);
    }
  }, [transcriptionError]);
  const mergedProps = merge(
    {
      isRunning: agent.isRunning,
      suggestions: autoSuggestions,
      onSelectSuggestion: handleSelectSuggestion,
      suggestionView: providedSuggestionView
    },
    {
      ...restProps,
      ...typeof providedMessageView === "string" ? { messageView: { className: providedMessageView } } : providedMessageView !== void 0 ? { messageView: providedMessageView } : {}
    }
  );
  const providedStopHandler = providedInputProps?.onStop;
  const hasMessages = agent.messages.length > 0;
  const shouldAllowStop = agent.isRunning && hasMessages;
  const effectiveStopHandler = shouldAllowStop ? providedStopHandler ?? stopCurrentRun : providedStopHandler;
  const showTranscription = isTranscriptionEnabled && isMediaRecorderSupported;
  const effectiveMode = isTranscribing ? "processing" : transcribeMode;
  const finalInputProps = {
    ...providedInputProps,
    onSubmitMessage: onSubmitInput,
    onStop: effectiveStopHandler,
    isRunning: agent.isRunning,
    mode: effectiveMode,
    value: inputValue,
    onChange: setInputValue,
    // Only provide transcription handlers if feature is available
    onStartTranscribe: showTranscription ? handleStartTranscribe : void 0,
    onCancelTranscribe: showTranscription ? handleCancelTranscribe : void 0,
    onFinishTranscribe: showTranscription ? handleFinishTranscribe : void 0,
    onFinishTranscribeWithAudio: showTranscription ? handleFinishTranscribeWithAudio : void 0
  };
  const messages = useMemo11(() => [...agent.messages], [JSON.stringify(agent.messages)]);
  const finalProps = merge(mergedProps, {
    messages,
    inputProps: finalInputProps
  });
  const RenderedChatView = renderSlot(chatView, CopilotChatView, finalProps);
  return /* @__PURE__ */ jsxs12(
    CopilotChatConfigurationProvider,
    {
      agentId: resolvedAgentId,
      threadId: resolvedThreadId,
      labels,
      isModalDefaultOpen,
      children: [
        transcriptionError && /* @__PURE__ */ jsx20(
          "div",
          {
            style: {
              position: "absolute",
              bottom: "100px",
              left: "50%",
              transform: "translateX(-50%)",
              backgroundColor: "#ef4444",
              color: "white",
              padding: "8px 16px",
              borderRadius: "8px",
              fontSize: "14px",
              zIndex: 50
            },
            children: transcriptionError
          }
        ),
        RenderedChatView
      ]
    }
  );
}
((CopilotChat2) => {
  CopilotChat2.View = CopilotChatView;
})(CopilotChat || (CopilotChat = {}));

// src/components/chat/CopilotChatToggleButton.tsx
import React14, { useState as useState13 } from "react";
import { MessageCircle, X as X2 } from "lucide-react";
import { jsx as jsx21, jsxs as jsxs13 } from "react/jsx-runtime";
var DefaultOpenIcon = ({
  className,
  ...props
}) => /* @__PURE__ */ jsx21(MessageCircle, { className: cn("h-6 w-6", className), strokeWidth: 1.75, fill: "currentColor", ...props });
var DefaultCloseIcon = ({
  className,
  ...props
}) => /* @__PURE__ */ jsx21(X2, { className: cn("h-6 w-6", className), strokeWidth: 1.75, ...props });
DefaultOpenIcon.displayName = "CopilotChatToggleButton.OpenIcon";
DefaultCloseIcon.displayName = "CopilotChatToggleButton.CloseIcon";
var ICON_TRANSITION_STYLE = Object.freeze({
  transition: "opacity 120ms ease-out, transform 260ms cubic-bezier(0.22, 1, 0.36, 1)"
});
var ICON_WRAPPER_BASE = "pointer-events-none absolute inset-0 flex items-center justify-center will-change-transform";
var BUTTON_BASE_CLASSES = cn(
  "fixed bottom-6 right-6 z-[1100] flex h-14 w-14 items-center justify-center",
  "rounded-full border border-primary bg-primary text-primary-foreground",
  "shadow-sm transition-all duration-200 ease-out",
  "hover:scale-[1.04] hover:shadow-md",
  "cursor-pointer",
  "active:scale-[0.96]",
  "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/50 focus-visible:ring-offset-2 focus-visible:ring-offset-background",
  "disabled:pointer-events-none disabled:opacity-60"
);
var CopilotChatToggleButton = React14.forwardRef(function CopilotChatToggleButton2({ openIcon, closeIcon, className, ...buttonProps }, ref) {
  const { onClick, type, disabled, ...restProps } = buttonProps;
  const configuration = useCopilotChatConfiguration();
  const labels = configuration?.labels ?? CopilotChatDefaultLabels;
  const [fallbackOpen, setFallbackOpen] = useState13(false);
  const isOpen = configuration?.isModalOpen ?? fallbackOpen;
  const setModalOpen = configuration?.setModalOpen ?? setFallbackOpen;
  const handleClick = (event) => {
    if (disabled) {
      return;
    }
    if (onClick) {
      onClick(event);
    }
    if (event.defaultPrevented) {
      return;
    }
    const nextOpen = !isOpen;
    setModalOpen(nextOpen);
  };
  const renderedOpenIcon = renderSlot(
    openIcon,
    DefaultOpenIcon,
    {
      className: "h-6 w-6",
      "aria-hidden": true,
      focusable: false
    }
  );
  const renderedCloseIcon = renderSlot(
    closeIcon,
    DefaultCloseIcon,
    {
      className: "h-6 w-6",
      "aria-hidden": true,
      focusable: false
    }
  );
  const openIconElement = /* @__PURE__ */ jsx21(
    "span",
    {
      "aria-hidden": "true",
      "data-slot": "chat-toggle-button-open-icon",
      className: ICON_WRAPPER_BASE,
      style: {
        ...ICON_TRANSITION_STYLE,
        opacity: isOpen ? 0 : 1,
        transform: `scale(${isOpen ? 0.75 : 1}) rotate(${isOpen ? 90 : 0}deg)`
      },
      children: renderedOpenIcon
    }
  );
  const closeIconElement = /* @__PURE__ */ jsx21(
    "span",
    {
      "aria-hidden": "true",
      "data-slot": "chat-toggle-button-close-icon",
      className: ICON_WRAPPER_BASE,
      style: {
        ...ICON_TRANSITION_STYLE,
        opacity: isOpen ? 1 : 0,
        transform: `scale(${isOpen ? 1 : 0.75}) rotate(${isOpen ? 0 : -90}deg)`
      },
      children: renderedCloseIcon
    }
  );
  return /* @__PURE__ */ jsxs13(
    "button",
    {
      ref,
      type: type ?? "button",
      "data-slot": "chat-toggle-button",
      "data-state": isOpen ? "open" : "closed",
      className: cn(BUTTON_BASE_CLASSES, className),
      "aria-label": isOpen ? labels.chatToggleCloseLabel : labels.chatToggleOpenLabel,
      "aria-pressed": isOpen,
      disabled,
      onClick: handleClick,
      ...restProps,
      children: [
        openIconElement,
        closeIconElement
      ]
    }
  );
});
CopilotChatToggleButton.displayName = "CopilotChatToggleButton";
var CopilotChatToggleButton_default = CopilotChatToggleButton;

// src/components/chat/CopilotSidebarView.tsx
import { useEffect as useEffect16, useRef as useRef8, useState as useState14 } from "react";

// src/components/chat/CopilotModalHeader.tsx
import { useCallback as useCallback10 } from "react";
import { X as X3 } from "lucide-react";
import { jsx as jsx22, jsxs as jsxs14 } from "react/jsx-runtime";
function CopilotModalHeader({
  title,
  titleContent,
  closeButton,
  children,
  className,
  ...rest
}) {
  const configuration = useCopilotChatConfiguration();
  const fallbackTitle = configuration?.labels.modalHeaderTitle ?? CopilotChatDefaultLabels.modalHeaderTitle;
  const resolvedTitle = title ?? fallbackTitle;
  const handleClose = useCallback10(() => {
    configuration?.setModalOpen(false);
  }, [configuration]);
  const BoundTitle = renderSlot(titleContent, CopilotModalHeader.Title, {
    children: resolvedTitle
  });
  const BoundCloseButton = renderSlot(closeButton, CopilotModalHeader.CloseButton, {
    onClick: handleClose
  });
  if (children) {
    return children({
      titleContent: BoundTitle,
      closeButton: BoundCloseButton,
      title: resolvedTitle,
      ...rest
    });
  }
  return /* @__PURE__ */ jsx22(
    "header",
    {
      "data-slot": "copilot-modal-header",
      className: cn(
        "flex items-center justify-between border-b border-border px-4 py-4",
        "bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/80",
        className
      ),
      ...rest,
      children: /* @__PURE__ */ jsxs14("div", { className: "flex w-full items-center gap-2", children: [
        /* @__PURE__ */ jsx22("div", { className: "flex-1", "aria-hidden": "true" }),
        /* @__PURE__ */ jsx22("div", { className: "flex flex-1 justify-center text-center", children: BoundTitle }),
        /* @__PURE__ */ jsx22("div", { className: "flex flex-1 justify-end", children: BoundCloseButton })
      ] })
    }
  );
}
CopilotModalHeader.displayName = "CopilotModalHeader";
((CopilotModalHeader2) => {
  CopilotModalHeader2.Title = ({ children, className, ...props }) => /* @__PURE__ */ jsx22(
    "div",
    {
      className: cn(
        "w-full text-base font-medium leading-none tracking-tight text-foreground",
        className
      ),
      ...props,
      children
    }
  );
  CopilotModalHeader2.CloseButton = ({
    className,
    ...props
  }) => /* @__PURE__ */ jsx22(
    "button",
    {
      type: "button",
      className: cn(
        "inline-flex size-8 items-center justify-center rounded-full text-muted-foreground transition cursor-pointer",
        "hover:bg-muted hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
        className
      ),
      "aria-label": "Close",
      ...props,
      children: /* @__PURE__ */ jsx22(X3, { className: "h-4 w-4", "aria-hidden": "true" })
    }
  );
})(CopilotModalHeader || (CopilotModalHeader = {}));
CopilotModalHeader.Title.displayName = "CopilotModalHeader.Title";
CopilotModalHeader.CloseButton.displayName = "CopilotModalHeader.CloseButton";

// src/components/chat/CopilotSidebarView.tsx
import { Fragment as Fragment7, jsx as jsx23, jsxs as jsxs15 } from "react/jsx-runtime";
var DEFAULT_SIDEBAR_WIDTH = 480;
var SIDEBAR_TRANSITION_MS = 260;
function CopilotSidebarView({ header, width, ...props }) {
  const configuration = useCopilotChatConfiguration();
  const isSidebarOpen = configuration?.isModalOpen ?? false;
  const sidebarRef = useRef8(null);
  const [sidebarWidth, setSidebarWidth] = useState14(width ?? DEFAULT_SIDEBAR_WIDTH);
  const widthToCss = (w) => {
    return typeof w === "number" ? `${w}px` : w;
  };
  const widthToMargin = (w) => {
    if (typeof w === "number") {
      return `${w}px`;
    }
    return w;
  };
  useEffect16(() => {
    if (width !== void 0) {
      return;
    }
    if (typeof window === "undefined") {
      return;
    }
    const element = sidebarRef.current;
    if (!element) {
      return;
    }
    const updateWidth = () => {
      const rect = element.getBoundingClientRect();
      if (rect.width > 0) {
        setSidebarWidth(rect.width);
      }
    };
    updateWidth();
    if (typeof ResizeObserver !== "undefined") {
      const observer = new ResizeObserver(() => updateWidth());
      observer.observe(element);
      return () => observer.disconnect();
    }
    window.addEventListener("resize", updateWidth);
    return () => window.removeEventListener("resize", updateWidth);
  }, [width]);
  const headerElement = renderSlot(header, CopilotModalHeader, {});
  return /* @__PURE__ */ jsxs15(Fragment7, { children: [
    isSidebarOpen && /* @__PURE__ */ jsx23(
      "style",
      {
        dangerouslySetInnerHTML: {
          __html: `
            @media (min-width: 768px) {
              body {
                margin-inline-end: ${widthToMargin(sidebarWidth)};
                transition: margin-inline-end ${SIDEBAR_TRANSITION_MS}ms ease;
              }
            }`
        }
      }
    ),
    /* @__PURE__ */ jsx23(CopilotChatToggleButton_default, {}),
    /* @__PURE__ */ jsx23(
      "aside",
      {
        ref: sidebarRef,
        "data-copilot-sidebar": true,
        className: cn(
          "fixed right-0 top-0 z-[1200] flex",
          // Height with dvh fallback and safe area support
          "h-[100vh] h-[100dvh] max-h-screen",
          // Responsive width: full on mobile, custom on desktop
          "w-full",
          "border-l border-border bg-background text-foreground shadow-xl",
          "transition-transform duration-300 ease-out",
          isSidebarOpen ? "translate-x-0" : "translate-x-full pointer-events-none"
        ),
        style: {
          // Use CSS custom property for responsive width
          ["--sidebar-width"]: widthToCss(sidebarWidth),
          // Safe area insets for iOS
          paddingTop: "env(safe-area-inset-top)",
          paddingBottom: "env(safe-area-inset-bottom)"
        },
        "aria-hidden": !isSidebarOpen,
        "aria-label": "Copilot chat sidebar",
        role: "complementary",
        children: /* @__PURE__ */ jsxs15("div", { className: "flex h-full w-full flex-col overflow-hidden", children: [
          headerElement,
          /* @__PURE__ */ jsx23("div", { className: "flex-1 overflow-hidden", "data-sidebar-chat": true, children: /* @__PURE__ */ jsx23(CopilotChatView_default, { ...props }) })
        ] })
      }
    )
  ] });
}
CopilotSidebarView.displayName = "CopilotSidebarView";
((CopilotSidebarView2) => {
  CopilotSidebarView2.WelcomeScreen = ({
    welcomeMessage,
    input,
    suggestionView,
    className,
    children,
    ...props
  }) => {
    const BoundWelcomeMessage = renderSlot(
      welcomeMessage,
      CopilotChatView_default.WelcomeMessage,
      {}
    );
    if (children) {
      return /* @__PURE__ */ jsx23(Fragment7, { children: children({
        welcomeMessage: BoundWelcomeMessage,
        input,
        suggestionView,
        className,
        ...props
      }) });
    }
    return /* @__PURE__ */ jsxs15(
      "div",
      {
        className: cn("h-full flex flex-col", className),
        ...props,
        children: [
          /* @__PURE__ */ jsx23("div", { className: "flex-1 flex flex-col items-center justify-center px-4", children: BoundWelcomeMessage }),
          /* @__PURE__ */ jsx23("div", { className: "px-8 pb-4", children: /* @__PURE__ */ jsxs15("div", { className: "max-w-3xl mx-auto", children: [
            /* @__PURE__ */ jsx23("div", { className: "mb-4 flex justify-center", children: suggestionView }),
            input
          ] }) })
        ]
      }
    );
  };
})(CopilotSidebarView || (CopilotSidebarView = {}));

// src/components/chat/CopilotPopupView.tsx
import { useEffect as useEffect17, useMemo as useMemo12, useRef as useRef9, useState as useState15 } from "react";
import { Fragment as Fragment8, jsx as jsx24, jsxs as jsxs16 } from "react/jsx-runtime";
var DEFAULT_POPUP_WIDTH = 420;
var DEFAULT_POPUP_HEIGHT = 560;
var dimensionToCss = (value, fallback) => {
  if (typeof value === "number" && Number.isFinite(value)) {
    return `${value}px`;
  }
  if (typeof value === "string" && value.trim().length > 0) {
    return value;
  }
  return `${fallback}px`;
};
function CopilotPopupView({
  header,
  width,
  height,
  clickOutsideToClose,
  className,
  ...restProps
}) {
  const configuration = useCopilotChatConfiguration();
  const isPopupOpen = configuration?.isModalOpen ?? false;
  const setModalOpen = configuration?.setModalOpen;
  const labels = configuration?.labels ?? CopilotChatDefaultLabels;
  const containerRef = useRef9(null);
  const [isRendered, setIsRendered] = useState15(isPopupOpen);
  const [isAnimatingOut, setIsAnimatingOut] = useState15(false);
  useEffect17(() => {
    if (isPopupOpen) {
      setIsRendered(true);
      setIsAnimatingOut(false);
      return;
    }
    if (!isRendered) {
      return;
    }
    setIsAnimatingOut(true);
    const timeout = setTimeout(() => {
      setIsRendered(false);
      setIsAnimatingOut(false);
    }, 200);
    return () => clearTimeout(timeout);
  }, [isPopupOpen, isRendered]);
  useEffect17(() => {
    if (!isPopupOpen) {
      return;
    }
    if (typeof window === "undefined") {
      return;
    }
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        event.preventDefault();
        setModalOpen?.(false);
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [isPopupOpen, setModalOpen]);
  useEffect17(() => {
    if (!isPopupOpen) {
      return;
    }
    const focusTimer = setTimeout(() => {
      containerRef.current?.focus({ preventScroll: true });
    }, 200);
    return () => clearTimeout(focusTimer);
  }, [isPopupOpen]);
  useEffect17(() => {
    if (!isPopupOpen || !clickOutsideToClose) {
      return;
    }
    if (typeof document === "undefined") {
      return;
    }
    const handlePointerDown = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      const container = containerRef.current;
      if (container?.contains(target)) {
        return;
      }
      const toggleButton = document.querySelector("[data-slot='chat-toggle-button']");
      if (toggleButton && toggleButton.contains(target)) {
        return;
      }
      setModalOpen?.(false);
    };
    document.addEventListener("pointerdown", handlePointerDown);
    return () => document.removeEventListener("pointerdown", handlePointerDown);
  }, [isPopupOpen, clickOutsideToClose, setModalOpen]);
  const headerElement = useMemo12(() => renderSlot(header, CopilotModalHeader, {}), [header]);
  const resolvedWidth = dimensionToCss(width, DEFAULT_POPUP_WIDTH);
  const resolvedHeight = dimensionToCss(height, DEFAULT_POPUP_HEIGHT);
  const popupStyle = useMemo12(
    () => ({
      "--copilot-popup-width": resolvedWidth,
      "--copilot-popup-height": resolvedHeight,
      "--copilot-popup-max-width": "calc(100vw - 3rem)",
      "--copilot-popup-max-height": "calc(100dvh - 7.5rem)",
      paddingTop: "env(safe-area-inset-top)",
      paddingBottom: "env(safe-area-inset-bottom)",
      paddingLeft: "env(safe-area-inset-left)",
      paddingRight: "env(safe-area-inset-right)"
    }),
    [resolvedHeight, resolvedWidth]
  );
  const popupAnimationClass = isPopupOpen && !isAnimatingOut ? "pointer-events-auto translate-y-0 opacity-100 md:scale-100" : "pointer-events-none translate-y-4 opacity-0 md:translate-y-5 md:scale-[0.95]";
  const popupContent = isRendered ? /* @__PURE__ */ jsx24(
    "div",
    {
      className: cn(
        "fixed inset-0 z-[1200] flex max-w-full flex-col items-stretch",
        "md:inset-auto md:bottom-24 md:right-6 md:items-end md:gap-4"
      ),
      children: /* @__PURE__ */ jsxs16(
        "div",
        {
          ref: containerRef,
          tabIndex: -1,
          role: "dialog",
          "aria-label": labels.modalHeaderTitle,
          "data-copilot-popup": true,
          className: cn(
            "relative flex h-full w-full flex-col overflow-hidden bg-background text-foreground",
            "origin-bottom focus:outline-none transform-gpu transition-transform transition-opacity duration-200 ease-out",
            "md:transition-transform md:transition-opacity",
            "rounded-none border border-border/0 shadow-none ring-0",
            "md:h-[var(--copilot-popup-height)] md:w-[var(--copilot-popup-width)]",
            "md:max-h-[var(--copilot-popup-max-height)] md:max-w-[var(--copilot-popup-max-width)]",
            "md:origin-bottom-right md:rounded-2xl md:border-border md:shadow-xl md:ring-1 md:ring-border/40",
            popupAnimationClass
          ),
          style: popupStyle,
          children: [
            headerElement,
            /* @__PURE__ */ jsx24("div", { className: "flex-1 overflow-hidden", "data-popup-chat": true, children: /* @__PURE__ */ jsx24(
              CopilotChatView_default,
              {
                ...restProps,
                className: cn("h-full min-h-0", className)
              }
            ) })
          ]
        }
      )
    }
  ) : null;
  return /* @__PURE__ */ jsxs16(Fragment8, { children: [
    /* @__PURE__ */ jsx24(CopilotChatToggleButton_default, {}),
    popupContent
  ] });
}
CopilotPopupView.displayName = "CopilotPopupView";
((CopilotPopupView2) => {
  CopilotPopupView2.WelcomeScreen = ({
    welcomeMessage,
    input,
    suggestionView,
    className,
    children,
    ...props
  }) => {
    const BoundWelcomeMessage = renderSlot(
      welcomeMessage,
      CopilotChatView_default.WelcomeMessage,
      {}
    );
    if (children) {
      return /* @__PURE__ */ jsx24(Fragment8, { children: children({
        welcomeMessage: BoundWelcomeMessage,
        input,
        suggestionView,
        className,
        ...props
      }) });
    }
    return /* @__PURE__ */ jsxs16(
      "div",
      {
        className: cn("h-full flex flex-col", className),
        ...props,
        children: [
          /* @__PURE__ */ jsx24("div", { className: "flex-1 flex flex-col items-center justify-center px-4", children: BoundWelcomeMessage }),
          /* @__PURE__ */ jsx24("div", { className: "px-6 pb-4", children: /* @__PURE__ */ jsxs16("div", { className: "max-w-3xl mx-auto", children: [
            /* @__PURE__ */ jsx24("div", { className: "mb-4 flex justify-center", children: suggestionView }),
            input
          ] }) })
        ]
      }
    );
  };
})(CopilotPopupView || (CopilotPopupView = {}));
var CopilotPopupView_default = CopilotPopupView;

// src/components/chat/CopilotSidebar.tsx
import { useMemo as useMemo13 } from "react";
import { jsx as jsx25 } from "react/jsx-runtime";
function CopilotSidebar({ header, defaultOpen, width, ...chatProps }) {
  const SidebarViewOverride = useMemo13(() => {
    const Component = (viewProps) => {
      const { header: viewHeader, width: viewWidth, ...restProps } = viewProps;
      return /* @__PURE__ */ jsx25(
        CopilotSidebarView,
        {
          ...restProps,
          header: header ?? viewHeader,
          width: width ?? viewWidth
        }
      );
    };
    return Object.assign(Component, CopilotChatView_default);
  }, [header, width]);
  return /* @__PURE__ */ jsx25(
    CopilotChat,
    {
      welcomeScreen: CopilotSidebarView.WelcomeScreen,
      ...chatProps,
      chatView: SidebarViewOverride,
      isModalDefaultOpen: defaultOpen
    }
  );
}
CopilotSidebar.displayName = "CopilotSidebar";

// src/components/chat/CopilotPopup.tsx
import { useMemo as useMemo14 } from "react";
import { jsx as jsx26 } from "react/jsx-runtime";
function CopilotPopup({
  header,
  defaultOpen,
  width,
  height,
  clickOutsideToClose,
  ...chatProps
}) {
  const PopupViewOverride = useMemo14(() => {
    const Component = (viewProps) => {
      const {
        header: viewHeader,
        width: viewWidth,
        height: viewHeight,
        clickOutsideToClose: viewClickOutsideToClose,
        ...restProps
      } = viewProps;
      return /* @__PURE__ */ jsx26(
        CopilotPopupView_default,
        {
          ...restProps,
          header: header ?? viewHeader,
          width: width ?? viewWidth,
          height: height ?? viewHeight,
          clickOutsideToClose: clickOutsideToClose ?? viewClickOutsideToClose
        }
      );
    };
    return Object.assign(Component, CopilotChatView_default);
  }, [clickOutsideToClose, header, height, width]);
  return /* @__PURE__ */ jsx26(
    CopilotChat,
    {
      welcomeScreen: CopilotPopupView_default.WelcomeScreen,
      ...chatProps,
      chatView: PopupViewOverride,
      isModalDefaultOpen: defaultOpen
    }
  );
}
CopilotPopup.displayName = "CopilotPopup";

// src/types/defineToolCallRenderer.ts
import { z as z3 } from "zod";
function defineToolCallRenderer(def) {
  const argsSchema = def.name === "*" && !def.args ? z3.any() : def.args;
  return {
    name: def.name,
    args: argsSchema,
    render: def.render,
    ...def.agentId ? { agentId: def.agentId } : {}
  };
}

// src/components/WildcardToolCallRender.tsx
import { useState as useState16 } from "react";
import { jsx as jsx27, jsxs as jsxs17 } from "react/jsx-runtime";
var WildcardToolCallRender = defineToolCallRenderer({
  name: "*",
  render: ({ args, result, name, status }) => {
    const [isExpanded, setIsExpanded] = useState16(false);
    const statusString = String(status);
    const isActive = statusString === "inProgress" || statusString === "executing";
    const isComplete = statusString === "complete";
    const statusStyles = isActive ? "bg-amber-100 text-amber-800 dark:bg-amber-500/15 dark:text-amber-400" : isComplete ? "bg-emerald-100 text-emerald-800 dark:bg-emerald-500/15 dark:text-emerald-400" : "bg-zinc-100 text-zinc-800 dark:bg-zinc-700/40 dark:text-zinc-300";
    return /* @__PURE__ */ jsx27("div", { className: "mt-2 pb-2", children: /* @__PURE__ */ jsxs17("div", { className: "rounded-xl border border-zinc-200/60 dark:border-zinc-800/60 bg-white/70 dark:bg-zinc-900/50 shadow-sm backdrop-blur p-4", children: [
      /* @__PURE__ */ jsxs17(
        "div",
        {
          className: "flex items-center justify-between gap-3 cursor-pointer",
          onClick: () => setIsExpanded(!isExpanded),
          children: [
            /* @__PURE__ */ jsxs17("div", { className: "flex items-center gap-2 min-w-0", children: [
              /* @__PURE__ */ jsx27(
                "svg",
                {
                  className: `h-4 w-4 text-zinc-500 dark:text-zinc-400 transition-transform ${isExpanded ? "rotate-90" : ""}`,
                  fill: "none",
                  viewBox: "0 0 24 24",
                  strokeWidth: 2,
                  stroke: "currentColor",
                  children: /* @__PURE__ */ jsx27(
                    "path",
                    {
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      d: "M8.25 4.5l7.5 7.5-7.5 7.5"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx27("span", { className: "inline-block h-2 w-2 rounded-full bg-blue-500" }),
              /* @__PURE__ */ jsx27("span", { className: "truncate text-sm font-medium text-zinc-900 dark:text-zinc-100", children: name })
            ] }),
            /* @__PURE__ */ jsx27(
              "span",
              {
                className: `inline-flex items-center rounded-full px-2 py-1 text-xs font-medium ${statusStyles}`,
                children: String(status)
              }
            )
          ]
        }
      ),
      isExpanded && /* @__PURE__ */ jsxs17("div", { className: "mt-3 grid gap-4", children: [
        /* @__PURE__ */ jsxs17("div", { children: [
          /* @__PURE__ */ jsx27("div", { className: "text-xs uppercase tracking-wide text-zinc-500 dark:text-zinc-400", children: "Arguments" }),
          /* @__PURE__ */ jsx27("pre", { className: "mt-2 max-h-64 overflow-auto rounded-md bg-zinc-50 dark:bg-zinc-800/60 p-3 text-xs leading-relaxed text-zinc-800 dark:text-zinc-200 whitespace-pre-wrap break-words", children: JSON.stringify(args ?? {}, null, 2) })
        ] }),
        result !== void 0 && /* @__PURE__ */ jsxs17("div", { children: [
          /* @__PURE__ */ jsx27("div", { className: "text-xs uppercase tracking-wide text-zinc-500 dark:text-zinc-400", children: "Result" }),
          /* @__PURE__ */ jsx27("pre", { className: "mt-2 max-h-64 overflow-auto rounded-md bg-zinc-50 dark:bg-zinc-800/60 p-3 text-xs leading-relaxed text-zinc-800 dark:text-zinc-200 whitespace-pre-wrap break-words", children: typeof result === "string" ? result : JSON.stringify(result, null, 2) })
        ] })
      ] })
    ] }) });
  }
});
export {
  AudioRecorderError,
  CopilotChat,
  CopilotChatAssistantMessage_default as CopilotChatAssistantMessage,
  CopilotChatAudioRecorder,
  CopilotChatConfigurationProvider,
  CopilotChatInput_default as CopilotChatInput,
  CopilotChatMessageView_default as CopilotChatMessageView,
  CopilotChatSuggestionPill_default as CopilotChatSuggestionPill,
  CopilotChatSuggestionView_default as CopilotChatSuggestionView,
  CopilotChatToggleButton,
  DefaultCloseIcon as CopilotChatToggleButtonCloseIcon,
  DefaultOpenIcon as CopilotChatToggleButtonOpenIcon,
  CopilotChatToolCallsView_default as CopilotChatToolCallsView,
  CopilotChatUserMessage_default as CopilotChatUserMessage,
  CopilotChatView_default as CopilotChatView,
  CopilotKitCoreReact,
  CopilotKitInspector,
  CopilotKitProvider,
  CopilotModalHeader,
  CopilotPopup,
  CopilotPopupView,
  CopilotSidebar,
  CopilotSidebarView,
  MCPAppsActivityContentSchema,
  MCPAppsActivityRenderer,
  MCPAppsActivityType,
  UseAgentUpdate,
  WildcardToolCallRender,
  defineToolCallRenderer,
  useAgent,
  useAgentContext,
  useConfigureSuggestions,
  useCopilotChatConfiguration,
  useCopilotKit,
  useFrontendTool,
  useHumanInTheLoop,
  useRenderActivityMessage,
  useRenderCustomMessages,
  useRenderToolCall,
  useSuggestions
};
//# sourceMappingURL=index.mjs.map